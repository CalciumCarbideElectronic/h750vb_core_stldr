
h750vb_core_stldr.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001be8c  20000000  20000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .Dev_info     000000c8  2001be8c  2001be8c  0003be8c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .rodata       00000404  2001bf54  2001bf54  0002bf54  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .eh_frame     00000004  2001c358  2001c358  0002c358  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM          00000008  2001c35c  2001c35c  0002c35c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 ._user_heap_stack 00000604  2001c364  2001c364  0002c364  2**0
                  ALLOC
  6 .init_array   00000004  2001c968  2001c968  0002c968  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  2001c96c  2001c96c  0002c96c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000007c  2001c970  2001c970  0002c970  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000090  2001c9ec  2001c9ec  0002c9ec  2**2
                  ALLOC
 10 .ARM.attributes 0000002e  00000000  00000000  0003bf54  2**0
                  CONTENTS, READONLY
 11 .debug_info   00024ddd  00000000  00000000  0003bf82  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000488d  00000000  00000000  00060d5f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00001250  00000000  00000000  000655ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  00038b17  00000000  00000000  0006683c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00017928  00000000  00000000  0009f353  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    001561b9  00000000  00000000  000b6c7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007b  00000000  00000000  0020ce34  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 00001058  00000000  00000000  0020ceaf  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_frame  0000489c  00000000  00000000  0020df08  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

20000000 <__do_global_dtors_aux>:
20000000:	b510      	push	{r4, lr}
20000002:	4c05      	ldr	r4, [pc, #20]	; (20000018 <__do_global_dtors_aux+0x18>)
20000004:	7823      	ldrb	r3, [r4, #0]
20000006:	b933      	cbnz	r3, 20000016 <__do_global_dtors_aux+0x16>
20000008:	4b04      	ldr	r3, [pc, #16]	; (2000001c <__do_global_dtors_aux+0x1c>)
2000000a:	b113      	cbz	r3, 20000012 <__do_global_dtors_aux+0x12>
2000000c:	4804      	ldr	r0, [pc, #16]	; (20000020 <__do_global_dtors_aux+0x20>)
2000000e:	f3af 8000 	nop.w
20000012:	2301      	movs	r3, #1
20000014:	7023      	strb	r3, [r4, #0]
20000016:	bd10      	pop	{r4, pc}
20000018:	2001c9ec 	.word	0x2001c9ec
2000001c:	00000000 	.word	0x00000000
20000020:	2001c358 	.word	0x2001c358

20000024 <frame_dummy>:
20000024:	b508      	push	{r3, lr}
20000026:	4b03      	ldr	r3, [pc, #12]	; (20000034 <frame_dummy+0x10>)
20000028:	b11b      	cbz	r3, 20000032 <frame_dummy+0xe>
2000002a:	4903      	ldr	r1, [pc, #12]	; (20000038 <frame_dummy+0x14>)
2000002c:	4803      	ldr	r0, [pc, #12]	; (2000003c <frame_dummy+0x18>)
2000002e:	f3af 8000 	nop.w
20000032:	bd08      	pop	{r3, pc}
20000034:	00000000 	.word	0x00000000
20000038:	2001c9f0 	.word	0x2001c9f0
2000003c:	2001c358 	.word	0x2001c358

20000040 <_mainCRTStartup>:
20000040:	4b15      	ldr	r3, [pc, #84]	; (20000098 <_mainCRTStartup+0x58>)
20000042:	2b00      	cmp	r3, #0
20000044:	bf08      	it	eq
20000046:	4b13      	ldreq	r3, [pc, #76]	; (20000094 <_mainCRTStartup+0x54>)
20000048:	469d      	mov	sp, r3
2000004a:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
2000004e:	2100      	movs	r1, #0
20000050:	468b      	mov	fp, r1
20000052:	460f      	mov	r7, r1
20000054:	4813      	ldr	r0, [pc, #76]	; (200000a4 <_mainCRTStartup+0x64>)
20000056:	4a14      	ldr	r2, [pc, #80]	; (200000a8 <_mainCRTStartup+0x68>)
20000058:	1a12      	subs	r2, r2, r0
2000005a:	f01b ff03 	bl	2001be64 <memset>
2000005e:	4b0f      	ldr	r3, [pc, #60]	; (2000009c <_mainCRTStartup+0x5c>)
20000060:	2b00      	cmp	r3, #0
20000062:	d000      	beq.n	20000066 <_mainCRTStartup+0x26>
20000064:	4798      	blx	r3
20000066:	4b0e      	ldr	r3, [pc, #56]	; (200000a0 <_mainCRTStartup+0x60>)
20000068:	2b00      	cmp	r3, #0
2000006a:	d000      	beq.n	2000006e <_mainCRTStartup+0x2e>
2000006c:	4798      	blx	r3
2000006e:	2000      	movs	r0, #0
20000070:	2100      	movs	r1, #0
20000072:	0004      	movs	r4, r0
20000074:	000d      	movs	r5, r1
20000076:	480d      	ldr	r0, [pc, #52]	; (200000ac <_mainCRTStartup+0x6c>)
20000078:	2800      	cmp	r0, #0
2000007a:	d002      	beq.n	20000082 <_mainCRTStartup+0x42>
2000007c:	480c      	ldr	r0, [pc, #48]	; (200000b0 <_mainCRTStartup+0x70>)
2000007e:	f3af 8000 	nop.w
20000082:	f01b fecb 	bl	2001be1c <__libc_init_array>
20000086:	0020      	movs	r0, r4
20000088:	0029      	movs	r1, r5
2000008a:	f000 fb75 	bl	20000778 <main>
2000008e:	f01b feb1 	bl	2001bdf4 <exit>
20000092:	bf00      	nop
20000094:	00080000 	.word	0x00080000
	...
200000a4:	2001c9ec 	.word	0x2001c9ec
200000a8:	2001ca7c 	.word	0x2001ca7c
	...

200000b4 <MX_GPIO_Init>:
     PC15-OSC32_OUT (OSC32_OUT)   ------> RCC_OSC32_OUT
     PH0-OSC_IN (PH0)   ------> RCC_OSC_IN
     PH1-OSC_OUT (PH1)   ------> RCC_OSC_OUT
*/
void MX_GPIO_Init(void)
{
200000b4:	b480      	push	{r7}
200000b6:	b087      	sub	sp, #28
200000b8:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
200000ba:	4b28      	ldr	r3, [pc, #160]	; (2000015c <MX_GPIO_Init+0xa8>)
200000bc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200000c0:	4a26      	ldr	r2, [pc, #152]	; (2000015c <MX_GPIO_Init+0xa8>)
200000c2:	f043 0310 	orr.w	r3, r3, #16
200000c6:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
200000ca:	4b24      	ldr	r3, [pc, #144]	; (2000015c <MX_GPIO_Init+0xa8>)
200000cc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200000d0:	f003 0310 	and.w	r3, r3, #16
200000d4:	617b      	str	r3, [r7, #20]
200000d6:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOC_CLK_ENABLE();
200000d8:	4b20      	ldr	r3, [pc, #128]	; (2000015c <MX_GPIO_Init+0xa8>)
200000da:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200000de:	4a1f      	ldr	r2, [pc, #124]	; (2000015c <MX_GPIO_Init+0xa8>)
200000e0:	f043 0304 	orr.w	r3, r3, #4
200000e4:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
200000e8:	4b1c      	ldr	r3, [pc, #112]	; (2000015c <MX_GPIO_Init+0xa8>)
200000ea:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200000ee:	f003 0304 	and.w	r3, r3, #4
200000f2:	613b      	str	r3, [r7, #16]
200000f4:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
200000f6:	4b19      	ldr	r3, [pc, #100]	; (2000015c <MX_GPIO_Init+0xa8>)
200000f8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200000fc:	4a17      	ldr	r2, [pc, #92]	; (2000015c <MX_GPIO_Init+0xa8>)
200000fe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
20000102:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
20000106:	4b15      	ldr	r3, [pc, #84]	; (2000015c <MX_GPIO_Init+0xa8>)
20000108:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
2000010c:	f003 0380 	and.w	r3, r3, #128	; 0x80
20000110:	60fb      	str	r3, [r7, #12]
20000112:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
20000114:	4b11      	ldr	r3, [pc, #68]	; (2000015c <MX_GPIO_Init+0xa8>)
20000116:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
2000011a:	4a10      	ldr	r2, [pc, #64]	; (2000015c <MX_GPIO_Init+0xa8>)
2000011c:	f043 0302 	orr.w	r3, r3, #2
20000120:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
20000124:	4b0d      	ldr	r3, [pc, #52]	; (2000015c <MX_GPIO_Init+0xa8>)
20000126:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
2000012a:	f003 0302 	and.w	r3, r3, #2
2000012e:	60bb      	str	r3, [r7, #8]
20000130:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
20000132:	4b0a      	ldr	r3, [pc, #40]	; (2000015c <MX_GPIO_Init+0xa8>)
20000134:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
20000138:	4a08      	ldr	r2, [pc, #32]	; (2000015c <MX_GPIO_Init+0xa8>)
2000013a:	f043 0308 	orr.w	r3, r3, #8
2000013e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
20000142:	4b06      	ldr	r3, [pc, #24]	; (2000015c <MX_GPIO_Init+0xa8>)
20000144:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
20000148:	f003 0308 	and.w	r3, r3, #8
2000014c:	607b      	str	r3, [r7, #4]
2000014e:	687b      	ldr	r3, [r7, #4]

}
20000150:	bf00      	nop
20000152:	371c      	adds	r7, #28
20000154:	46bd      	mov	sp, r7
20000156:	f85d 7b04 	ldr.w	r7, [sp], #4
2000015a:	4770      	bx	lr
2000015c:	58024400 	.word	0x58024400

20000160 <Init>:
  *      R0             : "1" 			: Operation succeeded
  * 			  "0" 			: Operation failure
  * Note: Mandatory for all types of device
  */
int Init (void)
{
20000160:	b580      	push	{r7, lr}
20000162:	af00      	add	r7, sp, #0
  main();
20000164:	f000 fb08 	bl	20000778 <main>
  sFLASH_Init();
20000168:	f001 f960 	bl	2000142c <sFLASH_Init>
  return 1;
2000016c:	2301      	movs	r3, #1
}
2000016e:	4618      	mov	r0, r3
20000170:	bd80      	pop	{r7, pc}

20000172 <Read>:
  *      R0             : "1" 			: Operation succeeded
  * 			  "0" 			: Operation failure
  * Note: Mandatory for all types except SRAM and PSRAM
  */
int Read (uint32_t Address, uint32_t Size, uint8_t* buffer)
{
20000172:	b580      	push	{r7, lr}
20000174:	b086      	sub	sp, #24
20000176:	af00      	add	r7, sp, #0
20000178:	60f8      	str	r0, [r7, #12]
2000017a:	60b9      	str	r1, [r7, #8]
2000017c:	607a      	str	r2, [r7, #4]
	sFLASH_MemoryMapped();
2000017e:	f000 fdb9 	bl	20000cf4 <sFLASH_MemoryMapped>
	for (int i=0;i<Size;i++){
20000182:	2300      	movs	r3, #0
20000184:	617b      	str	r3, [r7, #20]
20000186:	e008      	b.n	2000019a <Read+0x28>
		buffer[i] = *(uint8_t *) Address;
20000188:	68fa      	ldr	r2, [r7, #12]
2000018a:	697b      	ldr	r3, [r7, #20]
2000018c:	6879      	ldr	r1, [r7, #4]
2000018e:	440b      	add	r3, r1
20000190:	7812      	ldrb	r2, [r2, #0]
20000192:	701a      	strb	r2, [r3, #0]
	for (int i=0;i<Size;i++){
20000194:	697b      	ldr	r3, [r7, #20]
20000196:	3301      	adds	r3, #1
20000198:	617b      	str	r3, [r7, #20]
2000019a:	697b      	ldr	r3, [r7, #20]
2000019c:	68ba      	ldr	r2, [r7, #8]
2000019e:	429a      	cmp	r2, r3
200001a0:	d8f2      	bhi.n	20000188 <Read+0x16>
	}
    return 1;
200001a2:	2301      	movs	r3, #1
}
200001a4:	4618      	mov	r0, r3
200001a6:	3718      	adds	r7, #24
200001a8:	46bd      	mov	sp, r7
200001aa:	bd80      	pop	{r7, pc}

200001ac <Write>:
  *      R0           : "1" 			: Operation succeeded
  *                     "0" 			: Operation failure
  * Note: Mandatory for all types except SRAM and PSRAM
  */
int Write (uint32_t Address, uint32_t Size, uint8_t* buffer)
{
200001ac:	b580      	push	{r7, lr}
200001ae:	b08a      	sub	sp, #40	; 0x28
200001b0:	af00      	add	r7, sp, #0
200001b2:	60f8      	str	r0, [r7, #12]
200001b4:	60b9      	str	r1, [r7, #8]
200001b6:	607a      	str	r2, [r7, #4]
//	return 1;
  uint32_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
200001b8:	2300      	movs	r3, #0
200001ba:	627b      	str	r3, [r7, #36]	; 0x24
200001bc:	2300      	movs	r3, #0
200001be:	623b      	str	r3, [r7, #32]
200001c0:	2300      	movs	r3, #0
200001c2:	61fb      	str	r3, [r7, #28]
200001c4:	2300      	movs	r3, #0
200001c6:	61bb      	str	r3, [r7, #24]
200001c8:	2300      	movs	r3, #0
200001ca:	617b      	str	r3, [r7, #20]
  uint32_t   QSPI_DataNum = 0;
200001cc:	2300      	movs	r3, #0
200001ce:	613b      	str	r3, [r7, #16]

  Addr = Address % QSPI_PAGESIZE;
200001d0:	68fa      	ldr	r2, [r7, #12]
200001d2:	4b5a      	ldr	r3, [pc, #360]	; (2000033c <Write+0x190>)
200001d4:	fba3 1302 	umull	r1, r3, r3, r2
200001d8:	09d9      	lsrs	r1, r3, #7
200001da:	460b      	mov	r3, r1
200001dc:	021b      	lsls	r3, r3, #8
200001de:	1a5b      	subs	r3, r3, r1
200001e0:	1ad3      	subs	r3, r2, r3
200001e2:	61fb      	str	r3, [r7, #28]
  count = QSPI_PAGESIZE - Addr;
200001e4:	69fb      	ldr	r3, [r7, #28]
200001e6:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
200001ea:	61bb      	str	r3, [r7, #24]
  NumOfPage =  Size / QSPI_PAGESIZE;
200001ec:	68bb      	ldr	r3, [r7, #8]
200001ee:	4a53      	ldr	r2, [pc, #332]	; (2000033c <Write+0x190>)
200001f0:	fba2 2303 	umull	r2, r3, r2, r3
200001f4:	09db      	lsrs	r3, r3, #7
200001f6:	627b      	str	r3, [r7, #36]	; 0x24
  NumOfSingle = Size % QSPI_PAGESIZE;
200001f8:	68ba      	ldr	r2, [r7, #8]
200001fa:	4b50      	ldr	r3, [pc, #320]	; (2000033c <Write+0x190>)
200001fc:	fba3 1302 	umull	r1, r3, r3, r2
20000200:	09d9      	lsrs	r1, r3, #7
20000202:	460b      	mov	r3, r1
20000204:	021b      	lsls	r3, r3, #8
20000206:	1a5b      	subs	r3, r3, r1
20000208:	1ad3      	subs	r3, r2, r3
2000020a:	623b      	str	r3, [r7, #32]

  if (Addr == 0) /*!< Address is QSPI_PAGESIZE aligned  */
2000020c:	69fb      	ldr	r3, [r7, #28]
2000020e:	2b00      	cmp	r3, #0
20000210:	d124      	bne.n	2000025c <Write+0xb0>
  {
    if (NumOfPage == 0) /*!< NumByteToWrite < QSPI_PAGESIZE */
20000212:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20000214:	2b00      	cmp	r3, #0
20000216:	d114      	bne.n	20000242 <Write+0x96>
    {
      QSPI_DataNum = Size;
20000218:	68bb      	ldr	r3, [r7, #8]
2000021a:	613b      	str	r3, [r7, #16]
      sFLASH_WriteBuffer(Address, QSPI_DataNum, buffer);
2000021c:	687a      	ldr	r2, [r7, #4]
2000021e:	6939      	ldr	r1, [r7, #16]
20000220:	68f8      	ldr	r0, [r7, #12]
20000222:	f000 fe67 	bl	20000ef4 <sFLASH_WriteBuffer>
20000226:	e083      	b.n	20000330 <Write+0x184>
    }
    else /*!< Size > QSPI_PAGESIZE */
    {
      while (NumOfPage--)
      {
        QSPI_DataNum = QSPI_PAGESIZE;
20000228:	23ff      	movs	r3, #255	; 0xff
2000022a:	613b      	str	r3, [r7, #16]
        sFLASH_WriteBuffer(Address, QSPI_DataNum, buffer);
2000022c:	687a      	ldr	r2, [r7, #4]
2000022e:	6939      	ldr	r1, [r7, #16]
20000230:	68f8      	ldr	r0, [r7, #12]
20000232:	f000 fe5f 	bl	20000ef4 <sFLASH_WriteBuffer>
        Address +=  QSPI_PAGESIZE;
20000236:	68fb      	ldr	r3, [r7, #12]
20000238:	33ff      	adds	r3, #255	; 0xff
2000023a:	60fb      	str	r3, [r7, #12]
        buffer += QSPI_PAGESIZE;
2000023c:	687b      	ldr	r3, [r7, #4]
2000023e:	33ff      	adds	r3, #255	; 0xff
20000240:	607b      	str	r3, [r7, #4]
      while (NumOfPage--)
20000242:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20000244:	1e5a      	subs	r2, r3, #1
20000246:	627a      	str	r2, [r7, #36]	; 0x24
20000248:	2b00      	cmp	r3, #0
2000024a:	d1ed      	bne.n	20000228 <Write+0x7c>
      }

      QSPI_DataNum = NumOfSingle;
2000024c:	6a3b      	ldr	r3, [r7, #32]
2000024e:	613b      	str	r3, [r7, #16]
      sFLASH_WriteBuffer(Address, QSPI_DataNum, buffer);
20000250:	687a      	ldr	r2, [r7, #4]
20000252:	6939      	ldr	r1, [r7, #16]
20000254:	68f8      	ldr	r0, [r7, #12]
20000256:	f000 fe4d 	bl	20000ef4 <sFLASH_WriteBuffer>
2000025a:	e069      	b.n	20000330 <Write+0x184>
    }
  }
  else /*!< Address is not QSPI_PAGESIZE aligned  */
  {
    if (NumOfPage == 0) /*!< Size < QSPI_PAGESIZE */
2000025c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2000025e:	2b00      	cmp	r3, #0
20000260:	d126      	bne.n	200002b0 <Write+0x104>
    {
      if (NumOfSingle > count) /*!< (Size + Address) > QSPI_PAGESIZE */
20000262:	6a3a      	ldr	r2, [r7, #32]
20000264:	69bb      	ldr	r3, [r7, #24]
20000266:	429a      	cmp	r2, r3
20000268:	d91a      	bls.n	200002a0 <Write+0xf4>
      {
        temp = NumOfSingle - count;
2000026a:	6a3a      	ldr	r2, [r7, #32]
2000026c:	69bb      	ldr	r3, [r7, #24]
2000026e:	1ad3      	subs	r3, r2, r3
20000270:	617b      	str	r3, [r7, #20]
        QSPI_DataNum = count;
20000272:	69bb      	ldr	r3, [r7, #24]
20000274:	613b      	str	r3, [r7, #16]
        sFLASH_WriteBuffer(Address, QSPI_DataNum, buffer);
20000276:	687a      	ldr	r2, [r7, #4]
20000278:	6939      	ldr	r1, [r7, #16]
2000027a:	68f8      	ldr	r0, [r7, #12]
2000027c:	f000 fe3a 	bl	20000ef4 <sFLASH_WriteBuffer>
        Address +=  count;
20000280:	68fa      	ldr	r2, [r7, #12]
20000282:	69bb      	ldr	r3, [r7, #24]
20000284:	4413      	add	r3, r2
20000286:	60fb      	str	r3, [r7, #12]
        buffer += count;
20000288:	687a      	ldr	r2, [r7, #4]
2000028a:	69bb      	ldr	r3, [r7, #24]
2000028c:	4413      	add	r3, r2
2000028e:	607b      	str	r3, [r7, #4]

        QSPI_DataNum = temp;
20000290:	697b      	ldr	r3, [r7, #20]
20000292:	613b      	str	r3, [r7, #16]
        sFLASH_WriteBuffer(Address, QSPI_DataNum, buffer);
20000294:	687a      	ldr	r2, [r7, #4]
20000296:	6939      	ldr	r1, [r7, #16]
20000298:	68f8      	ldr	r0, [r7, #12]
2000029a:	f000 fe2b 	bl	20000ef4 <sFLASH_WriteBuffer>
2000029e:	e047      	b.n	20000330 <Write+0x184>
      }
      else
      {
        QSPI_DataNum = Size;
200002a0:	68bb      	ldr	r3, [r7, #8]
200002a2:	613b      	str	r3, [r7, #16]
        sFLASH_WriteBuffer(Address, QSPI_DataNum, buffer);
200002a4:	687a      	ldr	r2, [r7, #4]
200002a6:	6939      	ldr	r1, [r7, #16]
200002a8:	68f8      	ldr	r0, [r7, #12]
200002aa:	f000 fe23 	bl	20000ef4 <sFLASH_WriteBuffer>
200002ae:	e03f      	b.n	20000330 <Write+0x184>
      }
    }
    else /*!< Size > QSPI_PAGESIZE */
    {
      Size -= count;
200002b0:	68ba      	ldr	r2, [r7, #8]
200002b2:	69bb      	ldr	r3, [r7, #24]
200002b4:	1ad3      	subs	r3, r2, r3
200002b6:	60bb      	str	r3, [r7, #8]
      NumOfPage =  Size / QSPI_PAGESIZE;
200002b8:	68bb      	ldr	r3, [r7, #8]
200002ba:	4a20      	ldr	r2, [pc, #128]	; (2000033c <Write+0x190>)
200002bc:	fba2 2303 	umull	r2, r3, r2, r3
200002c0:	09db      	lsrs	r3, r3, #7
200002c2:	627b      	str	r3, [r7, #36]	; 0x24
      NumOfSingle = Size % QSPI_PAGESIZE;
200002c4:	68ba      	ldr	r2, [r7, #8]
200002c6:	4b1d      	ldr	r3, [pc, #116]	; (2000033c <Write+0x190>)
200002c8:	fba3 1302 	umull	r1, r3, r3, r2
200002cc:	09d9      	lsrs	r1, r3, #7
200002ce:	460b      	mov	r3, r1
200002d0:	021b      	lsls	r3, r3, #8
200002d2:	1a5b      	subs	r3, r3, r1
200002d4:	1ad3      	subs	r3, r2, r3
200002d6:	623b      	str	r3, [r7, #32]

      QSPI_DataNum = count;
200002d8:	69bb      	ldr	r3, [r7, #24]
200002da:	613b      	str	r3, [r7, #16]

      sFLASH_WriteBuffer(Address, QSPI_DataNum, buffer);
200002dc:	687a      	ldr	r2, [r7, #4]
200002de:	6939      	ldr	r1, [r7, #16]
200002e0:	68f8      	ldr	r0, [r7, #12]
200002e2:	f000 fe07 	bl	20000ef4 <sFLASH_WriteBuffer>
      Address +=  count;
200002e6:	68fa      	ldr	r2, [r7, #12]
200002e8:	69bb      	ldr	r3, [r7, #24]
200002ea:	4413      	add	r3, r2
200002ec:	60fb      	str	r3, [r7, #12]
      buffer += count;
200002ee:	687a      	ldr	r2, [r7, #4]
200002f0:	69bb      	ldr	r3, [r7, #24]
200002f2:	4413      	add	r3, r2
200002f4:	607b      	str	r3, [r7, #4]

      while (NumOfPage--)
200002f6:	e00c      	b.n	20000312 <Write+0x166>
      {
        QSPI_DataNum = QSPI_PAGESIZE;
200002f8:	23ff      	movs	r3, #255	; 0xff
200002fa:	613b      	str	r3, [r7, #16]

        sFLASH_WriteBuffer(Address, QSPI_DataNum, buffer);
200002fc:	687a      	ldr	r2, [r7, #4]
200002fe:	6939      	ldr	r1, [r7, #16]
20000300:	68f8      	ldr	r0, [r7, #12]
20000302:	f000 fdf7 	bl	20000ef4 <sFLASH_WriteBuffer>
        Address +=  QSPI_PAGESIZE;
20000306:	68fb      	ldr	r3, [r7, #12]
20000308:	33ff      	adds	r3, #255	; 0xff
2000030a:	60fb      	str	r3, [r7, #12]
        buffer += QSPI_PAGESIZE;
2000030c:	687b      	ldr	r3, [r7, #4]
2000030e:	33ff      	adds	r3, #255	; 0xff
20000310:	607b      	str	r3, [r7, #4]
      while (NumOfPage--)
20000312:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20000314:	1e5a      	subs	r2, r3, #1
20000316:	627a      	str	r2, [r7, #36]	; 0x24
20000318:	2b00      	cmp	r3, #0
2000031a:	d1ed      	bne.n	200002f8 <Write+0x14c>
      }

      if (NumOfSingle != 0)
2000031c:	6a3b      	ldr	r3, [r7, #32]
2000031e:	2b00      	cmp	r3, #0
20000320:	d006      	beq.n	20000330 <Write+0x184>
      {
        QSPI_DataNum = NumOfSingle;
20000322:	6a3b      	ldr	r3, [r7, #32]
20000324:	613b      	str	r3, [r7, #16]

        sFLASH_WriteBuffer(Address, QSPI_DataNum, buffer);
20000326:	687a      	ldr	r2, [r7, #4]
20000328:	6939      	ldr	r1, [r7, #16]
2000032a:	68f8      	ldr	r0, [r7, #12]
2000032c:	f000 fde2 	bl	20000ef4 <sFLASH_WriteBuffer>
      }
    }
  }

  return 1;
20000330:	2301      	movs	r3, #1
}
20000332:	4618      	mov	r0, r3
20000334:	3728      	adds	r7, #40	; 0x28
20000336:	46bd      	mov	sp, r7
20000338:	bd80      	pop	{r7, pc}
2000033a:	bf00      	nop
2000033c:	80808081 	.word	0x80808081

20000340 <MassErase>:
  *     R0             : "1" : Operation succeeded
  * 			 "0" : Operation failure
  * Note: Not Mandatory for SRAM PSRAM and NOR_FLASH
  */
int MassErase (void)
{
20000340:	b580      	push	{r7, lr}
20000342:	af00      	add	r7, sp, #0
  sFLASH_EraseBulk();
20000344:	f000 fd7e 	bl	20000e44 <sFLASH_EraseBulk>
  return 1;
20000348:	2301      	movs	r3, #1
}
2000034a:	4618      	mov	r0, r3
2000034c:	bd80      	pop	{r7, pc}
	...

20000350 <SectorErase>:
  *     R0             : "1" : Operation succeeded
  * 			 "0" : Operation failure
  * Note: Not Mandatory for SRAM PSRAM and NOR_FLASH
  */
int SectorErase (uint32_t EraseStartAddress ,uint32_t EraseEndAddress)
{
20000350:	b580      	push	{r7, lr}
20000352:	b084      	sub	sp, #16
20000354:	af00      	add	r7, sp, #0
20000356:	6078      	str	r0, [r7, #4]
20000358:	6039      	str	r1, [r7, #0]

	uint32_t BlockAddr;
	EraseStartAddress = EraseStartAddress -  EraseStartAddress % 0x10000;
2000035a:	687a      	ldr	r2, [r7, #4]
2000035c:	4b0b      	ldr	r3, [pc, #44]	; (2000038c <SectorErase+0x3c>)
2000035e:	4013      	ands	r3, r2
20000360:	607b      	str	r3, [r7, #4]

	while (EraseEndAddress>=EraseStartAddress)
20000362:	e00a      	b.n	2000037a <SectorErase+0x2a>
	{
		BlockAddr = EraseStartAddress & 0x0FFFFFFF;
20000364:	687b      	ldr	r3, [r7, #4]
20000366:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
2000036a:	60fb      	str	r3, [r7, #12]
		sFLASH_EraseSector( BlockAddr);
2000036c:	68f8      	ldr	r0, [r7, #12]
2000036e:	f000 fd37 	bl	20000de0 <sFLASH_EraseSector>
    EraseStartAddress += 0x10000;
20000372:	687b      	ldr	r3, [r7, #4]
20000374:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
20000378:	607b      	str	r3, [r7, #4]
	while (EraseEndAddress>=EraseStartAddress)
2000037a:	683a      	ldr	r2, [r7, #0]
2000037c:	687b      	ldr	r3, [r7, #4]
2000037e:	429a      	cmp	r2, r3
20000380:	d2f0      	bcs.n	20000364 <SectorErase+0x14>
	}
 	return 1;
20000382:	2301      	movs	r3, #1

}
20000384:	4618      	mov	r0, r3
20000386:	3710      	adds	r7, #16
20000388:	46bd      	mov	sp, r7
2000038a:	bd80      	pop	{r7, pc}
2000038c:	ffff0000 	.word	0xffff0000

20000390 <CheckSum>:
  * outputs   :
  *     R0             : Checksum value
  * Note: Optional for all types of device
  */
uint32_t CheckSum(uint32_t StartAddress, uint32_t Size, uint32_t InitVal)
{
20000390:	b580      	push	{r7, lr}
20000392:	b088      	sub	sp, #32
20000394:	af00      	add	r7, sp, #0
20000396:	60f8      	str	r0, [r7, #12]
20000398:	60b9      	str	r1, [r7, #8]
2000039a:	607a      	str	r2, [r7, #4]
  uint8_t missalignementAddress = StartAddress%4;
2000039c:	68fb      	ldr	r3, [r7, #12]
2000039e:	b2db      	uxtb	r3, r3
200003a0:	f003 0303 	and.w	r3, r3, #3
200003a4:	77fb      	strb	r3, [r7, #31]
  uint8_t missalignementSize = Size ;
200003a6:	68bb      	ldr	r3, [r7, #8]
200003a8:	77bb      	strb	r3, [r7, #30]
	int cnt;
	uint32_t Val;
  uint8_t value;

  StartAddress-=StartAddress%4;
200003aa:	68fb      	ldr	r3, [r7, #12]
200003ac:	f023 0303 	bic.w	r3, r3, #3
200003b0:	60fb      	str	r3, [r7, #12]
  Size += (Size%4==0)?0:4-(Size%4);
200003b2:	68bb      	ldr	r3, [r7, #8]
200003b4:	f003 0303 	and.w	r3, r3, #3
200003b8:	2b00      	cmp	r3, #0
200003ba:	d005      	beq.n	200003c8 <CheckSum+0x38>
200003bc:	68bb      	ldr	r3, [r7, #8]
200003be:	f003 0303 	and.w	r3, r3, #3
200003c2:	f1c3 0304 	rsb	r3, r3, #4
200003c6:	e000      	b.n	200003ca <CheckSum+0x3a>
200003c8:	2300      	movs	r3, #0
200003ca:	68ba      	ldr	r2, [r7, #8]
200003cc:	4413      	add	r3, r2
200003ce:	60bb      	str	r3, [r7, #8]

  for(cnt=0; cnt<Size ; cnt+=4)
200003d0:	2300      	movs	r3, #0
200003d2:	61bb      	str	r3, [r7, #24]
200003d4:	e0df      	b.n	20000596 <CheckSum+0x206>
  {
    sFLASH_ReadBuffer(&value, StartAddress ,1);
200003d6:	f107 0313 	add.w	r3, r7, #19
200003da:	2201      	movs	r2, #1
200003dc:	68f9      	ldr	r1, [r7, #12]
200003de:	4618      	mov	r0, r3
200003e0:	f000 fdc6 	bl	20000f70 <sFLASH_ReadBuffer>
    Val = value;
200003e4:	7cfb      	ldrb	r3, [r7, #19]
200003e6:	617b      	str	r3, [r7, #20]
    sFLASH_ReadBuffer(&value, StartAddress + 1,1);
200003e8:	68fb      	ldr	r3, [r7, #12]
200003ea:	1c59      	adds	r1, r3, #1
200003ec:	f107 0313 	add.w	r3, r7, #19
200003f0:	2201      	movs	r2, #1
200003f2:	4618      	mov	r0, r3
200003f4:	f000 fdbc 	bl	20000f70 <sFLASH_ReadBuffer>
    Val+= value<<8;
200003f8:	7cfb      	ldrb	r3, [r7, #19]
200003fa:	021b      	lsls	r3, r3, #8
200003fc:	461a      	mov	r2, r3
200003fe:	697b      	ldr	r3, [r7, #20]
20000400:	4413      	add	r3, r2
20000402:	617b      	str	r3, [r7, #20]
    sFLASH_ReadBuffer(&value, StartAddress + 2,1);
20000404:	68fb      	ldr	r3, [r7, #12]
20000406:	1c99      	adds	r1, r3, #2
20000408:	f107 0313 	add.w	r3, r7, #19
2000040c:	2201      	movs	r2, #1
2000040e:	4618      	mov	r0, r3
20000410:	f000 fdae 	bl	20000f70 <sFLASH_ReadBuffer>
    Val+= value<<16;
20000414:	7cfb      	ldrb	r3, [r7, #19]
20000416:	041b      	lsls	r3, r3, #16
20000418:	461a      	mov	r2, r3
2000041a:	697b      	ldr	r3, [r7, #20]
2000041c:	4413      	add	r3, r2
2000041e:	617b      	str	r3, [r7, #20]
    sFLASH_ReadBuffer(&value, StartAddress + 3,1);
20000420:	68fb      	ldr	r3, [r7, #12]
20000422:	1cd9      	adds	r1, r3, #3
20000424:	f107 0313 	add.w	r3, r7, #19
20000428:	2201      	movs	r2, #1
2000042a:	4618      	mov	r0, r3
2000042c:	f000 fda0 	bl	20000f70 <sFLASH_ReadBuffer>
    Val+= value<<24;
20000430:	7cfb      	ldrb	r3, [r7, #19]
20000432:	061b      	lsls	r3, r3, #24
20000434:	461a      	mov	r2, r3
20000436:	697b      	ldr	r3, [r7, #20]
20000438:	4413      	add	r3, r2
2000043a:	617b      	str	r3, [r7, #20]
    if(missalignementAddress)
2000043c:	7ffb      	ldrb	r3, [r7, #31]
2000043e:	2b00      	cmp	r3, #0
20000440:	d03e      	beq.n	200004c0 <CheckSum+0x130>
    {
      switch (missalignementAddress)
20000442:	7ffb      	ldrb	r3, [r7, #31]
20000444:	2b02      	cmp	r3, #2
20000446:	d01d      	beq.n	20000484 <CheckSum+0xf4>
20000448:	2b03      	cmp	r3, #3
2000044a:	d02d      	beq.n	200004a8 <CheckSum+0x118>
2000044c:	2b01      	cmp	r3, #1
2000044e:	f040 809c 	bne.w	2000058a <CheckSum+0x1fa>
      {
        case 1:
          InitVal += (uint8_t) (Val>>8 & 0xff);
20000452:	697b      	ldr	r3, [r7, #20]
20000454:	0a1b      	lsrs	r3, r3, #8
20000456:	b2db      	uxtb	r3, r3
20000458:	461a      	mov	r2, r3
2000045a:	687b      	ldr	r3, [r7, #4]
2000045c:	4413      	add	r3, r2
2000045e:	607b      	str	r3, [r7, #4]
          InitVal += (uint8_t) (Val>>16 & 0xff);
20000460:	697b      	ldr	r3, [r7, #20]
20000462:	0c1b      	lsrs	r3, r3, #16
20000464:	b2db      	uxtb	r3, r3
20000466:	461a      	mov	r2, r3
20000468:	687b      	ldr	r3, [r7, #4]
2000046a:	4413      	add	r3, r2
2000046c:	607b      	str	r3, [r7, #4]
          InitVal += (uint8_t) (Val>>24 & 0xff);
2000046e:	697b      	ldr	r3, [r7, #20]
20000470:	0e1b      	lsrs	r3, r3, #24
20000472:	b2db      	uxtb	r3, r3
20000474:	461a      	mov	r2, r3
20000476:	687b      	ldr	r3, [r7, #4]
20000478:	4413      	add	r3, r2
2000047a:	607b      	str	r3, [r7, #4]
          missalignementAddress-=1;
2000047c:	7ffb      	ldrb	r3, [r7, #31]
2000047e:	3b01      	subs	r3, #1
20000480:	77fb      	strb	r3, [r7, #31]
          break;
20000482:	e082      	b.n	2000058a <CheckSum+0x1fa>
        case 2:
          InitVal += (uint8_t) (Val>>16 & 0xff);
20000484:	697b      	ldr	r3, [r7, #20]
20000486:	0c1b      	lsrs	r3, r3, #16
20000488:	b2db      	uxtb	r3, r3
2000048a:	461a      	mov	r2, r3
2000048c:	687b      	ldr	r3, [r7, #4]
2000048e:	4413      	add	r3, r2
20000490:	607b      	str	r3, [r7, #4]
          InitVal += (uint8_t) (Val>>24 & 0xff);
20000492:	697b      	ldr	r3, [r7, #20]
20000494:	0e1b      	lsrs	r3, r3, #24
20000496:	b2db      	uxtb	r3, r3
20000498:	461a      	mov	r2, r3
2000049a:	687b      	ldr	r3, [r7, #4]
2000049c:	4413      	add	r3, r2
2000049e:	607b      	str	r3, [r7, #4]
          missalignementAddress-=2;
200004a0:	7ffb      	ldrb	r3, [r7, #31]
200004a2:	3b02      	subs	r3, #2
200004a4:	77fb      	strb	r3, [r7, #31]
          break;
200004a6:	e070      	b.n	2000058a <CheckSum+0x1fa>
        case 3:
          InitVal += (uint8_t) (Val>>24 & 0xff);
200004a8:	697b      	ldr	r3, [r7, #20]
200004aa:	0e1b      	lsrs	r3, r3, #24
200004ac:	b2db      	uxtb	r3, r3
200004ae:	461a      	mov	r2, r3
200004b0:	687b      	ldr	r3, [r7, #4]
200004b2:	4413      	add	r3, r2
200004b4:	607b      	str	r3, [r7, #4]
          missalignementAddress-=3;
200004b6:	7ffb      	ldrb	r3, [r7, #31]
200004b8:	3b03      	subs	r3, #3
200004ba:	77fb      	strb	r3, [r7, #31]
          break;
200004bc:	bf00      	nop
200004be:	e064      	b.n	2000058a <CheckSum+0x1fa>
      }
    }
    else if((Size-missalignementSize)%4 && (Size-cnt) <=4)
200004c0:	7fbb      	ldrb	r3, [r7, #30]
200004c2:	68ba      	ldr	r2, [r7, #8]
200004c4:	1ad3      	subs	r3, r2, r3
200004c6:	f003 0303 	and.w	r3, r3, #3
200004ca:	2b00      	cmp	r3, #0
200004cc:	d042      	beq.n	20000554 <CheckSum+0x1c4>
200004ce:	69bb      	ldr	r3, [r7, #24]
200004d0:	68ba      	ldr	r2, [r7, #8]
200004d2:	1ad3      	subs	r3, r2, r3
200004d4:	2b04      	cmp	r3, #4
200004d6:	d83d      	bhi.n	20000554 <CheckSum+0x1c4>
    {
      switch (Size-missalignementSize)
200004d8:	7fbb      	ldrb	r3, [r7, #30]
200004da:	68ba      	ldr	r2, [r7, #8]
200004dc:	1ad3      	subs	r3, r2, r3
200004de:	2b02      	cmp	r3, #2
200004e0:	d01c      	beq.n	2000051c <CheckSum+0x18c>
200004e2:	2b03      	cmp	r3, #3
200004e4:	d02b      	beq.n	2000053e <CheckSum+0x1ae>
200004e6:	2b01      	cmp	r3, #1
200004e8:	d000      	beq.n	200004ec <CheckSum+0x15c>
        case 3:
          InitVal += (uint8_t) Val;
          missalignementSize-=3;
          break;
      }
    }
200004ea:	e04e      	b.n	2000058a <CheckSum+0x1fa>
          InitVal += (uint8_t) Val;
200004ec:	697b      	ldr	r3, [r7, #20]
200004ee:	b2db      	uxtb	r3, r3
200004f0:	461a      	mov	r2, r3
200004f2:	687b      	ldr	r3, [r7, #4]
200004f4:	4413      	add	r3, r2
200004f6:	607b      	str	r3, [r7, #4]
          InitVal += (uint8_t) (Val>>8 & 0xff);
200004f8:	697b      	ldr	r3, [r7, #20]
200004fa:	0a1b      	lsrs	r3, r3, #8
200004fc:	b2db      	uxtb	r3, r3
200004fe:	461a      	mov	r2, r3
20000500:	687b      	ldr	r3, [r7, #4]
20000502:	4413      	add	r3, r2
20000504:	607b      	str	r3, [r7, #4]
          InitVal += (uint8_t) (Val>>16 & 0xff);
20000506:	697b      	ldr	r3, [r7, #20]
20000508:	0c1b      	lsrs	r3, r3, #16
2000050a:	b2db      	uxtb	r3, r3
2000050c:	461a      	mov	r2, r3
2000050e:	687b      	ldr	r3, [r7, #4]
20000510:	4413      	add	r3, r2
20000512:	607b      	str	r3, [r7, #4]
          missalignementSize-=1;
20000514:	7fbb      	ldrb	r3, [r7, #30]
20000516:	3b01      	subs	r3, #1
20000518:	77bb      	strb	r3, [r7, #30]
          break;
2000051a:	e01a      	b.n	20000552 <CheckSum+0x1c2>
          InitVal += (uint8_t) Val;
2000051c:	697b      	ldr	r3, [r7, #20]
2000051e:	b2db      	uxtb	r3, r3
20000520:	461a      	mov	r2, r3
20000522:	687b      	ldr	r3, [r7, #4]
20000524:	4413      	add	r3, r2
20000526:	607b      	str	r3, [r7, #4]
          InitVal += (uint8_t) (Val>>8 & 0xff);
20000528:	697b      	ldr	r3, [r7, #20]
2000052a:	0a1b      	lsrs	r3, r3, #8
2000052c:	b2db      	uxtb	r3, r3
2000052e:	461a      	mov	r2, r3
20000530:	687b      	ldr	r3, [r7, #4]
20000532:	4413      	add	r3, r2
20000534:	607b      	str	r3, [r7, #4]
          missalignementSize-=2;
20000536:	7fbb      	ldrb	r3, [r7, #30]
20000538:	3b02      	subs	r3, #2
2000053a:	77bb      	strb	r3, [r7, #30]
          break;
2000053c:	e009      	b.n	20000552 <CheckSum+0x1c2>
          InitVal += (uint8_t) Val;
2000053e:	697b      	ldr	r3, [r7, #20]
20000540:	b2db      	uxtb	r3, r3
20000542:	461a      	mov	r2, r3
20000544:	687b      	ldr	r3, [r7, #4]
20000546:	4413      	add	r3, r2
20000548:	607b      	str	r3, [r7, #4]
          missalignementSize-=3;
2000054a:	7fbb      	ldrb	r3, [r7, #30]
2000054c:	3b03      	subs	r3, #3
2000054e:	77bb      	strb	r3, [r7, #30]
          break;
20000550:	bf00      	nop
    }
20000552:	e01a      	b.n	2000058a <CheckSum+0x1fa>
    else
    {
      InitVal += (uint8_t) Val;
20000554:	697b      	ldr	r3, [r7, #20]
20000556:	b2db      	uxtb	r3, r3
20000558:	461a      	mov	r2, r3
2000055a:	687b      	ldr	r3, [r7, #4]
2000055c:	4413      	add	r3, r2
2000055e:	607b      	str	r3, [r7, #4]
      InitVal += (uint8_t) (Val>>8 & 0xff);
20000560:	697b      	ldr	r3, [r7, #20]
20000562:	0a1b      	lsrs	r3, r3, #8
20000564:	b2db      	uxtb	r3, r3
20000566:	461a      	mov	r2, r3
20000568:	687b      	ldr	r3, [r7, #4]
2000056a:	4413      	add	r3, r2
2000056c:	607b      	str	r3, [r7, #4]
      InitVal += (uint8_t) (Val>>16 & 0xff);
2000056e:	697b      	ldr	r3, [r7, #20]
20000570:	0c1b      	lsrs	r3, r3, #16
20000572:	b2db      	uxtb	r3, r3
20000574:	461a      	mov	r2, r3
20000576:	687b      	ldr	r3, [r7, #4]
20000578:	4413      	add	r3, r2
2000057a:	607b      	str	r3, [r7, #4]
      InitVal += (uint8_t) (Val>>24 & 0xff);
2000057c:	697b      	ldr	r3, [r7, #20]
2000057e:	0e1b      	lsrs	r3, r3, #24
20000580:	b2db      	uxtb	r3, r3
20000582:	461a      	mov	r2, r3
20000584:	687b      	ldr	r3, [r7, #4]
20000586:	4413      	add	r3, r2
20000588:	607b      	str	r3, [r7, #4]
    }
    StartAddress+=4;
2000058a:	68fb      	ldr	r3, [r7, #12]
2000058c:	3304      	adds	r3, #4
2000058e:	60fb      	str	r3, [r7, #12]
  for(cnt=0; cnt<Size ; cnt+=4)
20000590:	69bb      	ldr	r3, [r7, #24]
20000592:	3304      	adds	r3, #4
20000594:	61bb      	str	r3, [r7, #24]
20000596:	69bb      	ldr	r3, [r7, #24]
20000598:	68ba      	ldr	r2, [r7, #8]
2000059a:	429a      	cmp	r2, r3
2000059c:	f63f af1b 	bhi.w	200003d6 <CheckSum+0x46>
  }

  return (InitVal);
200005a0:	687b      	ldr	r3, [r7, #4]
}
200005a2:	4618      	mov	r0, r3
200005a4:	3720      	adds	r7, #32
200005a6:	46bd      	mov	sp, r7
200005a8:	bd80      	pop	{r7, pc}

200005aa <Verify>:
  *     R0             : Operation failed (address of failure)
  *     R1             : Checksum value
  * Note: Optional for all types of device
  */
uint64_t Verify (uint32_t MemoryAddr, uint32_t RAMBufferAddr, uint32_t Size, uint32_t missalignement)
{
200005aa:	e92d 4890 	stmdb	sp!, {r4, r7, fp, lr}
200005ae:	b08a      	sub	sp, #40	; 0x28
200005b0:	af00      	add	r7, sp, #0
200005b2:	60f8      	str	r0, [r7, #12]
200005b4:	60b9      	str	r1, [r7, #8]
200005b6:	607a      	str	r2, [r7, #4]
200005b8:	603b      	str	r3, [r7, #0]
  uint32_t InitVal = 0;
200005ba:	2300      	movs	r3, #0
200005bc:	623b      	str	r3, [r7, #32]
  uint32_t VerifiedData = 0;
200005be:	2300      	movs	r3, #0
200005c0:	627b      	str	r3, [r7, #36]	; 0x24
  uint8_t TmpBuffer = 0x00;
200005c2:	2300      	movs	r3, #0
200005c4:	75fb      	strb	r3, [r7, #23]
	uint64_t checksum;
  Size*=4;
200005c6:	687b      	ldr	r3, [r7, #4]
200005c8:	009b      	lsls	r3, r3, #2
200005ca:	607b      	str	r3, [r7, #4]

  checksum = CheckSum((uint32_t)MemoryAddr + (missalignement & 0xf), Size - ((missalignement >> 16) & 0xF), InitVal);
200005cc:	683b      	ldr	r3, [r7, #0]
200005ce:	f003 020f 	and.w	r2, r3, #15
200005d2:	68fb      	ldr	r3, [r7, #12]
200005d4:	18d0      	adds	r0, r2, r3
200005d6:	683b      	ldr	r3, [r7, #0]
200005d8:	0c1b      	lsrs	r3, r3, #16
200005da:	f003 030f 	and.w	r3, r3, #15
200005de:	687a      	ldr	r2, [r7, #4]
200005e0:	1ad3      	subs	r3, r2, r3
200005e2:	6a3a      	ldr	r2, [r7, #32]
200005e4:	4619      	mov	r1, r3
200005e6:	f7ff fed3 	bl	20000390 <CheckSum>
200005ea:	4603      	mov	r3, r0
200005ec:	f04f 0400 	mov.w	r4, #0
200005f0:	e9c7 3406 	strd	r3, r4, [r7, #24]

  while (Size>VerifiedData)
200005f4:	e02a      	b.n	2000064c <Verify+0xa2>
  {
    sFLASH_ReadBuffer(&TmpBuffer, MemoryAddr+VerifiedData, 1);
200005f6:	68fa      	ldr	r2, [r7, #12]
200005f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
200005fa:	18d1      	adds	r1, r2, r3
200005fc:	f107 0317 	add.w	r3, r7, #23
20000600:	2201      	movs	r2, #1
20000602:	4618      	mov	r0, r3
20000604:	f000 fcb4 	bl	20000f70 <sFLASH_ReadBuffer>

    if (TmpBuffer != *((uint8_t*)RAMBufferAddr+VerifiedData))
20000608:	6a7a      	ldr	r2, [r7, #36]	; 0x24
2000060a:	68bb      	ldr	r3, [r7, #8]
2000060c:	4413      	add	r3, r2
2000060e:	781a      	ldrb	r2, [r3, #0]
20000610:	7dfb      	ldrb	r3, [r7, #23]
20000612:	429a      	cmp	r2, r3
20000614:	d017      	beq.n	20000646 <Verify+0x9c>
      return ((checksum<<32) + MemoryAddr+VerifiedData);
20000616:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
2000061a:	f04f 0300 	mov.w	r3, #0
2000061e:	f04f 0400 	mov.w	r4, #0
20000622:	000c      	movs	r4, r1
20000624:	2300      	movs	r3, #0
20000626:	68fa      	ldr	r2, [r7, #12]
20000628:	4693      	mov	fp, r2
2000062a:	f04f 0c00 	mov.w	ip, #0
2000062e:	eb1b 0103 	adds.w	r1, fp, r3
20000632:	eb4c 0204 	adc.w	r2, ip, r4
20000636:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20000638:	f04f 0400 	mov.w	r4, #0
2000063c:	eb13 0b01 	adds.w	fp, r3, r1
20000640:	eb44 0c02 	adc.w	ip, r4, r2
20000644:	e00f      	b.n	20000666 <Verify+0xbc>

    VerifiedData++;
20000646:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20000648:	3301      	adds	r3, #1
2000064a:	627b      	str	r3, [r7, #36]	; 0x24
  while (Size>VerifiedData)
2000064c:	687a      	ldr	r2, [r7, #4]
2000064e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20000650:	429a      	cmp	r2, r3
20000652:	d8d0      	bhi.n	200005f6 <Verify+0x4c>
  }

  return (checksum<<32);
20000654:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
20000658:	f04f 0b00 	mov.w	fp, #0
2000065c:	f04f 0c00 	mov.w	ip, #0
20000660:	468c      	mov	ip, r1
20000662:	f04f 0b00 	mov.w	fp, #0
20000666:	465b      	mov	r3, fp
20000668:	4664      	mov	r4, ip
}
2000066a:	4618      	mov	r0, r3
2000066c:	4621      	mov	r1, r4
2000066e:	3728      	adds	r7, #40	; 0x28
20000670:	46bd      	mov	sp, r7
20000672:	e8bd 8890 	ldmia.w	sp!, {r4, r7, fp, pc}

20000676 <ITM_SendChar>:
           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
  \param [in]     ch  Character to transmit.
  \returns            Character to transmit.
 */
__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
{
20000676:	b480      	push	{r7}
20000678:	b083      	sub	sp, #12
2000067a:	af00      	add	r7, sp, #0
2000067c:	6078      	str	r0, [r7, #4]
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
2000067e:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
20000682:	f8d3 3e80 	ldr.w	r3, [r3, #3712]	; 0xe80
20000686:	f003 0301 	and.w	r3, r3, #1
2000068a:	2b00      	cmp	r3, #0
2000068c:	d013      	beq.n	200006b6 <ITM_SendChar+0x40>
      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
2000068e:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
20000692:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
20000696:	f003 0301 	and.w	r3, r3, #1
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
2000069a:	2b00      	cmp	r3, #0
2000069c:	d00b      	beq.n	200006b6 <ITM_SendChar+0x40>
  {
    while (ITM->PORT[0U].u32 == 0UL)
2000069e:	e000      	b.n	200006a2 <ITM_SendChar+0x2c>
    {
      __NOP();
200006a0:	bf00      	nop
    while (ITM->PORT[0U].u32 == 0UL)
200006a2:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
200006a6:	681b      	ldr	r3, [r3, #0]
200006a8:	2b00      	cmp	r3, #0
200006aa:	d0f9      	beq.n	200006a0 <ITM_SendChar+0x2a>
    }
    ITM->PORT[0U].u8 = (uint8_t)ch;
200006ac:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
200006b0:	687a      	ldr	r2, [r7, #4]
200006b2:	b2d2      	uxtb	r2, r2
200006b4:	701a      	strb	r2, [r3, #0]
  }
  return (ch);
200006b6:	687b      	ldr	r3, [r7, #4]
}
200006b8:	4618      	mov	r0, r3
200006ba:	370c      	adds	r7, #12
200006bc:	46bd      	mov	sp, r7
200006be:	f85d 7b04 	ldr.w	r7, [sp], #4
200006c2:	4770      	bx	lr

200006c4 <PatchSWD>:

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */


void PatchSWD(){
200006c4:	b480      	push	{r7}
200006c6:	af00      	add	r7, sp, #0
	  *(__IO uint32_t*)(0x5C001004) |= 0x00700000; // DBGMCU_CR D3DBGCKEN D1DBGCKEN TRACECLKEN
200006c8:	4b1e      	ldr	r3, [pc, #120]	; (20000744 <PatchSWD+0x80>)
200006ca:	681b      	ldr	r3, [r3, #0]
200006cc:	4a1d      	ldr	r2, [pc, #116]	; (20000744 <PatchSWD+0x80>)
200006ce:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
200006d2:	6013      	str	r3, [r2, #0]

	  //UNLOCK FUNNEL
	  *(__IO uint32_t*)(0x5C004FB0) = 0xC5ACCE55; // SWTF_LAR
200006d4:	4b1c      	ldr	r3, [pc, #112]	; (20000748 <PatchSWD+0x84>)
200006d6:	4a1d      	ldr	r2, [pc, #116]	; (2000074c <PatchSWD+0x88>)
200006d8:	601a      	str	r2, [r3, #0]
	  *(__IO uint32_t*)(0x5C003FB0) = 0xC5ACCE55; // SWO_LAR
200006da:	4b1d      	ldr	r3, [pc, #116]	; (20000750 <PatchSWD+0x8c>)
200006dc:	4a1b      	ldr	r2, [pc, #108]	; (2000074c <PatchSWD+0x88>)
200006de:	601a      	str	r2, [r3, #0]

	  //SWO current output divisor register
	  //This divisor value (0x000000C7) corresponds to 400Mhz
	  //To change it, you can use the following rule
	  // value = (CPU Freq/sw speed )-1
	   *(__IO uint32_t*)(0x5C003010) = ((SystemCoreClock / 2000000) - 1); // SWO_CODR
200006e0:	4b1c      	ldr	r3, [pc, #112]	; (20000754 <PatchSWD+0x90>)
200006e2:	681b      	ldr	r3, [r3, #0]
200006e4:	4a1c      	ldr	r2, [pc, #112]	; (20000758 <PatchSWD+0x94>)
200006e6:	fba2 2303 	umull	r2, r3, r2, r3
200006ea:	0cdb      	lsrs	r3, r3, #19
200006ec:	4a1b      	ldr	r2, [pc, #108]	; (2000075c <PatchSWD+0x98>)
200006ee:	3b01      	subs	r3, #1
200006f0:	6013      	str	r3, [r2, #0]

	  //SWO selected pin protocol register
	   *(__IO uint32_t*)(0x5C0030F0) = 0x00000002; // SWO_SPPR
200006f2:	4b1b      	ldr	r3, [pc, #108]	; (20000760 <PatchSWD+0x9c>)
200006f4:	2202      	movs	r2, #2
200006f6:	601a      	str	r2, [r3, #0]

	  //Enable ITM input of SWO trace funnel
	   *(__IO uint32_t*)(0x5C004000) |= 0x00000001; // SWFT_CTRL
200006f8:	4b1a      	ldr	r3, [pc, #104]	; (20000764 <PatchSWD+0xa0>)
200006fa:	681b      	ldr	r3, [r3, #0]
200006fc:	4a19      	ldr	r2, [pc, #100]	; (20000764 <PatchSWD+0xa0>)
200006fe:	f043 0301 	orr.w	r3, r3, #1
20000702:	6013      	str	r3, [r2, #0]

	  //RCC_AHB4ENR enable GPIOB clock
	   *(__IO uint32_t*)(0x580244E0) |= 0x00000002;
20000704:	4b18      	ldr	r3, [pc, #96]	; (20000768 <PatchSWD+0xa4>)
20000706:	681b      	ldr	r3, [r3, #0]
20000708:	4a17      	ldr	r2, [pc, #92]	; (20000768 <PatchSWD+0xa4>)
2000070a:	f043 0302 	orr.w	r3, r3, #2
2000070e:	6013      	str	r3, [r2, #0]

	  // Configure GPIOB pin 3 as AF
	   *(__IO uint32_t*)(0x58020400) = (*(__IO uint32_t*)(0x58020400) & 0xffffff3f) | 0x00000080;
20000710:	4b16      	ldr	r3, [pc, #88]	; (2000076c <PatchSWD+0xa8>)
20000712:	681b      	ldr	r3, [r3, #0]
20000714:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
20000718:	4a14      	ldr	r2, [pc, #80]	; (2000076c <PatchSWD+0xa8>)
2000071a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
2000071e:	6013      	str	r3, [r2, #0]

	  // Configure GPIOB pin 3 Speed
	   *(__IO uint32_t*)(0x58020408) |= 0x00000080;
20000720:	4b13      	ldr	r3, [pc, #76]	; (20000770 <PatchSWD+0xac>)
20000722:	681b      	ldr	r3, [r3, #0]
20000724:	4a12      	ldr	r2, [pc, #72]	; (20000770 <PatchSWD+0xac>)
20000726:	f043 0380 	orr.w	r3, r3, #128	; 0x80
2000072a:	6013      	str	r3, [r2, #0]

	  // Force AF0 for GPIOB pin 3
	   *(__IO uint32_t*)(0x58020420) &= 0xFFFF0FFF;
2000072c:	4b11      	ldr	r3, [pc, #68]	; (20000774 <PatchSWD+0xb0>)
2000072e:	681b      	ldr	r3, [r3, #0]
20000730:	4a10      	ldr	r2, [pc, #64]	; (20000774 <PatchSWD+0xb0>)
20000732:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
20000736:	6013      	str	r3, [r2, #0]

}
20000738:	bf00      	nop
2000073a:	46bd      	mov	sp, r7
2000073c:	f85d 7b04 	ldr.w	r7, [sp], #4
20000740:	4770      	bx	lr
20000742:	bf00      	nop
20000744:	5c001004 	.word	0x5c001004
20000748:	5c004fb0 	.word	0x5c004fb0
2000074c:	c5acce55 	.word	0xc5acce55
20000750:	5c003fb0 	.word	0x5c003fb0
20000754:	2001c978 	.word	0x2001c978
20000758:	431bde83 	.word	0x431bde83
2000075c:	5c003010 	.word	0x5c003010
20000760:	5c0030f0 	.word	0x5c0030f0
20000764:	5c004000 	.word	0x5c004000
20000768:	580244e0 	.word	0x580244e0
2000076c:	58020400 	.word	0x58020400
20000770:	58020408 	.word	0x58020408
20000774:	58020420 	.word	0x58020420

20000778 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
20000778:	b580      	push	{r7, lr}
2000077a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */
  PatchSWD();
2000077c:	f7ff ffa2 	bl	200006c4 <PatchSWD>
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
20000780:	f001 f9c8 	bl	20001b14 <HAL_Init>

  /* USER CODE BEGIN Init */
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
20000784:	f000 f808 	bl	20000798 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
20000788:	f7ff fc94 	bl	200000b4 <MX_GPIO_Init>
  MX_QUADSPI_Init();
2000078c:	f000 f8be 	bl	2000090c <MX_QUADSPI_Init>
20000790:	2300      	movs	r3, #0
////		  printf("address:0x%x\t%d \n",addr+i,*(uint8_t*)(addr+i));
//	  }
  }
#endif
  /* USER CODE END 3 */
}
20000792:	4618      	mov	r0, r3
20000794:	bd80      	pop	{r7, pc}
	...

20000798 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
20000798:	b580      	push	{r7, lr}
2000079a:	b0cc      	sub	sp, #304	; 0x130
2000079c:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
2000079e:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
200007a2:	224c      	movs	r2, #76	; 0x4c
200007a4:	2100      	movs	r1, #0
200007a6:	4618      	mov	r0, r3
200007a8:	f01b fb5c 	bl	2001be64 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
200007ac:	f107 03c4 	add.w	r3, r7, #196	; 0xc4
200007b0:	2220      	movs	r2, #32
200007b2:	2100      	movs	r1, #0
200007b4:	4618      	mov	r0, r3
200007b6:	f01b fb55 	bl	2001be64 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
200007ba:	f107 0308 	add.w	r3, r7, #8
200007be:	4618      	mov	r0, r3
200007c0:	23bc      	movs	r3, #188	; 0xbc
200007c2:	461a      	mov	r2, r3
200007c4:	2100      	movs	r1, #0
200007c6:	f01b fb4d 	bl	2001be64 <memset>

  /** Supply configuration update enable 
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
200007ca:	2002      	movs	r0, #2
200007cc:	f013 fe0e 	bl	200143ec <HAL_PWREx_ConfigSupply>
  /** Configure the main internal regulator output voltage 
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
200007d0:	1d3b      	adds	r3, r7, #4
200007d2:	2200      	movs	r2, #0
200007d4:	601a      	str	r2, [r3, #0]
200007d6:	4b3b      	ldr	r3, [pc, #236]	; (200008c4 <SystemClock_Config+0x12c>)
200007d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200007da:	4a3a      	ldr	r2, [pc, #232]	; (200008c4 <SystemClock_Config+0x12c>)
200007dc:	f023 0301 	bic.w	r3, r3, #1
200007e0:	62d3      	str	r3, [r2, #44]	; 0x2c
200007e2:	4b38      	ldr	r3, [pc, #224]	; (200008c4 <SystemClock_Config+0x12c>)
200007e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200007e6:	f003 0201 	and.w	r2, r3, #1
200007ea:	1d3b      	adds	r3, r7, #4
200007ec:	601a      	str	r2, [r3, #0]
200007ee:	4b36      	ldr	r3, [pc, #216]	; (200008c8 <SystemClock_Config+0x130>)
200007f0:	699b      	ldr	r3, [r3, #24]
200007f2:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
200007f6:	4a34      	ldr	r2, [pc, #208]	; (200008c8 <SystemClock_Config+0x130>)
200007f8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
200007fc:	6193      	str	r3, [r2, #24]
200007fe:	4b32      	ldr	r3, [pc, #200]	; (200008c8 <SystemClock_Config+0x130>)
20000800:	699b      	ldr	r3, [r3, #24]
20000802:	f403 4240 	and.w	r2, r3, #49152	; 0xc000
20000806:	1d3b      	adds	r3, r7, #4
20000808:	601a      	str	r2, [r3, #0]
2000080a:	1d3b      	adds	r3, r7, #4
2000080c:	681b      	ldr	r3, [r3, #0]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
2000080e:	bf00      	nop
20000810:	4b2d      	ldr	r3, [pc, #180]	; (200008c8 <SystemClock_Config+0x130>)
20000812:	699b      	ldr	r3, [r3, #24]
20000814:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
20000818:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2000081c:	d1f8      	bne.n	20000810 <SystemClock_Config+0x78>
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
2000081e:	2302      	movs	r3, #2
20000820:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
  RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
20000824:	2301      	movs	r3, #1
20000826:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
2000082a:	2340      	movs	r3, #64	; 0x40
2000082c:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
20000830:	2300      	movs	r3, #0
20000832:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
20000836:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
2000083a:	4618      	mov	r0, r3
2000083c:	f016 ff94 	bl	20017768 <HAL_RCC_OscConfig>
20000840:	4603      	mov	r3, r0
20000842:	2b00      	cmp	r3, #0
20000844:	d001      	beq.n	2000084a <SystemClock_Config+0xb2>
  {
    Error_Handler();
20000846:	f000 f84e 	bl	200008e6 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
2000084a:	233f      	movs	r3, #63	; 0x3f
2000084c:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
20000850:	2300      	movs	r3, #0
20000852:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
20000856:	2300      	movs	r3, #0
20000858:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
2000085c:	2308      	movs	r3, #8
2000085e:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
20000862:	2340      	movs	r3, #64	; 0x40
20000864:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
20000868:	2340      	movs	r3, #64	; 0x40
2000086a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV4;
2000086e:	f44f 63a0 	mov.w	r3, #1280	; 0x500
20000872:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
20000876:	2340      	movs	r3, #64	; 0x40
20000878:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
2000087c:	f107 03c4 	add.w	r3, r7, #196	; 0xc4
20000880:	2100      	movs	r1, #0
20000882:	4618      	mov	r0, r3
20000884:	f017 fc6e 	bl	20018164 <HAL_RCC_ClockConfig>
20000888:	4603      	mov	r3, r0
2000088a:	2b00      	cmp	r3, #0
2000088c:	d001      	beq.n	20000892 <SystemClock_Config+0xfa>
  {
    Error_Handler();
2000088e:	f000 f82a 	bl	200008e6 <Error_Handler>
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_QSPI;
20000892:	f107 0308 	add.w	r3, r7, #8
20000896:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
2000089a:	601a      	str	r2, [r3, #0]
  PeriphClkInitStruct.QspiClockSelection = RCC_QSPICLKSOURCE_D1HCLK;
2000089c:	f107 0308 	add.w	r3, r7, #8
200008a0:	2200      	movs	r2, #0
200008a2:	649a      	str	r2, [r3, #72]	; 0x48
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
200008a4:	f107 0308 	add.w	r3, r7, #8
200008a8:	4618      	mov	r0, r3
200008aa:	f018 fbf1 	bl	20019090 <HAL_RCCEx_PeriphCLKConfig>
200008ae:	4603      	mov	r3, r0
200008b0:	2b00      	cmp	r3, #0
200008b2:	d001      	beq.n	200008b8 <SystemClock_Config+0x120>
  {
    Error_Handler();
200008b4:	f000 f817 	bl	200008e6 <Error_Handler>
  }
}
200008b8:	bf00      	nop
200008ba:	f507 7798 	add.w	r7, r7, #304	; 0x130
200008be:	46bd      	mov	sp, r7
200008c0:	bd80      	pop	{r7, pc}
200008c2:	bf00      	nop
200008c4:	58000400 	.word	0x58000400
200008c8:	58024800 	.word	0x58024800

200008cc <__io_putchar>:

/* USER CODE BEGIN 4 */

int __io_putchar(int ch){
200008cc:	b580      	push	{r7, lr}
200008ce:	b082      	sub	sp, #8
200008d0:	af00      	add	r7, sp, #0
200008d2:	6078      	str	r0, [r7, #4]
    ITM_SendChar(ch);
200008d4:	687b      	ldr	r3, [r7, #4]
200008d6:	4618      	mov	r0, r3
200008d8:	f7ff fecd 	bl	20000676 <ITM_SendChar>
    return 0;
200008dc:	2300      	movs	r3, #0
}
200008de:	4618      	mov	r0, r3
200008e0:	3708      	adds	r7, #8
200008e2:	46bd      	mov	sp, r7
200008e4:	bd80      	pop	{r7, pc}

200008e6 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
200008e6:	b480      	push	{r7}
200008e8:	af00      	add	r7, sp, #0
#ifdef DEBUG
	printf("in error handler\n");
#endif

  /* USER CODE END Error_Handler_Debug */
}
200008ea:	bf00      	nop
200008ec:	46bd      	mov	sp, r7
200008ee:	f85d 7b04 	ldr.w	r7, [sp], #4
200008f2:	4770      	bx	lr

200008f4 <assert_failed>:
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{ 
200008f4:	b480      	push	{r7}
200008f6:	b083      	sub	sp, #12
200008f8:	af00      	add	r7, sp, #0
200008fa:	6078      	str	r0, [r7, #4]
200008fc:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
200008fe:	bf00      	nop
20000900:	370c      	adds	r7, #12
20000902:	46bd      	mov	sp, r7
20000904:	f85d 7b04 	ldr.w	r7, [sp], #4
20000908:	4770      	bx	lr
	...

2000090c <MX_QUADSPI_Init>:

QSPI_HandleTypeDef hqspi;

/* QUADSPI init function */
void MX_QUADSPI_Init(void)
{
2000090c:	b580      	push	{r7, lr}
2000090e:	af00      	add	r7, sp, #0

  hqspi.Instance = QUADSPI;
20000910:	4b12      	ldr	r3, [pc, #72]	; (2000095c <MX_QUADSPI_Init+0x50>)
20000912:	4a13      	ldr	r2, [pc, #76]	; (20000960 <MX_QUADSPI_Init+0x54>)
20000914:	601a      	str	r2, [r3, #0]
  hqspi.Init.ClockPrescaler = 1;
20000916:	4b11      	ldr	r3, [pc, #68]	; (2000095c <MX_QUADSPI_Init+0x50>)
20000918:	2201      	movs	r2, #1
2000091a:	605a      	str	r2, [r3, #4]
  hqspi.Init.FifoThreshold = 10;
2000091c:	4b0f      	ldr	r3, [pc, #60]	; (2000095c <MX_QUADSPI_Init+0x50>)
2000091e:	220a      	movs	r2, #10
20000920:	609a      	str	r2, [r3, #8]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
20000922:	4b0e      	ldr	r3, [pc, #56]	; (2000095c <MX_QUADSPI_Init+0x50>)
20000924:	2210      	movs	r2, #16
20000926:	60da      	str	r2, [r3, #12]
  hqspi.Init.FlashSize = 28;
20000928:	4b0c      	ldr	r3, [pc, #48]	; (2000095c <MX_QUADSPI_Init+0x50>)
2000092a:	221c      	movs	r2, #28
2000092c:	611a      	str	r2, [r3, #16]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
2000092e:	4b0b      	ldr	r3, [pc, #44]	; (2000095c <MX_QUADSPI_Init+0x50>)
20000930:	2200      	movs	r2, #0
20000932:	615a      	str	r2, [r3, #20]
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
20000934:	4b09      	ldr	r3, [pc, #36]	; (2000095c <MX_QUADSPI_Init+0x50>)
20000936:	2200      	movs	r2, #0
20000938:	619a      	str	r2, [r3, #24]
  hqspi.Init.FlashID = QSPI_FLASH_ID_1;
2000093a:	4b08      	ldr	r3, [pc, #32]	; (2000095c <MX_QUADSPI_Init+0x50>)
2000093c:	2200      	movs	r2, #0
2000093e:	61da      	str	r2, [r3, #28]
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
20000940:	4b06      	ldr	r3, [pc, #24]	; (2000095c <MX_QUADSPI_Init+0x50>)
20000942:	2200      	movs	r2, #0
20000944:	621a      	str	r2, [r3, #32]
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
20000946:	4805      	ldr	r0, [pc, #20]	; (2000095c <MX_QUADSPI_Init+0x50>)
20000948:	f014 fc1a 	bl	20015180 <HAL_QSPI_Init>
2000094c:	4603      	mov	r3, r0
2000094e:	2b00      	cmp	r3, #0
20000950:	d001      	beq.n	20000956 <MX_QUADSPI_Init+0x4a>
  {
    Error_Handler();
20000952:	f7ff ffc8 	bl	200008e6 <Error_Handler>
  }

}
20000956:	bf00      	nop
20000958:	bd80      	pop	{r7, pc}
2000095a:	bf00      	nop
2000095c:	2001ca10 	.word	0x2001ca10
20000960:	52005000 	.word	0x52005000

20000964 <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
20000964:	b580      	push	{r7, lr}
20000966:	b08c      	sub	sp, #48	; 0x30
20000968:	af00      	add	r7, sp, #0
2000096a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
2000096c:	f107 031c 	add.w	r3, r7, #28
20000970:	2200      	movs	r2, #0
20000972:	601a      	str	r2, [r3, #0]
20000974:	605a      	str	r2, [r3, #4]
20000976:	609a      	str	r2, [r3, #8]
20000978:	60da      	str	r2, [r3, #12]
2000097a:	611a      	str	r2, [r3, #16]
  if(qspiHandle->Instance==QUADSPI)
2000097c:	687b      	ldr	r3, [r7, #4]
2000097e:	681b      	ldr	r3, [r3, #0]
20000980:	4a4a      	ldr	r2, [pc, #296]	; (20000aac <HAL_QSPI_MspInit+0x148>)
20000982:	4293      	cmp	r3, r2
20000984:	f040 808e 	bne.w	20000aa4 <HAL_QSPI_MspInit+0x140>
  {
  /* USER CODE BEGIN QUADSPI_MspInit 0 */

  /* USER CODE END QUADSPI_MspInit 0 */
    /* QUADSPI clock enable */
    __HAL_RCC_QSPI_CLK_ENABLE();
20000988:	4b49      	ldr	r3, [pc, #292]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
2000098a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
2000098e:	4a48      	ldr	r2, [pc, #288]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
20000990:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
20000994:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
20000998:	4b45      	ldr	r3, [pc, #276]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
2000099a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
2000099e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
200009a2:	61bb      	str	r3, [r7, #24]
200009a4:	69bb      	ldr	r3, [r7, #24]
  
    __HAL_RCC_GPIOE_CLK_ENABLE();
200009a6:	4b42      	ldr	r3, [pc, #264]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
200009a8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200009ac:	4a40      	ldr	r2, [pc, #256]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
200009ae:	f043 0310 	orr.w	r3, r3, #16
200009b2:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
200009b6:	4b3e      	ldr	r3, [pc, #248]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
200009b8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200009bc:	f003 0310 	and.w	r3, r3, #16
200009c0:	617b      	str	r3, [r7, #20]
200009c2:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
200009c4:	4b3a      	ldr	r3, [pc, #232]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
200009c6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200009ca:	4a39      	ldr	r2, [pc, #228]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
200009cc:	f043 0302 	orr.w	r3, r3, #2
200009d0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
200009d4:	4b36      	ldr	r3, [pc, #216]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
200009d6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200009da:	f003 0302 	and.w	r3, r3, #2
200009de:	613b      	str	r3, [r7, #16]
200009e0:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
200009e2:	4b33      	ldr	r3, [pc, #204]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
200009e4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200009e8:	4a31      	ldr	r2, [pc, #196]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
200009ea:	f043 0308 	orr.w	r3, r3, #8
200009ee:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
200009f2:	4b2f      	ldr	r3, [pc, #188]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
200009f4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200009f8:	f003 0308 	and.w	r3, r3, #8
200009fc:	60fb      	str	r3, [r7, #12]
200009fe:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
20000a00:	4b2b      	ldr	r3, [pc, #172]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
20000a02:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
20000a06:	4a2a      	ldr	r2, [pc, #168]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
20000a08:	f043 0304 	orr.w	r3, r3, #4
20000a0c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
20000a10:	4b27      	ldr	r3, [pc, #156]	; (20000ab0 <HAL_QSPI_MspInit+0x14c>)
20000a12:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
20000a16:	f003 0304 	and.w	r3, r3, #4
20000a1a:	60bb      	str	r3, [r7, #8]
20000a1c:	68bb      	ldr	r3, [r7, #8]
    PB10     ------> QUADSPI_BK1_NCS
    PD13     ------> QUADSPI_BK1_IO3
    PC9     ------> QUADSPI_BK1_IO0
    PC10     ------> QUADSPI_BK1_IO1 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2;
20000a1e:	2304      	movs	r3, #4
20000a20:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20000a22:	2302      	movs	r3, #2
20000a24:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20000a26:	2300      	movs	r3, #0
20000a28:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
20000a2a:	2303      	movs	r3, #3
20000a2c:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
20000a2e:	2309      	movs	r3, #9
20000a30:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
20000a32:	f107 031c 	add.w	r3, r7, #28
20000a36:	4619      	mov	r1, r3
20000a38:	481e      	ldr	r0, [pc, #120]	; (20000ab4 <HAL_QSPI_MspInit+0x150>)
20000a3a:	f00b f915 	bl	2000bc68 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_10;
20000a3e:	f240 4304 	movw	r3, #1028	; 0x404
20000a42:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20000a44:	2302      	movs	r3, #2
20000a46:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20000a48:	2300      	movs	r3, #0
20000a4a:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
20000a4c:	2303      	movs	r3, #3
20000a4e:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
20000a50:	2309      	movs	r3, #9
20000a52:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
20000a54:	f107 031c 	add.w	r3, r7, #28
20000a58:	4619      	mov	r1, r3
20000a5a:	4817      	ldr	r0, [pc, #92]	; (20000ab8 <HAL_QSPI_MspInit+0x154>)
20000a5c:	f00b f904 	bl	2000bc68 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_13;
20000a60:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20000a64:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20000a66:	2302      	movs	r3, #2
20000a68:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20000a6a:	2300      	movs	r3, #0
20000a6c:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
20000a6e:	2303      	movs	r3, #3
20000a70:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
20000a72:	2309      	movs	r3, #9
20000a74:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
20000a76:	f107 031c 	add.w	r3, r7, #28
20000a7a:	4619      	mov	r1, r3
20000a7c:	480f      	ldr	r0, [pc, #60]	; (20000abc <HAL_QSPI_MspInit+0x158>)
20000a7e:	f00b f8f3 	bl	2000bc68 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
20000a82:	f44f 63c0 	mov.w	r3, #1536	; 0x600
20000a86:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20000a88:	2302      	movs	r3, #2
20000a8a:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20000a8c:	2300      	movs	r3, #0
20000a8e:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
20000a90:	2303      	movs	r3, #3
20000a92:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
20000a94:	2309      	movs	r3, #9
20000a96:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
20000a98:	f107 031c 	add.w	r3, r7, #28
20000a9c:	4619      	mov	r1, r3
20000a9e:	4808      	ldr	r0, [pc, #32]	; (20000ac0 <HAL_QSPI_MspInit+0x15c>)
20000aa0:	f00b f8e2 	bl	2000bc68 <HAL_GPIO_Init>

  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
20000aa4:	bf00      	nop
20000aa6:	3730      	adds	r7, #48	; 0x30
20000aa8:	46bd      	mov	sp, r7
20000aaa:	bd80      	pop	{r7, pc}
20000aac:	52005000 	.word	0x52005000
20000ab0:	58024400 	.word	0x58024400
20000ab4:	58021000 	.word	0x58021000
20000ab8:	58020400 	.word	0x58020400
20000abc:	58020c00 	.word	0x58020c00
20000ac0:	58020800 	.word	0x58020800

20000ac4 <HAL_QSPI_MspDeInit>:

void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef* qspiHandle)
{
20000ac4:	b580      	push	{r7, lr}
20000ac6:	b082      	sub	sp, #8
20000ac8:	af00      	add	r7, sp, #0
20000aca:	6078      	str	r0, [r7, #4]

  if(qspiHandle->Instance==QUADSPI)
20000acc:	687b      	ldr	r3, [r7, #4]
20000ace:	681b      	ldr	r3, [r3, #0]
20000ad0:	4a10      	ldr	r2, [pc, #64]	; (20000b14 <HAL_QSPI_MspDeInit+0x50>)
20000ad2:	4293      	cmp	r3, r2
20000ad4:	d11a      	bne.n	20000b0c <HAL_QSPI_MspDeInit+0x48>
  {
  /* USER CODE BEGIN QUADSPI_MspDeInit 0 */

  /* USER CODE END QUADSPI_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_QSPI_CLK_DISABLE();
20000ad6:	4b10      	ldr	r3, [pc, #64]	; (20000b18 <HAL_QSPI_MspDeInit+0x54>)
20000ad8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
20000adc:	4a0e      	ldr	r2, [pc, #56]	; (20000b18 <HAL_QSPI_MspDeInit+0x54>)
20000ade:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
20000ae2:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
    PB10     ------> QUADSPI_BK1_NCS
    PD13     ------> QUADSPI_BK1_IO3
    PC9     ------> QUADSPI_BK1_IO0
    PC10     ------> QUADSPI_BK1_IO1 
    */
    HAL_GPIO_DeInit(GPIOE, GPIO_PIN_2);
20000ae6:	2104      	movs	r1, #4
20000ae8:	480c      	ldr	r0, [pc, #48]	; (20000b1c <HAL_QSPI_MspDeInit+0x58>)
20000aea:	f00b fb6d 	bl	2000c1c8 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_2|GPIO_PIN_10);
20000aee:	f240 4104 	movw	r1, #1028	; 0x404
20000af2:	480b      	ldr	r0, [pc, #44]	; (20000b20 <HAL_QSPI_MspDeInit+0x5c>)
20000af4:	f00b fb68 	bl	2000c1c8 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_13);
20000af8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
20000afc:	4809      	ldr	r0, [pc, #36]	; (20000b24 <HAL_QSPI_MspDeInit+0x60>)
20000afe:	f00b fb63 	bl	2000c1c8 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_9|GPIO_PIN_10);
20000b02:	f44f 61c0 	mov.w	r1, #1536	; 0x600
20000b06:	4808      	ldr	r0, [pc, #32]	; (20000b28 <HAL_QSPI_MspDeInit+0x64>)
20000b08:	f00b fb5e 	bl	2000c1c8 <HAL_GPIO_DeInit>

  /* USER CODE BEGIN QUADSPI_MspDeInit 1 */

  /* USER CODE END QUADSPI_MspDeInit 1 */
  }
} 
20000b0c:	bf00      	nop
20000b0e:	3708      	adds	r7, #8
20000b10:	46bd      	mov	sp, r7
20000b12:	bd80      	pop	{r7, pc}
20000b14:	52005000 	.word	0x52005000
20000b18:	58024400 	.word	0x58024400
20000b1c:	58021000 	.word	0x58021000
20000b20:	58020400 	.word	0x58020400
20000b24:	58020c00 	.word	0x58020c00
20000b28:	58020800 	.word	0x58020800

20000b2c <initCommonCmd>:
#include "spidriver.h"
#include "stm32h7xx_hal_qspi.h"
#include "quadspi.h"

extern QSPI_HandleTypeDef hqspi;
static void initCommonCmd(QSPI_CommandTypeDef *cmd) {
20000b2c:	b480      	push	{r7}
20000b2e:	b083      	sub	sp, #12
20000b30:	af00      	add	r7, sp, #0
20000b32:	6078      	str	r0, [r7, #4]

  cmd->Instruction=QSPI_INSTRUCTION_1_LINE;
20000b34:	687b      	ldr	r3, [r7, #4]
20000b36:	f44f 7280 	mov.w	r2, #256	; 0x100
20000b3a:	601a      	str	r2, [r3, #0]
  cmd->InstructionMode=QSPI_INSTRUCTION_1_LINE;
20000b3c:	687b      	ldr	r3, [r7, #4]
20000b3e:	f44f 7280 	mov.w	r2, #256	; 0x100
20000b42:	619a      	str	r2, [r3, #24]

  cmd->AddressMode=QSPI_ADDRESS_NONE;
20000b44:	687b      	ldr	r3, [r7, #4]
20000b46:	2200      	movs	r2, #0
20000b48:	61da      	str	r2, [r3, #28]
  cmd->Address=0x0;
20000b4a:	687b      	ldr	r3, [r7, #4]
20000b4c:	2200      	movs	r2, #0
20000b4e:	605a      	str	r2, [r3, #4]
  cmd->AddressSize=0;
20000b50:	687b      	ldr	r3, [r7, #4]
20000b52:	2200      	movs	r2, #0
20000b54:	60da      	str	r2, [r3, #12]


  cmd->AlternateByteMode=QSPI_ALTERNATE_BYTES_NONE;
20000b56:	687b      	ldr	r3, [r7, #4]
20000b58:	2200      	movs	r2, #0
20000b5a:	621a      	str	r2, [r3, #32]
  cmd->AlternateBytesSize=0;
20000b5c:	687b      	ldr	r3, [r7, #4]
20000b5e:	2200      	movs	r2, #0
20000b60:	611a      	str	r2, [r3, #16]
  cmd->AlternateBytes=0;
20000b62:	687b      	ldr	r3, [r7, #4]
20000b64:	2200      	movs	r2, #0
20000b66:	609a      	str	r2, [r3, #8]


  cmd->DataMode=QSPI_DATA_NONE;
20000b68:	687b      	ldr	r3, [r7, #4]
20000b6a:	2200      	movs	r2, #0
20000b6c:	625a      	str	r2, [r3, #36]	; 0x24
  cmd->NbData=0;
20000b6e:	687b      	ldr	r3, [r7, #4]
20000b70:	2200      	movs	r2, #0
20000b72:	629a      	str	r2, [r3, #40]	; 0x28

  cmd->DummyCycles=0;
20000b74:	687b      	ldr	r3, [r7, #4]
20000b76:	2200      	movs	r2, #0
20000b78:	615a      	str	r2, [r3, #20]

  cmd->DdrMode=QSPI_DDR_MODE_DISABLE;
20000b7a:	687b      	ldr	r3, [r7, #4]
20000b7c:	2200      	movs	r2, #0
20000b7e:	62da      	str	r2, [r3, #44]	; 0x2c
  cmd->DdrHoldHalfCycle=0;
20000b80:	687b      	ldr	r3, [r7, #4]
20000b82:	2200      	movs	r2, #0
20000b84:	631a      	str	r2, [r3, #48]	; 0x30

  cmd->SIOOMode=QSPI_SIOO_INST_EVERY_CMD;
20000b86:	687b      	ldr	r3, [r7, #4]
20000b88:	2200      	movs	r2, #0
20000b8a:	635a      	str	r2, [r3, #52]	; 0x34
}
20000b8c:	bf00      	nop
20000b8e:	370c      	adds	r7, #12
20000b90:	46bd      	mov	sp, r7
20000b92:	f85d 7b04 	ldr.w	r7, [sp], #4
20000b96:	4770      	bx	lr

20000b98 <initReadRegCmd>:

static void initReadRegCmd(QSPI_CommandTypeDef *cmd,uint32_t regLen){
20000b98:	b580      	push	{r7, lr}
20000b9a:	b082      	sub	sp, #8
20000b9c:	af00      	add	r7, sp, #0
20000b9e:	6078      	str	r0, [r7, #4]
20000ba0:	6039      	str	r1, [r7, #0]

	initCommonCmd(cmd);
20000ba2:	6878      	ldr	r0, [r7, #4]
20000ba4:	f7ff ffc2 	bl	20000b2c <initCommonCmd>
	cmd->AddressMode = QSPI_ADDRESS_NONE;
20000ba8:	687b      	ldr	r3, [r7, #4]
20000baa:	2200      	movs	r2, #0
20000bac:	61da      	str	r2, [r3, #28]

	cmd->DataMode = QSPI_DATA_1_LINE;
20000bae:	687b      	ldr	r3, [r7, #4]
20000bb0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
20000bb4:	625a      	str	r2, [r3, #36]	; 0x24
	cmd->NbData = regLen;
20000bb6:	687b      	ldr	r3, [r7, #4]
20000bb8:	683a      	ldr	r2, [r7, #0]
20000bba:	629a      	str	r2, [r3, #40]	; 0x28

	cmd->DummyCycles = 0;
20000bbc:	687b      	ldr	r3, [r7, #4]
20000bbe:	2200      	movs	r2, #0
20000bc0:	615a      	str	r2, [r3, #20]

}
20000bc2:	bf00      	nop
20000bc4:	3708      	adds	r7, #8
20000bc6:	46bd      	mov	sp, r7
20000bc8:	bd80      	pop	{r7, pc}

20000bca <QSPI_WriteEnable>:

void QSPI_WriteEnable(QSPI_HandleTypeDef *hqspi) {
20000bca:	b580      	push	{r7, lr}
20000bcc:	b096      	sub	sp, #88	; 0x58
20000bce:	af00      	add	r7, sp, #0
20000bd0:	6078      	str	r0, [r7, #4]
	QSPI_CommandTypeDef sCommand;
	QSPI_AutoPollingTypeDef sConfig;
	initCommonCmd(&sCommand);
20000bd2:	f107 0320 	add.w	r3, r7, #32
20000bd6:	4618      	mov	r0, r3
20000bd8:	f7ff ffa8 	bl	20000b2c <initCommonCmd>

	sCommand.InstructionMode = QSPI_INSTRUCTION_4_LINES;
20000bdc:	f44f 7340 	mov.w	r3, #768	; 0x300
20000be0:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.Instruction = WRITE_ENABLE_CMD;
20000be2:	2306      	movs	r3, #6
20000be4:	623b      	str	r3, [r7, #32]

	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20000be6:	2300      	movs	r3, #0
20000be8:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20000bea:	2300      	movs	r3, #0
20000bec:	643b      	str	r3, [r7, #64]	; 0x40
	sCommand.DataMode = QSPI_DATA_NONE;
20000bee:	2300      	movs	r3, #0
20000bf0:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.DummyCycles = 0;
20000bf2:	2300      	movs	r3, #0
20000bf4:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20000bf6:	2300      	movs	r3, #0
20000bf8:	64fb      	str	r3, [r7, #76]	; 0x4c
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20000bfa:	2300      	movs	r3, #0
20000bfc:	653b      	str	r3, [r7, #80]	; 0x50
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20000bfe:	2300      	movs	r3, #0
20000c00:	657b      	str	r3, [r7, #84]	; 0x54

	if (HAL_QSPI_Command(hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
20000c02:	f107 0320 	add.w	r3, r7, #32
20000c06:	f241 3288 	movw	r2, #5000	; 0x1388
20000c0a:	4619      	mov	r1, r3
20000c0c:	6878      	ldr	r0, [r7, #4]
20000c0e:	f014 fdab 	bl	20015768 <HAL_QSPI_Command>
20000c12:	4603      	mov	r3, r0
20000c14:	2b00      	cmp	r3, #0
20000c16:	d001      	beq.n	20000c1c <QSPI_WriteEnable+0x52>
			!= HAL_OK) {
		Error_Handler();
20000c18:	f7ff fe65 	bl	200008e6 <Error_Handler>
	}

	sConfig.Match = 0x02;
20000c1c:	2302      	movs	r3, #2
20000c1e:	60bb      	str	r3, [r7, #8]
	sConfig.Mask = 0x02;
20000c20:	2302      	movs	r3, #2
20000c22:	60fb      	str	r3, [r7, #12]
	sConfig.MatchMode = QSPI_MATCH_MODE_AND;
20000c24:	2300      	movs	r3, #0
20000c26:	61bb      	str	r3, [r7, #24]
	sConfig.StatusBytesSize = 1;
20000c28:	2301      	movs	r3, #1
20000c2a:	617b      	str	r3, [r7, #20]
	sConfig.Interval = 0x10;
20000c2c:	2310      	movs	r3, #16
20000c2e:	613b      	str	r3, [r7, #16]
	sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
20000c30:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
20000c34:	61fb      	str	r3, [r7, #28]


	sCommand.Instruction =  READ_STATUS_REG_CMD;
20000c36:	2305      	movs	r3, #5
20000c38:	623b      	str	r3, [r7, #32]
	sCommand.InstructionMode = QSPI_INSTRUCTION_4_LINES;
20000c3a:	f44f 7340 	mov.w	r3, #768	; 0x300
20000c3e:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20000c40:	2300      	movs	r3, #0
20000c42:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DataMode = QSPI_DATA_4_LINES;
20000c44:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
20000c48:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.NbData = 1;
20000c4a:	2301      	movs	r3, #1
20000c4c:	64bb      	str	r3, [r7, #72]	; 0x48
	sCommand.DummyCycles = 0;
20000c4e:	2300      	movs	r3, #0
20000c50:	637b      	str	r3, [r7, #52]	; 0x34

	if (HAL_QSPI_AutoPolling(hqspi, &sCommand, &sConfig,
20000c52:	f107 0208 	add.w	r2, r7, #8
20000c56:	f107 0120 	add.w	r1, r7, #32
20000c5a:	f241 3388 	movw	r3, #5000	; 0x1388
20000c5e:	6878      	ldr	r0, [r7, #4]
20000c60:	f015 fbe4 	bl	2001642c <HAL_QSPI_AutoPolling>
20000c64:	4603      	mov	r3, r0
20000c66:	2b00      	cmp	r3, #0
20000c68:	d001      	beq.n	20000c6e <QSPI_WriteEnable+0xa4>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		Error_Handler();
20000c6a:	f7ff fe3c 	bl	200008e6 <Error_Handler>
	}
}
20000c6e:	bf00      	nop
20000c70:	3758      	adds	r7, #88	; 0x58
20000c72:	46bd      	mov	sp, r7
20000c74:	bd80      	pop	{r7, pc}
	...

20000c78 <QSPI_AutoPollingMemReady>:

void QSPI_AutoPollingMemReady() {
20000c78:	b580      	push	{r7, lr}
20000c7a:	b094      	sub	sp, #80	; 0x50
20000c7c:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;
	QSPI_AutoPollingTypeDef sConfig;
	initCommonCmd(&sCommand);
20000c7e:	f107 0318 	add.w	r3, r7, #24
20000c82:	4618      	mov	r0, r3
20000c84:	f7ff ff52 	bl	20000b2c <initCommonCmd>

	sCommand.InstructionMode = QSPI_INSTRUCTION_4_LINES;
20000c88:	f44f 7340 	mov.w	r3, #768	; 0x300
20000c8c:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.Instruction = READ_STATUS_REG_CMD;
20000c8e:	2305      	movs	r3, #5
20000c90:	61bb      	str	r3, [r7, #24]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20000c92:	2300      	movs	r3, #0
20000c94:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20000c96:	2300      	movs	r3, #0
20000c98:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DataMode = QSPI_DATA_4_LINES;
20000c9a:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
20000c9e:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DummyCycles = 0;
20000ca0:	2300      	movs	r3, #0
20000ca2:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20000ca4:	2300      	movs	r3, #0
20000ca6:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20000ca8:	2300      	movs	r3, #0
20000caa:	64bb      	str	r3, [r7, #72]	; 0x48
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20000cac:	2300      	movs	r3, #0
20000cae:	64fb      	str	r3, [r7, #76]	; 0x4c

	sConfig.Match = 0x00;
20000cb0:	2300      	movs	r3, #0
20000cb2:	603b      	str	r3, [r7, #0]
	sConfig.Mask = 0x01;
20000cb4:	2301      	movs	r3, #1
20000cb6:	607b      	str	r3, [r7, #4]
	sConfig.MatchMode = QSPI_MATCH_MODE_AND;
20000cb8:	2300      	movs	r3, #0
20000cba:	613b      	str	r3, [r7, #16]
	sConfig.StatusBytesSize = 1;
20000cbc:	2301      	movs	r3, #1
20000cbe:	60fb      	str	r3, [r7, #12]
	sConfig.Interval = 0x10;
20000cc0:	2310      	movs	r3, #16
20000cc2:	60bb      	str	r3, [r7, #8]
	sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
20000cc4:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
20000cc8:	617b      	str	r3, [r7, #20]

	if (HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig,100000)!= HAL_OK) {
20000cca:	463a      	mov	r2, r7
20000ccc:	f107 0118 	add.w	r1, r7, #24
20000cd0:	4b06      	ldr	r3, [pc, #24]	; (20000cec <QSPI_AutoPollingMemReady+0x74>)
20000cd2:	4807      	ldr	r0, [pc, #28]	; (20000cf0 <QSPI_AutoPollingMemReady+0x78>)
20000cd4:	f015 fbaa 	bl	2001642c <HAL_QSPI_AutoPolling>
20000cd8:	4603      	mov	r3, r0
20000cda:	2b00      	cmp	r3, #0
20000cdc:	d001      	beq.n	20000ce2 <QSPI_AutoPollingMemReady+0x6a>
		Error_Handler();
20000cde:	f7ff fe02 	bl	200008e6 <Error_Handler>
	}
}
20000ce2:	bf00      	nop
20000ce4:	3750      	adds	r7, #80	; 0x50
20000ce6:	46bd      	mov	sp, r7
20000ce8:	bd80      	pop	{r7, pc}
20000cea:	bf00      	nop
20000cec:	000186a0 	.word	0x000186a0
20000cf0:	2001ca10 	.word	0x2001ca10

20000cf4 <sFLASH_MemoryMapped>:



void sFLASH_MemoryMapped(){
20000cf4:	b580      	push	{r7, lr}
20000cf6:	b090      	sub	sp, #64	; 0x40
20000cf8:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef cmd;
	QSPI_MemoryMappedTypeDef cfg;
	initCommonCmd(&cmd);
20000cfa:	f107 0308 	add.w	r3, r7, #8
20000cfe:	4618      	mov	r0, r3
20000d00:	f7ff ff14 	bl	20000b2c <initCommonCmd>

	cmd.InstructionMode = QSPI_INSTRUCTION_4_LINES;
20000d04:	f44f 7340 	mov.w	r3, #768	; 0x300
20000d08:	623b      	str	r3, [r7, #32]
	cmd.Instruction =   0xEB;
20000d0a:	23eb      	movs	r3, #235	; 0xeb
20000d0c:	60bb      	str	r3, [r7, #8]

	cmd.AddressMode = QSPI_ADDRESS_4_LINES;
20000d0e:	f44f 6340 	mov.w	r3, #3072	; 0xc00
20000d12:	627b      	str	r3, [r7, #36]	; 0x24
	cmd.AddressSize = QSPI_ADDRESS_24_BITS;
20000d14:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20000d18:	617b      	str	r3, [r7, #20]
	cmd.Address=0;
20000d1a:	2300      	movs	r3, #0
20000d1c:	60fb      	str	r3, [r7, #12]

	cmd.AlternateByteMode =  QSPI_ALTERNATE_BYTES_4_LINES;
20000d1e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
20000d22:	62bb      	str	r3, [r7, #40]	; 0x28
	cmd.AlternateBytesSize = QSPI_ALTERNATE_BYTES_8_BITS;
20000d24:	2300      	movs	r3, #0
20000d26:	61bb      	str	r3, [r7, #24]
	cmd.AlternateBytes = 0xA;
20000d28:	230a      	movs	r3, #10
20000d2a:	613b      	str	r3, [r7, #16]

	cmd.DummyCycles = 4;
20000d2c:	2304      	movs	r3, #4
20000d2e:	61fb      	str	r3, [r7, #28]

	cmd.DataMode =QSPI_DATA_4_LINES;
20000d30:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
20000d34:	62fb      	str	r3, [r7, #44]	; 0x2c
	cmd.DdrMode = QSPI_DDR_MODE_DISABLE;
20000d36:	2300      	movs	r3, #0
20000d38:	637b      	str	r3, [r7, #52]	; 0x34
	cmd.DdrHoldHalfCycle = QUADSPI_CCR_DCYC_0;
20000d3a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20000d3e:	63bb      	str	r3, [r7, #56]	; 0x38

	cmd.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20000d40:	2300      	movs	r3, #0
20000d42:	63fb      	str	r3, [r7, #60]	; 0x3c

	cfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE;
20000d44:	2300      	movs	r3, #0
20000d46:	607b      	str	r3, [r7, #4]
	cfg.TimeOutPeriod = 0x20;
20000d48:	2320      	movs	r3, #32
20000d4a:	603b      	str	r3, [r7, #0]

	cmd.NbData=0;
20000d4c:	2300      	movs	r3, #0
20000d4e:	633b      	str	r3, [r7, #48]	; 0x30

	if (HAL_QSPI_MemoryMapped(&hqspi, &cmd, &cfg)!=HAL_OK){
20000d50:	463a      	mov	r2, r7
20000d52:	f107 0308 	add.w	r3, r7, #8
20000d56:	4619      	mov	r1, r3
20000d58:	4805      	ldr	r0, [pc, #20]	; (20000d70 <sFLASH_MemoryMapped+0x7c>)
20000d5a:	f015 fe65 	bl	20016a28 <HAL_QSPI_MemoryMapped>
20000d5e:	4603      	mov	r3, r0
20000d60:	2b00      	cmp	r3, #0
20000d62:	d001      	beq.n	20000d68 <sFLASH_MemoryMapped+0x74>
		Error_Handler();
20000d64:	f7ff fdbf 	bl	200008e6 <Error_Handler>
	}
}
20000d68:	bf00      	nop
20000d6a:	3740      	adds	r7, #64	; 0x40
20000d6c:	46bd      	mov	sp, r7
20000d6e:	bd80      	pop	{r7, pc}
20000d70:	2001ca10 	.word	0x2001ca10

20000d74 <sFLASH_DeInit>:

void sFLASH_DeInit(void) {
20000d74:	b580      	push	{r7, lr}
20000d76:	af00      	add	r7, sp, #0
	QSPI_WriteEnable(&hqspi);
20000d78:	4802      	ldr	r0, [pc, #8]	; (20000d84 <sFLASH_DeInit+0x10>)
20000d7a:	f7ff ff26 	bl	20000bca <QSPI_WriteEnable>
}
20000d7e:	bf00      	nop
20000d80:	bd80      	pop	{r7, pc}
20000d82:	bf00      	nop
20000d84:	2001ca10 	.word	0x2001ca10

20000d88 <sFLASH_Reset>:


void sFLASH_Reset(void){
20000d88:	b580      	push	{r7, lr}
20000d8a:	b08e      	sub	sp, #56	; 0x38
20000d8c:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef cmd;
	initCommonCmd(&cmd);
20000d8e:	463b      	mov	r3, r7
20000d90:	4618      	mov	r0, r3
20000d92:	f7ff fecb 	bl	20000b2c <initCommonCmd>
	cmd.AddressMode=QSPI_ADDRESS_NONE;
20000d96:	2300      	movs	r3, #0
20000d98:	61fb      	str	r3, [r7, #28]
	cmd.Instruction=CHIP_RESET_ENABLE;
20000d9a:	2366      	movs	r3, #102	; 0x66
20000d9c:	603b      	str	r3, [r7, #0]
	if (HAL_QSPI_Command(&hqspi, &cmd,1000) != HAL_OK) {
20000d9e:	463b      	mov	r3, r7
20000da0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20000da4:	4619      	mov	r1, r3
20000da6:	480d      	ldr	r0, [pc, #52]	; (20000ddc <sFLASH_Reset+0x54>)
20000da8:	f014 fcde 	bl	20015768 <HAL_QSPI_Command>
20000dac:	4603      	mov	r3, r0
20000dae:	2b00      	cmp	r3, #0
20000db0:	d001      	beq.n	20000db6 <sFLASH_Reset+0x2e>
		Error_Handler();
20000db2:	f7ff fd98 	bl	200008e6 <Error_Handler>
	}
	cmd.Instruction=CHIP_RESET;
20000db6:	2399      	movs	r3, #153	; 0x99
20000db8:	603b      	str	r3, [r7, #0]
	if (HAL_QSPI_Command(&hqspi, &cmd,1000) != HAL_OK) {
20000dba:	463b      	mov	r3, r7
20000dbc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20000dc0:	4619      	mov	r1, r3
20000dc2:	4806      	ldr	r0, [pc, #24]	; (20000ddc <sFLASH_Reset+0x54>)
20000dc4:	f014 fcd0 	bl	20015768 <HAL_QSPI_Command>
20000dc8:	4603      	mov	r3, r0
20000dca:	2b00      	cmp	r3, #0
20000dcc:	d001      	beq.n	20000dd2 <sFLASH_Reset+0x4a>
		Error_Handler();
20000dce:	f7ff fd8a 	bl	200008e6 <Error_Handler>
	}


}
20000dd2:	bf00      	nop
20000dd4:	3738      	adds	r7, #56	; 0x38
20000dd6:	46bd      	mov	sp, r7
20000dd8:	bd80      	pop	{r7, pc}
20000dda:	bf00      	nop
20000ddc:	2001ca10 	.word	0x2001ca10

20000de0 <sFLASH_EraseSector>:

void sFLASH_EraseSector(uint32_t SectorAddr) {
20000de0:	b580      	push	{r7, lr}
20000de2:	b090      	sub	sp, #64	; 0x40
20000de4:	af00      	add	r7, sp, #0
20000de6:	6078      	str	r0, [r7, #4]

  sFLASH_InstanceCmd1(QSPICMD_ENTER_WRITE);
20000de8:	2006      	movs	r0, #6
20000dea:	f000 fa4d 	bl	20001288 <sFLASH_InstanceCmd1>
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
20000dee:	f107 0308 	add.w	r3, r7, #8
20000df2:	4618      	mov	r0, r3
20000df4:	f7ff fe9a 	bl	20000b2c <initCommonCmd>
	//64KB Erase
	sCommand.Instruction = SECTOR_ERASE_CMD;
20000df8:	23d8      	movs	r3, #216	; 0xd8
20000dfa:	60bb      	str	r3, [r7, #8]
	sCommand.InstructionMode= QSPI_INSTRUCTION_4_LINES;
20000dfc:	f44f 7340 	mov.w	r3, #768	; 0x300
20000e00:	623b      	str	r3, [r7, #32]
	sCommand.AddressMode = QSPI_ADDRESS_4_LINES;
20000e02:	f44f 6340 	mov.w	r3, #3072	; 0xc00
20000e06:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
20000e08:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20000e0c:	617b      	str	r3, [r7, #20]
	sCommand.Address = SectorAddr;
20000e0e:	687b      	ldr	r3, [r7, #4]
20000e10:	60fb      	str	r3, [r7, #12]
	sCommand.DummyCycles = 0;
20000e12:	2300      	movs	r3, #0
20000e14:	61fb      	str	r3, [r7, #28]
	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
20000e16:	f107 0308 	add.w	r3, r7, #8
20000e1a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20000e1e:	4619      	mov	r1, r3
20000e20:	4807      	ldr	r0, [pc, #28]	; (20000e40 <sFLASH_EraseSector+0x60>)
20000e22:	f014 fca1 	bl	20015768 <HAL_QSPI_Command>
20000e26:	4603      	mov	r3, r0
20000e28:	2b00      	cmp	r3, #0
20000e2a:	d001      	beq.n	20000e30 <sFLASH_EraseSector+0x50>
		Error_Handler();
20000e2c:	f7ff fd5b 	bl	200008e6 <Error_Handler>
	}
	QSPI_AutoPollingMemReady(&hqspi);
20000e30:	4803      	ldr	r0, [pc, #12]	; (20000e40 <sFLASH_EraseSector+0x60>)
20000e32:	f7ff ff21 	bl	20000c78 <QSPI_AutoPollingMemReady>
}
20000e36:	bf00      	nop
20000e38:	3740      	adds	r7, #64	; 0x40
20000e3a:	46bd      	mov	sp, r7
20000e3c:	bd80      	pop	{r7, pc}
20000e3e:	bf00      	nop
20000e40:	2001ca10 	.word	0x2001ca10

20000e44 <sFLASH_EraseBulk>:

void sFLASH_EraseBulk(void) {
20000e44:	b580      	push	{r7, lr}
20000e46:	b082      	sub	sp, #8
20000e48:	af00      	add	r7, sp, #0
	for(int i=0;i<32;i++){
20000e4a:	2300      	movs	r3, #0
20000e4c:	607b      	str	r3, [r7, #4]
20000e4e:	e007      	b.n	20000e60 <sFLASH_EraseBulk+0x1c>
		sFLASH_EraseSector(i<<16);
20000e50:	687b      	ldr	r3, [r7, #4]
20000e52:	041b      	lsls	r3, r3, #16
20000e54:	4618      	mov	r0, r3
20000e56:	f7ff ffc3 	bl	20000de0 <sFLASH_EraseSector>
	for(int i=0;i<32;i++){
20000e5a:	687b      	ldr	r3, [r7, #4]
20000e5c:	3301      	adds	r3, #1
20000e5e:	607b      	str	r3, [r7, #4]
20000e60:	687b      	ldr	r3, [r7, #4]
20000e62:	2b1f      	cmp	r3, #31
20000e64:	ddf4      	ble.n	20000e50 <sFLASH_EraseBulk+0xc>
//
//	#ifdef DEBUG
//	printf("Done BulkErase:  Extend:0x%x \n",sFLASH_ReadReg1(QSPICMD_READREG_READEXT));
//
//	#endif
}
20000e66:	bf00      	nop
20000e68:	3708      	adds	r7, #8
20000e6a:	46bd      	mov	sp, r7
20000e6c:	bd80      	pop	{r7, pc}
	...

20000e70 <sFLASH_WritePage>:

void sFLASH_WritePage(
		uint8_t *pBuffer,
		uint32_t WriteAddr,
		uint32_t NumByteToWrite) {
20000e70:	b580      	push	{r7, lr}
20000e72:	b092      	sub	sp, #72	; 0x48
20000e74:	af00      	add	r7, sp, #0
20000e76:	60f8      	str	r0, [r7, #12]
20000e78:	60b9      	str	r1, [r7, #8]
20000e7a:	607a      	str	r2, [r7, #4]

    sFLASH_InstanceCmd1(QSPICMD_ENTER_WRITE);
20000e7c:	2006      	movs	r0, #6
20000e7e:	f000 fa03 	bl	20001288 <sFLASH_InstanceCmd1>
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
20000e82:	f107 0310 	add.w	r3, r7, #16
20000e86:	4618      	mov	r0, r3
20000e88:	f7ff fe50 	bl	20000b2c <initCommonCmd>
	sCommand.Instruction = PAGE_PROG_CMD;
20000e8c:	2302      	movs	r3, #2
20000e8e:	613b      	str	r3, [r7, #16]
	sCommand.InstructionMode= QSPI_INSTRUCTION_4_LINES;
20000e90:	f44f 7340 	mov.w	r3, #768	; 0x300
20000e94:	62bb      	str	r3, [r7, #40]	; 0x28

	sCommand.AddressMode = QSPI_ADDRESS_4_LINES;
20000e96:	f44f 6340 	mov.w	r3, #3072	; 0xc00
20000e9a:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
20000e9c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20000ea0:	61fb      	str	r3, [r7, #28]
	sCommand.Address = WriteAddr;
20000ea2:	68bb      	ldr	r3, [r7, #8]
20000ea4:	617b      	str	r3, [r7, #20]

	sCommand.DataMode = QSPI_DATA_4_LINES;
20000ea6:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
20000eaa:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.NbData = NumByteToWrite;
20000eac:	687b      	ldr	r3, [r7, #4]
20000eae:	63bb      	str	r3, [r7, #56]	; 0x38

	sCommand.DummyCycles=0;
20000eb0:	2300      	movs	r3, #0
20000eb2:	627b      	str	r3, [r7, #36]	; 0x24

	sCommand.SIOOMode=QSPI_SIOO_INST_ONLY_FIRST_CMD;
20000eb4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
20000eb8:	647b      	str	r3, [r7, #68]	; 0x44

	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
20000eba:	f107 0310 	add.w	r3, r7, #16
20000ebe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20000ec2:	4619      	mov	r1, r3
20000ec4:	480a      	ldr	r0, [pc, #40]	; (20000ef0 <sFLASH_WritePage+0x80>)
20000ec6:	f014 fc4f 	bl	20015768 <HAL_QSPI_Command>
20000eca:	4603      	mov	r3, r0
20000ecc:	2b00      	cmp	r3, #0
20000ece:	d001      	beq.n	20000ed4 <sFLASH_WritePage+0x64>
		Error_Handler();
20000ed0:	f7ff fd09 	bl	200008e6 <Error_Handler>
	}

	HAL_QSPI_Transmit(&hqspi, pBuffer,1000);
20000ed4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20000ed8:	68f9      	ldr	r1, [r7, #12]
20000eda:	4805      	ldr	r0, [pc, #20]	; (20000ef0 <sFLASH_WritePage+0x80>)
20000edc:	f014 febc 	bl	20015c58 <HAL_QSPI_Transmit>
	QSPI_AutoPollingMemReady(&hqspi); }
20000ee0:	4803      	ldr	r0, [pc, #12]	; (20000ef0 <sFLASH_WritePage+0x80>)
20000ee2:	f7ff fec9 	bl	20000c78 <QSPI_AutoPollingMemReady>
20000ee6:	bf00      	nop
20000ee8:	3748      	adds	r7, #72	; 0x48
20000eea:	46bd      	mov	sp, r7
20000eec:	bd80      	pop	{r7, pc}
20000eee:	bf00      	nop
20000ef0:	2001ca10 	.word	0x2001ca10

20000ef4 <sFLASH_WriteBuffer>:

int sFLASH_WriteBuffer(
		uint32_t WriteAddr,
		uint32_t NumByteToWrite,
		uint8_t *pBuffer
		) {
20000ef4:	b580      	push	{r7, lr}
20000ef6:	b092      	sub	sp, #72	; 0x48
20000ef8:	af00      	add	r7, sp, #0
20000efa:	60f8      	str	r0, [r7, #12]
20000efc:	60b9      	str	r1, [r7, #8]
20000efe:	607a      	str	r2, [r7, #4]

    sFLASH_InstanceCmd1(QSPICMD_ENTER_WRITE);
20000f00:	2006      	movs	r0, #6
20000f02:	f000 f9c1 	bl	20001288 <sFLASH_InstanceCmd1>
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
20000f06:	f107 0310 	add.w	r3, r7, #16
20000f0a:	4618      	mov	r0, r3
20000f0c:	f7ff fe0e 	bl	20000b2c <initCommonCmd>
	sCommand.Instruction = PAGE_PROG_CMD;
20000f10:	2302      	movs	r3, #2
20000f12:	613b      	str	r3, [r7, #16]

	sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
20000f14:	f44f 6380 	mov.w	r3, #1024	; 0x400
20000f18:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
20000f1a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20000f1e:	61fb      	str	r3, [r7, #28]
	sCommand.Address = WriteAddr;
20000f20:	68fb      	ldr	r3, [r7, #12]
20000f22:	617b      	str	r3, [r7, #20]



	sCommand.DataMode = QSPI_DATA_1_LINE;
20000f24:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20000f28:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.NbData = NumByteToWrite;
20000f2a:	68bb      	ldr	r3, [r7, #8]
20000f2c:	63bb      	str	r3, [r7, #56]	; 0x38

	sCommand.DummyCycles = 0;
20000f2e:	2300      	movs	r3, #0
20000f30:	627b      	str	r3, [r7, #36]	; 0x24
	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
20000f32:	f107 0310 	add.w	r3, r7, #16
20000f36:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20000f3a:	4619      	mov	r1, r3
20000f3c:	480b      	ldr	r0, [pc, #44]	; (20000f6c <sFLASH_WriteBuffer+0x78>)
20000f3e:	f014 fc13 	bl	20015768 <HAL_QSPI_Command>
20000f42:	4603      	mov	r3, r0
20000f44:	2b00      	cmp	r3, #0
20000f46:	d003      	beq.n	20000f50 <sFLASH_WriteBuffer+0x5c>
		Error_Handler();
20000f48:	f7ff fccd 	bl	200008e6 <Error_Handler>
		return 0;
20000f4c:	2300      	movs	r3, #0
20000f4e:	e009      	b.n	20000f64 <sFLASH_WriteBuffer+0x70>
	}
	HAL_QSPI_Transmit(&hqspi, pBuffer,1000);
20000f50:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20000f54:	6879      	ldr	r1, [r7, #4]
20000f56:	4805      	ldr	r0, [pc, #20]	; (20000f6c <sFLASH_WriteBuffer+0x78>)
20000f58:	f014 fe7e 	bl	20015c58 <HAL_QSPI_Transmit>
	QSPI_AutoPollingMemReady(&hqspi);
20000f5c:	4803      	ldr	r0, [pc, #12]	; (20000f6c <sFLASH_WriteBuffer+0x78>)
20000f5e:	f7ff fe8b 	bl	20000c78 <QSPI_AutoPollingMemReady>
	return 1;
20000f62:	2301      	movs	r3, #1
}
20000f64:	4618      	mov	r0, r3
20000f66:	3748      	adds	r7, #72	; 0x48
20000f68:	46bd      	mov	sp, r7
20000f6a:	bd80      	pop	{r7, pc}
20000f6c:	2001ca10 	.word	0x2001ca10

20000f70 <sFLASH_ReadBuffer>:

void sFLASH_ReadBuffer(uint8_t *pBuffer, uint32_t ReadAddr,
		uint32_t NumByteToRead) {
20000f70:	b580      	push	{r7, lr}
20000f72:	b092      	sub	sp, #72	; 0x48
20000f74:	af00      	add	r7, sp, #0
20000f76:	60f8      	str	r0, [r7, #12]
20000f78:	60b9      	str	r1, [r7, #8]
20000f7a:	607a      	str	r2, [r7, #4]
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
20000f7c:	f107 0310 	add.w	r3, r7, #16
20000f80:	4618      	mov	r0, r3
20000f82:	f7ff fdd3 	bl	20000b2c <initCommonCmd>
	sCommand.Instruction = 0x0B;
20000f86:	230b      	movs	r3, #11
20000f88:	613b      	str	r3, [r7, #16]
	sCommand.InstructionMode = QSPI_INSTRUCTION_4_LINES;
20000f8a:	f44f 7340 	mov.w	r3, #768	; 0x300
20000f8e:	62bb      	str	r3, [r7, #40]	; 0x28

	sCommand.AddressMode = QSPI_ADDRESS_4_LINES;
20000f90:	f44f 6340 	mov.w	r3, #3072	; 0xc00
20000f94:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
20000f96:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20000f9a:	61fb      	str	r3, [r7, #28]
	sCommand.Address = ReadAddr;
20000f9c:	68bb      	ldr	r3, [r7, #8]
20000f9e:	617b      	str	r3, [r7, #20]


	sCommand.DataMode = QSPI_DATA_4_LINES;
20000fa0:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
20000fa4:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.NbData = NumByteToRead;
20000fa6:	687b      	ldr	r3, [r7, #4]
20000fa8:	63bb      	str	r3, [r7, #56]	; 0x38

	sCommand.DummyCycles = 6;
20000faa:	2306      	movs	r3, #6
20000fac:	627b      	str	r3, [r7, #36]	; 0x24
	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
20000fae:	f107 0310 	add.w	r3, r7, #16
20000fb2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20000fb6:	4619      	mov	r1, r3
20000fb8:	480a      	ldr	r0, [pc, #40]	; (20000fe4 <sFLASH_ReadBuffer+0x74>)
20000fba:	f014 fbd5 	bl	20015768 <HAL_QSPI_Command>
20000fbe:	4603      	mov	r3, r0
20000fc0:	2b00      	cmp	r3, #0
20000fc2:	d001      	beq.n	20000fc8 <sFLASH_ReadBuffer+0x58>
		Error_Handler();
20000fc4:	f7ff fc8f 	bl	200008e6 <Error_Handler>
	}
	HAL_QSPI_Receive(&hqspi, pBuffer,1000);
20000fc8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20000fcc:	68f9      	ldr	r1, [r7, #12]
20000fce:	4805      	ldr	r0, [pc, #20]	; (20000fe4 <sFLASH_ReadBuffer+0x74>)
20000fd0:	f014 fed4 	bl	20015d7c <HAL_QSPI_Receive>
	QSPI_AutoPollingMemReady(&hqspi);
20000fd4:	4803      	ldr	r0, [pc, #12]	; (20000fe4 <sFLASH_ReadBuffer+0x74>)
20000fd6:	f7ff fe4f 	bl	20000c78 <QSPI_AutoPollingMemReady>
}
20000fda:	bf00      	nop
20000fdc:	3748      	adds	r7, #72	; 0x48
20000fde:	46bd      	mov	sp, r7
20000fe0:	bd80      	pop	{r7, pc}
20000fe2:	bf00      	nop
20000fe4:	2001ca10 	.word	0x2001ca10

20000fe8 <sFLASH_ReadID>:

uint32_t sFLASH_ReadID(void) {
20000fe8:	b580      	push	{r7, lr}
20000fea:	b090      	sub	sp, #64	; 0x40
20000fec:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
20000fee:	1d3b      	adds	r3, r7, #4
20000ff0:	4618      	mov	r0, r3
20000ff2:	f7ff fd9b 	bl	20000b2c <initCommonCmd>

	sCommand.Instruction = 0xAF;
20000ff6:	23af      	movs	r3, #175	; 0xaf
20000ff8:	607b      	str	r3, [r7, #4]
	sCommand.InstructionMode= QSPI_INSTRUCTION_4_LINES;
20000ffa:	f44f 7340 	mov.w	r3, #768	; 0x300
20000ffe:	61fb      	str	r3, [r7, #28]

	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20001000:	2300      	movs	r3, #0
20001002:	623b      	str	r3, [r7, #32]

	sCommand.DataMode = QSPI_DATA_4_LINES;
20001004:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
20001008:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.NbData = 3;
2000100a:	2303      	movs	r3, #3
2000100c:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
2000100e:	2300      	movs	r3, #0
20001010:	61bb      	str	r3, [r7, #24]

	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
20001012:	1d3b      	adds	r3, r7, #4
20001014:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20001018:	4619      	mov	r1, r3
2000101a:	480e      	ldr	r0, [pc, #56]	; (20001054 <sFLASH_ReadID+0x6c>)
2000101c:	f014 fba4 	bl	20015768 <HAL_QSPI_Command>
20001020:	4603      	mov	r3, r0
20001022:	2b00      	cmp	r3, #0
20001024:	d001      	beq.n	2000102a <sFLASH_ReadID+0x42>
		Error_Handler();
20001026:	f7ff fc5e 	bl	200008e6 <Error_Handler>
	}

	uint8_t pData[4];
	HAL_QSPI_Receive(&hqspi,pData,1000);
2000102a:	463b      	mov	r3, r7
2000102c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20001030:	4619      	mov	r1, r3
20001032:	4808      	ldr	r0, [pc, #32]	; (20001054 <sFLASH_ReadID+0x6c>)
20001034:	f014 fea2 	bl	20015d7c <HAL_QSPI_Receive>

	uint32_t res;
	res = (pData[0] << 16) | (pData[1] << 8) | pData[2];
20001038:	783b      	ldrb	r3, [r7, #0]
2000103a:	041a      	lsls	r2, r3, #16
2000103c:	787b      	ldrb	r3, [r7, #1]
2000103e:	021b      	lsls	r3, r3, #8
20001040:	4313      	orrs	r3, r2
20001042:	78ba      	ldrb	r2, [r7, #2]
20001044:	4313      	orrs	r3, r2
20001046:	63fb      	str	r3, [r7, #60]	; 0x3c
	return res;
20001048:	6bfb      	ldr	r3, [r7, #60]	; 0x3c

}
2000104a:	4618      	mov	r0, r3
2000104c:	3740      	adds	r7, #64	; 0x40
2000104e:	46bd      	mov	sp, r7
20001050:	bd80      	pop	{r7, pc}
20001052:	bf00      	nop
20001054:	2001ca10 	.word	0x2001ca10

20001058 <sFLASH_ReadReg1>:


uint8_t sFLASH_ReadReg1(uint8_t ins) {
20001058:	b580      	push	{r7, lr}
2000105a:	b092      	sub	sp, #72	; 0x48
2000105c:	af00      	add	r7, sp, #0
2000105e:	4603      	mov	r3, r0
20001060:	71fb      	strb	r3, [r7, #7]
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
20001062:	f107 0310 	add.w	r3, r7, #16
20001066:	4618      	mov	r0, r3
20001068:	f7ff fd60 	bl	20000b2c <initCommonCmd>

	sCommand.Instruction = ins;
2000106c:	79fb      	ldrb	r3, [r7, #7]
2000106e:	613b      	str	r3, [r7, #16]
	sCommand.InstructionMode = QSPI_INSTRUCTION_4_LINES;
20001070:	f44f 7340 	mov.w	r3, #768	; 0x300
20001074:	62bb      	str	r3, [r7, #40]	; 0x28

	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20001076:	2300      	movs	r3, #0
20001078:	62fb      	str	r3, [r7, #44]	; 0x2c

	sCommand.DataMode = QSPI_DATA_4_LINES;
2000107a:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
2000107e:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.NbData = 1;
20001080:	2301      	movs	r3, #1
20001082:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DummyCycles = 0;
20001084:	2300      	movs	r3, #0
20001086:	627b      	str	r3, [r7, #36]	; 0x24

	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
20001088:	f107 0310 	add.w	r3, r7, #16
2000108c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20001090:	4619      	mov	r1, r3
20001092:	480a      	ldr	r0, [pc, #40]	; (200010bc <sFLASH_ReadReg1+0x64>)
20001094:	f014 fb68 	bl	20015768 <HAL_QSPI_Command>
20001098:	4603      	mov	r3, r0
2000109a:	2b00      	cmp	r3, #0
2000109c:	d001      	beq.n	200010a2 <sFLASH_ReadReg1+0x4a>
		Error_Handler();
2000109e:	f7ff fc22 	bl	200008e6 <Error_Handler>
	}
	uint8_t pData;
	HAL_QSPI_Receive(&hqspi,&pData,1000);
200010a2:	f107 030f 	add.w	r3, r7, #15
200010a6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
200010aa:	4619      	mov	r1, r3
200010ac:	4803      	ldr	r0, [pc, #12]	; (200010bc <sFLASH_ReadReg1+0x64>)
200010ae:	f014 fe65 	bl	20015d7c <HAL_QSPI_Receive>
	return  pData;
200010b2:	7bfb      	ldrb	r3, [r7, #15]
}
200010b4:	4618      	mov	r0, r3
200010b6:	3748      	adds	r7, #72	; 0x48
200010b8:	46bd      	mov	sp, r7
200010ba:	bd80      	pop	{r7, pc}
200010bc:	2001ca10 	.word	0x2001ca10

200010c0 <sFLASH_SetReg1>:

uint8_t sFLASH_SetReg1(uint8_t ins, uint8_t payload){
200010c0:	b580      	push	{r7, lr}
200010c2:	b090      	sub	sp, #64	; 0x40
200010c4:	af00      	add	r7, sp, #0
200010c6:	4603      	mov	r3, r0
200010c8:	460a      	mov	r2, r1
200010ca:	71fb      	strb	r3, [r7, #7]
200010cc:	4613      	mov	r3, r2
200010ce:	71bb      	strb	r3, [r7, #6]
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
200010d0:	f107 0308 	add.w	r3, r7, #8
200010d4:	4618      	mov	r0, r3
200010d6:	f7ff fd29 	bl	20000b2c <initCommonCmd>

	sCommand.Instruction = ins;
200010da:	79fb      	ldrb	r3, [r7, #7]
200010dc:	60bb      	str	r3, [r7, #8]
	sCommand.InstructionMode = QSPI_INSTRUCTION_4_LINES;
200010de:	f44f 7340 	mov.w	r3, #768	; 0x300
200010e2:	623b      	str	r3, [r7, #32]

	sCommand.AddressMode = QSPI_ADDRESS_NONE;
200010e4:	2300      	movs	r3, #0
200010e6:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.AddressSize =QSPI_ADDRESS_8_BITS;
200010e8:	2300      	movs	r3, #0
200010ea:	617b      	str	r3, [r7, #20]

	sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
200010ec:	2300      	movs	r3, #0
200010ee:	62bb      	str	r3, [r7, #40]	; 0x28

	sCommand.DataMode =  QSPI_DATA_4_LINES;
200010f0:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
200010f4:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.NbData = 1;
200010f6:	2301      	movs	r3, #1
200010f8:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DummyCycles = 0;
200010fa:	2300      	movs	r3, #0
200010fc:	61fb      	str	r3, [r7, #28]

	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
200010fe:	f107 0308 	add.w	r3, r7, #8
20001102:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20001106:	4619      	mov	r1, r3
20001108:	4809      	ldr	r0, [pc, #36]	; (20001130 <sFLASH_SetReg1+0x70>)
2000110a:	f014 fb2d 	bl	20015768 <HAL_QSPI_Command>
2000110e:	4603      	mov	r3, r0
20001110:	2b00      	cmp	r3, #0
20001112:	d001      	beq.n	20001118 <sFLASH_SetReg1+0x58>
		Error_Handler();
20001114:	f7ff fbe7 	bl	200008e6 <Error_Handler>
	}
	HAL_QSPI_Transmit(&hqspi,&payload,1000);
20001118:	1dbb      	adds	r3, r7, #6
2000111a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
2000111e:	4619      	mov	r1, r3
20001120:	4803      	ldr	r0, [pc, #12]	; (20001130 <sFLASH_SetReg1+0x70>)
20001122:	f014 fd99 	bl	20015c58 <HAL_QSPI_Transmit>
}
20001126:	bf00      	nop
20001128:	4618      	mov	r0, r3
2000112a:	3740      	adds	r7, #64	; 0x40
2000112c:	46bd      	mov	sp, r7
2000112e:	bd80      	pop	{r7, pc}
20001130:	2001ca10 	.word	0x2001ca10

20001134 <sFLASH_SetReg1SingleLine>:

uint8_t sFLASH_SetReg1SingleLine(uint8_t ins, uint8_t payload){
20001134:	b580      	push	{r7, lr}
20001136:	b090      	sub	sp, #64	; 0x40
20001138:	af00      	add	r7, sp, #0
2000113a:	4603      	mov	r3, r0
2000113c:	460a      	mov	r2, r1
2000113e:	71fb      	strb	r3, [r7, #7]
20001140:	4613      	mov	r3, r2
20001142:	71bb      	strb	r3, [r7, #6]
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
20001144:	f107 0308 	add.w	r3, r7, #8
20001148:	4618      	mov	r0, r3
2000114a:	f7ff fcef 	bl	20000b2c <initCommonCmd>
	sCommand.Instruction = ins;
2000114e:	79fb      	ldrb	r3, [r7, #7]
20001150:	60bb      	str	r3, [r7, #8]
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20001152:	f44f 7380 	mov.w	r3, #256	; 0x100
20001156:	623b      	str	r3, [r7, #32]

	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20001158:	2300      	movs	r3, #0
2000115a:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.AddressSize = QSPI_ADDRESS_8_BITS;
2000115c:	2300      	movs	r3, #0
2000115e:	617b      	str	r3, [r7, #20]
	sCommand.Address =0x0;
20001160:	2300      	movs	r3, #0
20001162:	60fb      	str	r3, [r7, #12]

	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20001164:	2300      	movs	r3, #0
20001166:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.AlternateBytesSize = QSPI_ALTERNATE_BYTES_8_BITS;
20001168:	2300      	movs	r3, #0
2000116a:	61bb      	str	r3, [r7, #24]
	sCommand.AlternateBytes =0x0;
2000116c:	2300      	movs	r3, #0
2000116e:	613b      	str	r3, [r7, #16]

	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_HALF_CLK_DELAY;
20001170:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
20001174:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20001176:	2300      	movs	r3, #0
20001178:	637b      	str	r3, [r7, #52]	; 0x34

	sCommand.SIOOMode  = QSPI_SIOO_INST_EVERY_CMD;
2000117a:	2300      	movs	r3, #0
2000117c:	63fb      	str	r3, [r7, #60]	; 0x3c

	sCommand.DataMode = QSPI_DATA_1_LINE;
2000117e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20001182:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.NbData = 1;
20001184:	2301      	movs	r3, #1
20001186:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DummyCycles = 0;
20001188:	2300      	movs	r3, #0
2000118a:	61fb      	str	r3, [r7, #28]
	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
2000118c:	f107 0308 	add.w	r3, r7, #8
20001190:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20001194:	4619      	mov	r1, r3
20001196:	480b      	ldr	r0, [pc, #44]	; (200011c4 <sFLASH_SetReg1SingleLine+0x90>)
20001198:	f014 fae6 	bl	20015768 <HAL_QSPI_Command>
2000119c:	4603      	mov	r3, r0
2000119e:	2b00      	cmp	r3, #0
200011a0:	d001      	beq.n	200011a6 <sFLASH_SetReg1SingleLine+0x72>
		Error_Handler();
200011a2:	f7ff fba0 	bl	200008e6 <Error_Handler>
	}
	HAL_QSPI_Transmit(&hqspi,&payload,1000);
200011a6:	1dbb      	adds	r3, r7, #6
200011a8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
200011ac:	4619      	mov	r1, r3
200011ae:	4805      	ldr	r0, [pc, #20]	; (200011c4 <sFLASH_SetReg1SingleLine+0x90>)
200011b0:	f014 fd52 	bl	20015c58 <HAL_QSPI_Transmit>
    QSPI_AutoPollingMemReadySingleLine();
200011b4:	f000 f8ca 	bl	2000134c <QSPI_AutoPollingMemReadySingleLine>
}
200011b8:	bf00      	nop
200011ba:	4618      	mov	r0, r3
200011bc:	3740      	adds	r7, #64	; 0x40
200011be:	46bd      	mov	sp, r7
200011c0:	bd80      	pop	{r7, pc}
200011c2:	bf00      	nop
200011c4:	2001ca10 	.word	0x2001ca10

200011c8 <sFLASH_QPIMODE>:


void sFLASH_QPIMODE(uint8_t enable){
200011c8:	b580      	push	{r7, lr}
200011ca:	b090      	sub	sp, #64	; 0x40
200011cc:	af00      	add	r7, sp, #0
200011ce:	4603      	mov	r3, r0
200011d0:	71fb      	strb	r3, [r7, #7]
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
200011d2:	f107 0308 	add.w	r3, r7, #8
200011d6:	4618      	mov	r0, r3
200011d8:	f7ff fca8 	bl	20000b2c <initCommonCmd>
	if(enable){
200011dc:	79fb      	ldrb	r3, [r7, #7]
200011de:	2b00      	cmp	r3, #0
200011e0:	d005      	beq.n	200011ee <sFLASH_QPIMODE+0x26>
		sCommand.Instruction =  QSPICMD_ENTER_QUAD;
200011e2:	2335      	movs	r3, #53	; 0x35
200011e4:	60bb      	str	r3, [r7, #8]
		sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
200011e6:	f44f 7380 	mov.w	r3, #256	; 0x100
200011ea:	623b      	str	r3, [r7, #32]
200011ec:	e004      	b.n	200011f8 <sFLASH_QPIMODE+0x30>
	} else{
		sCommand.Instruction =  QSPICMD_EXIT_QUAD;
200011ee:	23f5      	movs	r3, #245	; 0xf5
200011f0:	60bb      	str	r3, [r7, #8]
		sCommand.InstructionMode = QSPI_INSTRUCTION_4_LINES;
200011f2:	f44f 7340 	mov.w	r3, #768	; 0x300
200011f6:	623b      	str	r3, [r7, #32]
	}

	sCommand.AddressMode = QSPI_ADDRESS_NONE;
200011f8:	2300      	movs	r3, #0
200011fa:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DataMode = QSPI_DATA_NONE;
200011fc:	2300      	movs	r3, #0
200011fe:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.NbData = 0;
20001200:	2300      	movs	r3, #0
20001202:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DummyCycles = 0;
20001204:	2300      	movs	r3, #0
20001206:	61fb      	str	r3, [r7, #28]
	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
20001208:	f107 0308 	add.w	r3, r7, #8
2000120c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20001210:	4619      	mov	r1, r3
20001212:	4806      	ldr	r0, [pc, #24]	; (2000122c <sFLASH_QPIMODE+0x64>)
20001214:	f014 faa8 	bl	20015768 <HAL_QSPI_Command>
20001218:	4603      	mov	r3, r0
2000121a:	2b00      	cmp	r3, #0
2000121c:	d001      	beq.n	20001222 <sFLASH_QPIMODE+0x5a>
		Error_Handler();
2000121e:	f7ff fb62 	bl	200008e6 <Error_Handler>
	}

}
20001222:	bf00      	nop
20001224:	3740      	adds	r7, #64	; 0x40
20001226:	46bd      	mov	sp, r7
20001228:	bd80      	pop	{r7, pc}
2000122a:	bf00      	nop
2000122c:	2001ca10 	.word	0x2001ca10

20001230 <sFLASH_InstanceCmd1SingleLine>:

void sFLASH_InstanceCmd1SingleLine(uint8_t ins){
20001230:	b580      	push	{r7, lr}
20001232:	b090      	sub	sp, #64	; 0x40
20001234:	af00      	add	r7, sp, #0
20001236:	4603      	mov	r3, r0
20001238:	71fb      	strb	r3, [r7, #7]
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
2000123a:	f107 0308 	add.w	r3, r7, #8
2000123e:	4618      	mov	r0, r3
20001240:	f7ff fc74 	bl	20000b2c <initCommonCmd>
	sCommand.Instruction = ins;
20001244:	79fb      	ldrb	r3, [r7, #7]
20001246:	60bb      	str	r3, [r7, #8]
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20001248:	f44f 7380 	mov.w	r3, #256	; 0x100
2000124c:	623b      	str	r3, [r7, #32]

	sCommand.AddressMode = QSPI_ADDRESS_NONE;
2000124e:	2300      	movs	r3, #0
20001250:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DataMode = QSPI_DATA_NONE;
20001252:	2300      	movs	r3, #0
20001254:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.NbData = 0;
20001256:	2300      	movs	r3, #0
20001258:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DummyCycles = 0;
2000125a:	2300      	movs	r3, #0
2000125c:	61fb      	str	r3, [r7, #28]
	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
2000125e:	f107 0308 	add.w	r3, r7, #8
20001262:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20001266:	4619      	mov	r1, r3
20001268:	4806      	ldr	r0, [pc, #24]	; (20001284 <sFLASH_InstanceCmd1SingleLine+0x54>)
2000126a:	f014 fa7d 	bl	20015768 <HAL_QSPI_Command>
2000126e:	4603      	mov	r3, r0
20001270:	2b00      	cmp	r3, #0
20001272:	d001      	beq.n	20001278 <sFLASH_InstanceCmd1SingleLine+0x48>
		Error_Handler();
20001274:	f7ff fb37 	bl	200008e6 <Error_Handler>
	}

	QSPI_AutoPollingMemReadySingleLine();
20001278:	f000 f868 	bl	2000134c <QSPI_AutoPollingMemReadySingleLine>

}
2000127c:	bf00      	nop
2000127e:	3740      	adds	r7, #64	; 0x40
20001280:	46bd      	mov	sp, r7
20001282:	bd80      	pop	{r7, pc}
20001284:	2001ca10 	.word	0x2001ca10

20001288 <sFLASH_InstanceCmd1>:

void sFLASH_InstanceCmd1(uint8_t ins){
20001288:	b580      	push	{r7, lr}
2000128a:	b090      	sub	sp, #64	; 0x40
2000128c:	af00      	add	r7, sp, #0
2000128e:	4603      	mov	r3, r0
20001290:	71fb      	strb	r3, [r7, #7]
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
20001292:	f107 0308 	add.w	r3, r7, #8
20001296:	4618      	mov	r0, r3
20001298:	f7ff fc48 	bl	20000b2c <initCommonCmd>
	sCommand.Instruction = ins;
2000129c:	79fb      	ldrb	r3, [r7, #7]
2000129e:	60bb      	str	r3, [r7, #8]
	sCommand.InstructionMode = QSPI_INSTRUCTION_4_LINES;
200012a0:	f44f 7340 	mov.w	r3, #768	; 0x300
200012a4:	623b      	str	r3, [r7, #32]

	sCommand.AddressMode = QSPI_ADDRESS_NONE;
200012a6:	2300      	movs	r3, #0
200012a8:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DataMode = QSPI_DATA_NONE;
200012aa:	2300      	movs	r3, #0
200012ac:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.NbData = 0;
200012ae:	2300      	movs	r3, #0
200012b0:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DummyCycles = 0;
200012b2:	2300      	movs	r3, #0
200012b4:	61fb      	str	r3, [r7, #28]
	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
200012b6:	f107 0308 	add.w	r3, r7, #8
200012ba:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
200012be:	4619      	mov	r1, r3
200012c0:	4805      	ldr	r0, [pc, #20]	; (200012d8 <sFLASH_InstanceCmd1+0x50>)
200012c2:	f014 fa51 	bl	20015768 <HAL_QSPI_Command>
200012c6:	4603      	mov	r3, r0
200012c8:	2b00      	cmp	r3, #0
200012ca:	d001      	beq.n	200012d0 <sFLASH_InstanceCmd1+0x48>
		Error_Handler();
200012cc:	f7ff fb0b 	bl	200008e6 <Error_Handler>
	}

}
200012d0:	bf00      	nop
200012d2:	3740      	adds	r7, #64	; 0x40
200012d4:	46bd      	mov	sp, r7
200012d6:	bd80      	pop	{r7, pc}
200012d8:	2001ca10 	.word	0x2001ca10

200012dc <sFLASH_ReadIDSingleLine>:


uint32_t sFLASH_ReadIDSingleLine(void) {
200012dc:	b580      	push	{r7, lr}
200012de:	b090      	sub	sp, #64	; 0x40
200012e0:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
200012e2:	1d3b      	adds	r3, r7, #4
200012e4:	4618      	mov	r0, r3
200012e6:	f7ff fc21 	bl	20000b2c <initCommonCmd>

	sCommand.Instruction = 0x9F;
200012ea:	239f      	movs	r3, #159	; 0x9f
200012ec:	607b      	str	r3, [r7, #4]
	sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
200012ee:	f44f 7380 	mov.w	r3, #256	; 0x100
200012f2:	61fb      	str	r3, [r7, #28]

	sCommand.AddressMode = QSPI_ADDRESS_NONE;
200012f4:	2300      	movs	r3, #0
200012f6:	623b      	str	r3, [r7, #32]

	sCommand.DataMode = QSPI_DATA_1_LINE;
200012f8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200012fc:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.NbData = 3;
200012fe:	2303      	movs	r3, #3
20001300:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
20001302:	2300      	movs	r3, #0
20001304:	61bb      	str	r3, [r7, #24]

	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
20001306:	1d3b      	adds	r3, r7, #4
20001308:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
2000130c:	4619      	mov	r1, r3
2000130e:	480e      	ldr	r0, [pc, #56]	; (20001348 <sFLASH_ReadIDSingleLine+0x6c>)
20001310:	f014 fa2a 	bl	20015768 <HAL_QSPI_Command>
20001314:	4603      	mov	r3, r0
20001316:	2b00      	cmp	r3, #0
20001318:	d001      	beq.n	2000131e <sFLASH_ReadIDSingleLine+0x42>
		Error_Handler();
2000131a:	f7ff fae4 	bl	200008e6 <Error_Handler>
	}

	uint8_t pData[4];
	HAL_QSPI_Receive(&hqspi,pData,1000);
2000131e:	463b      	mov	r3, r7
20001320:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20001324:	4619      	mov	r1, r3
20001326:	4808      	ldr	r0, [pc, #32]	; (20001348 <sFLASH_ReadIDSingleLine+0x6c>)
20001328:	f014 fd28 	bl	20015d7c <HAL_QSPI_Receive>

	uint32_t res;
	res = (pData[0] << 16) | (pData[1] << 8) | pData[2];
2000132c:	783b      	ldrb	r3, [r7, #0]
2000132e:	041a      	lsls	r2, r3, #16
20001330:	787b      	ldrb	r3, [r7, #1]
20001332:	021b      	lsls	r3, r3, #8
20001334:	4313      	orrs	r3, r2
20001336:	78ba      	ldrb	r2, [r7, #2]
20001338:	4313      	orrs	r3, r2
2000133a:	63fb      	str	r3, [r7, #60]	; 0x3c
	return res;
2000133c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c

}
2000133e:	4618      	mov	r0, r3
20001340:	3740      	adds	r7, #64	; 0x40
20001342:	46bd      	mov	sp, r7
20001344:	bd80      	pop	{r7, pc}
20001346:	bf00      	nop
20001348:	2001ca10 	.word	0x2001ca10

2000134c <QSPI_AutoPollingMemReadySingleLine>:

void QSPI_AutoPollingMemReadySingleLine() {
2000134c:	b580      	push	{r7, lr}
2000134e:	b094      	sub	sp, #80	; 0x50
20001350:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;
	QSPI_AutoPollingTypeDef sConfig;
	initCommonCmd(&sCommand);
20001352:	f107 0318 	add.w	r3, r7, #24
20001356:	4618      	mov	r0, r3
20001358:	f7ff fbe8 	bl	20000b2c <initCommonCmd>

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2000135c:	f44f 7380 	mov.w	r3, #256	; 0x100
20001360:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.Instruction = READ_STATUS_REG_CMD;
20001362:	2305      	movs	r3, #5
20001364:	61bb      	str	r3, [r7, #24]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20001366:	2300      	movs	r3, #0
20001368:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2000136a:	2300      	movs	r3, #0
2000136c:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DataMode = QSPI_DATA_1_LINE;
2000136e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20001372:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DummyCycles = 0;
20001374:	2300      	movs	r3, #0
20001376:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20001378:	2300      	movs	r3, #0
2000137a:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2000137c:	2300      	movs	r3, #0
2000137e:	64bb      	str	r3, [r7, #72]	; 0x48
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20001380:	2300      	movs	r3, #0
20001382:	64fb      	str	r3, [r7, #76]	; 0x4c

	sConfig.Match = 0x00;
20001384:	2300      	movs	r3, #0
20001386:	603b      	str	r3, [r7, #0]
	sConfig.Mask = 0x01;
20001388:	2301      	movs	r3, #1
2000138a:	607b      	str	r3, [r7, #4]
	sConfig.MatchMode = QSPI_MATCH_MODE_AND;
2000138c:	2300      	movs	r3, #0
2000138e:	613b      	str	r3, [r7, #16]
	sConfig.StatusBytesSize = 1;
20001390:	2301      	movs	r3, #1
20001392:	60fb      	str	r3, [r7, #12]
	sConfig.Interval = 0x10;
20001394:	2310      	movs	r3, #16
20001396:	60bb      	str	r3, [r7, #8]
	sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
20001398:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
2000139c:	617b      	str	r3, [r7, #20]

	if (HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig,1000)!= HAL_OK) {
2000139e:	463a      	mov	r2, r7
200013a0:	f107 0118 	add.w	r1, r7, #24
200013a4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
200013a8:	4805      	ldr	r0, [pc, #20]	; (200013c0 <QSPI_AutoPollingMemReadySingleLine+0x74>)
200013aa:	f015 f83f 	bl	2001642c <HAL_QSPI_AutoPolling>
200013ae:	4603      	mov	r3, r0
200013b0:	2b00      	cmp	r3, #0
200013b2:	d001      	beq.n	200013b8 <QSPI_AutoPollingMemReadySingleLine+0x6c>
		Error_Handler();
200013b4:	f7ff fa97 	bl	200008e6 <Error_Handler>
	}
}
200013b8:	bf00      	nop
200013ba:	3750      	adds	r7, #80	; 0x50
200013bc:	46bd      	mov	sp, r7
200013be:	bd80      	pop	{r7, pc}
200013c0:	2001ca10 	.word	0x2001ca10

200013c4 <sFLASH_ReadReg1SingleLine>:

uint8_t sFLASH_ReadReg1SingleLine(uint8_t ins) {
200013c4:	b580      	push	{r7, lr}
200013c6:	b092      	sub	sp, #72	; 0x48
200013c8:	af00      	add	r7, sp, #0
200013ca:	4603      	mov	r3, r0
200013cc:	71fb      	strb	r3, [r7, #7]
	QSPI_CommandTypeDef sCommand;
	initCommonCmd(&sCommand);
200013ce:	f107 0310 	add.w	r3, r7, #16
200013d2:	4618      	mov	r0, r3
200013d4:	f7ff fbaa 	bl	20000b2c <initCommonCmd>

	sCommand.Instruction = ins;
200013d8:	79fb      	ldrb	r3, [r7, #7]
200013da:	613b      	str	r3, [r7, #16]
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
200013dc:	f44f 7380 	mov.w	r3, #256	; 0x100
200013e0:	62bb      	str	r3, [r7, #40]	; 0x28

	sCommand.AddressMode = QSPI_ADDRESS_NONE;
200013e2:	2300      	movs	r3, #0
200013e4:	62fb      	str	r3, [r7, #44]	; 0x2c

	sCommand.DataMode = QSPI_DATA_1_LINE;
200013e6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200013ea:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.NbData = 1;
200013ec:	2301      	movs	r3, #1
200013ee:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DummyCycles = 0;
200013f0:	2300      	movs	r3, #0
200013f2:	627b      	str	r3, [r7, #36]	; 0x24

	if (HAL_QSPI_Command(&hqspi, &sCommand,1000) != HAL_OK) {
200013f4:	f107 0310 	add.w	r3, r7, #16
200013f8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
200013fc:	4619      	mov	r1, r3
200013fe:	480a      	ldr	r0, [pc, #40]	; (20001428 <sFLASH_ReadReg1SingleLine+0x64>)
20001400:	f014 f9b2 	bl	20015768 <HAL_QSPI_Command>
20001404:	4603      	mov	r3, r0
20001406:	2b00      	cmp	r3, #0
20001408:	d001      	beq.n	2000140e <sFLASH_ReadReg1SingleLine+0x4a>
		Error_Handler();
2000140a:	f7ff fa6c 	bl	200008e6 <Error_Handler>
	}
	uint8_t pData;
	HAL_QSPI_Receive(&hqspi,&pData,1000);
2000140e:	f107 030f 	add.w	r3, r7, #15
20001412:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
20001416:	4619      	mov	r1, r3
20001418:	4803      	ldr	r0, [pc, #12]	; (20001428 <sFLASH_ReadReg1SingleLine+0x64>)
2000141a:	f014 fcaf 	bl	20015d7c <HAL_QSPI_Receive>
	return  pData;
2000141e:	7bfb      	ldrb	r3, [r7, #15]
}
20001420:	4618      	mov	r0, r3
20001422:	3748      	adds	r7, #72	; 0x48
20001424:	46bd      	mov	sp, r7
20001426:	bd80      	pop	{r7, pc}
20001428:	2001ca10 	.word	0x2001ca10

2000142c <sFLASH_Init>:


void sFLASH_Init(void) {
2000142c:	b580      	push	{r7, lr}
2000142e:	af00      	add	r7, sp, #0
  sFLASH_Reset();
20001430:	f7ff fcaa 	bl	20000d88 <sFLASH_Reset>

  //If the SRWD is set to 1 and
  //WP# is pulled high (VIH), the Status Register can be changed by a WRSR instruction.
  sFLASH_QPIMODE(0);
20001434:	2000      	movs	r0, #0
20001436:	f7ff fec7 	bl	200011c8 <sFLASH_QPIMODE>
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2, GPIO_PIN_SET);
2000143a:	2201      	movs	r2, #1
2000143c:	2104      	movs	r1, #4
2000143e:	480f      	ldr	r0, [pc, #60]	; (2000147c <sFLASH_Init+0x50>)
20001440:	f00b f838 	bl	2000c4b4 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_SET);
20001444:	2201      	movs	r2, #1
20001446:	f44f 5100 	mov.w	r1, #8192	; 0x2000
2000144a:	480d      	ldr	r0, [pc, #52]	; (20001480 <sFLASH_Init+0x54>)
2000144c:	f00b f832 	bl	2000c4b4 <HAL_GPIO_WritePin>


  //QE: 1 BP[3:0]=0 to disable all protection
  sFLASH_InstanceCmd1SingleLine(QSPICMD_ENTER_WRITE);
20001450:	2006      	movs	r0, #6
20001452:	f7ff feed 	bl	20001230 <sFLASH_InstanceCmd1SingleLine>
  sFLASH_SetReg1SingleLine(QSPICMD_SETREG_STATUS, 0x40);
20001456:	2140      	movs	r1, #64	; 0x40
20001458:	2001      	movs	r0, #1
2000145a:	f7ff fe6b 	bl	20001134 <sFLASH_SetReg1SingleLine>

  //6 Dummy Cycle for qpi mode, no burst mode
  sFLASH_InstanceCmd1SingleLine(QSPICMD_ENTER_WRITE);
2000145e:	2006      	movs	r0, #6
20001460:	f7ff fee6 	bl	20001230 <sFLASH_InstanceCmd1SingleLine>
  sFLASH_SetReg1SingleLine(QSPICMD_SETREG_READP_NV, 0x30);
20001464:	2130      	movs	r1, #48	; 0x30
20001466:	2065      	movs	r0, #101	; 0x65
20001468:	f7ff fe64 	bl	20001134 <sFLASH_SetReg1SingleLine>


#ifdef DEBUG
  printf("Enter QuadMode\n==============================\n");
#endif
  sFLASH_QPIMODE(1);
2000146c:	2001      	movs	r0, #1
2000146e:	f7ff feab 	bl	200011c8 <sFLASH_QPIMODE>

  QSPI_AutoPollingMemReady();
20001472:	f7ff fc01 	bl	20000c78 <QSPI_AutoPollingMemReady>
  printf("Function Register:\t\t\t%x\n",sFLASH_ReadReg1(QSPICMD_READREG_FUNCTION));
  printf("Read Parameters:\t\t\t%x\n",sFLASH_ReadReg1(QSPICMD_READREG_READP_V));
#endif


}
20001476:	bf00      	nop
20001478:	bd80      	pop	{r7, pc}
2000147a:	bf00      	nop
2000147c:	58021000 	.word	0x58021000
20001480:	58020c00 	.word	0x58020c00

20001484 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
20001484:	b480      	push	{r7}
20001486:	b083      	sub	sp, #12
20001488:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
2000148a:	4b0a      	ldr	r3, [pc, #40]	; (200014b4 <HAL_MspInit+0x30>)
2000148c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
20001490:	4a08      	ldr	r2, [pc, #32]	; (200014b4 <HAL_MspInit+0x30>)
20001492:	f043 0302 	orr.w	r3, r3, #2
20001496:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
2000149a:	4b06      	ldr	r3, [pc, #24]	; (200014b4 <HAL_MspInit+0x30>)
2000149c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
200014a0:	f003 0302 	and.w	r3, r3, #2
200014a4:	607b      	str	r3, [r7, #4]
200014a6:	687b      	ldr	r3, [r7, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
200014a8:	bf00      	nop
200014aa:	370c      	adds	r7, #12
200014ac:	46bd      	mov	sp, r7
200014ae:	f85d 7b04 	ldr.w	r7, [sp], #4
200014b2:	4770      	bx	lr
200014b4:	58024400 	.word	0x58024400

200014b8 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
200014b8:	b480      	push	{r7}
200014ba:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
200014bc:	bf00      	nop
200014be:	46bd      	mov	sp, r7
200014c0:	f85d 7b04 	ldr.w	r7, [sp], #4
200014c4:	4770      	bx	lr

200014c6 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
200014c6:	b480      	push	{r7}
200014c8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
200014ca:	e7fe      	b.n	200014ca <HardFault_Handler+0x4>

200014cc <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
200014cc:	b480      	push	{r7}
200014ce:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
200014d0:	e7fe      	b.n	200014d0 <MemManage_Handler+0x4>

200014d2 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
200014d2:	b480      	push	{r7}
200014d4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
200014d6:	e7fe      	b.n	200014d6 <BusFault_Handler+0x4>

200014d8 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
200014d8:	b480      	push	{r7}
200014da:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
200014dc:	e7fe      	b.n	200014dc <UsageFault_Handler+0x4>

200014de <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
200014de:	b480      	push	{r7}
200014e0:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
200014e2:	bf00      	nop
200014e4:	46bd      	mov	sp, r7
200014e6:	f85d 7b04 	ldr.w	r7, [sp], #4
200014ea:	4770      	bx	lr

200014ec <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
200014ec:	b480      	push	{r7}
200014ee:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
200014f0:	bf00      	nop
200014f2:	46bd      	mov	sp, r7
200014f4:	f85d 7b04 	ldr.w	r7, [sp], #4
200014f8:	4770      	bx	lr

200014fa <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
200014fa:	b480      	push	{r7}
200014fc:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
200014fe:	bf00      	nop
20001500:	46bd      	mov	sp, r7
20001502:	f85d 7b04 	ldr.w	r7, [sp], #4
20001506:	4770      	bx	lr

20001508 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
20001508:	b580      	push	{r7, lr}
2000150a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
2000150c:	f000 fbda 	bl	20001cc4 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
20001510:	bf00      	nop
20001512:	bd80      	pop	{r7, pc}

20001514 <initialise_monitor_handles>:
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
20001514:	b480      	push	{r7}
20001516:	af00      	add	r7, sp, #0
}
20001518:	bf00      	nop
2000151a:	46bd      	mov	sp, r7
2000151c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001520:	4770      	bx	lr

20001522 <_getpid>:

int _getpid(void)
{
20001522:	b480      	push	{r7}
20001524:	af00      	add	r7, sp, #0
	return 1;
20001526:	2301      	movs	r3, #1
}
20001528:	4618      	mov	r0, r3
2000152a:	46bd      	mov	sp, r7
2000152c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001530:	4770      	bx	lr

20001532 <_kill>:

int _kill(int pid, int sig)
{
20001532:	b580      	push	{r7, lr}
20001534:	b082      	sub	sp, #8
20001536:	af00      	add	r7, sp, #0
20001538:	6078      	str	r0, [r7, #4]
2000153a:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
2000153c:	f01a fc54 	bl	2001bde8 <__errno>
20001540:	4602      	mov	r2, r0
20001542:	2316      	movs	r3, #22
20001544:	6013      	str	r3, [r2, #0]
	return -1;
20001546:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
2000154a:	4618      	mov	r0, r3
2000154c:	3708      	adds	r7, #8
2000154e:	46bd      	mov	sp, r7
20001550:	bd80      	pop	{r7, pc}

20001552 <_exit>:

void _exit (int status)
{
20001552:	b580      	push	{r7, lr}
20001554:	b082      	sub	sp, #8
20001556:	af00      	add	r7, sp, #0
20001558:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
2000155a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
2000155e:	6878      	ldr	r0, [r7, #4]
20001560:	f7ff ffe7 	bl	20001532 <_kill>
	while (1) {}		/* Make sure we hang here */
20001564:	e7fe      	b.n	20001564 <_exit+0x12>

20001566 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
20001566:	b580      	push	{r7, lr}
20001568:	b086      	sub	sp, #24
2000156a:	af00      	add	r7, sp, #0
2000156c:	60f8      	str	r0, [r7, #12]
2000156e:	60b9      	str	r1, [r7, #8]
20001570:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
20001572:	2300      	movs	r3, #0
20001574:	617b      	str	r3, [r7, #20]
20001576:	e00a      	b.n	2000158e <_read+0x28>
	{
		*ptr++ = __io_getchar();
20001578:	f3af 8000 	nop.w
2000157c:	4601      	mov	r1, r0
2000157e:	68bb      	ldr	r3, [r7, #8]
20001580:	1c5a      	adds	r2, r3, #1
20001582:	60ba      	str	r2, [r7, #8]
20001584:	b2ca      	uxtb	r2, r1
20001586:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
20001588:	697b      	ldr	r3, [r7, #20]
2000158a:	3301      	adds	r3, #1
2000158c:	617b      	str	r3, [r7, #20]
2000158e:	697a      	ldr	r2, [r7, #20]
20001590:	687b      	ldr	r3, [r7, #4]
20001592:	429a      	cmp	r2, r3
20001594:	dbf0      	blt.n	20001578 <_read+0x12>
	}

return len;
20001596:	687b      	ldr	r3, [r7, #4]
}
20001598:	4618      	mov	r0, r3
2000159a:	3718      	adds	r7, #24
2000159c:	46bd      	mov	sp, r7
2000159e:	bd80      	pop	{r7, pc}

200015a0 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
200015a0:	b580      	push	{r7, lr}
200015a2:	b086      	sub	sp, #24
200015a4:	af00      	add	r7, sp, #0
200015a6:	60f8      	str	r0, [r7, #12]
200015a8:	60b9      	str	r1, [r7, #8]
200015aa:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
200015ac:	2300      	movs	r3, #0
200015ae:	617b      	str	r3, [r7, #20]
200015b0:	e009      	b.n	200015c6 <_write+0x26>
	{
		__io_putchar(*ptr++);
200015b2:	68bb      	ldr	r3, [r7, #8]
200015b4:	1c5a      	adds	r2, r3, #1
200015b6:	60ba      	str	r2, [r7, #8]
200015b8:	781b      	ldrb	r3, [r3, #0]
200015ba:	4618      	mov	r0, r3
200015bc:	f7ff f986 	bl	200008cc <__io_putchar>
	for (DataIdx = 0; DataIdx < len; DataIdx++)
200015c0:	697b      	ldr	r3, [r7, #20]
200015c2:	3301      	adds	r3, #1
200015c4:	617b      	str	r3, [r7, #20]
200015c6:	697a      	ldr	r2, [r7, #20]
200015c8:	687b      	ldr	r3, [r7, #4]
200015ca:	429a      	cmp	r2, r3
200015cc:	dbf1      	blt.n	200015b2 <_write+0x12>
	}
	return len;
200015ce:	687b      	ldr	r3, [r7, #4]
}
200015d0:	4618      	mov	r0, r3
200015d2:	3718      	adds	r7, #24
200015d4:	46bd      	mov	sp, r7
200015d6:	bd80      	pop	{r7, pc}

200015d8 <_close>:

int _close(int file)
{
200015d8:	b480      	push	{r7}
200015da:	b083      	sub	sp, #12
200015dc:	af00      	add	r7, sp, #0
200015de:	6078      	str	r0, [r7, #4]
	return -1;
200015e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
200015e4:	4618      	mov	r0, r3
200015e6:	370c      	adds	r7, #12
200015e8:	46bd      	mov	sp, r7
200015ea:	f85d 7b04 	ldr.w	r7, [sp], #4
200015ee:	4770      	bx	lr

200015f0 <_fstat>:


int _fstat(int file, struct stat *st)
{
200015f0:	b480      	push	{r7}
200015f2:	b083      	sub	sp, #12
200015f4:	af00      	add	r7, sp, #0
200015f6:	6078      	str	r0, [r7, #4]
200015f8:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
200015fa:	683b      	ldr	r3, [r7, #0]
200015fc:	f44f 5200 	mov.w	r2, #8192	; 0x2000
20001600:	605a      	str	r2, [r3, #4]
	return 0;
20001602:	2300      	movs	r3, #0
}
20001604:	4618      	mov	r0, r3
20001606:	370c      	adds	r7, #12
20001608:	46bd      	mov	sp, r7
2000160a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000160e:	4770      	bx	lr

20001610 <_isatty>:

int _isatty(int file)
{
20001610:	b480      	push	{r7}
20001612:	b083      	sub	sp, #12
20001614:	af00      	add	r7, sp, #0
20001616:	6078      	str	r0, [r7, #4]
	return 1;
20001618:	2301      	movs	r3, #1
}
2000161a:	4618      	mov	r0, r3
2000161c:	370c      	adds	r7, #12
2000161e:	46bd      	mov	sp, r7
20001620:	f85d 7b04 	ldr.w	r7, [sp], #4
20001624:	4770      	bx	lr

20001626 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
20001626:	b480      	push	{r7}
20001628:	b085      	sub	sp, #20
2000162a:	af00      	add	r7, sp, #0
2000162c:	60f8      	str	r0, [r7, #12]
2000162e:	60b9      	str	r1, [r7, #8]
20001630:	607a      	str	r2, [r7, #4]
	return 0;
20001632:	2300      	movs	r3, #0
}
20001634:	4618      	mov	r0, r3
20001636:	3714      	adds	r7, #20
20001638:	46bd      	mov	sp, r7
2000163a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000163e:	4770      	bx	lr

20001640 <_open>:

int _open(char *path, int flags, ...)
{
20001640:	b40e      	push	{r1, r2, r3}
20001642:	b480      	push	{r7}
20001644:	b082      	sub	sp, #8
20001646:	af00      	add	r7, sp, #0
20001648:	6078      	str	r0, [r7, #4]
	/* Pretend like we always fail */
	return -1;
2000164a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
2000164e:	4618      	mov	r0, r3
20001650:	3708      	adds	r7, #8
20001652:	46bd      	mov	sp, r7
20001654:	f85d 7b04 	ldr.w	r7, [sp], #4
20001658:	b003      	add	sp, #12
2000165a:	4770      	bx	lr

2000165c <_wait>:

int _wait(int *status)
{
2000165c:	b580      	push	{r7, lr}
2000165e:	b082      	sub	sp, #8
20001660:	af00      	add	r7, sp, #0
20001662:	6078      	str	r0, [r7, #4]
	errno = ECHILD;
20001664:	f01a fbc0 	bl	2001bde8 <__errno>
20001668:	4602      	mov	r2, r0
2000166a:	230a      	movs	r3, #10
2000166c:	6013      	str	r3, [r2, #0]
	return -1;
2000166e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
20001672:	4618      	mov	r0, r3
20001674:	3708      	adds	r7, #8
20001676:	46bd      	mov	sp, r7
20001678:	bd80      	pop	{r7, pc}

2000167a <_unlink>:

int _unlink(char *name)
{
2000167a:	b580      	push	{r7, lr}
2000167c:	b082      	sub	sp, #8
2000167e:	af00      	add	r7, sp, #0
20001680:	6078      	str	r0, [r7, #4]
	errno = ENOENT;
20001682:	f01a fbb1 	bl	2001bde8 <__errno>
20001686:	4602      	mov	r2, r0
20001688:	2302      	movs	r3, #2
2000168a:	6013      	str	r3, [r2, #0]
	return -1;
2000168c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
20001690:	4618      	mov	r0, r3
20001692:	3708      	adds	r7, #8
20001694:	46bd      	mov	sp, r7
20001696:	bd80      	pop	{r7, pc}

20001698 <_times>:

int _times(struct tms *buf)
{
20001698:	b480      	push	{r7}
2000169a:	b083      	sub	sp, #12
2000169c:	af00      	add	r7, sp, #0
2000169e:	6078      	str	r0, [r7, #4]
	return -1;
200016a0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
200016a4:	4618      	mov	r0, r3
200016a6:	370c      	adds	r7, #12
200016a8:	46bd      	mov	sp, r7
200016aa:	f85d 7b04 	ldr.w	r7, [sp], #4
200016ae:	4770      	bx	lr

200016b0 <_stat>:

int _stat(char *file, struct stat *st)
{
200016b0:	b480      	push	{r7}
200016b2:	b083      	sub	sp, #12
200016b4:	af00      	add	r7, sp, #0
200016b6:	6078      	str	r0, [r7, #4]
200016b8:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
200016ba:	683b      	ldr	r3, [r7, #0]
200016bc:	f44f 5200 	mov.w	r2, #8192	; 0x2000
200016c0:	605a      	str	r2, [r3, #4]
	return 0;
200016c2:	2300      	movs	r3, #0
}
200016c4:	4618      	mov	r0, r3
200016c6:	370c      	adds	r7, #12
200016c8:	46bd      	mov	sp, r7
200016ca:	f85d 7b04 	ldr.w	r7, [sp], #4
200016ce:	4770      	bx	lr

200016d0 <_link>:

int _link(char *old, char *new)
{
200016d0:	b580      	push	{r7, lr}
200016d2:	b082      	sub	sp, #8
200016d4:	af00      	add	r7, sp, #0
200016d6:	6078      	str	r0, [r7, #4]
200016d8:	6039      	str	r1, [r7, #0]
	errno = EMLINK;
200016da:	f01a fb85 	bl	2001bde8 <__errno>
200016de:	4602      	mov	r2, r0
200016e0:	231f      	movs	r3, #31
200016e2:	6013      	str	r3, [r2, #0]
	return -1;
200016e4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
200016e8:	4618      	mov	r0, r3
200016ea:	3708      	adds	r7, #8
200016ec:	46bd      	mov	sp, r7
200016ee:	bd80      	pop	{r7, pc}

200016f0 <_fork>:

int _fork(void)
{
200016f0:	b580      	push	{r7, lr}
200016f2:	af00      	add	r7, sp, #0
	errno = EAGAIN;
200016f4:	f01a fb78 	bl	2001bde8 <__errno>
200016f8:	4602      	mov	r2, r0
200016fa:	230b      	movs	r3, #11
200016fc:	6013      	str	r3, [r2, #0]
	return -1;
200016fe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
20001702:	4618      	mov	r0, r3
20001704:	bd80      	pop	{r7, pc}

20001706 <_execve>:

int _execve(char *name, char **argv, char **env)
{
20001706:	b580      	push	{r7, lr}
20001708:	b084      	sub	sp, #16
2000170a:	af00      	add	r7, sp, #0
2000170c:	60f8      	str	r0, [r7, #12]
2000170e:	60b9      	str	r1, [r7, #8]
20001710:	607a      	str	r2, [r7, #4]
	errno = ENOMEM;
20001712:	f01a fb69 	bl	2001bde8 <__errno>
20001716:	4602      	mov	r2, r0
20001718:	230c      	movs	r3, #12
2000171a:	6013      	str	r3, [r2, #0]
	return -1;
2000171c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
20001720:	4618      	mov	r0, r3
20001722:	3710      	adds	r7, #16
20001724:	46bd      	mov	sp, r7
20001726:	bd80      	pop	{r7, pc}

20001728 <_sbrk>:
/**
 _sbrk
 Increase program data space. Malloc and related functions depend on this
**/
caddr_t _sbrk(int incr)
{
20001728:	b580      	push	{r7, lr}
2000172a:	b084      	sub	sp, #16
2000172c:	af00      	add	r7, sp, #0
2000172e:	6078      	str	r0, [r7, #4]
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
20001730:	4b11      	ldr	r3, [pc, #68]	; (20001778 <_sbrk+0x50>)
20001732:	681b      	ldr	r3, [r3, #0]
20001734:	2b00      	cmp	r3, #0
20001736:	d102      	bne.n	2000173e <_sbrk+0x16>
		heap_end = &end;
20001738:	4b0f      	ldr	r3, [pc, #60]	; (20001778 <_sbrk+0x50>)
2000173a:	4a10      	ldr	r2, [pc, #64]	; (2000177c <_sbrk+0x54>)
2000173c:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
2000173e:	4b0e      	ldr	r3, [pc, #56]	; (20001778 <_sbrk+0x50>)
20001740:	681b      	ldr	r3, [r3, #0]
20001742:	60fb      	str	r3, [r7, #12]
	if (heap_end + incr > stack_ptr)
20001744:	4b0c      	ldr	r3, [pc, #48]	; (20001778 <_sbrk+0x50>)
20001746:	681a      	ldr	r2, [r3, #0]
20001748:	687b      	ldr	r3, [r7, #4]
2000174a:	4413      	add	r3, r2
2000174c:	466a      	mov	r2, sp
2000174e:	4293      	cmp	r3, r2
20001750:	d907      	bls.n	20001762 <_sbrk+0x3a>
	{
		errno = ENOMEM;
20001752:	f01a fb49 	bl	2001bde8 <__errno>
20001756:	4602      	mov	r2, r0
20001758:	230c      	movs	r3, #12
2000175a:	6013      	str	r3, [r2, #0]
		return (caddr_t) -1;
2000175c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
20001760:	e006      	b.n	20001770 <_sbrk+0x48>
	}

	heap_end += incr;
20001762:	4b05      	ldr	r3, [pc, #20]	; (20001778 <_sbrk+0x50>)
20001764:	681a      	ldr	r2, [r3, #0]
20001766:	687b      	ldr	r3, [r7, #4]
20001768:	4413      	add	r3, r2
2000176a:	4a03      	ldr	r2, [pc, #12]	; (20001778 <_sbrk+0x50>)
2000176c:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
2000176e:	68fb      	ldr	r3, [r7, #12]
}
20001770:	4618      	mov	r0, r3
20001772:	3710      	adds	r7, #16
20001774:	46bd      	mov	sp, r7
20001776:	bd80      	pop	{r7, pc}
20001778:	2001ca0c 	.word	0x2001ca0c
2000177c:	2001c368 	.word	0x2001c368

20001780 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
20001780:	b480      	push	{r7}
20001782:	af00      	add	r7, sp, #0
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
20001784:	4b29      	ldr	r3, [pc, #164]	; (2000182c <SystemInit+0xac>)
20001786:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000178a:	4a28      	ldr	r2, [pc, #160]	; (2000182c <SystemInit+0xac>)
2000178c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
20001790:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
20001794:	4b26      	ldr	r3, [pc, #152]	; (20001830 <SystemInit+0xb0>)
20001796:	681b      	ldr	r3, [r3, #0]
20001798:	4a25      	ldr	r2, [pc, #148]	; (20001830 <SystemInit+0xb0>)
2000179a:	f043 0301 	orr.w	r3, r3, #1
2000179e:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
200017a0:	4b23      	ldr	r3, [pc, #140]	; (20001830 <SystemInit+0xb0>)
200017a2:	2200      	movs	r2, #0
200017a4:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, CSSON , CSION,RC48ON, CSIKERON PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
200017a6:	4b22      	ldr	r3, [pc, #136]	; (20001830 <SystemInit+0xb0>)
200017a8:	681a      	ldr	r2, [r3, #0]
200017aa:	4921      	ldr	r1, [pc, #132]	; (20001830 <SystemInit+0xb0>)
200017ac:	4b21      	ldr	r3, [pc, #132]	; (20001834 <SystemInit+0xb4>)
200017ae:	4013      	ands	r3, r2
200017b0:	600b      	str	r3, [r1, #0]

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
200017b2:	4b1f      	ldr	r3, [pc, #124]	; (20001830 <SystemInit+0xb0>)
200017b4:	2200      	movs	r2, #0
200017b6:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
200017b8:	4b1d      	ldr	r3, [pc, #116]	; (20001830 <SystemInit+0xb0>)
200017ba:	2200      	movs	r2, #0
200017bc:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
200017be:	4b1c      	ldr	r3, [pc, #112]	; (20001830 <SystemInit+0xb0>)
200017c0:	2200      	movs	r2, #0
200017c2:	621a      	str	r2, [r3, #32]

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x00000000;
200017c4:	4b1a      	ldr	r3, [pc, #104]	; (20001830 <SystemInit+0xb0>)
200017c6:	2200      	movs	r2, #0
200017c8:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000000;
200017ca:	4b19      	ldr	r3, [pc, #100]	; (20001830 <SystemInit+0xb0>)
200017cc:	2200      	movs	r2, #0
200017ce:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x00000000;
200017d0:	4b17      	ldr	r3, [pc, #92]	; (20001830 <SystemInit+0xb0>)
200017d2:	2200      	movs	r2, #0
200017d4:	631a      	str	r2, [r3, #48]	; 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
200017d6:	4b16      	ldr	r3, [pc, #88]	; (20001830 <SystemInit+0xb0>)
200017d8:	2200      	movs	r2, #0
200017da:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x00000000;
200017dc:	4b14      	ldr	r3, [pc, #80]	; (20001830 <SystemInit+0xb0>)
200017de:	2200      	movs	r2, #0
200017e0:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
200017e2:	4b13      	ldr	r3, [pc, #76]	; (20001830 <SystemInit+0xb0>)
200017e4:	2200      	movs	r2, #0
200017e6:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x00000000;
200017e8:	4b11      	ldr	r3, [pc, #68]	; (20001830 <SystemInit+0xb0>)
200017ea:	2200      	movs	r2, #0
200017ec:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
200017ee:	4b10      	ldr	r3, [pc, #64]	; (20001830 <SystemInit+0xb0>)
200017f0:	2200      	movs	r2, #0
200017f2:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
200017f4:	4b0e      	ldr	r3, [pc, #56]	; (20001830 <SystemInit+0xb0>)
200017f6:	681b      	ldr	r3, [r3, #0]
200017f8:	4a0d      	ldr	r2, [pc, #52]	; (20001830 <SystemInit+0xb0>)
200017fa:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
200017fe:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
20001800:	4b0b      	ldr	r3, [pc, #44]	; (20001830 <SystemInit+0xb0>)
20001802:	2200      	movs	r2, #0
20001804:	661a      	str	r2, [r3, #96]	; 0x60
  SCB->VTOR = FLASH_BANK2_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
#endif /* VECT_TAB_SRAM */

#else
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
20001806:	4b0c      	ldr	r3, [pc, #48]	; (20001838 <SystemInit+0xb8>)
20001808:	681a      	ldr	r2, [r3, #0]
2000180a:	4b0c      	ldr	r3, [pc, #48]	; (2000183c <SystemInit+0xbc>)
2000180c:	4013      	ands	r3, r2
2000180e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20001812:	d202      	bcs.n	2000181a <SystemInit+0x9a>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
20001814:	4b0a      	ldr	r3, [pc, #40]	; (20001840 <SystemInit+0xc0>)
20001816:	2201      	movs	r2, #1
20001818:	601a      	str	r2, [r3, #0]

  /* Configure the Vector Table location add offset address for cortex-M7 ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM */
#else
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
2000181a:	4b04      	ldr	r3, [pc, #16]	; (2000182c <SystemInit+0xac>)
2000181c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
20001820:	609a      	str	r2, [r3, #8]
#endif

#endif /*DUAL_CORE && CORE_CM4*/

}
20001822:	bf00      	nop
20001824:	46bd      	mov	sp, r7
20001826:	f85d 7b04 	ldr.w	r7, [sp], #4
2000182a:	4770      	bx	lr
2000182c:	e000ed00 	.word	0xe000ed00
20001830:	58024400 	.word	0x58024400
20001834:	eaf6ed7f 	.word	0xeaf6ed7f
20001838:	5c001000 	.word	0x5c001000
2000183c:	ffff0000 	.word	0xffff0000
20001840:	51008108 	.word	0x51008108

20001844 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
20001844:	b480      	push	{r7}
20001846:	b089      	sub	sp, #36	; 0x24
20001848:	af00      	add	r7, sp, #0
  uint32_t pllp, pllsource, pllm, pllfracen, hsivalue, tmp;
  float_t fracn1, pllvco;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
2000184a:	4ba8      	ldr	r3, [pc, #672]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
2000184c:	691b      	ldr	r3, [r3, #16]
2000184e:	f003 0338 	and.w	r3, r3, #56	; 0x38
20001852:	2b18      	cmp	r3, #24
20001854:	f200 8122 	bhi.w	20001a9c <SystemCoreClockUpdate+0x258>
20001858:	a201      	add	r2, pc, #4	; (adr r2, 20001860 <SystemCoreClockUpdate+0x1c>)
2000185a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2000185e:	bf00      	nop
20001860:	200018c5 	.word	0x200018c5
20001864:	20001a9d 	.word	0x20001a9d
20001868:	20001a9d 	.word	0x20001a9d
2000186c:	20001a9d 	.word	0x20001a9d
20001870:	20001a9d 	.word	0x20001a9d
20001874:	20001a9d 	.word	0x20001a9d
20001878:	20001a9d 	.word	0x20001a9d
2000187c:	20001a9d 	.word	0x20001a9d
20001880:	200018db 	.word	0x200018db
20001884:	20001a9d 	.word	0x20001a9d
20001888:	20001a9d 	.word	0x20001a9d
2000188c:	20001a9d 	.word	0x20001a9d
20001890:	20001a9d 	.word	0x20001a9d
20001894:	20001a9d 	.word	0x20001a9d
20001898:	20001a9d 	.word	0x20001a9d
2000189c:	20001a9d 	.word	0x20001a9d
200018a0:	200018e3 	.word	0x200018e3
200018a4:	20001a9d 	.word	0x20001a9d
200018a8:	20001a9d 	.word	0x20001a9d
200018ac:	20001a9d 	.word	0x20001a9d
200018b0:	20001a9d 	.word	0x20001a9d
200018b4:	20001a9d 	.word	0x20001a9d
200018b8:	20001a9d 	.word	0x20001a9d
200018bc:	20001a9d 	.word	0x20001a9d
200018c0:	200018eb 	.word	0x200018eb
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    SystemCoreClock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
200018c4:	4b89      	ldr	r3, [pc, #548]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
200018c6:	681b      	ldr	r3, [r3, #0]
200018c8:	08db      	lsrs	r3, r3, #3
200018ca:	f003 0303 	and.w	r3, r3, #3
200018ce:	4a88      	ldr	r2, [pc, #544]	; (20001af0 <SystemCoreClockUpdate+0x2ac>)
200018d0:	fa22 f303 	lsr.w	r3, r2, r3
200018d4:	4a87      	ldr	r2, [pc, #540]	; (20001af4 <SystemCoreClockUpdate+0x2b0>)
200018d6:	6013      	str	r3, [r2, #0]
    break;
200018d8:	e0e4      	b.n	20001aa4 <SystemCoreClockUpdate+0x260>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    SystemCoreClock = CSI_VALUE;
200018da:	4b86      	ldr	r3, [pc, #536]	; (20001af4 <SystemCoreClockUpdate+0x2b0>)
200018dc:	4a86      	ldr	r2, [pc, #536]	; (20001af8 <SystemCoreClockUpdate+0x2b4>)
200018de:	601a      	str	r2, [r3, #0]
    break;
200018e0:	e0e0      	b.n	20001aa4 <SystemCoreClockUpdate+0x260>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    SystemCoreClock = HSE_VALUE;
200018e2:	4b84      	ldr	r3, [pc, #528]	; (20001af4 <SystemCoreClockUpdate+0x2b0>)
200018e4:	4a85      	ldr	r2, [pc, #532]	; (20001afc <SystemCoreClockUpdate+0x2b8>)
200018e6:	601a      	str	r2, [r3, #0]
    break;
200018e8:	e0dc      	b.n	20001aa4 <SystemCoreClockUpdate+0x260>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
200018ea:	4b80      	ldr	r3, [pc, #512]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
200018ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200018ee:	f003 0303 	and.w	r3, r3, #3
200018f2:	61bb      	str	r3, [r7, #24]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
200018f4:	4b7d      	ldr	r3, [pc, #500]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
200018f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200018f8:	091b      	lsrs	r3, r3, #4
200018fa:	f003 033f 	and.w	r3, r3, #63	; 0x3f
200018fe:	617b      	str	r3, [r7, #20]
    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
20001900:	4b7a      	ldr	r3, [pc, #488]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
20001902:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20001904:	f003 0301 	and.w	r3, r3, #1
20001908:	613b      	str	r3, [r7, #16]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
2000190a:	4b78      	ldr	r3, [pc, #480]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
2000190c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000190e:	08db      	lsrs	r3, r3, #3
20001910:	f3c3 030c 	ubfx	r3, r3, #0, #13
20001914:	693a      	ldr	r2, [r7, #16]
20001916:	fb02 f303 	mul.w	r3, r2, r3
2000191a:	ee07 3a90 	vmov	s15, r3
2000191e:	eef8 7a67 	vcvt.f32.u32	s15, s15
20001922:	edc7 7a03 	vstr	s15, [r7, #12]

    if (pllm != 0U)
20001926:	697b      	ldr	r3, [r7, #20]
20001928:	2b00      	cmp	r3, #0
2000192a:	f000 80b3 	beq.w	20001a94 <SystemCoreClockUpdate+0x250>
    {
      switch (pllsource)
2000192e:	69bb      	ldr	r3, [r7, #24]
20001930:	2b01      	cmp	r3, #1
20001932:	d032      	beq.n	2000199a <SystemCoreClockUpdate+0x156>
20001934:	2b01      	cmp	r3, #1
20001936:	d302      	bcc.n	2000193e <SystemCoreClockUpdate+0xfa>
20001938:	2b02      	cmp	r3, #2
2000193a:	d050      	beq.n	200019de <SystemCoreClockUpdate+0x19a>
2000193c:	e071      	b.n	20001a22 <SystemCoreClockUpdate+0x1de>
      {
        case RCC_PLLCKSELR_PLLSRC_HSI:  /* HSI used as PLL clock source */

        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
2000193e:	4b6b      	ldr	r3, [pc, #428]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
20001940:	681b      	ldr	r3, [r3, #0]
20001942:	08db      	lsrs	r3, r3, #3
20001944:	f003 0303 	and.w	r3, r3, #3
20001948:	4a69      	ldr	r2, [pc, #420]	; (20001af0 <SystemCoreClockUpdate+0x2ac>)
2000194a:	fa22 f303 	lsr.w	r3, r2, r3
2000194e:	60bb      	str	r3, [r7, #8]
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
20001950:	68bb      	ldr	r3, [r7, #8]
20001952:	ee07 3a90 	vmov	s15, r3
20001956:	eef8 6a67 	vcvt.f32.u32	s13, s15
2000195a:	697b      	ldr	r3, [r7, #20]
2000195c:	ee07 3a90 	vmov	s15, r3
20001960:	eef8 7a67 	vcvt.f32.u32	s15, s15
20001964:	ee86 7aa7 	vdiv.f32	s14, s13, s15
20001968:	4b60      	ldr	r3, [pc, #384]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
2000196a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000196c:	f3c3 0308 	ubfx	r3, r3, #0, #9
20001970:	ee07 3a90 	vmov	s15, r3
20001974:	eef8 6a67 	vcvt.f32.u32	s13, s15
20001978:	ed97 6a03 	vldr	s12, [r7, #12]
2000197c:	eddf 5a60 	vldr	s11, [pc, #384]	; 20001b00 <SystemCoreClockUpdate+0x2bc>
20001980:	eec6 7a25 	vdiv.f32	s15, s12, s11
20001984:	ee76 7aa7 	vadd.f32	s15, s13, s15
20001988:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2000198c:	ee77 7aa6 	vadd.f32	s15, s15, s13
20001990:	ee67 7a27 	vmul.f32	s15, s14, s15
20001994:	edc7 7a07 	vstr	s15, [r7, #28]

        break;
20001998:	e065      	b.n	20001a66 <SystemCoreClockUpdate+0x222>

        case RCC_PLLCKSELR_PLLSRC_CSI:  /* CSI used as PLL clock source */
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2000199a:	697b      	ldr	r3, [r7, #20]
2000199c:	ee07 3a90 	vmov	s15, r3
200019a0:	eef8 7a67 	vcvt.f32.u32	s15, s15
200019a4:	eddf 6a57 	vldr	s13, [pc, #348]	; 20001b04 <SystemCoreClockUpdate+0x2c0>
200019a8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
200019ac:	4b4f      	ldr	r3, [pc, #316]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
200019ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200019b0:	f3c3 0308 	ubfx	r3, r3, #0, #9
200019b4:	ee07 3a90 	vmov	s15, r3
200019b8:	eef8 6a67 	vcvt.f32.u32	s13, s15
200019bc:	ed97 6a03 	vldr	s12, [r7, #12]
200019c0:	eddf 5a4f 	vldr	s11, [pc, #316]	; 20001b00 <SystemCoreClockUpdate+0x2bc>
200019c4:	eec6 7a25 	vdiv.f32	s15, s12, s11
200019c8:	ee76 7aa7 	vadd.f32	s15, s13, s15
200019cc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
200019d0:	ee77 7aa6 	vadd.f32	s15, s15, s13
200019d4:	ee67 7a27 	vmul.f32	s15, s14, s15
200019d8:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
200019dc:	e043      	b.n	20001a66 <SystemCoreClockUpdate+0x222>

        case RCC_PLLCKSELR_PLLSRC_HSE:  /* HSE used as PLL clock source */
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
200019de:	697b      	ldr	r3, [r7, #20]
200019e0:	ee07 3a90 	vmov	s15, r3
200019e4:	eef8 7a67 	vcvt.f32.u32	s15, s15
200019e8:	eddf 6a47 	vldr	s13, [pc, #284]	; 20001b08 <SystemCoreClockUpdate+0x2c4>
200019ec:	ee86 7aa7 	vdiv.f32	s14, s13, s15
200019f0:	4b3e      	ldr	r3, [pc, #248]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
200019f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200019f4:	f3c3 0308 	ubfx	r3, r3, #0, #9
200019f8:	ee07 3a90 	vmov	s15, r3
200019fc:	eef8 6a67 	vcvt.f32.u32	s13, s15
20001a00:	ed97 6a03 	vldr	s12, [r7, #12]
20001a04:	eddf 5a3e 	vldr	s11, [pc, #248]	; 20001b00 <SystemCoreClockUpdate+0x2bc>
20001a08:	eec6 7a25 	vdiv.f32	s15, s12, s11
20001a0c:	ee76 7aa7 	vadd.f32	s15, s13, s15
20001a10:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
20001a14:	ee77 7aa6 	vadd.f32	s15, s15, s13
20001a18:	ee67 7a27 	vmul.f32	s15, s14, s15
20001a1c:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
20001a20:	e021      	b.n	20001a66 <SystemCoreClockUpdate+0x222>

      default:
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
20001a22:	697b      	ldr	r3, [r7, #20]
20001a24:	ee07 3a90 	vmov	s15, r3
20001a28:	eef8 7a67 	vcvt.f32.u32	s15, s15
20001a2c:	eddf 6a35 	vldr	s13, [pc, #212]	; 20001b04 <SystemCoreClockUpdate+0x2c0>
20001a30:	ee86 7aa7 	vdiv.f32	s14, s13, s15
20001a34:	4b2d      	ldr	r3, [pc, #180]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
20001a36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001a38:	f3c3 0308 	ubfx	r3, r3, #0, #9
20001a3c:	ee07 3a90 	vmov	s15, r3
20001a40:	eef8 6a67 	vcvt.f32.u32	s13, s15
20001a44:	ed97 6a03 	vldr	s12, [r7, #12]
20001a48:	eddf 5a2d 	vldr	s11, [pc, #180]	; 20001b00 <SystemCoreClockUpdate+0x2bc>
20001a4c:	eec6 7a25 	vdiv.f32	s15, s12, s11
20001a50:	ee76 7aa7 	vadd.f32	s15, s13, s15
20001a54:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
20001a58:	ee77 7aa6 	vadd.f32	s15, s15, s13
20001a5c:	ee67 7a27 	vmul.f32	s15, s14, s15
20001a60:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
20001a64:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
20001a66:	4b21      	ldr	r3, [pc, #132]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
20001a68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001a6a:	0a5b      	lsrs	r3, r3, #9
20001a6c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20001a70:	3301      	adds	r3, #1
20001a72:	607b      	str	r3, [r7, #4]
      SystemCoreClock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
20001a74:	687b      	ldr	r3, [r7, #4]
20001a76:	ee07 3a90 	vmov	s15, r3
20001a7a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
20001a7e:	edd7 6a07 	vldr	s13, [r7, #28]
20001a82:	eec6 7a87 	vdiv.f32	s15, s13, s14
20001a86:	eefc 7ae7 	vcvt.u32.f32	s15, s15
20001a8a:	ee17 2a90 	vmov	r2, s15
20001a8e:	4b19      	ldr	r3, [pc, #100]	; (20001af4 <SystemCoreClockUpdate+0x2b0>)
20001a90:	601a      	str	r2, [r3, #0]
    }
    else
    {
      SystemCoreClock = 0U;
    }
    break;
20001a92:	e007      	b.n	20001aa4 <SystemCoreClockUpdate+0x260>
      SystemCoreClock = 0U;
20001a94:	4b17      	ldr	r3, [pc, #92]	; (20001af4 <SystemCoreClockUpdate+0x2b0>)
20001a96:	2200      	movs	r2, #0
20001a98:	601a      	str	r2, [r3, #0]
    break;
20001a9a:	e003      	b.n	20001aa4 <SystemCoreClockUpdate+0x260>

  default:
    SystemCoreClock = CSI_VALUE;
20001a9c:	4b15      	ldr	r3, [pc, #84]	; (20001af4 <SystemCoreClockUpdate+0x2b0>)
20001a9e:	4a16      	ldr	r2, [pc, #88]	; (20001af8 <SystemCoreClockUpdate+0x2b4>)
20001aa0:	601a      	str	r2, [r3, #0]
    break;
20001aa2:	bf00      	nop
  }

  /* Compute SystemClock frequency --------------------------------------------------*/
#if defined (RCC_D1CFGR_D1CPRE)
  tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];
20001aa4:	4b11      	ldr	r3, [pc, #68]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
20001aa6:	699b      	ldr	r3, [r3, #24]
20001aa8:	0a1b      	lsrs	r3, r3, #8
20001aaa:	f003 030f 	and.w	r3, r3, #15
20001aae:	4a17      	ldr	r2, [pc, #92]	; (20001b0c <SystemCoreClockUpdate+0x2c8>)
20001ab0:	5cd3      	ldrb	r3, [r2, r3]
20001ab2:	603b      	str	r3, [r7, #0]

  /* SystemCoreClock frequency : CM7 CPU frequency  */
  SystemCoreClock >>= tmp;
20001ab4:	4b0f      	ldr	r3, [pc, #60]	; (20001af4 <SystemCoreClockUpdate+0x2b0>)
20001ab6:	681a      	ldr	r2, [r3, #0]
20001ab8:	683b      	ldr	r3, [r7, #0]
20001aba:	fa22 f303 	lsr.w	r3, r2, r3
20001abe:	4a0d      	ldr	r2, [pc, #52]	; (20001af4 <SystemCoreClockUpdate+0x2b0>)
20001ac0:	6013      	str	r3, [r2, #0]

  /* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency  */
  SystemD2Clock = (SystemCoreClock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
20001ac2:	4b0c      	ldr	r3, [pc, #48]	; (20001af4 <SystemCoreClockUpdate+0x2b0>)
20001ac4:	681a      	ldr	r2, [r3, #0]
20001ac6:	4b09      	ldr	r3, [pc, #36]	; (20001aec <SystemCoreClockUpdate+0x2a8>)
20001ac8:	699b      	ldr	r3, [r3, #24]
20001aca:	f003 030f 	and.w	r3, r3, #15
20001ace:	490f      	ldr	r1, [pc, #60]	; (20001b0c <SystemCoreClockUpdate+0x2c8>)
20001ad0:	5ccb      	ldrb	r3, [r1, r3]
20001ad2:	f003 031f 	and.w	r3, r3, #31
20001ad6:	fa22 f303 	lsr.w	r3, r2, r3
20001ada:	4a0d      	ldr	r2, [pc, #52]	; (20001b10 <SystemCoreClockUpdate+0x2cc>)
20001adc:	6013      	str	r3, [r2, #0]

  /* SystemD2Clock frequency : AXI and AHBs Clock frequency  */
  SystemD2Clock = (SystemCoreClock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));

#endif
}
20001ade:	bf00      	nop
20001ae0:	3724      	adds	r7, #36	; 0x24
20001ae2:	46bd      	mov	sp, r7
20001ae4:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ae8:	4770      	bx	lr
20001aea:	bf00      	nop
20001aec:	58024400 	.word	0x58024400
20001af0:	03d09000 	.word	0x03d09000
20001af4:	2001c978 	.word	0x2001c978
20001af8:	003d0900 	.word	0x003d0900
20001afc:	016e3600 	.word	0x016e3600
20001b00:	46000000 	.word	0x46000000
20001b04:	4a742400 	.word	0x4a742400
20001b08:	4bb71b00 	.word	0x4bb71b00
20001b0c:	2001bf54 	.word	0x2001bf54
20001b10:	2001c97c 	.word	0x2001c97c

20001b14 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
20001b14:	b580      	push	{r7, lr}
20001b16:	b082      	sub	sp, #8
20001b18:	af00      	add	r7, sp, #0
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
20001b1a:	2003      	movs	r0, #3
20001b1c:	f001 fb2e 	bl	2000317c <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
20001b20:	f016 ff9c 	bl	20018a5c <HAL_RCC_GetSysClockFreq>
20001b24:	4601      	mov	r1, r0
20001b26:	4b15      	ldr	r3, [pc, #84]	; (20001b7c <HAL_Init+0x68>)
20001b28:	699b      	ldr	r3, [r3, #24]
20001b2a:	0a1b      	lsrs	r3, r3, #8
20001b2c:	f003 030f 	and.w	r3, r3, #15
20001b30:	4a13      	ldr	r2, [pc, #76]	; (20001b80 <HAL_Init+0x6c>)
20001b32:	5cd3      	ldrb	r3, [r2, r3]
20001b34:	f003 031f 	and.w	r3, r3, #31
20001b38:	fa21 f303 	lsr.w	r3, r1, r3
20001b3c:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
20001b3e:	4b0f      	ldr	r3, [pc, #60]	; (20001b7c <HAL_Init+0x68>)
20001b40:	699b      	ldr	r3, [r3, #24]
20001b42:	f003 030f 	and.w	r3, r3, #15
20001b46:	4a0e      	ldr	r2, [pc, #56]	; (20001b80 <HAL_Init+0x6c>)
20001b48:	5cd3      	ldrb	r3, [r2, r3]
20001b4a:	f003 031f 	and.w	r3, r3, #31
20001b4e:	687a      	ldr	r2, [r7, #4]
20001b50:	fa22 f303 	lsr.w	r3, r2, r3
20001b54:	4a0b      	ldr	r2, [pc, #44]	; (20001b84 <HAL_Init+0x70>)
20001b56:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
20001b58:	4a0b      	ldr	r2, [pc, #44]	; (20001b88 <HAL_Init+0x74>)
20001b5a:	687b      	ldr	r3, [r7, #4]
20001b5c:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
20001b5e:	2000      	movs	r0, #0
20001b60:	f000 f87a 	bl	20001c58 <HAL_InitTick>
20001b64:	4603      	mov	r3, r0
20001b66:	2b00      	cmp	r3, #0
20001b68:	d001      	beq.n	20001b6e <HAL_Init+0x5a>
  {
    return HAL_ERROR;
20001b6a:	2301      	movs	r3, #1
20001b6c:	e002      	b.n	20001b74 <HAL_Init+0x60>
  }

  /* Init the low level hardware */
  HAL_MspInit();
20001b6e:	f7ff fc89 	bl	20001484 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
20001b72:	2300      	movs	r3, #0
}
20001b74:	4618      	mov	r0, r3
20001b76:	3708      	adds	r7, #8
20001b78:	46bd      	mov	sp, r7
20001b7a:	bd80      	pop	{r7, pc}
20001b7c:	58024400 	.word	0x58024400
20001b80:	2001bf54 	.word	0x2001bf54
20001b84:	2001c97c 	.word	0x2001c97c
20001b88:	2001c978 	.word	0x2001c978

20001b8c <HAL_DeInit>:
  * @brief  This function de-Initializes common part of the HAL and stops the systick.
  *         This function is optional.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
20001b8c:	b580      	push	{r7, lr}
20001b8e:	af00      	add	r7, sp, #0
  /* Reset of all peripherals */
  __HAL_RCC_AHB3_FORCE_RESET();
20001b90:	4b29      	ldr	r3, [pc, #164]	; (20001c38 <HAL_DeInit+0xac>)
20001b92:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
20001b96:	67da      	str	r2, [r3, #124]	; 0x7c
  __HAL_RCC_AHB3_RELEASE_RESET();
20001b98:	4b27      	ldr	r3, [pc, #156]	; (20001c38 <HAL_DeInit+0xac>)
20001b9a:	2200      	movs	r2, #0
20001b9c:	67da      	str	r2, [r3, #124]	; 0x7c

  __HAL_RCC_AHB1_FORCE_RESET();
20001b9e:	4b26      	ldr	r3, [pc, #152]	; (20001c38 <HAL_DeInit+0xac>)
20001ba0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
20001ba4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __HAL_RCC_AHB1_RELEASE_RESET();
20001ba8:	4b23      	ldr	r3, [pc, #140]	; (20001c38 <HAL_DeInit+0xac>)
20001baa:	2200      	movs	r2, #0
20001bac:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  __HAL_RCC_AHB2_FORCE_RESET();
20001bb0:	4b21      	ldr	r3, [pc, #132]	; (20001c38 <HAL_DeInit+0xac>)
20001bb2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
20001bb6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __HAL_RCC_AHB2_RELEASE_RESET();
20001bba:	4b1f      	ldr	r3, [pc, #124]	; (20001c38 <HAL_DeInit+0xac>)
20001bbc:	2200      	movs	r2, #0
20001bbe:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  __HAL_RCC_AHB4_FORCE_RESET();
20001bc2:	4b1d      	ldr	r3, [pc, #116]	; (20001c38 <HAL_DeInit+0xac>)
20001bc4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
20001bc8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 __HAL_RCC_AHB4_RELEASE_RESET();
20001bcc:	4b1a      	ldr	r3, [pc, #104]	; (20001c38 <HAL_DeInit+0xac>)
20001bce:	2200      	movs	r2, #0
20001bd0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  __HAL_RCC_APB3_FORCE_RESET();
20001bd4:	4b18      	ldr	r3, [pc, #96]	; (20001c38 <HAL_DeInit+0xac>)
20001bd6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
20001bda:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  __HAL_RCC_APB3_RELEASE_RESET();
20001bde:	4b16      	ldr	r3, [pc, #88]	; (20001c38 <HAL_DeInit+0xac>)
20001be0:	2200      	movs	r2, #0
20001be2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  __HAL_RCC_APB1L_FORCE_RESET();
20001be6:	4b14      	ldr	r3, [pc, #80]	; (20001c38 <HAL_DeInit+0xac>)
20001be8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
20001bec:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  __HAL_RCC_APB1L_RELEASE_RESET();
20001bf0:	4b11      	ldr	r3, [pc, #68]	; (20001c38 <HAL_DeInit+0xac>)
20001bf2:	2200      	movs	r2, #0
20001bf4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  __HAL_RCC_APB1H_FORCE_RESET();
20001bf8:	4b0f      	ldr	r3, [pc, #60]	; (20001c38 <HAL_DeInit+0xac>)
20001bfa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
20001bfe:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __HAL_RCC_APB1H_RELEASE_RESET();
20001c02:	4b0d      	ldr	r3, [pc, #52]	; (20001c38 <HAL_DeInit+0xac>)
20001c04:	2200      	movs	r2, #0
20001c06:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

   __HAL_RCC_APB2_FORCE_RESET();
20001c0a:	4b0b      	ldr	r3, [pc, #44]	; (20001c38 <HAL_DeInit+0xac>)
20001c0c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
20001c10:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
   __HAL_RCC_APB2_RELEASE_RESET();
20001c14:	4b08      	ldr	r3, [pc, #32]	; (20001c38 <HAL_DeInit+0xac>)
20001c16:	2200      	movs	r2, #0
20001c18:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

  __HAL_RCC_APB4_FORCE_RESET();
20001c1c:	4b06      	ldr	r3, [pc, #24]	; (20001c38 <HAL_DeInit+0xac>)
20001c1e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
20001c22:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  __HAL_RCC_APB4_RELEASE_RESET();
20001c26:	4b04      	ldr	r3, [pc, #16]	; (20001c38 <HAL_DeInit+0xac>)
20001c28:	2200      	movs	r2, #0
20001c2a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

  /* De-Init the low level hardware */
  HAL_MspDeInit();
20001c2e:	f000 f80c 	bl	20001c4a <HAL_MspDeInit>

  /* Return function status */
  return HAL_OK;
20001c32:	2300      	movs	r3, #0
}
20001c34:	4618      	mov	r0, r3
20001c36:	bd80      	pop	{r7, pc}
20001c38:	58024400 	.word	0x58024400
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
20001c3c:	b480      	push	{r7}
20001c3e:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
20001c40:	bf00      	nop
20001c42:	46bd      	mov	sp, r7
20001c44:	f85d 7b04 	ldr.w	r7, [sp], #4
20001c48:	4770      	bx	lr

20001c4a <HAL_MspDeInit>:
/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
20001c4a:	b480      	push	{r7}
20001c4c:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   */
}
20001c4e:	bf00      	nop
20001c50:	46bd      	mov	sp, r7
20001c52:	f85d 7b04 	ldr.w	r7, [sp], #4
20001c56:	4770      	bx	lr

20001c58 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
20001c58:	b580      	push	{r7, lr}
20001c5a:	b082      	sub	sp, #8
20001c5c:	af00      	add	r7, sp, #0
20001c5e:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
20001c60:	4b15      	ldr	r3, [pc, #84]	; (20001cb8 <HAL_InitTick+0x60>)
20001c62:	781b      	ldrb	r3, [r3, #0]
20001c64:	2b00      	cmp	r3, #0
20001c66:	d101      	bne.n	20001c6c <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
20001c68:	2301      	movs	r3, #1
20001c6a:	e021      	b.n	20001cb0 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
20001c6c:	4b13      	ldr	r3, [pc, #76]	; (20001cbc <HAL_InitTick+0x64>)
20001c6e:	681a      	ldr	r2, [r3, #0]
20001c70:	4b11      	ldr	r3, [pc, #68]	; (20001cb8 <HAL_InitTick+0x60>)
20001c72:	781b      	ldrb	r3, [r3, #0]
20001c74:	4619      	mov	r1, r3
20001c76:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
20001c7a:	fbb3 f3f1 	udiv	r3, r3, r1
20001c7e:	fbb2 f3f3 	udiv	r3, r2, r3
20001c82:	4618      	mov	r0, r3
20001c84:	f001 faf8 	bl	20003278 <HAL_SYSTICK_Config>
20001c88:	4603      	mov	r3, r0
20001c8a:	2b00      	cmp	r3, #0
20001c8c:	d001      	beq.n	20001c92 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
20001c8e:	2301      	movs	r3, #1
20001c90:	e00e      	b.n	20001cb0 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
20001c92:	687b      	ldr	r3, [r7, #4]
20001c94:	2b0f      	cmp	r3, #15
20001c96:	d80a      	bhi.n	20001cae <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
20001c98:	2200      	movs	r2, #0
20001c9a:	6879      	ldr	r1, [r7, #4]
20001c9c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
20001ca0:	f001 fa8c 	bl	200031bc <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
20001ca4:	4a06      	ldr	r2, [pc, #24]	; (20001cc0 <HAL_InitTick+0x68>)
20001ca6:	687b      	ldr	r3, [r7, #4]
20001ca8:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
20001caa:	2300      	movs	r3, #0
20001cac:	e000      	b.n	20001cb0 <HAL_InitTick+0x58>
    return HAL_ERROR;
20001cae:	2301      	movs	r3, #1
}
20001cb0:	4618      	mov	r0, r3
20001cb2:	3708      	adds	r7, #8
20001cb4:	46bd      	mov	sp, r7
20001cb6:	bd80      	pop	{r7, pc}
20001cb8:	2001c984 	.word	0x2001c984
20001cbc:	2001c978 	.word	0x2001c978
20001cc0:	2001c980 	.word	0x2001c980

20001cc4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
20001cc4:	b480      	push	{r7}
20001cc6:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
20001cc8:	4b06      	ldr	r3, [pc, #24]	; (20001ce4 <HAL_IncTick+0x20>)
20001cca:	781b      	ldrb	r3, [r3, #0]
20001ccc:	461a      	mov	r2, r3
20001cce:	4b06      	ldr	r3, [pc, #24]	; (20001ce8 <HAL_IncTick+0x24>)
20001cd0:	681b      	ldr	r3, [r3, #0]
20001cd2:	4413      	add	r3, r2
20001cd4:	4a04      	ldr	r2, [pc, #16]	; (20001ce8 <HAL_IncTick+0x24>)
20001cd6:	6013      	str	r3, [r2, #0]
}
20001cd8:	bf00      	nop
20001cda:	46bd      	mov	sp, r7
20001cdc:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ce0:	4770      	bx	lr
20001ce2:	bf00      	nop
20001ce4:	2001c984 	.word	0x2001c984
20001ce8:	2001ca5c 	.word	0x2001ca5c

20001cec <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
20001cec:	b480      	push	{r7}
20001cee:	af00      	add	r7, sp, #0
  return uwTick;
20001cf0:	4b03      	ldr	r3, [pc, #12]	; (20001d00 <HAL_GetTick+0x14>)
20001cf2:	681b      	ldr	r3, [r3, #0]
}
20001cf4:	4618      	mov	r0, r3
20001cf6:	46bd      	mov	sp, r7
20001cf8:	f85d 7b04 	ldr.w	r7, [sp], #4
20001cfc:	4770      	bx	lr
20001cfe:	bf00      	nop
20001d00:	2001ca5c 	.word	0x2001ca5c

20001d04 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
20001d04:	b480      	push	{r7}
20001d06:	af00      	add	r7, sp, #0
  return uwTickPrio;
20001d08:	4b03      	ldr	r3, [pc, #12]	; (20001d18 <HAL_GetTickPrio+0x14>)
20001d0a:	681b      	ldr	r3, [r3, #0]
}
20001d0c:	4618      	mov	r0, r3
20001d0e:	46bd      	mov	sp, r7
20001d10:	f85d 7b04 	ldr.w	r7, [sp], #4
20001d14:	4770      	bx	lr
20001d16:	bf00      	nop
20001d18:	2001c980 	.word	0x2001c980

20001d1c <HAL_SetTickFreq>:
/**
  * @brief Set new tick Freq.
  * @retval Status
  */
HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
{
20001d1c:	b580      	push	{r7, lr}
20001d1e:	b084      	sub	sp, #16
20001d20:	af00      	add	r7, sp, #0
20001d22:	4603      	mov	r3, r0
20001d24:	71fb      	strb	r3, [r7, #7]
  HAL_StatusTypeDef status  = HAL_OK;
20001d26:	2300      	movs	r3, #0
20001d28:	73fb      	strb	r3, [r7, #15]
  HAL_TickFreqTypeDef prevTickFreq;

  assert_param(IS_TICKFREQ(Freq));
20001d2a:	79fb      	ldrb	r3, [r7, #7]
20001d2c:	2b64      	cmp	r3, #100	; 0x64
20001d2e:	d00a      	beq.n	20001d46 <HAL_SetTickFreq+0x2a>
20001d30:	79fb      	ldrb	r3, [r7, #7]
20001d32:	2b0a      	cmp	r3, #10
20001d34:	d007      	beq.n	20001d46 <HAL_SetTickFreq+0x2a>
20001d36:	79fb      	ldrb	r3, [r7, #7]
20001d38:	2b01      	cmp	r3, #1
20001d3a:	d004      	beq.n	20001d46 <HAL_SetTickFreq+0x2a>
20001d3c:	f240 1169 	movw	r1, #361	; 0x169
20001d40:	480f      	ldr	r0, [pc, #60]	; (20001d80 <HAL_SetTickFreq+0x64>)
20001d42:	f7fe fdd7 	bl	200008f4 <assert_failed>

  if (uwTickFreq != Freq)
20001d46:	4b0f      	ldr	r3, [pc, #60]	; (20001d84 <HAL_SetTickFreq+0x68>)
20001d48:	781b      	ldrb	r3, [r3, #0]
20001d4a:	79fa      	ldrb	r2, [r7, #7]
20001d4c:	429a      	cmp	r2, r3
20001d4e:	d012      	beq.n	20001d76 <HAL_SetTickFreq+0x5a>
  {

    /* Back up uwTickFreq frequency */
    prevTickFreq = uwTickFreq;
20001d50:	4b0c      	ldr	r3, [pc, #48]	; (20001d84 <HAL_SetTickFreq+0x68>)
20001d52:	781b      	ldrb	r3, [r3, #0]
20001d54:	73bb      	strb	r3, [r7, #14]

    /* Update uwTickFreq global variable used by HAL_InitTick() */
    uwTickFreq = Freq;
20001d56:	4a0b      	ldr	r2, [pc, #44]	; (20001d84 <HAL_SetTickFreq+0x68>)
20001d58:	79fb      	ldrb	r3, [r7, #7]
20001d5a:	7013      	strb	r3, [r2, #0]

    /* Apply the new tick Freq  */
    status = HAL_InitTick(uwTickPrio);
20001d5c:	4b0a      	ldr	r3, [pc, #40]	; (20001d88 <HAL_SetTickFreq+0x6c>)
20001d5e:	681b      	ldr	r3, [r3, #0]
20001d60:	4618      	mov	r0, r3
20001d62:	f7ff ff79 	bl	20001c58 <HAL_InitTick>
20001d66:	4603      	mov	r3, r0
20001d68:	73fb      	strb	r3, [r7, #15]
    if (status != HAL_OK)
20001d6a:	7bfb      	ldrb	r3, [r7, #15]
20001d6c:	2b00      	cmp	r3, #0
20001d6e:	d002      	beq.n	20001d76 <HAL_SetTickFreq+0x5a>
    {
      /* Restore previous tick frequency */
      uwTickFreq = prevTickFreq;
20001d70:	4a04      	ldr	r2, [pc, #16]	; (20001d84 <HAL_SetTickFreq+0x68>)
20001d72:	7bbb      	ldrb	r3, [r7, #14]
20001d74:	7013      	strb	r3, [r2, #0]
    }
  }

  return status;
20001d76:	7bfb      	ldrb	r3, [r7, #15]
}
20001d78:	4618      	mov	r0, r3
20001d7a:	3710      	adds	r7, #16
20001d7c:	46bd      	mov	sp, r7
20001d7e:	bd80      	pop	{r7, pc}
20001d80:	2001bf64 	.word	0x2001bf64
20001d84:	2001c984 	.word	0x2001c984
20001d88:	2001c980 	.word	0x2001c980

20001d8c <HAL_GetTickFreq>:
/**
  * @brief Return tick frequency.
  * @retval tick period in Hz
  */
HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
20001d8c:	b480      	push	{r7}
20001d8e:	af00      	add	r7, sp, #0
  return uwTickFreq;
20001d90:	4b03      	ldr	r3, [pc, #12]	; (20001da0 <HAL_GetTickFreq+0x14>)
20001d92:	781b      	ldrb	r3, [r3, #0]
}
20001d94:	4618      	mov	r0, r3
20001d96:	46bd      	mov	sp, r7
20001d98:	f85d 7b04 	ldr.w	r7, [sp], #4
20001d9c:	4770      	bx	lr
20001d9e:	bf00      	nop
20001da0:	2001c984 	.word	0x2001c984

20001da4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
20001da4:	b580      	push	{r7, lr}
20001da6:	b084      	sub	sp, #16
20001da8:	af00      	add	r7, sp, #0
20001daa:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
20001dac:	f7ff ff9e 	bl	20001cec <HAL_GetTick>
20001db0:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
20001db2:	687b      	ldr	r3, [r7, #4]
20001db4:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
20001db6:	68fb      	ldr	r3, [r7, #12]
20001db8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
20001dbc:	d005      	beq.n	20001dca <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
20001dbe:	4b09      	ldr	r3, [pc, #36]	; (20001de4 <HAL_Delay+0x40>)
20001dc0:	781b      	ldrb	r3, [r3, #0]
20001dc2:	461a      	mov	r2, r3
20001dc4:	68fb      	ldr	r3, [r7, #12]
20001dc6:	4413      	add	r3, r2
20001dc8:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
20001dca:	bf00      	nop
20001dcc:	f7ff ff8e 	bl	20001cec <HAL_GetTick>
20001dd0:	4602      	mov	r2, r0
20001dd2:	68bb      	ldr	r3, [r7, #8]
20001dd4:	1ad3      	subs	r3, r2, r3
20001dd6:	68fa      	ldr	r2, [r7, #12]
20001dd8:	429a      	cmp	r2, r3
20001dda:	d8f7      	bhi.n	20001dcc <HAL_Delay+0x28>
  {
  }
}
20001ddc:	bf00      	nop
20001dde:	3710      	adds	r7, #16
20001de0:	46bd      	mov	sp, r7
20001de2:	bd80      	pop	{r7, pc}
20001de4:	2001c984 	.word	0x2001c984

20001de8 <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
20001de8:	b480      	push	{r7}
20001dea:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
20001dec:	4b05      	ldr	r3, [pc, #20]	; (20001e04 <HAL_SuspendTick+0x1c>)
20001dee:	681b      	ldr	r3, [r3, #0]
20001df0:	4a04      	ldr	r2, [pc, #16]	; (20001e04 <HAL_SuspendTick+0x1c>)
20001df2:	f023 0302 	bic.w	r3, r3, #2
20001df6:	6013      	str	r3, [r2, #0]
}
20001df8:	bf00      	nop
20001dfa:	46bd      	mov	sp, r7
20001dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e00:	4770      	bx	lr
20001e02:	bf00      	nop
20001e04:	e000e010 	.word	0xe000e010

20001e08 <HAL_ResumeTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
20001e08:	b480      	push	{r7}
20001e0a:	af00      	add	r7, sp, #0
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
20001e0c:	4b05      	ldr	r3, [pc, #20]	; (20001e24 <HAL_ResumeTick+0x1c>)
20001e0e:	681b      	ldr	r3, [r3, #0]
20001e10:	4a04      	ldr	r2, [pc, #16]	; (20001e24 <HAL_ResumeTick+0x1c>)
20001e12:	f043 0302 	orr.w	r3, r3, #2
20001e16:	6013      	str	r3, [r2, #0]
}
20001e18:	bf00      	nop
20001e1a:	46bd      	mov	sp, r7
20001e1c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e20:	4770      	bx	lr
20001e22:	bf00      	nop
20001e24:	e000e010 	.word	0xe000e010

20001e28 <HAL_GetHalVersion>:
/**
  * @brief  Returns the HAL revision
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
20001e28:	b480      	push	{r7}
20001e2a:	af00      	add	r7, sp, #0
 return __STM32H7xx_HAL_VERSION;
20001e2c:	f04f 7384 	mov.w	r3, #17301504	; 0x1080000
}
20001e30:	4618      	mov	r0, r3
20001e32:	46bd      	mov	sp, r7
20001e34:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e38:	4770      	bx	lr
	...

20001e3c <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
20001e3c:	b480      	push	{r7}
20001e3e:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
20001e40:	4b03      	ldr	r3, [pc, #12]	; (20001e50 <HAL_GetREVID+0x14>)
20001e42:	681b      	ldr	r3, [r3, #0]
20001e44:	0c1b      	lsrs	r3, r3, #16
}
20001e46:	4618      	mov	r0, r3
20001e48:	46bd      	mov	sp, r7
20001e4a:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e4e:	4770      	bx	lr
20001e50:	5c001000 	.word	0x5c001000

20001e54 <HAL_GetDEVID>:
/**
  * @brief  Returns the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
20001e54:	b480      	push	{r7}
20001e56:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
20001e58:	4b04      	ldr	r3, [pc, #16]	; (20001e6c <HAL_GetDEVID+0x18>)
20001e5a:	681b      	ldr	r3, [r3, #0]
20001e5c:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
20001e60:	4618      	mov	r0, r3
20001e62:	46bd      	mov	sp, r7
20001e64:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e68:	4770      	bx	lr
20001e6a:	bf00      	nop
20001e6c:	5c001000 	.word	0x5c001000

20001e70 <HAL_GetUIDw0>:
/**
  * @brief  Return the first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
20001e70:	b480      	push	{r7}
20001e72:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)UID_BASE)));
20001e74:	4b03      	ldr	r3, [pc, #12]	; (20001e84 <HAL_GetUIDw0+0x14>)
20001e76:	681b      	ldr	r3, [r3, #0]
}
20001e78:	4618      	mov	r0, r3
20001e7a:	46bd      	mov	sp, r7
20001e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e80:	4770      	bx	lr
20001e82:	bf00      	nop
20001e84:	1ff1e800 	.word	0x1ff1e800

20001e88 <HAL_GetUIDw1>:
/**
  * @brief  Return the second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
20001e88:	b480      	push	{r7}
20001e8a:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
20001e8c:	4b03      	ldr	r3, [pc, #12]	; (20001e9c <HAL_GetUIDw1+0x14>)
20001e8e:	681b      	ldr	r3, [r3, #0]
}
20001e90:	4618      	mov	r0, r3
20001e92:	46bd      	mov	sp, r7
20001e94:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e98:	4770      	bx	lr
20001e9a:	bf00      	nop
20001e9c:	1ff1e804 	.word	0x1ff1e804

20001ea0 <HAL_GetUIDw2>:
/**
  * @brief  Return the third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
20001ea0:	b480      	push	{r7}
20001ea2:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
20001ea4:	4b03      	ldr	r3, [pc, #12]	; (20001eb4 <HAL_GetUIDw2+0x14>)
20001ea6:	681b      	ldr	r3, [r3, #0]
}
20001ea8:	4618      	mov	r0, r3
20001eaa:	46bd      	mov	sp, r7
20001eac:	f85d 7b04 	ldr.w	r7, [sp], #4
20001eb0:	4770      	bx	lr
20001eb2:	bf00      	nop
20001eb4:	1ff1e808 	.word	0x1ff1e808

20001eb8 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig>:
  *            @arg SYSCFG_VREFBUF_VOLTAGE_SCALE3: VREF_OUT4 around 1.8 V.
  *                                                This requires VDDA equal to or higher than 2.1 V.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
{
20001eb8:	b580      	push	{r7, lr}
20001eba:	b082      	sub	sp, #8
20001ebc:	af00      	add	r7, sp, #0
20001ebe:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));
20001ec0:	687b      	ldr	r3, [r7, #4]
20001ec2:	2b10      	cmp	r3, #16
20001ec4:	d00d      	beq.n	20001ee2 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x2a>
20001ec6:	687b      	ldr	r3, [r7, #4]
20001ec8:	2b00      	cmp	r3, #0
20001eca:	d00a      	beq.n	20001ee2 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x2a>
20001ecc:	687b      	ldr	r3, [r7, #4]
20001ece:	2b30      	cmp	r3, #48	; 0x30
20001ed0:	d007      	beq.n	20001ee2 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x2a>
20001ed2:	687b      	ldr	r3, [r7, #4]
20001ed4:	2b20      	cmp	r3, #32
20001ed6:	d004      	beq.n	20001ee2 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x2a>
20001ed8:	f240 210b 	movw	r1, #523	; 0x20b
20001edc:	4807      	ldr	r0, [pc, #28]	; (20001efc <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x44>)
20001ede:	f7fe fd09 	bl	200008f4 <assert_failed>

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
20001ee2:	4b07      	ldr	r3, [pc, #28]	; (20001f00 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x48>)
20001ee4:	681b      	ldr	r3, [r3, #0]
20001ee6:	f023 0270 	bic.w	r2, r3, #112	; 0x70
20001eea:	4905      	ldr	r1, [pc, #20]	; (20001f00 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x48>)
20001eec:	687b      	ldr	r3, [r7, #4]
20001eee:	4313      	orrs	r3, r2
20001ef0:	600b      	str	r3, [r1, #0]
}
20001ef2:	bf00      	nop
20001ef4:	3708      	adds	r7, #8
20001ef6:	46bd      	mov	sp, r7
20001ef8:	bd80      	pop	{r7, pc}
20001efa:	bf00      	nop
20001efc:	2001bf64 	.word	0x2001bf64
20001f00:	58003c00 	.word	0x58003c00

20001f04 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE: VREF+ pin is internally connect to VREFINT output.
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE: VREF+ pin is high impedance.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
20001f04:	b580      	push	{r7, lr}
20001f06:	b082      	sub	sp, #8
20001f08:	af00      	add	r7, sp, #0
20001f0a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));
20001f0c:	687b      	ldr	r3, [r7, #4]
20001f0e:	2b00      	cmp	r3, #0
20001f10:	d007      	beq.n	20001f22 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x1e>
20001f12:	687b      	ldr	r3, [r7, #4]
20001f14:	2b02      	cmp	r3, #2
20001f16:	d004      	beq.n	20001f22 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x1e>
20001f18:	f240 211b 	movw	r1, #539	; 0x21b
20001f1c:	4807      	ldr	r0, [pc, #28]	; (20001f3c <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x38>)
20001f1e:	f7fe fce9 	bl	200008f4 <assert_failed>

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
20001f22:	4b07      	ldr	r3, [pc, #28]	; (20001f40 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x3c>)
20001f24:	681b      	ldr	r3, [r3, #0]
20001f26:	f023 0202 	bic.w	r2, r3, #2
20001f2a:	4905      	ldr	r1, [pc, #20]	; (20001f40 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x3c>)
20001f2c:	687b      	ldr	r3, [r7, #4]
20001f2e:	4313      	orrs	r3, r2
20001f30:	600b      	str	r3, [r1, #0]
}
20001f32:	bf00      	nop
20001f34:	3708      	adds	r7, #8
20001f36:	46bd      	mov	sp, r7
20001f38:	bd80      	pop	{r7, pc}
20001f3a:	bf00      	nop
20001f3c:	2001bf64 	.word	0x2001bf64
20001f40:	58003c00 	.word	0x58003c00

20001f44 <HAL_SYSCFG_VREFBUF_TrimmingConfig>:
/**
  * @brief  Tune the Internal Voltage Reference buffer (VREFBUF).
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
{
20001f44:	b580      	push	{r7, lr}
20001f46:	b082      	sub	sp, #8
20001f48:	af00      	add	r7, sp, #0
20001f4a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));
20001f4c:	687b      	ldr	r3, [r7, #4]
20001f4e:	2b00      	cmp	r3, #0
20001f50:	d002      	beq.n	20001f58 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x14>
20001f52:	687b      	ldr	r3, [r7, #4]
20001f54:	2b3f      	cmp	r3, #63	; 0x3f
20001f56:	d904      	bls.n	20001f62 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x1e>
20001f58:	f240 2127 	movw	r1, #551	; 0x227
20001f5c:	4807      	ldr	r0, [pc, #28]	; (20001f7c <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x38>)
20001f5e:	f7fe fcc9 	bl	200008f4 <assert_failed>

  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
20001f62:	4b07      	ldr	r3, [pc, #28]	; (20001f80 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x3c>)
20001f64:	685b      	ldr	r3, [r3, #4]
20001f66:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
20001f6a:	4905      	ldr	r1, [pc, #20]	; (20001f80 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x3c>)
20001f6c:	687b      	ldr	r3, [r7, #4]
20001f6e:	4313      	orrs	r3, r2
20001f70:	604b      	str	r3, [r1, #4]
}
20001f72:	bf00      	nop
20001f74:	3708      	adds	r7, #8
20001f76:	46bd      	mov	sp, r7
20001f78:	bd80      	pop	{r7, pc}
20001f7a:	bf00      	nop
20001f7c:	2001bf64 	.word	0x2001bf64
20001f80:	58003c00 	.word	0x58003c00

20001f84 <HAL_SYSCFG_EnableVREFBUF>:
/**
  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
  * @retval HAL_OK/HAL_TIMEOUT
  */
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
{
20001f84:	b580      	push	{r7, lr}
20001f86:	b082      	sub	sp, #8
20001f88:	af00      	add	r7, sp, #0
  uint32_t  tickstart;

  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
20001f8a:	4b0f      	ldr	r3, [pc, #60]	; (20001fc8 <HAL_SYSCFG_EnableVREFBUF+0x44>)
20001f8c:	681b      	ldr	r3, [r3, #0]
20001f8e:	4a0e      	ldr	r2, [pc, #56]	; (20001fc8 <HAL_SYSCFG_EnableVREFBUF+0x44>)
20001f90:	f043 0301 	orr.w	r3, r3, #1
20001f94:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
20001f96:	f7ff fea9 	bl	20001cec <HAL_GetTick>
20001f9a:	6078      	str	r0, [r7, #4]

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
20001f9c:	e008      	b.n	20001fb0 <HAL_SYSCFG_EnableVREFBUF+0x2c>
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
20001f9e:	f7ff fea5 	bl	20001cec <HAL_GetTick>
20001fa2:	4602      	mov	r2, r0
20001fa4:	687b      	ldr	r3, [r7, #4]
20001fa6:	1ad3      	subs	r3, r2, r3
20001fa8:	2b0a      	cmp	r3, #10
20001faa:	d901      	bls.n	20001fb0 <HAL_SYSCFG_EnableVREFBUF+0x2c>
    {
      return HAL_TIMEOUT;
20001fac:	2303      	movs	r3, #3
20001fae:	e006      	b.n	20001fbe <HAL_SYSCFG_EnableVREFBUF+0x3a>
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
20001fb0:	4b05      	ldr	r3, [pc, #20]	; (20001fc8 <HAL_SYSCFG_EnableVREFBUF+0x44>)
20001fb2:	681b      	ldr	r3, [r3, #0]
20001fb4:	f003 0308 	and.w	r3, r3, #8
20001fb8:	2b00      	cmp	r3, #0
20001fba:	d0f0      	beq.n	20001f9e <HAL_SYSCFG_EnableVREFBUF+0x1a>
    }
  }

  return HAL_OK;
20001fbc:	2300      	movs	r3, #0
}
20001fbe:	4618      	mov	r0, r3
20001fc0:	3708      	adds	r7, #8
20001fc2:	46bd      	mov	sp, r7
20001fc4:	bd80      	pop	{r7, pc}
20001fc6:	bf00      	nop
20001fc8:	58003c00 	.word	0x58003c00

20001fcc <HAL_SYSCFG_DisableVREFBUF>:
  * @brief  Disable the Internal Voltage Reference buffer (VREFBUF).
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
20001fcc:	b480      	push	{r7}
20001fce:	af00      	add	r7, sp, #0
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
20001fd0:	4b05      	ldr	r3, [pc, #20]	; (20001fe8 <HAL_SYSCFG_DisableVREFBUF+0x1c>)
20001fd2:	681b      	ldr	r3, [r3, #0]
20001fd4:	4a04      	ldr	r2, [pc, #16]	; (20001fe8 <HAL_SYSCFG_DisableVREFBUF+0x1c>)
20001fd6:	f023 0301 	bic.w	r3, r3, #1
20001fda:	6013      	str	r3, [r2, #0]
}
20001fdc:	bf00      	nop
20001fde:	46bd      	mov	sp, r7
20001fe0:	f85d 7b04 	ldr.w	r7, [sp], #4
20001fe4:	4770      	bx	lr
20001fe6:	bf00      	nop
20001fe8:	58003c00 	.word	0x58003c00

20001fec <HAL_SYSCFG_ETHInterfaceSelect>:
  *   @arg SYSCFG_ETH_MII : Select the Media Independent Interface
  *   @arg SYSCFG_ETH_RMII: Select the Reduced Media Independent Interface
  * @retval None
  */
void HAL_SYSCFG_ETHInterfaceSelect(uint32_t SYSCFG_ETHInterface)
{
20001fec:	b580      	push	{r7, lr}
20001fee:	b082      	sub	sp, #8
20001ff0:	af00      	add	r7, sp, #0
20001ff2:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));
20001ff4:	687b      	ldr	r3, [r7, #4]
20001ff6:	2b00      	cmp	r3, #0
20001ff8:	d008      	beq.n	2000200c <HAL_SYSCFG_ETHInterfaceSelect+0x20>
20001ffa:	687b      	ldr	r3, [r7, #4]
20001ffc:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
20002000:	d004      	beq.n	2000200c <HAL_SYSCFG_ETHInterfaceSelect+0x20>
20002002:	f240 215b 	movw	r1, #603	; 0x25b
20002006:	4807      	ldr	r0, [pc, #28]	; (20002024 <HAL_SYSCFG_ETHInterfaceSelect+0x38>)
20002008:	f7fe fc74 	bl	200008f4 <assert_failed>

  MODIFY_REG(SYSCFG->PMCR, SYSCFG_PMCR_EPIS_SEL, (uint32_t)(SYSCFG_ETHInterface));
2000200c:	4b06      	ldr	r3, [pc, #24]	; (20002028 <HAL_SYSCFG_ETHInterfaceSelect+0x3c>)
2000200e:	685b      	ldr	r3, [r3, #4]
20002010:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
20002014:	4904      	ldr	r1, [pc, #16]	; (20002028 <HAL_SYSCFG_ETHInterfaceSelect+0x3c>)
20002016:	687b      	ldr	r3, [r7, #4]
20002018:	4313      	orrs	r3, r2
2000201a:	604b      	str	r3, [r1, #4]
}
2000201c:	bf00      	nop
2000201e:	3708      	adds	r7, #8
20002020:	46bd      	mov	sp, r7
20002022:	bd80      	pop	{r7, pc}
20002024:	2001bf64 	.word	0x2001bf64
20002028:	58000400 	.word	0x58000400

2000202c <HAL_SYSCFG_AnalogSwitchConfig>:
  *   @arg SYSCFG_SWITCH_PC3_CLOSE
  * @retval None
  */

void HAL_SYSCFG_AnalogSwitchConfig(uint32_t SYSCFG_AnalogSwitch , uint32_t SYSCFG_SwitchState )
{
2000202c:	b580      	push	{r7, lr}
2000202e:	b082      	sub	sp, #8
20002030:	af00      	add	r7, sp, #0
20002032:	6078      	str	r0, [r7, #4]
20002034:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ANALOG_SWITCH(SYSCFG_AnalogSwitch));
20002036:	687b      	ldr	r3, [r7, #4]
20002038:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2000203c:	2b00      	cmp	r3, #0
2000203e:	d113      	bne.n	20002068 <HAL_SYSCFG_AnalogSwitchConfig+0x3c>
20002040:	687b      	ldr	r3, [r7, #4]
20002042:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20002046:	2b00      	cmp	r3, #0
20002048:	d10e      	bne.n	20002068 <HAL_SYSCFG_AnalogSwitchConfig+0x3c>
2000204a:	687b      	ldr	r3, [r7, #4]
2000204c:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
20002050:	2b00      	cmp	r3, #0
20002052:	d109      	bne.n	20002068 <HAL_SYSCFG_AnalogSwitchConfig+0x3c>
20002054:	687b      	ldr	r3, [r7, #4]
20002056:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2000205a:	2b00      	cmp	r3, #0
2000205c:	d104      	bne.n	20002068 <HAL_SYSCFG_AnalogSwitchConfig+0x3c>
2000205e:	f240 2179 	movw	r1, #633	; 0x279
20002062:	4808      	ldr	r0, [pc, #32]	; (20002084 <HAL_SYSCFG_AnalogSwitchConfig+0x58>)
20002064:	f7fe fc46 	bl	200008f4 <assert_failed>
  assert_param(IS_SYSCFG_SWITCH_STATE(SYSCFG_SwitchState));

  MODIFY_REG(SYSCFG->PMCR, (uint32_t) SYSCFG_AnalogSwitch, (uint32_t)(SYSCFG_SwitchState));
20002068:	4b07      	ldr	r3, [pc, #28]	; (20002088 <HAL_SYSCFG_AnalogSwitchConfig+0x5c>)
2000206a:	685a      	ldr	r2, [r3, #4]
2000206c:	687b      	ldr	r3, [r7, #4]
2000206e:	43db      	mvns	r3, r3
20002070:	401a      	ands	r2, r3
20002072:	4905      	ldr	r1, [pc, #20]	; (20002088 <HAL_SYSCFG_AnalogSwitchConfig+0x5c>)
20002074:	683b      	ldr	r3, [r7, #0]
20002076:	4313      	orrs	r3, r2
20002078:	604b      	str	r3, [r1, #4]
}
2000207a:	bf00      	nop
2000207c:	3708      	adds	r7, #8
2000207e:	46bd      	mov	sp, r7
20002080:	bd80      	pop	{r7, pc}
20002082:	bf00      	nop
20002084:	2001bf64 	.word	0x2001bf64
20002088:	58000400 	.word	0x58000400

2000208c <HAL_SYSCFG_EnableBOOST>:
  *         when the supply voltage is below 2.7 V: in this case, the analog switch
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_EnableBOOST(void)
{
2000208c:	b480      	push	{r7}
2000208e:	af00      	add	r7, sp, #0
 SET_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
20002090:	4b05      	ldr	r3, [pc, #20]	; (200020a8 <HAL_SYSCFG_EnableBOOST+0x1c>)
20002092:	685b      	ldr	r3, [r3, #4]
20002094:	4a04      	ldr	r2, [pc, #16]	; (200020a8 <HAL_SYSCFG_EnableBOOST+0x1c>)
20002096:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2000209a:	6053      	str	r3, [r2, #4]
}
2000209c:	bf00      	nop
2000209e:	46bd      	mov	sp, r7
200020a0:	f85d 7b04 	ldr.w	r7, [sp], #4
200020a4:	4770      	bx	lr
200020a6:	bf00      	nop
200020a8:	58000400 	.word	0x58000400

200020ac <HAL_SYSCFG_DisableBOOST>:
  *         when the supply voltage is below 2.7 V: in this case, the analog switch
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_DisableBOOST(void)
{
200020ac:	b480      	push	{r7}
200020ae:	af00      	add	r7, sp, #0
 CLEAR_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
200020b0:	4b05      	ldr	r3, [pc, #20]	; (200020c8 <HAL_SYSCFG_DisableBOOST+0x1c>)
200020b2:	685b      	ldr	r3, [r3, #4]
200020b4:	4a04      	ldr	r2, [pc, #16]	; (200020c8 <HAL_SYSCFG_DisableBOOST+0x1c>)
200020b6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
200020ba:	6053      	str	r3, [r2, #4]
}
200020bc:	bf00      	nop
200020be:	46bd      	mov	sp, r7
200020c0:	f85d 7b04 	ldr.w	r7, [sp], #4
200020c4:	4770      	bx	lr
200020c6:	bf00      	nop
200020c8:	58000400 	.word	0x58000400

200020cc <HAL_SYSCFG_CM7BootAddConfig>:
  *   @arg SYSCFG_BOOT_ADDR1:  Select the boot address1
  * @param  BootAddress :Specifies the CM7 Boot Address to be loaded in Address0 or Address1
  * @retval None
  */
void HAL_SYSCFG_CM7BootAddConfig(uint32_t BootRegister, uint32_t BootAddress)
{
200020cc:	b580      	push	{r7, lr}
200020ce:	b082      	sub	sp, #8
200020d0:	af00      	add	r7, sp, #0
200020d2:	6078      	str	r0, [r7, #4]
200020d4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_SYSCFG_BOOT_REGISTER(BootRegister));
200020d6:	687b      	ldr	r3, [r7, #4]
200020d8:	2b00      	cmp	r3, #0
200020da:	d007      	beq.n	200020ec <HAL_SYSCFG_CM7BootAddConfig+0x20>
200020dc:	687b      	ldr	r3, [r7, #4]
200020de:	2b01      	cmp	r3, #1
200020e0:	d004      	beq.n	200020ec <HAL_SYSCFG_CM7BootAddConfig+0x20>
200020e2:	f240 21a7 	movw	r1, #679	; 0x2a7
200020e6:	4815      	ldr	r0, [pc, #84]	; (2000213c <HAL_SYSCFG_CM7BootAddConfig+0x70>)
200020e8:	f7fe fc04 	bl	200008f4 <assert_failed>
  assert_param(IS_SYSCFG_BOOT_ADDRESS(BootAddress));
200020ec:	683b      	ldr	r3, [r7, #0]
200020ee:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
200020f2:	d304      	bcc.n	200020fe <HAL_SYSCFG_CM7BootAddConfig+0x32>
200020f4:	f44f 712a 	mov.w	r1, #680	; 0x2a8
200020f8:	4810      	ldr	r0, [pc, #64]	; (2000213c <HAL_SYSCFG_CM7BootAddConfig+0x70>)
200020fa:	f7fe fbfb 	bl	200008f4 <assert_failed>
  if ( BootRegister == SYSCFG_BOOT_ADDR0 )
200020fe:	687b      	ldr	r3, [r7, #4]
20002100:	2b00      	cmp	r3, #0
20002102:	d10b      	bne.n	2000211c <HAL_SYSCFG_CM7BootAddConfig+0x50>
  {
    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BCM7_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BCM7_ADD0_Pos));
#else
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BOOT_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BOOT_ADD0_Pos));
20002104:	4b0e      	ldr	r3, [pc, #56]	; (20002140 <HAL_SYSCFG_CM7BootAddConfig+0x74>)
20002106:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
2000210a:	b29a      	uxth	r2, r3
2000210c:	683b      	ldr	r3, [r7, #0]
2000210e:	0c1b      	lsrs	r3, r3, #16
20002110:	041b      	lsls	r3, r3, #16
20002112:	490b      	ldr	r1, [pc, #44]	; (20002140 <HAL_SYSCFG_CM7BootAddConfig+0x74>)
20002114:	4313      	orrs	r3, r2
20002116:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BCM7_ADD1, (BootAddress >> 16));
#else
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
#endif /*DUAL_CORE*/
  }
}
2000211a:	e00a      	b.n	20002132 <HAL_SYSCFG_CM7BootAddConfig+0x66>
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
2000211c:	4b08      	ldr	r3, [pc, #32]	; (20002140 <HAL_SYSCFG_CM7BootAddConfig+0x74>)
2000211e:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
20002122:	4b08      	ldr	r3, [pc, #32]	; (20002144 <HAL_SYSCFG_CM7BootAddConfig+0x78>)
20002124:	4013      	ands	r3, r2
20002126:	683a      	ldr	r2, [r7, #0]
20002128:	0c12      	lsrs	r2, r2, #16
2000212a:	4905      	ldr	r1, [pc, #20]	; (20002140 <HAL_SYSCFG_CM7BootAddConfig+0x74>)
2000212c:	4313      	orrs	r3, r2
2000212e:	f8c1 330c 	str.w	r3, [r1, #780]	; 0x30c
}
20002132:	bf00      	nop
20002134:	3708      	adds	r7, #8
20002136:	46bd      	mov	sp, r7
20002138:	bd80      	pop	{r7, pc}
2000213a:	bf00      	nop
2000213c:	2001bf64 	.word	0x2001bf64
20002140:	58000400 	.word	0x58000400
20002144:	ffff0000 	.word	0xffff0000

20002148 <HAL_EnableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.
  * @retval None
  */
void HAL_EnableCompensationCell(void)
{
20002148:	b480      	push	{r7}
2000214a:	af00      	add	r7, sp, #0
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN) ;
2000214c:	4b05      	ldr	r3, [pc, #20]	; (20002164 <HAL_EnableCompensationCell+0x1c>)
2000214e:	6a1b      	ldr	r3, [r3, #32]
20002150:	4a04      	ldr	r2, [pc, #16]	; (20002164 <HAL_EnableCompensationCell+0x1c>)
20002152:	f043 0301 	orr.w	r3, r3, #1
20002156:	6213      	str	r3, [r2, #32]
}
20002158:	bf00      	nop
2000215a:	46bd      	mov	sp, r7
2000215c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002160:	4770      	bx	lr
20002162:	bf00      	nop
20002164:	58000400 	.word	0x58000400

20002168 <HAL_DisableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.
  * @retval None
  */
void HAL_DisableCompensationCell(void)
{
20002168:	b480      	push	{r7}
2000216a:	af00      	add	r7, sp, #0
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN);
2000216c:	4b05      	ldr	r3, [pc, #20]	; (20002184 <HAL_DisableCompensationCell+0x1c>)
2000216e:	6a1b      	ldr	r3, [r3, #32]
20002170:	4a04      	ldr	r2, [pc, #16]	; (20002184 <HAL_DisableCompensationCell+0x1c>)
20002172:	f023 0301 	bic.w	r3, r3, #1
20002176:	6213      	str	r3, [r2, #32]
}
20002178:	bf00      	nop
2000217a:	46bd      	mov	sp, r7
2000217c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002180:	4770      	bx	lr
20002182:	bf00      	nop
20002184:	58000400 	.word	0x58000400

20002188 <HAL_SYSCFG_EnableIOSpeedOptimize>:
  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is
  *         higher than 2.5 V might be destructive.
  * @retval None
  */
void HAL_SYSCFG_EnableIOSpeedOptimize(void)
{
20002188:	b480      	push	{r7}
2000218a:	af00      	add	r7, sp, #0
#if defined(SYSCFG_CCCSR_HSLV)
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
2000218c:	4b05      	ldr	r3, [pc, #20]	; (200021a4 <HAL_SYSCFG_EnableIOSpeedOptimize+0x1c>)
2000218e:	6a1b      	ldr	r3, [r3, #32]
20002190:	4a04      	ldr	r2, [pc, #16]	; (200021a4 <HAL_SYSCFG_EnableIOSpeedOptimize+0x1c>)
20002192:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20002196:	6213      	str	r3, [r2, #32]
#else
  SET_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
20002198:	bf00      	nop
2000219a:	46bd      	mov	sp, r7
2000219c:	f85d 7b04 	ldr.w	r7, [sp], #4
200021a0:	4770      	bx	lr
200021a2:	bf00      	nop
200021a4:	58000400 	.word	0x58000400

200021a8 <HAL_SYSCFG_DisableIOSpeedOptimize>:
  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is
  *         higher than 2.5 V might be destructive.
  * @retval None
  */
void HAL_SYSCFG_DisableIOSpeedOptimize(void)
{
200021a8:	b480      	push	{r7}
200021aa:	af00      	add	r7, sp, #0
#if defined(SYSCFG_CCCSR_HSLV)
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
200021ac:	4b05      	ldr	r3, [pc, #20]	; (200021c4 <HAL_SYSCFG_DisableIOSpeedOptimize+0x1c>)
200021ae:	6a1b      	ldr	r3, [r3, #32]
200021b0:	4a04      	ldr	r2, [pc, #16]	; (200021c4 <HAL_SYSCFG_DisableIOSpeedOptimize+0x1c>)
200021b2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
200021b6:	6213      	str	r3, [r2, #32]
#else
  CLEAR_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
200021b8:	bf00      	nop
200021ba:	46bd      	mov	sp, r7
200021bc:	f85d 7b04 	ldr.w	r7, [sp], #4
200021c0:	4770      	bx	lr
200021c2:	bf00      	nop
200021c4:	58000400 	.word	0x58000400

200021c8 <HAL_SYSCFG_CompensationCodeSelect>:
  *   @arg SYSCFG_CELL_CODE : Select Code from the cell (available in the SYSCFG_CCVR)
  *   @arg SYSCFG_REGISTER_CODE: Select Code from the SYSCFG compensation cell code register (SYSCFG_CCCR)
  * @retval None
  */
void HAL_SYSCFG_CompensationCodeSelect(uint32_t SYSCFG_CompCode)
{
200021c8:	b580      	push	{r7, lr}
200021ca:	b082      	sub	sp, #8
200021cc:	af00      	add	r7, sp, #0
200021ce:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_SELECT(SYSCFG_CompCode));
200021d0:	687b      	ldr	r3, [r7, #4]
200021d2:	2b00      	cmp	r3, #0
200021d4:	d007      	beq.n	200021e6 <HAL_SYSCFG_CompensationCodeSelect+0x1e>
200021d6:	687b      	ldr	r3, [r7, #4]
200021d8:	2b02      	cmp	r3, #2
200021da:	d004      	beq.n	200021e6 <HAL_SYSCFG_CompensationCodeSelect+0x1e>
200021dc:	f240 3143 	movw	r1, #835	; 0x343
200021e0:	4807      	ldr	r0, [pc, #28]	; (20002200 <HAL_SYSCFG_CompensationCodeSelect+0x38>)
200021e2:	f7fe fb87 	bl	200008f4 <assert_failed>
  MODIFY_REG(SYSCFG->CCCSR, SYSCFG_CCCSR_CS, (uint32_t)(SYSCFG_CompCode));
200021e6:	4b07      	ldr	r3, [pc, #28]	; (20002204 <HAL_SYSCFG_CompensationCodeSelect+0x3c>)
200021e8:	6a1b      	ldr	r3, [r3, #32]
200021ea:	f023 0202 	bic.w	r2, r3, #2
200021ee:	4905      	ldr	r1, [pc, #20]	; (20002204 <HAL_SYSCFG_CompensationCodeSelect+0x3c>)
200021f0:	687b      	ldr	r3, [r7, #4]
200021f2:	4313      	orrs	r3, r2
200021f4:	620b      	str	r3, [r1, #32]
}
200021f6:	bf00      	nop
200021f8:	3708      	adds	r7, #8
200021fa:	46bd      	mov	sp, r7
200021fc:	bd80      	pop	{r7, pc}
200021fe:	bf00      	nop
20002200:	2001bf64 	.word	0x2001bf64
20002204:	58000400 	.word	0x58000400

20002208 <HAL_SYSCFG_CompensationCodeConfig>:
  *         This code is applied to the I/O compensation cell when the CS bit of the
  *          SYSCFG_CMPCR is set
  * @retval None
  */
void HAL_SYSCFG_CompensationCodeConfig(uint32_t SYSCFG_PMOSCode, uint32_t SYSCFG_NMOSCode )
{
20002208:	b580      	push	{r7, lr}
2000220a:	b082      	sub	sp, #8
2000220c:	af00      	add	r7, sp, #0
2000220e:	6078      	str	r0, [r7, #4]
20002210:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_PMOSCode));
20002212:	687b      	ldr	r3, [r7, #4]
20002214:	2b0f      	cmp	r3, #15
20002216:	d904      	bls.n	20002222 <HAL_SYSCFG_CompensationCodeConfig+0x1a>
20002218:	f44f 7155 	mov.w	r1, #852	; 0x354
2000221c:	480c      	ldr	r0, [pc, #48]	; (20002250 <HAL_SYSCFG_CompensationCodeConfig+0x48>)
2000221e:	f7fe fb69 	bl	200008f4 <assert_failed>
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_NMOSCode));
20002222:	683b      	ldr	r3, [r7, #0]
20002224:	2b0f      	cmp	r3, #15
20002226:	d904      	bls.n	20002232 <HAL_SYSCFG_CompensationCodeConfig+0x2a>
20002228:	f240 3155 	movw	r1, #853	; 0x355
2000222c:	4808      	ldr	r0, [pc, #32]	; (20002250 <HAL_SYSCFG_CompensationCodeConfig+0x48>)
2000222e:	f7fe fb61 	bl	200008f4 <assert_failed>
  MODIFY_REG(SYSCFG->CCCR, SYSCFG_CCCR_NCC|SYSCFG_CCCR_PCC, (((uint32_t)(SYSCFG_PMOSCode)<< 4)|(uint32_t)(SYSCFG_NMOSCode)) );
20002232:	4b08      	ldr	r3, [pc, #32]	; (20002254 <HAL_SYSCFG_CompensationCodeConfig+0x4c>)
20002234:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20002236:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
2000223a:	687b      	ldr	r3, [r7, #4]
2000223c:	0119      	lsls	r1, r3, #4
2000223e:	683b      	ldr	r3, [r7, #0]
20002240:	430b      	orrs	r3, r1
20002242:	4904      	ldr	r1, [pc, #16]	; (20002254 <HAL_SYSCFG_CompensationCodeConfig+0x4c>)
20002244:	4313      	orrs	r3, r2
20002246:	628b      	str	r3, [r1, #40]	; 0x28
}
20002248:	bf00      	nop
2000224a:	3708      	adds	r7, #8
2000224c:	46bd      	mov	sp, r7
2000224e:	bd80      	pop	{r7, pc}
20002250:	2001bf64 	.word	0x2001bf64
20002254:	58000400 	.word	0x58000400

20002258 <HAL_DBGMCU_EnableDBGSleepMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_EnableDBGSleepMode(void)
{
20002258:	b480      	push	{r7}
2000225a:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
2000225c:	4b05      	ldr	r3, [pc, #20]	; (20002274 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
2000225e:	685b      	ldr	r3, [r3, #4]
20002260:	4a04      	ldr	r2, [pc, #16]	; (20002274 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
20002262:	f043 0301 	orr.w	r3, r3, #1
20002266:	6053      	str	r3, [r2, #4]
}
20002268:	bf00      	nop
2000226a:	46bd      	mov	sp, r7
2000226c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002270:	4770      	bx	lr
20002272:	bf00      	nop
20002274:	5c001000 	.word	0x5c001000

20002278 <HAL_DBGMCU_DisableDBGSleepMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_DisableDBGSleepMode(void)
{
20002278:	b480      	push	{r7}
2000227a:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
2000227c:	4b05      	ldr	r3, [pc, #20]	; (20002294 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
2000227e:	685b      	ldr	r3, [r3, #4]
20002280:	4a04      	ldr	r2, [pc, #16]	; (20002294 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
20002282:	f023 0301 	bic.w	r3, r3, #1
20002286:	6053      	str	r3, [r2, #4]
}
20002288:	bf00      	nop
2000228a:	46bd      	mov	sp, r7
2000228c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002290:	4770      	bx	lr
20002292:	bf00      	nop
20002294:	5c001000 	.word	0x5c001000

20002298 <HAL_DBGMCU_EnableDBGStopMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_EnableDBGStopMode(void)
{
20002298:	b480      	push	{r7}
2000229a:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
2000229c:	4b05      	ldr	r3, [pc, #20]	; (200022b4 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
2000229e:	685b      	ldr	r3, [r3, #4]
200022a0:	4a04      	ldr	r2, [pc, #16]	; (200022b4 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
200022a2:	f043 0302 	orr.w	r3, r3, #2
200022a6:	6053      	str	r3, [r2, #4]
}
200022a8:	bf00      	nop
200022aa:	46bd      	mov	sp, r7
200022ac:	f85d 7b04 	ldr.w	r7, [sp], #4
200022b0:	4770      	bx	lr
200022b2:	bf00      	nop
200022b4:	5c001000 	.word	0x5c001000

200022b8 <HAL_DBGMCU_DisableDBGStopMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_DisableDBGStopMode(void)
{
200022b8:	b480      	push	{r7}
200022ba:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
200022bc:	4b05      	ldr	r3, [pc, #20]	; (200022d4 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
200022be:	685b      	ldr	r3, [r3, #4]
200022c0:	4a04      	ldr	r2, [pc, #16]	; (200022d4 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
200022c2:	f023 0302 	bic.w	r3, r3, #2
200022c6:	6053      	str	r3, [r2, #4]
}
200022c8:	bf00      	nop
200022ca:	46bd      	mov	sp, r7
200022cc:	f85d 7b04 	ldr.w	r7, [sp], #4
200022d0:	4770      	bx	lr
200022d2:	bf00      	nop
200022d4:	5c001000 	.word	0x5c001000

200022d8 <HAL_DBGMCU_EnableDBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_EnableDBGStandbyMode(void)
{
200022d8:	b480      	push	{r7}
200022da:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
200022dc:	4b05      	ldr	r3, [pc, #20]	; (200022f4 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
200022de:	685b      	ldr	r3, [r3, #4]
200022e0:	4a04      	ldr	r2, [pc, #16]	; (200022f4 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
200022e2:	f043 0304 	orr.w	r3, r3, #4
200022e6:	6053      	str	r3, [r2, #4]
}
200022e8:	bf00      	nop
200022ea:	46bd      	mov	sp, r7
200022ec:	f85d 7b04 	ldr.w	r7, [sp], #4
200022f0:	4770      	bx	lr
200022f2:	bf00      	nop
200022f4:	5c001000 	.word	0x5c001000

200022f8 <HAL_DBGMCU_DisableDBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_DisableDBGStandbyMode(void)
{
200022f8:	b480      	push	{r7}
200022fa:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
200022fc:	4b05      	ldr	r3, [pc, #20]	; (20002314 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
200022fe:	685b      	ldr	r3, [r3, #4]
20002300:	4a04      	ldr	r2, [pc, #16]	; (20002314 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
20002302:	f023 0304 	bic.w	r3, r3, #4
20002306:	6053      	str	r3, [r2, #4]
}
20002308:	bf00      	nop
2000230a:	46bd      	mov	sp, r7
2000230c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002310:	4770      	bx	lr
20002312:	bf00      	nop
20002314:	5c001000 	.word	0x5c001000

20002318 <HAL_EnableDomain3DBGStopMode>:
/**
  * @brief  Enable the Debug Module during Domain3/SRDomain STOP mode
  * @retval None
  */
void HAL_EnableDomain3DBGStopMode(void)
{
20002318:	b480      	push	{r7}
2000231a:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD3);
2000231c:	4b05      	ldr	r3, [pc, #20]	; (20002334 <HAL_EnableDomain3DBGStopMode+0x1c>)
2000231e:	685b      	ldr	r3, [r3, #4]
20002320:	4a04      	ldr	r2, [pc, #16]	; (20002334 <HAL_EnableDomain3DBGStopMode+0x1c>)
20002322:	f043 0380 	orr.w	r3, r3, #128	; 0x80
20002326:	6053      	str	r3, [r2, #4]
}
20002328:	bf00      	nop
2000232a:	46bd      	mov	sp, r7
2000232c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002330:	4770      	bx	lr
20002332:	bf00      	nop
20002334:	5c001000 	.word	0x5c001000

20002338 <HAL_DisableDomain3DBGStopMode>:
/**
  * @brief  Disable the Debug Module during Domain3/SRDomain STOP mode
  * @retval None
  */
void HAL_DisableDomain3DBGStopMode(void)
{
20002338:	b480      	push	{r7}
2000233a:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD3);
2000233c:	4b05      	ldr	r3, [pc, #20]	; (20002354 <HAL_DisableDomain3DBGStopMode+0x1c>)
2000233e:	685b      	ldr	r3, [r3, #4]
20002340:	4a04      	ldr	r2, [pc, #16]	; (20002354 <HAL_DisableDomain3DBGStopMode+0x1c>)
20002342:	f023 0380 	bic.w	r3, r3, #128	; 0x80
20002346:	6053      	str	r3, [r2, #4]
}
20002348:	bf00      	nop
2000234a:	46bd      	mov	sp, r7
2000234c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002350:	4770      	bx	lr
20002352:	bf00      	nop
20002354:	5c001000 	.word	0x5c001000

20002358 <HAL_EnableDomain3DBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during Domain3/SRDomain STANDBY mode
  * @retval None
  */
void HAL_EnableDomain3DBGStandbyMode(void)
{
20002358:	b480      	push	{r7}
2000235a:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD3);
2000235c:	4b05      	ldr	r3, [pc, #20]	; (20002374 <HAL_EnableDomain3DBGStandbyMode+0x1c>)
2000235e:	685b      	ldr	r3, [r3, #4]
20002360:	4a04      	ldr	r2, [pc, #16]	; (20002374 <HAL_EnableDomain3DBGStandbyMode+0x1c>)
20002362:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20002366:	6053      	str	r3, [r2, #4]
}
20002368:	bf00      	nop
2000236a:	46bd      	mov	sp, r7
2000236c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002370:	4770      	bx	lr
20002372:	bf00      	nop
20002374:	5c001000 	.word	0x5c001000

20002378 <HAL_DisableDomain3DBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during Domain3/SRDomain STANDBY mode
  * @retval None
  */
void HAL_DisableDomain3DBGStandbyMode(void)
{
20002378:	b480      	push	{r7}
2000237a:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD3);
2000237c:	4b05      	ldr	r3, [pc, #20]	; (20002394 <HAL_DisableDomain3DBGStandbyMode+0x1c>)
2000237e:	685b      	ldr	r3, [r3, #4]
20002380:	4a04      	ldr	r2, [pc, #16]	; (20002394 <HAL_DisableDomain3DBGStandbyMode+0x1c>)
20002382:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20002386:	6053      	str	r3, [r2, #4]
}
20002388:	bf00      	nop
2000238a:	46bd      	mov	sp, r7
2000238c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002390:	4770      	bx	lr
20002392:	bf00      	nop
20002394:	5c001000 	.word	0x5c001000

20002398 <HAL_SetFMCMemorySwappingConfig>:
  * @param  BankMapConfig: Defines the FMC Bank mapping configuration. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
  * @retval HAL state
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
20002398:	b580      	push	{r7, lr}
2000239a:	b082      	sub	sp, #8
2000239c:	af00      	add	r7, sp, #0
2000239e:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
200023a0:	687b      	ldr	r3, [r7, #4]
200023a2:	2b00      	cmp	r3, #0
200023a4:	d00c      	beq.n	200023c0 <HAL_SetFMCMemorySwappingConfig+0x28>
200023a6:	687b      	ldr	r3, [r7, #4]
200023a8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
200023ac:	d008      	beq.n	200023c0 <HAL_SetFMCMemorySwappingConfig+0x28>
200023ae:	687b      	ldr	r3, [r7, #4]
200023b0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200023b4:	d004      	beq.n	200023c0 <HAL_SetFMCMemorySwappingConfig+0x28>
200023b6:	f44f 6181 	mov.w	r1, #1032	; 0x408
200023ba:	4807      	ldr	r0, [pc, #28]	; (200023d8 <HAL_SetFMCMemorySwappingConfig+0x40>)
200023bc:	f7fe fa9a 	bl	200008f4 <assert_failed>
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
200023c0:	4b06      	ldr	r3, [pc, #24]	; (200023dc <HAL_SetFMCMemorySwappingConfig+0x44>)
200023c2:	681b      	ldr	r3, [r3, #0]
200023c4:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
200023c8:	4904      	ldr	r1, [pc, #16]	; (200023dc <HAL_SetFMCMemorySwappingConfig+0x44>)
200023ca:	687b      	ldr	r3, [r7, #4]
200023cc:	4313      	orrs	r3, r2
200023ce:	600b      	str	r3, [r1, #0]
}
200023d0:	bf00      	nop
200023d2:	3708      	adds	r7, #8
200023d4:	46bd      	mov	sp, r7
200023d6:	bd80      	pop	{r7, pc}
200023d8:	2001bf64 	.word	0x2001bf64
200023dc:	52004000 	.word	0x52004000

200023e0 <HAL_GetFMCMemorySwappingConfig>:
  * @brief  Get FMC Bank mapping mode.
  * @retval The FMC Bank mapping mode. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
*/
uint32_t HAL_GetFMCMemorySwappingConfig(void)
{
200023e0:	b480      	push	{r7}
200023e2:	af00      	add	r7, sp, #0
  return READ_BIT(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP);
200023e4:	4b04      	ldr	r3, [pc, #16]	; (200023f8 <HAL_GetFMCMemorySwappingConfig+0x18>)
200023e6:	681b      	ldr	r3, [r3, #0]
200023e8:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
}
200023ec:	4618      	mov	r0, r3
200023ee:	46bd      	mov	sp, r7
200023f0:	f85d 7b04 	ldr.w	r7, [sp], #4
200023f4:	4770      	bx	lr
200023f6:	bf00      	nop
200023f8:	52004000 	.word	0x52004000

200023fc <HAL_EXTI_EdgeConfig>:
  *   @arg EXTI_RISING_EDGE : Configurable line, with Rising edge trigger detection
  *   @arg EXTI_FALLING_EDGE: Configurable line, with Falling edge trigger detection
  * @retval None
  */
void HAL_EXTI_EdgeConfig(uint32_t EXTI_Line , uint32_t EXTI_Edge )
{
200023fc:	b580      	push	{r7, lr}
200023fe:	b082      	sub	sp, #8
20002400:	af00      	add	r7, sp, #0
20002402:	6078      	str	r0, [r7, #4]
20002404:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));
20002406:	687b      	ldr	r3, [r7, #4]
20002408:	2b00      	cmp	r3, #0
2000240a:	d04f      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
2000240c:	687b      	ldr	r3, [r7, #4]
2000240e:	2b01      	cmp	r3, #1
20002410:	d04c      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002412:	687b      	ldr	r3, [r7, #4]
20002414:	2b02      	cmp	r3, #2
20002416:	d049      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002418:	687b      	ldr	r3, [r7, #4]
2000241a:	2b03      	cmp	r3, #3
2000241c:	d046      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
2000241e:	687b      	ldr	r3, [r7, #4]
20002420:	2b04      	cmp	r3, #4
20002422:	d043      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002424:	687b      	ldr	r3, [r7, #4]
20002426:	2b05      	cmp	r3, #5
20002428:	d040      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
2000242a:	687b      	ldr	r3, [r7, #4]
2000242c:	2b06      	cmp	r3, #6
2000242e:	d03d      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002430:	687b      	ldr	r3, [r7, #4]
20002432:	2b07      	cmp	r3, #7
20002434:	d03a      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002436:	687b      	ldr	r3, [r7, #4]
20002438:	2b08      	cmp	r3, #8
2000243a:	d037      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
2000243c:	687b      	ldr	r3, [r7, #4]
2000243e:	2b09      	cmp	r3, #9
20002440:	d034      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002442:	687b      	ldr	r3, [r7, #4]
20002444:	2b0a      	cmp	r3, #10
20002446:	d031      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002448:	687b      	ldr	r3, [r7, #4]
2000244a:	2b0b      	cmp	r3, #11
2000244c:	d02e      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
2000244e:	687b      	ldr	r3, [r7, #4]
20002450:	2b0c      	cmp	r3, #12
20002452:	d02b      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002454:	687b      	ldr	r3, [r7, #4]
20002456:	2b0d      	cmp	r3, #13
20002458:	d028      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
2000245a:	687b      	ldr	r3, [r7, #4]
2000245c:	2b0e      	cmp	r3, #14
2000245e:	d025      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002460:	687b      	ldr	r3, [r7, #4]
20002462:	2b0f      	cmp	r3, #15
20002464:	d022      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002466:	687b      	ldr	r3, [r7, #4]
20002468:	2b10      	cmp	r3, #16
2000246a:	d01f      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
2000246c:	687b      	ldr	r3, [r7, #4]
2000246e:	2b11      	cmp	r3, #17
20002470:	d01c      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002472:	687b      	ldr	r3, [r7, #4]
20002474:	2b12      	cmp	r3, #18
20002476:	d019      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002478:	687b      	ldr	r3, [r7, #4]
2000247a:	2b13      	cmp	r3, #19
2000247c:	d016      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
2000247e:	687b      	ldr	r3, [r7, #4]
20002480:	2b14      	cmp	r3, #20
20002482:	d013      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002484:	687b      	ldr	r3, [r7, #4]
20002486:	2b15      	cmp	r3, #21
20002488:	d010      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
2000248a:	687b      	ldr	r3, [r7, #4]
2000248c:	2b31      	cmp	r3, #49	; 0x31
2000248e:	d00d      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002490:	687b      	ldr	r3, [r7, #4]
20002492:	2b33      	cmp	r3, #51	; 0x33
20002494:	d00a      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
20002496:	687b      	ldr	r3, [r7, #4]
20002498:	2b55      	cmp	r3, #85	; 0x55
2000249a:	d007      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
2000249c:	687b      	ldr	r3, [r7, #4]
2000249e:	2b56      	cmp	r3, #86	; 0x56
200024a0:	d004      	beq.n	200024ac <HAL_EXTI_EdgeConfig+0xb0>
200024a2:	f240 4125 	movw	r1, #1061	; 0x425
200024a6:	4837      	ldr	r0, [pc, #220]	; (20002584 <HAL_EXTI_EdgeConfig+0x188>)
200024a8:	f7fe fa24 	bl	200008f4 <assert_failed>
  assert_param(IS_EXTI_EDGE_LINE(EXTI_Edge));
200024ac:	683b      	ldr	r3, [r7, #0]
200024ae:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
200024b2:	d008      	beq.n	200024c6 <HAL_EXTI_EdgeConfig+0xca>
200024b4:	683b      	ldr	r3, [r7, #0]
200024b6:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
200024ba:	d004      	beq.n	200024c6 <HAL_EXTI_EdgeConfig+0xca>
200024bc:	f240 4126 	movw	r1, #1062	; 0x426
200024c0:	4830      	ldr	r0, [pc, #192]	; (20002584 <HAL_EXTI_EdgeConfig+0x188>)
200024c2:	f7fe fa17 	bl	200008f4 <assert_failed>

  /* Clear Rising Falling edge configuration */
  CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
200024c6:	687b      	ldr	r3, [r7, #4]
200024c8:	095b      	lsrs	r3, r3, #5
200024ca:	015a      	lsls	r2, r3, #5
200024cc:	4b2e      	ldr	r3, [pc, #184]	; (20002588 <HAL_EXTI_EdgeConfig+0x18c>)
200024ce:	4413      	add	r3, r2
200024d0:	6819      	ldr	r1, [r3, #0]
200024d2:	687b      	ldr	r3, [r7, #4]
200024d4:	f003 031f 	and.w	r3, r3, #31
200024d8:	2201      	movs	r2, #1
200024da:	fa02 f303 	lsl.w	r3, r2, r3
200024de:	43da      	mvns	r2, r3
200024e0:	687b      	ldr	r3, [r7, #4]
200024e2:	095b      	lsrs	r3, r3, #5
200024e4:	0158      	lsls	r0, r3, #5
200024e6:	4b28      	ldr	r3, [pc, #160]	; (20002588 <HAL_EXTI_EdgeConfig+0x18c>)
200024e8:	4403      	add	r3, r0
200024ea:	4618      	mov	r0, r3
200024ec:	ea01 0302 	and.w	r3, r1, r2
200024f0:	6003      	str	r3, [r0, #0]
  CLEAR_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
200024f2:	687b      	ldr	r3, [r7, #4]
200024f4:	095b      	lsrs	r3, r3, #5
200024f6:	f103 7330 	add.w	r3, r3, #46137344	; 0x2c00000
200024fa:	015b      	lsls	r3, r3, #5
200024fc:	681a      	ldr	r2, [r3, #0]
200024fe:	687b      	ldr	r3, [r7, #4]
20002500:	f003 031f 	and.w	r3, r3, #31
20002504:	2101      	movs	r1, #1
20002506:	fa01 f303 	lsl.w	r3, r1, r3
2000250a:	43db      	mvns	r3, r3
2000250c:	6879      	ldr	r1, [r7, #4]
2000250e:	0949      	lsrs	r1, r1, #5
20002510:	f101 7130 	add.w	r1, r1, #46137344	; 0x2c00000
20002514:	0149      	lsls	r1, r1, #5
20002516:	4013      	ands	r3, r2
20002518:	600b      	str	r3, [r1, #0]

  if( (EXTI_Edge & EXTI_RISING_EDGE) == EXTI_RISING_EDGE)
2000251a:	683b      	ldr	r3, [r7, #0]
2000251c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
20002520:	2b00      	cmp	r3, #0
20002522:	d012      	beq.n	2000254a <HAL_EXTI_EdgeConfig+0x14e>
  {
   SET_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
20002524:	687b      	ldr	r3, [r7, #4]
20002526:	095b      	lsrs	r3, r3, #5
20002528:	f103 7330 	add.w	r3, r3, #46137344	; 0x2c00000
2000252c:	015b      	lsls	r3, r3, #5
2000252e:	681a      	ldr	r2, [r3, #0]
20002530:	687b      	ldr	r3, [r7, #4]
20002532:	f003 031f 	and.w	r3, r3, #31
20002536:	2101      	movs	r1, #1
20002538:	fa01 f303 	lsl.w	r3, r1, r3
2000253c:	6879      	ldr	r1, [r7, #4]
2000253e:	0949      	lsrs	r1, r1, #5
20002540:	f101 7130 	add.w	r1, r1, #46137344	; 0x2c00000
20002544:	0149      	lsls	r1, r1, #5
20002546:	4313      	orrs	r3, r2
20002548:	600b      	str	r3, [r1, #0]
  }
  if( (EXTI_Edge & EXTI_FALLING_EDGE) == EXTI_FALLING_EDGE)
2000254a:	683b      	ldr	r3, [r7, #0]
2000254c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
20002550:	2b00      	cmp	r3, #0
20002552:	d013      	beq.n	2000257c <HAL_EXTI_EdgeConfig+0x180>
  {
   SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
20002554:	687b      	ldr	r3, [r7, #4]
20002556:	095b      	lsrs	r3, r3, #5
20002558:	015a      	lsls	r2, r3, #5
2000255a:	4b0b      	ldr	r3, [pc, #44]	; (20002588 <HAL_EXTI_EdgeConfig+0x18c>)
2000255c:	4413      	add	r3, r2
2000255e:	6819      	ldr	r1, [r3, #0]
20002560:	687b      	ldr	r3, [r7, #4]
20002562:	f003 031f 	and.w	r3, r3, #31
20002566:	2201      	movs	r2, #1
20002568:	409a      	lsls	r2, r3
2000256a:	687b      	ldr	r3, [r7, #4]
2000256c:	095b      	lsrs	r3, r3, #5
2000256e:	0158      	lsls	r0, r3, #5
20002570:	4b05      	ldr	r3, [pc, #20]	; (20002588 <HAL_EXTI_EdgeConfig+0x18c>)
20002572:	4403      	add	r3, r0
20002574:	4618      	mov	r0, r3
20002576:	ea41 0302 	orr.w	r3, r1, r2
2000257a:	6003      	str	r3, [r0, #0]
  }
}
2000257c:	bf00      	nop
2000257e:	3708      	adds	r7, #8
20002580:	46bd      	mov	sp, r7
20002582:	bd80      	pop	{r7, pc}
20002584:	2001bf64 	.word	0x2001bf64
20002588:	58000004 	.word	0x58000004

2000258c <HAL_EXTI_GenerateSWInterrupt>:
  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,
  *          (EXTI_LINE0..EXTI_LINE21),EXTI_LINE49,EXTI_LINE51,EXTI_LINE82,EXTI_LINE84,EXTI_LINE85 and EXTI_LINE86.
  * @retval None
  */
void HAL_EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
2000258c:	b580      	push	{r7, lr}
2000258e:	b082      	sub	sp, #8
20002590:	af00      	add	r7, sp, #0
20002592:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));
20002594:	687b      	ldr	r3, [r7, #4]
20002596:	2b00      	cmp	r3, #0
20002598:	d04f      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
2000259a:	687b      	ldr	r3, [r7, #4]
2000259c:	2b01      	cmp	r3, #1
2000259e:	d04c      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025a0:	687b      	ldr	r3, [r7, #4]
200025a2:	2b02      	cmp	r3, #2
200025a4:	d049      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025a6:	687b      	ldr	r3, [r7, #4]
200025a8:	2b03      	cmp	r3, #3
200025aa:	d046      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025ac:	687b      	ldr	r3, [r7, #4]
200025ae:	2b04      	cmp	r3, #4
200025b0:	d043      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025b2:	687b      	ldr	r3, [r7, #4]
200025b4:	2b05      	cmp	r3, #5
200025b6:	d040      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025b8:	687b      	ldr	r3, [r7, #4]
200025ba:	2b06      	cmp	r3, #6
200025bc:	d03d      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025be:	687b      	ldr	r3, [r7, #4]
200025c0:	2b07      	cmp	r3, #7
200025c2:	d03a      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025c4:	687b      	ldr	r3, [r7, #4]
200025c6:	2b08      	cmp	r3, #8
200025c8:	d037      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025ca:	687b      	ldr	r3, [r7, #4]
200025cc:	2b09      	cmp	r3, #9
200025ce:	d034      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025d0:	687b      	ldr	r3, [r7, #4]
200025d2:	2b0a      	cmp	r3, #10
200025d4:	d031      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025d6:	687b      	ldr	r3, [r7, #4]
200025d8:	2b0b      	cmp	r3, #11
200025da:	d02e      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025dc:	687b      	ldr	r3, [r7, #4]
200025de:	2b0c      	cmp	r3, #12
200025e0:	d02b      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025e2:	687b      	ldr	r3, [r7, #4]
200025e4:	2b0d      	cmp	r3, #13
200025e6:	d028      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025e8:	687b      	ldr	r3, [r7, #4]
200025ea:	2b0e      	cmp	r3, #14
200025ec:	d025      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025ee:	687b      	ldr	r3, [r7, #4]
200025f0:	2b0f      	cmp	r3, #15
200025f2:	d022      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025f4:	687b      	ldr	r3, [r7, #4]
200025f6:	2b10      	cmp	r3, #16
200025f8:	d01f      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
200025fa:	687b      	ldr	r3, [r7, #4]
200025fc:	2b11      	cmp	r3, #17
200025fe:	d01c      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
20002600:	687b      	ldr	r3, [r7, #4]
20002602:	2b12      	cmp	r3, #18
20002604:	d019      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
20002606:	687b      	ldr	r3, [r7, #4]
20002608:	2b13      	cmp	r3, #19
2000260a:	d016      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
2000260c:	687b      	ldr	r3, [r7, #4]
2000260e:	2b14      	cmp	r3, #20
20002610:	d013      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
20002612:	687b      	ldr	r3, [r7, #4]
20002614:	2b15      	cmp	r3, #21
20002616:	d010      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
20002618:	687b      	ldr	r3, [r7, #4]
2000261a:	2b31      	cmp	r3, #49	; 0x31
2000261c:	d00d      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
2000261e:	687b      	ldr	r3, [r7, #4]
20002620:	2b33      	cmp	r3, #51	; 0x33
20002622:	d00a      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
20002624:	687b      	ldr	r3, [r7, #4]
20002626:	2b55      	cmp	r3, #85	; 0x55
20002628:	d007      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
2000262a:	687b      	ldr	r3, [r7, #4]
2000262c:	2b56      	cmp	r3, #86	; 0x56
2000262e:	d004      	beq.n	2000263a <HAL_EXTI_GenerateSWInterrupt+0xae>
20002630:	f240 413f 	movw	r1, #1087	; 0x43f
20002634:	480d      	ldr	r0, [pc, #52]	; (2000266c <HAL_EXTI_GenerateSWInterrupt+0xe0>)
20002636:	f7fe f95d 	bl	200008f4 <assert_failed>

  SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
2000263a:	687b      	ldr	r3, [r7, #4]
2000263c:	095b      	lsrs	r3, r3, #5
2000263e:	015a      	lsls	r2, r3, #5
20002640:	4b0b      	ldr	r3, [pc, #44]	; (20002670 <HAL_EXTI_GenerateSWInterrupt+0xe4>)
20002642:	4413      	add	r3, r2
20002644:	6819      	ldr	r1, [r3, #0]
20002646:	687b      	ldr	r3, [r7, #4]
20002648:	f003 031f 	and.w	r3, r3, #31
2000264c:	2201      	movs	r2, #1
2000264e:	409a      	lsls	r2, r3
20002650:	687b      	ldr	r3, [r7, #4]
20002652:	095b      	lsrs	r3, r3, #5
20002654:	0158      	lsls	r0, r3, #5
20002656:	4b06      	ldr	r3, [pc, #24]	; (20002670 <HAL_EXTI_GenerateSWInterrupt+0xe4>)
20002658:	4403      	add	r3, r0
2000265a:	4618      	mov	r0, r3
2000265c:	ea41 0302 	orr.w	r3, r1, r2
20002660:	6003      	str	r3, [r0, #0]
}
20002662:	bf00      	nop
20002664:	3708      	adds	r7, #8
20002666:	46bd      	mov	sp, r7
20002668:	bd80      	pop	{r7, pc}
2000266a:	bf00      	nop
2000266c:	2001bf64 	.word	0x2001bf64
20002670:	58000008 	.word	0x58000008

20002674 <HAL_EXTI_D1_ClearFlag>:
  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,
  *         (EXTI_LINE0....EXTI_LINE87)excluding :line45, line81,line83 which are reserved
  * @retval None
  */
void HAL_EXTI_D1_ClearFlag(uint32_t EXTI_Line)
{
20002674:	b580      	push	{r7, lr}
20002676:	b082      	sub	sp, #8
20002678:	af00      	add	r7, sp, #0
2000267a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
 assert_param(IS_EXTI_D1_LINE(EXTI_Line));
2000267c:	687b      	ldr	r3, [r7, #4]
2000267e:	2b00      	cmp	r3, #0
20002680:	f000 8113 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002684:	687b      	ldr	r3, [r7, #4]
20002686:	2b01      	cmp	r3, #1
20002688:	f000 810f 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000268c:	687b      	ldr	r3, [r7, #4]
2000268e:	2b02      	cmp	r3, #2
20002690:	f000 810b 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002694:	687b      	ldr	r3, [r7, #4]
20002696:	2b03      	cmp	r3, #3
20002698:	f000 8107 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000269c:	687b      	ldr	r3, [r7, #4]
2000269e:	2b04      	cmp	r3, #4
200026a0:	f000 8103 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026a4:	687b      	ldr	r3, [r7, #4]
200026a6:	2b05      	cmp	r3, #5
200026a8:	f000 80ff 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026ac:	687b      	ldr	r3, [r7, #4]
200026ae:	2b06      	cmp	r3, #6
200026b0:	f000 80fb 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026b4:	687b      	ldr	r3, [r7, #4]
200026b6:	2b07      	cmp	r3, #7
200026b8:	f000 80f7 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026bc:	687b      	ldr	r3, [r7, #4]
200026be:	2b08      	cmp	r3, #8
200026c0:	f000 80f3 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026c4:	687b      	ldr	r3, [r7, #4]
200026c6:	2b09      	cmp	r3, #9
200026c8:	f000 80ef 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026cc:	687b      	ldr	r3, [r7, #4]
200026ce:	2b0a      	cmp	r3, #10
200026d0:	f000 80eb 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026d4:	687b      	ldr	r3, [r7, #4]
200026d6:	2b0b      	cmp	r3, #11
200026d8:	f000 80e7 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026dc:	687b      	ldr	r3, [r7, #4]
200026de:	2b0c      	cmp	r3, #12
200026e0:	f000 80e3 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026e4:	687b      	ldr	r3, [r7, #4]
200026e6:	2b0d      	cmp	r3, #13
200026e8:	f000 80df 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026ec:	687b      	ldr	r3, [r7, #4]
200026ee:	2b0e      	cmp	r3, #14
200026f0:	f000 80db 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026f4:	687b      	ldr	r3, [r7, #4]
200026f6:	2b0f      	cmp	r3, #15
200026f8:	f000 80d7 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200026fc:	687b      	ldr	r3, [r7, #4]
200026fe:	2b10      	cmp	r3, #16
20002700:	f000 80d3 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002704:	687b      	ldr	r3, [r7, #4]
20002706:	2b11      	cmp	r3, #17
20002708:	f000 80cf 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000270c:	687b      	ldr	r3, [r7, #4]
2000270e:	2b12      	cmp	r3, #18
20002710:	f000 80cb 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002714:	687b      	ldr	r3, [r7, #4]
20002716:	2b13      	cmp	r3, #19
20002718:	f000 80c7 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000271c:	687b      	ldr	r3, [r7, #4]
2000271e:	2b14      	cmp	r3, #20
20002720:	f000 80c3 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002724:	687b      	ldr	r3, [r7, #4]
20002726:	2b15      	cmp	r3, #21
20002728:	f000 80bf 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000272c:	687b      	ldr	r3, [r7, #4]
2000272e:	2b16      	cmp	r3, #22
20002730:	f000 80bb 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002734:	687b      	ldr	r3, [r7, #4]
20002736:	2b17      	cmp	r3, #23
20002738:	f000 80b7 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000273c:	687b      	ldr	r3, [r7, #4]
2000273e:	2b18      	cmp	r3, #24
20002740:	f000 80b3 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002744:	687b      	ldr	r3, [r7, #4]
20002746:	2b19      	cmp	r3, #25
20002748:	f000 80af 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000274c:	687b      	ldr	r3, [r7, #4]
2000274e:	2b1a      	cmp	r3, #26
20002750:	f000 80ab 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002754:	687b      	ldr	r3, [r7, #4]
20002756:	2b1b      	cmp	r3, #27
20002758:	f000 80a7 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000275c:	687b      	ldr	r3, [r7, #4]
2000275e:	2b1c      	cmp	r3, #28
20002760:	f000 80a3 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002764:	687b      	ldr	r3, [r7, #4]
20002766:	2b1d      	cmp	r3, #29
20002768:	f000 809f 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000276c:	687b      	ldr	r3, [r7, #4]
2000276e:	2b1e      	cmp	r3, #30
20002770:	f000 809b 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002774:	687b      	ldr	r3, [r7, #4]
20002776:	2b1f      	cmp	r3, #31
20002778:	f000 8097 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000277c:	687b      	ldr	r3, [r7, #4]
2000277e:	2b20      	cmp	r3, #32
20002780:	f000 8093 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002784:	687b      	ldr	r3, [r7, #4]
20002786:	2b21      	cmp	r3, #33	; 0x21
20002788:	f000 808f 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000278c:	687b      	ldr	r3, [r7, #4]
2000278e:	2b22      	cmp	r3, #34	; 0x22
20002790:	f000 808b 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002794:	687b      	ldr	r3, [r7, #4]
20002796:	2b23      	cmp	r3, #35	; 0x23
20002798:	f000 8087 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000279c:	687b      	ldr	r3, [r7, #4]
2000279e:	2b24      	cmp	r3, #36	; 0x24
200027a0:	f000 8083 	beq.w	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027a4:	687b      	ldr	r3, [r7, #4]
200027a6:	2b25      	cmp	r3, #37	; 0x25
200027a8:	d07f      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027aa:	687b      	ldr	r3, [r7, #4]
200027ac:	2b26      	cmp	r3, #38	; 0x26
200027ae:	d07c      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027b0:	687b      	ldr	r3, [r7, #4]
200027b2:	2b27      	cmp	r3, #39	; 0x27
200027b4:	d079      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027b6:	687b      	ldr	r3, [r7, #4]
200027b8:	2b28      	cmp	r3, #40	; 0x28
200027ba:	d076      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027bc:	687b      	ldr	r3, [r7, #4]
200027be:	2b29      	cmp	r3, #41	; 0x29
200027c0:	d073      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027c2:	687b      	ldr	r3, [r7, #4]
200027c4:	2b2a      	cmp	r3, #42	; 0x2a
200027c6:	d070      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027c8:	687b      	ldr	r3, [r7, #4]
200027ca:	2b2b      	cmp	r3, #43	; 0x2b
200027cc:	d06d      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027ce:	687b      	ldr	r3, [r7, #4]
200027d0:	2b2c      	cmp	r3, #44	; 0x2c
200027d2:	d06a      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027d4:	687b      	ldr	r3, [r7, #4]
200027d6:	2b2f      	cmp	r3, #47	; 0x2f
200027d8:	d067      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027da:	687b      	ldr	r3, [r7, #4]
200027dc:	2b30      	cmp	r3, #48	; 0x30
200027de:	d064      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027e0:	687b      	ldr	r3, [r7, #4]
200027e2:	2b31      	cmp	r3, #49	; 0x31
200027e4:	d061      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027e6:	687b      	ldr	r3, [r7, #4]
200027e8:	2b32      	cmp	r3, #50	; 0x32
200027ea:	d05e      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027ec:	687b      	ldr	r3, [r7, #4]
200027ee:	2b33      	cmp	r3, #51	; 0x33
200027f0:	d05b      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027f2:	687b      	ldr	r3, [r7, #4]
200027f4:	2b34      	cmp	r3, #52	; 0x34
200027f6:	d058      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027f8:	687b      	ldr	r3, [r7, #4]
200027fa:	2b35      	cmp	r3, #53	; 0x35
200027fc:	d055      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200027fe:	687b      	ldr	r3, [r7, #4]
20002800:	2b36      	cmp	r3, #54	; 0x36
20002802:	d052      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002804:	687b      	ldr	r3, [r7, #4]
20002806:	2b37      	cmp	r3, #55	; 0x37
20002808:	d04f      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000280a:	687b      	ldr	r3, [r7, #4]
2000280c:	2b38      	cmp	r3, #56	; 0x38
2000280e:	d04c      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002810:	687b      	ldr	r3, [r7, #4]
20002812:	2b39      	cmp	r3, #57	; 0x39
20002814:	d049      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002816:	687b      	ldr	r3, [r7, #4]
20002818:	2b3a      	cmp	r3, #58	; 0x3a
2000281a:	d046      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000281c:	687b      	ldr	r3, [r7, #4]
2000281e:	2b3b      	cmp	r3, #59	; 0x3b
20002820:	d043      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002822:	687b      	ldr	r3, [r7, #4]
20002824:	2b3c      	cmp	r3, #60	; 0x3c
20002826:	d040      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002828:	687b      	ldr	r3, [r7, #4]
2000282a:	2b3d      	cmp	r3, #61	; 0x3d
2000282c:	d03d      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000282e:	687b      	ldr	r3, [r7, #4]
20002830:	2b3e      	cmp	r3, #62	; 0x3e
20002832:	d03a      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002834:	687b      	ldr	r3, [r7, #4]
20002836:	2b3f      	cmp	r3, #63	; 0x3f
20002838:	d037      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000283a:	687b      	ldr	r3, [r7, #4]
2000283c:	2b40      	cmp	r3, #64	; 0x40
2000283e:	d034      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002840:	687b      	ldr	r3, [r7, #4]
20002842:	2b41      	cmp	r3, #65	; 0x41
20002844:	d031      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002846:	687b      	ldr	r3, [r7, #4]
20002848:	2b42      	cmp	r3, #66	; 0x42
2000284a:	d02e      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000284c:	687b      	ldr	r3, [r7, #4]
2000284e:	2b43      	cmp	r3, #67	; 0x43
20002850:	d02b      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002852:	687b      	ldr	r3, [r7, #4]
20002854:	2b44      	cmp	r3, #68	; 0x44
20002856:	d028      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002858:	687b      	ldr	r3, [r7, #4]
2000285a:	2b45      	cmp	r3, #69	; 0x45
2000285c:	d025      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000285e:	687b      	ldr	r3, [r7, #4]
20002860:	2b46      	cmp	r3, #70	; 0x46
20002862:	d022      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002864:	687b      	ldr	r3, [r7, #4]
20002866:	2b47      	cmp	r3, #71	; 0x47
20002868:	d01f      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000286a:	687b      	ldr	r3, [r7, #4]
2000286c:	2b48      	cmp	r3, #72	; 0x48
2000286e:	d01c      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002870:	687b      	ldr	r3, [r7, #4]
20002872:	2b49      	cmp	r3, #73	; 0x49
20002874:	d019      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002876:	687b      	ldr	r3, [r7, #4]
20002878:	2b4a      	cmp	r3, #74	; 0x4a
2000287a:	d016      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000287c:	687b      	ldr	r3, [r7, #4]
2000287e:	2b4b      	cmp	r3, #75	; 0x4b
20002880:	d013      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002882:	687b      	ldr	r3, [r7, #4]
20002884:	2b4c      	cmp	r3, #76	; 0x4c
20002886:	d010      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002888:	687b      	ldr	r3, [r7, #4]
2000288a:	2b55      	cmp	r3, #85	; 0x55
2000288c:	d00d      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000288e:	687b      	ldr	r3, [r7, #4]
20002890:	2b56      	cmp	r3, #86	; 0x56
20002892:	d00a      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
20002894:	687b      	ldr	r3, [r7, #4]
20002896:	2b57      	cmp	r3, #87	; 0x57
20002898:	d007      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
2000289a:	687b      	ldr	r3, [r7, #4]
2000289c:	2b58      	cmp	r3, #88	; 0x58
2000289e:	d004      	beq.n	200028aa <HAL_EXTI_D1_ClearFlag+0x236>
200028a0:	f240 414e 	movw	r1, #1102	; 0x44e
200028a4:	4809      	ldr	r0, [pc, #36]	; (200028cc <HAL_EXTI_D1_ClearFlag+0x258>)
200028a6:	f7fe f825 	bl	200008f4 <assert_failed>
 WRITE_REG(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->PR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
200028aa:	687b      	ldr	r3, [r7, #4]
200028ac:	f003 021f 	and.w	r2, r3, #31
200028b0:	687b      	ldr	r3, [r7, #4]
200028b2:	095b      	lsrs	r3, r3, #5
200028b4:	0119      	lsls	r1, r3, #4
200028b6:	4b06      	ldr	r3, [pc, #24]	; (200028d0 <HAL_EXTI_D1_ClearFlag+0x25c>)
200028b8:	440b      	add	r3, r1
200028ba:	4619      	mov	r1, r3
200028bc:	2301      	movs	r3, #1
200028be:	4093      	lsls	r3, r2
200028c0:	600b      	str	r3, [r1, #0]

}
200028c2:	bf00      	nop
200028c4:	3708      	adds	r7, #8
200028c6:	46bd      	mov	sp, r7
200028c8:	bd80      	pop	{r7, pc}
200028ca:	bf00      	nop
200028cc:	2001bf64 	.word	0x2001bf64
200028d0:	58000088 	.word	0x58000088

200028d4 <HAL_EXTI_D1_EventInputConfig>:
  * @param   EXTI_LineCmd controls (Enable/Disable) the EXTI line.

  * @retval None
  */
void HAL_EXTI_D1_EventInputConfig(uint32_t EXTI_Line , uint32_t EXTI_Mode,  uint32_t EXTI_LineCmd )
{
200028d4:	b580      	push	{r7, lr}
200028d6:	b084      	sub	sp, #16
200028d8:	af00      	add	r7, sp, #0
200028da:	60f8      	str	r0, [r7, #12]
200028dc:	60b9      	str	r1, [r7, #8]
200028de:	607a      	str	r2, [r7, #4]
  /* Check the parameter */
  assert_param(IS_EXTI_D1_LINE(EXTI_Line));
200028e0:	68fb      	ldr	r3, [r7, #12]
200028e2:	2b00      	cmp	r3, #0
200028e4:	f000 8113 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200028e8:	68fb      	ldr	r3, [r7, #12]
200028ea:	2b01      	cmp	r3, #1
200028ec:	f000 810f 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200028f0:	68fb      	ldr	r3, [r7, #12]
200028f2:	2b02      	cmp	r3, #2
200028f4:	f000 810b 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200028f8:	68fb      	ldr	r3, [r7, #12]
200028fa:	2b03      	cmp	r3, #3
200028fc:	f000 8107 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002900:	68fb      	ldr	r3, [r7, #12]
20002902:	2b04      	cmp	r3, #4
20002904:	f000 8103 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002908:	68fb      	ldr	r3, [r7, #12]
2000290a:	2b05      	cmp	r3, #5
2000290c:	f000 80ff 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002910:	68fb      	ldr	r3, [r7, #12]
20002912:	2b06      	cmp	r3, #6
20002914:	f000 80fb 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002918:	68fb      	ldr	r3, [r7, #12]
2000291a:	2b07      	cmp	r3, #7
2000291c:	f000 80f7 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002920:	68fb      	ldr	r3, [r7, #12]
20002922:	2b08      	cmp	r3, #8
20002924:	f000 80f3 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002928:	68fb      	ldr	r3, [r7, #12]
2000292a:	2b09      	cmp	r3, #9
2000292c:	f000 80ef 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002930:	68fb      	ldr	r3, [r7, #12]
20002932:	2b0a      	cmp	r3, #10
20002934:	f000 80eb 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002938:	68fb      	ldr	r3, [r7, #12]
2000293a:	2b0b      	cmp	r3, #11
2000293c:	f000 80e7 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002940:	68fb      	ldr	r3, [r7, #12]
20002942:	2b0c      	cmp	r3, #12
20002944:	f000 80e3 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002948:	68fb      	ldr	r3, [r7, #12]
2000294a:	2b0d      	cmp	r3, #13
2000294c:	f000 80df 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002950:	68fb      	ldr	r3, [r7, #12]
20002952:	2b0e      	cmp	r3, #14
20002954:	f000 80db 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002958:	68fb      	ldr	r3, [r7, #12]
2000295a:	2b0f      	cmp	r3, #15
2000295c:	f000 80d7 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002960:	68fb      	ldr	r3, [r7, #12]
20002962:	2b10      	cmp	r3, #16
20002964:	f000 80d3 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002968:	68fb      	ldr	r3, [r7, #12]
2000296a:	2b11      	cmp	r3, #17
2000296c:	f000 80cf 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002970:	68fb      	ldr	r3, [r7, #12]
20002972:	2b12      	cmp	r3, #18
20002974:	f000 80cb 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002978:	68fb      	ldr	r3, [r7, #12]
2000297a:	2b13      	cmp	r3, #19
2000297c:	f000 80c7 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002980:	68fb      	ldr	r3, [r7, #12]
20002982:	2b14      	cmp	r3, #20
20002984:	f000 80c3 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002988:	68fb      	ldr	r3, [r7, #12]
2000298a:	2b15      	cmp	r3, #21
2000298c:	f000 80bf 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002990:	68fb      	ldr	r3, [r7, #12]
20002992:	2b16      	cmp	r3, #22
20002994:	f000 80bb 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002998:	68fb      	ldr	r3, [r7, #12]
2000299a:	2b17      	cmp	r3, #23
2000299c:	f000 80b7 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029a0:	68fb      	ldr	r3, [r7, #12]
200029a2:	2b18      	cmp	r3, #24
200029a4:	f000 80b3 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029a8:	68fb      	ldr	r3, [r7, #12]
200029aa:	2b19      	cmp	r3, #25
200029ac:	f000 80af 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029b0:	68fb      	ldr	r3, [r7, #12]
200029b2:	2b1a      	cmp	r3, #26
200029b4:	f000 80ab 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029b8:	68fb      	ldr	r3, [r7, #12]
200029ba:	2b1b      	cmp	r3, #27
200029bc:	f000 80a7 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029c0:	68fb      	ldr	r3, [r7, #12]
200029c2:	2b1c      	cmp	r3, #28
200029c4:	f000 80a3 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029c8:	68fb      	ldr	r3, [r7, #12]
200029ca:	2b1d      	cmp	r3, #29
200029cc:	f000 809f 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029d0:	68fb      	ldr	r3, [r7, #12]
200029d2:	2b1e      	cmp	r3, #30
200029d4:	f000 809b 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029d8:	68fb      	ldr	r3, [r7, #12]
200029da:	2b1f      	cmp	r3, #31
200029dc:	f000 8097 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029e0:	68fb      	ldr	r3, [r7, #12]
200029e2:	2b20      	cmp	r3, #32
200029e4:	f000 8093 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029e8:	68fb      	ldr	r3, [r7, #12]
200029ea:	2b21      	cmp	r3, #33	; 0x21
200029ec:	f000 808f 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029f0:	68fb      	ldr	r3, [r7, #12]
200029f2:	2b22      	cmp	r3, #34	; 0x22
200029f4:	f000 808b 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
200029f8:	68fb      	ldr	r3, [r7, #12]
200029fa:	2b23      	cmp	r3, #35	; 0x23
200029fc:	f000 8087 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a00:	68fb      	ldr	r3, [r7, #12]
20002a02:	2b24      	cmp	r3, #36	; 0x24
20002a04:	f000 8083 	beq.w	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a08:	68fb      	ldr	r3, [r7, #12]
20002a0a:	2b25      	cmp	r3, #37	; 0x25
20002a0c:	d07f      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a0e:	68fb      	ldr	r3, [r7, #12]
20002a10:	2b26      	cmp	r3, #38	; 0x26
20002a12:	d07c      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a14:	68fb      	ldr	r3, [r7, #12]
20002a16:	2b27      	cmp	r3, #39	; 0x27
20002a18:	d079      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a1a:	68fb      	ldr	r3, [r7, #12]
20002a1c:	2b28      	cmp	r3, #40	; 0x28
20002a1e:	d076      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a20:	68fb      	ldr	r3, [r7, #12]
20002a22:	2b29      	cmp	r3, #41	; 0x29
20002a24:	d073      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a26:	68fb      	ldr	r3, [r7, #12]
20002a28:	2b2a      	cmp	r3, #42	; 0x2a
20002a2a:	d070      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a2c:	68fb      	ldr	r3, [r7, #12]
20002a2e:	2b2b      	cmp	r3, #43	; 0x2b
20002a30:	d06d      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a32:	68fb      	ldr	r3, [r7, #12]
20002a34:	2b2c      	cmp	r3, #44	; 0x2c
20002a36:	d06a      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a38:	68fb      	ldr	r3, [r7, #12]
20002a3a:	2b2f      	cmp	r3, #47	; 0x2f
20002a3c:	d067      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a3e:	68fb      	ldr	r3, [r7, #12]
20002a40:	2b30      	cmp	r3, #48	; 0x30
20002a42:	d064      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a44:	68fb      	ldr	r3, [r7, #12]
20002a46:	2b31      	cmp	r3, #49	; 0x31
20002a48:	d061      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a4a:	68fb      	ldr	r3, [r7, #12]
20002a4c:	2b32      	cmp	r3, #50	; 0x32
20002a4e:	d05e      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a50:	68fb      	ldr	r3, [r7, #12]
20002a52:	2b33      	cmp	r3, #51	; 0x33
20002a54:	d05b      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a56:	68fb      	ldr	r3, [r7, #12]
20002a58:	2b34      	cmp	r3, #52	; 0x34
20002a5a:	d058      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a5c:	68fb      	ldr	r3, [r7, #12]
20002a5e:	2b35      	cmp	r3, #53	; 0x35
20002a60:	d055      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a62:	68fb      	ldr	r3, [r7, #12]
20002a64:	2b36      	cmp	r3, #54	; 0x36
20002a66:	d052      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a68:	68fb      	ldr	r3, [r7, #12]
20002a6a:	2b37      	cmp	r3, #55	; 0x37
20002a6c:	d04f      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a6e:	68fb      	ldr	r3, [r7, #12]
20002a70:	2b38      	cmp	r3, #56	; 0x38
20002a72:	d04c      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a74:	68fb      	ldr	r3, [r7, #12]
20002a76:	2b39      	cmp	r3, #57	; 0x39
20002a78:	d049      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a7a:	68fb      	ldr	r3, [r7, #12]
20002a7c:	2b3a      	cmp	r3, #58	; 0x3a
20002a7e:	d046      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a80:	68fb      	ldr	r3, [r7, #12]
20002a82:	2b3b      	cmp	r3, #59	; 0x3b
20002a84:	d043      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a86:	68fb      	ldr	r3, [r7, #12]
20002a88:	2b3c      	cmp	r3, #60	; 0x3c
20002a8a:	d040      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a8c:	68fb      	ldr	r3, [r7, #12]
20002a8e:	2b3d      	cmp	r3, #61	; 0x3d
20002a90:	d03d      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a92:	68fb      	ldr	r3, [r7, #12]
20002a94:	2b3e      	cmp	r3, #62	; 0x3e
20002a96:	d03a      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a98:	68fb      	ldr	r3, [r7, #12]
20002a9a:	2b3f      	cmp	r3, #63	; 0x3f
20002a9c:	d037      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002a9e:	68fb      	ldr	r3, [r7, #12]
20002aa0:	2b40      	cmp	r3, #64	; 0x40
20002aa2:	d034      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002aa4:	68fb      	ldr	r3, [r7, #12]
20002aa6:	2b41      	cmp	r3, #65	; 0x41
20002aa8:	d031      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002aaa:	68fb      	ldr	r3, [r7, #12]
20002aac:	2b42      	cmp	r3, #66	; 0x42
20002aae:	d02e      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002ab0:	68fb      	ldr	r3, [r7, #12]
20002ab2:	2b43      	cmp	r3, #67	; 0x43
20002ab4:	d02b      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002ab6:	68fb      	ldr	r3, [r7, #12]
20002ab8:	2b44      	cmp	r3, #68	; 0x44
20002aba:	d028      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002abc:	68fb      	ldr	r3, [r7, #12]
20002abe:	2b45      	cmp	r3, #69	; 0x45
20002ac0:	d025      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002ac2:	68fb      	ldr	r3, [r7, #12]
20002ac4:	2b46      	cmp	r3, #70	; 0x46
20002ac6:	d022      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002ac8:	68fb      	ldr	r3, [r7, #12]
20002aca:	2b47      	cmp	r3, #71	; 0x47
20002acc:	d01f      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002ace:	68fb      	ldr	r3, [r7, #12]
20002ad0:	2b48      	cmp	r3, #72	; 0x48
20002ad2:	d01c      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002ad4:	68fb      	ldr	r3, [r7, #12]
20002ad6:	2b49      	cmp	r3, #73	; 0x49
20002ad8:	d019      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002ada:	68fb      	ldr	r3, [r7, #12]
20002adc:	2b4a      	cmp	r3, #74	; 0x4a
20002ade:	d016      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002ae0:	68fb      	ldr	r3, [r7, #12]
20002ae2:	2b4b      	cmp	r3, #75	; 0x4b
20002ae4:	d013      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002ae6:	68fb      	ldr	r3, [r7, #12]
20002ae8:	2b4c      	cmp	r3, #76	; 0x4c
20002aea:	d010      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002aec:	68fb      	ldr	r3, [r7, #12]
20002aee:	2b55      	cmp	r3, #85	; 0x55
20002af0:	d00d      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002af2:	68fb      	ldr	r3, [r7, #12]
20002af4:	2b56      	cmp	r3, #86	; 0x56
20002af6:	d00a      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002af8:	68fb      	ldr	r3, [r7, #12]
20002afa:	2b57      	cmp	r3, #87	; 0x57
20002afc:	d007      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002afe:	68fb      	ldr	r3, [r7, #12]
20002b00:	2b58      	cmp	r3, #88	; 0x58
20002b02:	d004      	beq.n	20002b0e <HAL_EXTI_D1_EventInputConfig+0x23a>
20002b04:	f240 4171 	movw	r1, #1137	; 0x471
20002b08:	483c      	ldr	r0, [pc, #240]	; (20002bfc <HAL_EXTI_D1_EventInputConfig+0x328>)
20002b0a:	f7fd fef3 	bl	200008f4 <assert_failed>
  assert_param(IS_EXTI_MODE_LINE(EXTI_Mode));
20002b0e:	68bb      	ldr	r3, [r7, #8]
20002b10:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20002b14:	d008      	beq.n	20002b28 <HAL_EXTI_D1_EventInputConfig+0x254>
20002b16:	68bb      	ldr	r3, [r7, #8]
20002b18:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20002b1c:	d004      	beq.n	20002b28 <HAL_EXTI_D1_EventInputConfig+0x254>
20002b1e:	f240 4172 	movw	r1, #1138	; 0x472
20002b22:	4836      	ldr	r0, [pc, #216]	; (20002bfc <HAL_EXTI_D1_EventInputConfig+0x328>)
20002b24:	f7fd fee6 	bl	200008f4 <assert_failed>

  if( (EXTI_Mode & EXTI_MODE_IT) == EXTI_MODE_IT)
20002b28:	68bb      	ldr	r3, [r7, #8]
20002b2a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20002b2e:	2b00      	cmp	r3, #0
20002b30:	d02d      	beq.n	20002b8e <HAL_EXTI_D1_EventInputConfig+0x2ba>
  {
     if( EXTI_LineCmd == 0UL)
20002b32:	687b      	ldr	r3, [r7, #4]
20002b34:	2b00      	cmp	r3, #0
20002b36:	d116      	bne.n	20002b66 <HAL_EXTI_D1_EventInputConfig+0x292>
     {
       /* Clear EXTI line configuration */
        CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
20002b38:	68fb      	ldr	r3, [r7, #12]
20002b3a:	095a      	lsrs	r2, r3, #5
20002b3c:	4b30      	ldr	r3, [pc, #192]	; (20002c00 <HAL_EXTI_D1_EventInputConfig+0x32c>)
20002b3e:	4413      	add	r3, r2
20002b40:	011b      	lsls	r3, r3, #4
20002b42:	6819      	ldr	r1, [r3, #0]
20002b44:	68fb      	ldr	r3, [r7, #12]
20002b46:	f003 031f 	and.w	r3, r3, #31
20002b4a:	2201      	movs	r2, #1
20002b4c:	fa02 f303 	lsl.w	r3, r2, r3
20002b50:	43da      	mvns	r2, r3
20002b52:	68fb      	ldr	r3, [r7, #12]
20002b54:	0958      	lsrs	r0, r3, #5
20002b56:	4b2a      	ldr	r3, [pc, #168]	; (20002c00 <HAL_EXTI_D1_EventInputConfig+0x32c>)
20002b58:	4403      	add	r3, r0
20002b5a:	011b      	lsls	r3, r3, #4
20002b5c:	4618      	mov	r0, r3
20002b5e:	ea01 0302 	and.w	r3, r1, r2
20002b62:	6003      	str	r3, [r0, #0]
20002b64:	e013      	b.n	20002b8e <HAL_EXTI_D1_EventInputConfig+0x2ba>
     }
     else
     {
        SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
20002b66:	68fb      	ldr	r3, [r7, #12]
20002b68:	095a      	lsrs	r2, r3, #5
20002b6a:	4b25      	ldr	r3, [pc, #148]	; (20002c00 <HAL_EXTI_D1_EventInputConfig+0x32c>)
20002b6c:	4413      	add	r3, r2
20002b6e:	011b      	lsls	r3, r3, #4
20002b70:	6819      	ldr	r1, [r3, #0]
20002b72:	68fb      	ldr	r3, [r7, #12]
20002b74:	f003 031f 	and.w	r3, r3, #31
20002b78:	2201      	movs	r2, #1
20002b7a:	409a      	lsls	r2, r3
20002b7c:	68fb      	ldr	r3, [r7, #12]
20002b7e:	0958      	lsrs	r0, r3, #5
20002b80:	4b1f      	ldr	r3, [pc, #124]	; (20002c00 <HAL_EXTI_D1_EventInputConfig+0x32c>)
20002b82:	4403      	add	r3, r0
20002b84:	011b      	lsls	r3, r3, #4
20002b86:	4618      	mov	r0, r3
20002b88:	ea41 0302 	orr.w	r3, r1, r2
20002b8c:	6003      	str	r3, [r0, #0]
     }
  }

  if( (EXTI_Mode & EXTI_MODE_EVT) == EXTI_MODE_EVT)
20002b8e:	68bb      	ldr	r3, [r7, #8]
20002b90:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20002b94:	2b00      	cmp	r3, #0
20002b96:	d02d      	beq.n	20002bf4 <HAL_EXTI_D1_EventInputConfig+0x320>
  {
    if( EXTI_LineCmd == 0UL)
20002b98:	687b      	ldr	r3, [r7, #4]
20002b9a:	2b00      	cmp	r3, #0
20002b9c:	d116      	bne.n	20002bcc <HAL_EXTI_D1_EventInputConfig+0x2f8>
    {
      /* Clear EXTI line configuration */
      CLEAR_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
20002b9e:	68fb      	ldr	r3, [r7, #12]
20002ba0:	095b      	lsrs	r3, r3, #5
20002ba2:	011a      	lsls	r2, r3, #4
20002ba4:	4b17      	ldr	r3, [pc, #92]	; (20002c04 <HAL_EXTI_D1_EventInputConfig+0x330>)
20002ba6:	4413      	add	r3, r2
20002ba8:	6819      	ldr	r1, [r3, #0]
20002baa:	68fb      	ldr	r3, [r7, #12]
20002bac:	f003 031f 	and.w	r3, r3, #31
20002bb0:	2201      	movs	r2, #1
20002bb2:	fa02 f303 	lsl.w	r3, r2, r3
20002bb6:	43da      	mvns	r2, r3
20002bb8:	68fb      	ldr	r3, [r7, #12]
20002bba:	095b      	lsrs	r3, r3, #5
20002bbc:	0118      	lsls	r0, r3, #4
20002bbe:	4b11      	ldr	r3, [pc, #68]	; (20002c04 <HAL_EXTI_D1_EventInputConfig+0x330>)
20002bc0:	4403      	add	r3, r0
20002bc2:	4618      	mov	r0, r3
20002bc4:	ea01 0302 	and.w	r3, r1, r2
20002bc8:	6003      	str	r3, [r0, #0]
    else
    {
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
    }
  }
}
20002bca:	e013      	b.n	20002bf4 <HAL_EXTI_D1_EventInputConfig+0x320>
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
20002bcc:	68fb      	ldr	r3, [r7, #12]
20002bce:	095b      	lsrs	r3, r3, #5
20002bd0:	011a      	lsls	r2, r3, #4
20002bd2:	4b0c      	ldr	r3, [pc, #48]	; (20002c04 <HAL_EXTI_D1_EventInputConfig+0x330>)
20002bd4:	4413      	add	r3, r2
20002bd6:	6819      	ldr	r1, [r3, #0]
20002bd8:	68fb      	ldr	r3, [r7, #12]
20002bda:	f003 031f 	and.w	r3, r3, #31
20002bde:	2201      	movs	r2, #1
20002be0:	409a      	lsls	r2, r3
20002be2:	68fb      	ldr	r3, [r7, #12]
20002be4:	095b      	lsrs	r3, r3, #5
20002be6:	0118      	lsls	r0, r3, #4
20002be8:	4b06      	ldr	r3, [pc, #24]	; (20002c04 <HAL_EXTI_D1_EventInputConfig+0x330>)
20002bea:	4403      	add	r3, r0
20002bec:	4618      	mov	r0, r3
20002bee:	ea41 0302 	orr.w	r3, r1, r2
20002bf2:	6003      	str	r3, [r0, #0]
}
20002bf4:	bf00      	nop
20002bf6:	3710      	adds	r7, #16
20002bf8:	46bd      	mov	sp, r7
20002bfa:	bd80      	pop	{r7, pc}
20002bfc:	2001bf64 	.word	0x2001bf64
20002c00:	05800008 	.word	0x05800008
20002c04:	58000084 	.word	0x58000084

20002c08 <HAL_EXTI_D3_EventInputConfig>:
  *   @arg LPTIM4_OUT_CLEAR : LPTIM4 out selected as D3 domain pendclear source
  *   @arg LPTIM5_OUT_CLEAR : LPTIM5 out selected as D3 domain pendclear source
  * @retval None
  */
void HAL_EXTI_D3_EventInputConfig(uint32_t EXTI_Line, uint32_t EXTI_LineCmd , uint32_t EXTI_ClearSrc  )
{
20002c08:	b580      	push	{r7, lr}
20002c0a:	b086      	sub	sp, #24
20002c0c:	af00      	add	r7, sp, #0
20002c0e:	60f8      	str	r0, [r7, #12]
20002c10:	60b9      	str	r1, [r7, #8]
20002c12:	607a      	str	r2, [r7, #4]
  __IO uint32_t *pRegv;

  /* Check the parameter */
  assert_param(IS_EXTI_D3_LINE(EXTI_Line));
20002c14:	68fb      	ldr	r3, [r7, #12]
20002c16:	2b00      	cmp	r3, #0
20002c18:	d058      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c1a:	68fb      	ldr	r3, [r7, #12]
20002c1c:	2b01      	cmp	r3, #1
20002c1e:	d055      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c20:	68fb      	ldr	r3, [r7, #12]
20002c22:	2b02      	cmp	r3, #2
20002c24:	d052      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c26:	68fb      	ldr	r3, [r7, #12]
20002c28:	2b03      	cmp	r3, #3
20002c2a:	d04f      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c2c:	68fb      	ldr	r3, [r7, #12]
20002c2e:	2b04      	cmp	r3, #4
20002c30:	d04c      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c32:	68fb      	ldr	r3, [r7, #12]
20002c34:	2b05      	cmp	r3, #5
20002c36:	d049      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c38:	68fb      	ldr	r3, [r7, #12]
20002c3a:	2b06      	cmp	r3, #6
20002c3c:	d046      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c3e:	68fb      	ldr	r3, [r7, #12]
20002c40:	2b07      	cmp	r3, #7
20002c42:	d043      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c44:	68fb      	ldr	r3, [r7, #12]
20002c46:	2b08      	cmp	r3, #8
20002c48:	d040      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c4a:	68fb      	ldr	r3, [r7, #12]
20002c4c:	2b09      	cmp	r3, #9
20002c4e:	d03d      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c50:	68fb      	ldr	r3, [r7, #12]
20002c52:	2b0a      	cmp	r3, #10
20002c54:	d03a      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c56:	68fb      	ldr	r3, [r7, #12]
20002c58:	2b0b      	cmp	r3, #11
20002c5a:	d037      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c5c:	68fb      	ldr	r3, [r7, #12]
20002c5e:	2b0c      	cmp	r3, #12
20002c60:	d034      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c62:	68fb      	ldr	r3, [r7, #12]
20002c64:	2b0d      	cmp	r3, #13
20002c66:	d031      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c68:	68fb      	ldr	r3, [r7, #12]
20002c6a:	2b0e      	cmp	r3, #14
20002c6c:	d02e      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c6e:	68fb      	ldr	r3, [r7, #12]
20002c70:	2b0f      	cmp	r3, #15
20002c72:	d02b      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c74:	68fb      	ldr	r3, [r7, #12]
20002c76:	2b13      	cmp	r3, #19
20002c78:	d028      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c7a:	68fb      	ldr	r3, [r7, #12]
20002c7c:	2b14      	cmp	r3, #20
20002c7e:	d025      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c80:	68fb      	ldr	r3, [r7, #12]
20002c82:	2b15      	cmp	r3, #21
20002c84:	d022      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c86:	68fb      	ldr	r3, [r7, #12]
20002c88:	2b19      	cmp	r3, #25
20002c8a:	d01f      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c8c:	68fb      	ldr	r3, [r7, #12]
20002c8e:	2b22      	cmp	r3, #34	; 0x22
20002c90:	d01c      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c92:	68fb      	ldr	r3, [r7, #12]
20002c94:	2b23      	cmp	r3, #35	; 0x23
20002c96:	d019      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c98:	68fb      	ldr	r3, [r7, #12]
20002c9a:	2b29      	cmp	r3, #41	; 0x29
20002c9c:	d016      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002c9e:	68fb      	ldr	r3, [r7, #12]
20002ca0:	2b30      	cmp	r3, #48	; 0x30
20002ca2:	d013      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002ca4:	68fb      	ldr	r3, [r7, #12]
20002ca6:	2b31      	cmp	r3, #49	; 0x31
20002ca8:	d010      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002caa:	68fb      	ldr	r3, [r7, #12]
20002cac:	2b32      	cmp	r3, #50	; 0x32
20002cae:	d00d      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002cb0:	68fb      	ldr	r3, [r7, #12]
20002cb2:	2b33      	cmp	r3, #51	; 0x33
20002cb4:	d00a      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002cb6:	68fb      	ldr	r3, [r7, #12]
20002cb8:	2b34      	cmp	r3, #52	; 0x34
20002cba:	d007      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002cbc:	68fb      	ldr	r3, [r7, #12]
20002cbe:	2b35      	cmp	r3, #53	; 0x35
20002cc0:	d004      	beq.n	20002ccc <HAL_EXTI_D3_EventInputConfig+0xc4>
20002cc2:	f240 41d1 	movw	r1, #1233	; 0x4d1
20002cc6:	4837      	ldr	r0, [pc, #220]	; (20002da4 <HAL_EXTI_D3_EventInputConfig+0x19c>)
20002cc8:	f7fd fe14 	bl	200008f4 <assert_failed>
  assert_param(IS_EXTI_D3_CLEAR(EXTI_ClearSrc));
20002ccc:	687b      	ldr	r3, [r7, #4]
20002cce:	2b00      	cmp	r3, #0
20002cd0:	d00d      	beq.n	20002cee <HAL_EXTI_D3_EventInputConfig+0xe6>
20002cd2:	687b      	ldr	r3, [r7, #4]
20002cd4:	2b01      	cmp	r3, #1
20002cd6:	d00a      	beq.n	20002cee <HAL_EXTI_D3_EventInputConfig+0xe6>
20002cd8:	687b      	ldr	r3, [r7, #4]
20002cda:	2b02      	cmp	r3, #2
20002cdc:	d007      	beq.n	20002cee <HAL_EXTI_D3_EventInputConfig+0xe6>
20002cde:	687b      	ldr	r3, [r7, #4]
20002ce0:	2b03      	cmp	r3, #3
20002ce2:	d004      	beq.n	20002cee <HAL_EXTI_D3_EventInputConfig+0xe6>
20002ce4:	f240 41d2 	movw	r1, #1234	; 0x4d2
20002ce8:	482e      	ldr	r0, [pc, #184]	; (20002da4 <HAL_EXTI_D3_EventInputConfig+0x19c>)
20002cea:	f7fd fe03 	bl	200008f4 <assert_failed>

  if( EXTI_LineCmd == 0UL)
20002cee:	68bb      	ldr	r3, [r7, #8]
20002cf0:	2b00      	cmp	r3, #0
20002cf2:	d116      	bne.n	20002d22 <HAL_EXTI_D3_EventInputConfig+0x11a>
  {
    /* Clear EXTI line configuration */
    CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) + ((EXTI_Line >> 5 ) * 0x20UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
20002cf4:	68fb      	ldr	r3, [r7, #12]
20002cf6:	095b      	lsrs	r3, r3, #5
20002cf8:	015a      	lsls	r2, r3, #5
20002cfa:	4b2b      	ldr	r3, [pc, #172]	; (20002da8 <HAL_EXTI_D3_EventInputConfig+0x1a0>)
20002cfc:	4413      	add	r3, r2
20002cfe:	6819      	ldr	r1, [r3, #0]
20002d00:	68fb      	ldr	r3, [r7, #12]
20002d02:	f003 031f 	and.w	r3, r3, #31
20002d06:	2201      	movs	r2, #1
20002d08:	fa02 f303 	lsl.w	r3, r2, r3
20002d0c:	43da      	mvns	r2, r3
20002d0e:	68fb      	ldr	r3, [r7, #12]
20002d10:	095b      	lsrs	r3, r3, #5
20002d12:	0158      	lsls	r0, r3, #5
20002d14:	4b24      	ldr	r3, [pc, #144]	; (20002da8 <HAL_EXTI_D3_EventInputConfig+0x1a0>)
20002d16:	4403      	add	r3, r0
20002d18:	4618      	mov	r0, r3
20002d1a:	ea01 0302 	and.w	r3, r1, r2
20002d1e:	6003      	str	r3, [r0, #0]
20002d20:	e013      	b.n	20002d4a <HAL_EXTI_D3_EventInputConfig+0x142>
  }
  else
  {
    SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) +((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
20002d22:	68fb      	ldr	r3, [r7, #12]
20002d24:	095b      	lsrs	r3, r3, #5
20002d26:	015a      	lsls	r2, r3, #5
20002d28:	4b1f      	ldr	r3, [pc, #124]	; (20002da8 <HAL_EXTI_D3_EventInputConfig+0x1a0>)
20002d2a:	4413      	add	r3, r2
20002d2c:	6819      	ldr	r1, [r3, #0]
20002d2e:	68fb      	ldr	r3, [r7, #12]
20002d30:	f003 031f 	and.w	r3, r3, #31
20002d34:	2201      	movs	r2, #1
20002d36:	409a      	lsls	r2, r3
20002d38:	68fb      	ldr	r3, [r7, #12]
20002d3a:	095b      	lsrs	r3, r3, #5
20002d3c:	0158      	lsls	r0, r3, #5
20002d3e:	4b1a      	ldr	r3, [pc, #104]	; (20002da8 <HAL_EXTI_D3_EventInputConfig+0x1a0>)
20002d40:	4403      	add	r3, r0
20002d42:	4618      	mov	r0, r3
20002d44:	ea41 0302 	orr.w	r3, r1, r2
20002d48:	6003      	str	r3, [r0, #0]
  }

  if(((EXTI_Line>>4)%2UL) == 0UL)
20002d4a:	68fb      	ldr	r3, [r7, #12]
20002d4c:	091b      	lsrs	r3, r3, #4
20002d4e:	f003 0301 	and.w	r3, r3, #1
20002d52:	2b00      	cmp	r3, #0
20002d54:	d106      	bne.n	20002d64 <HAL_EXTI_D3_EventInputConfig+0x15c>
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1L)) + ((EXTI_Line >> 5 ) * 0x20UL));
20002d56:	68fb      	ldr	r3, [r7, #12]
20002d58:	095b      	lsrs	r3, r3, #5
20002d5a:	015a      	lsls	r2, r3, #5
20002d5c:	4b13      	ldr	r3, [pc, #76]	; (20002dac <HAL_EXTI_D3_EventInputConfig+0x1a4>)
20002d5e:	4413      	add	r3, r2
20002d60:	617b      	str	r3, [r7, #20]
20002d62:	e005      	b.n	20002d70 <HAL_EXTI_D3_EventInputConfig+0x168>
  }
  else
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1H)) + ((EXTI_Line >> 5 ) * 0x20UL));
20002d64:	68fb      	ldr	r3, [r7, #12]
20002d66:	095b      	lsrs	r3, r3, #5
20002d68:	015a      	lsls	r2, r3, #5
20002d6a:	4b11      	ldr	r3, [pc, #68]	; (20002db0 <HAL_EXTI_D3_EventInputConfig+0x1a8>)
20002d6c:	4413      	add	r3, r2
20002d6e:	617b      	str	r3, [r7, #20]
  }
  MODIFY_REG(*pRegv, (uint32_t)(3UL << ((EXTI_Line*2UL) & 0x1FUL)), (uint32_t)(EXTI_ClearSrc << ((EXTI_Line*2UL) & 0x1FUL)));
20002d70:	697b      	ldr	r3, [r7, #20]
20002d72:	681a      	ldr	r2, [r3, #0]
20002d74:	68fb      	ldr	r3, [r7, #12]
20002d76:	005b      	lsls	r3, r3, #1
20002d78:	f003 031e 	and.w	r3, r3, #30
20002d7c:	2103      	movs	r1, #3
20002d7e:	fa01 f303 	lsl.w	r3, r1, r3
20002d82:	43db      	mvns	r3, r3
20002d84:	401a      	ands	r2, r3
20002d86:	68fb      	ldr	r3, [r7, #12]
20002d88:	005b      	lsls	r3, r3, #1
20002d8a:	f003 031e 	and.w	r3, r3, #30
20002d8e:	6879      	ldr	r1, [r7, #4]
20002d90:	fa01 f303 	lsl.w	r3, r1, r3
20002d94:	431a      	orrs	r2, r3
20002d96:	697b      	ldr	r3, [r7, #20]
20002d98:	601a      	str	r2, [r3, #0]

}
20002d9a:	bf00      	nop
20002d9c:	3718      	adds	r7, #24
20002d9e:	46bd      	mov	sp, r7
20002da0:	bd80      	pop	{r7, pc}
20002da2:	bf00      	nop
20002da4:	2001bf64 	.word	0x2001bf64
20002da8:	5800000c 	.word	0x5800000c
20002dac:	58000010 	.word	0x58000010
20002db0:	58000014 	.word	0x58000014

20002db4 <__NVIC_SetPriorityGrouping>:
{
20002db4:	b480      	push	{r7}
20002db6:	b085      	sub	sp, #20
20002db8:	af00      	add	r7, sp, #0
20002dba:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
20002dbc:	687b      	ldr	r3, [r7, #4]
20002dbe:	f003 0307 	and.w	r3, r3, #7
20002dc2:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
20002dc4:	4b0b      	ldr	r3, [pc, #44]	; (20002df4 <__NVIC_SetPriorityGrouping+0x40>)
20002dc6:	68db      	ldr	r3, [r3, #12]
20002dc8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
20002dca:	68ba      	ldr	r2, [r7, #8]
20002dcc:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
20002dd0:	4013      	ands	r3, r2
20002dd2:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
20002dd4:	68fb      	ldr	r3, [r7, #12]
20002dd6:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
20002dd8:	68bb      	ldr	r3, [r7, #8]
20002dda:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
20002ddc:	4b06      	ldr	r3, [pc, #24]	; (20002df8 <__NVIC_SetPriorityGrouping+0x44>)
20002dde:	4313      	orrs	r3, r2
20002de0:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
20002de2:	4a04      	ldr	r2, [pc, #16]	; (20002df4 <__NVIC_SetPriorityGrouping+0x40>)
20002de4:	68bb      	ldr	r3, [r7, #8]
20002de6:	60d3      	str	r3, [r2, #12]
}
20002de8:	bf00      	nop
20002dea:	3714      	adds	r7, #20
20002dec:	46bd      	mov	sp, r7
20002dee:	f85d 7b04 	ldr.w	r7, [sp], #4
20002df2:	4770      	bx	lr
20002df4:	e000ed00 	.word	0xe000ed00
20002df8:	05fa0000 	.word	0x05fa0000

20002dfc <__NVIC_GetPriorityGrouping>:
{
20002dfc:	b480      	push	{r7}
20002dfe:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
20002e00:	4b04      	ldr	r3, [pc, #16]	; (20002e14 <__NVIC_GetPriorityGrouping+0x18>)
20002e02:	68db      	ldr	r3, [r3, #12]
20002e04:	0a1b      	lsrs	r3, r3, #8
20002e06:	f003 0307 	and.w	r3, r3, #7
}
20002e0a:	4618      	mov	r0, r3
20002e0c:	46bd      	mov	sp, r7
20002e0e:	f85d 7b04 	ldr.w	r7, [sp], #4
20002e12:	4770      	bx	lr
20002e14:	e000ed00 	.word	0xe000ed00

20002e18 <__NVIC_EnableIRQ>:
{
20002e18:	b480      	push	{r7}
20002e1a:	b083      	sub	sp, #12
20002e1c:	af00      	add	r7, sp, #0
20002e1e:	4603      	mov	r3, r0
20002e20:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
20002e22:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002e26:	2b00      	cmp	r3, #0
20002e28:	db0b      	blt.n	20002e42 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
20002e2a:	88fb      	ldrh	r3, [r7, #6]
20002e2c:	f003 021f 	and.w	r2, r3, #31
20002e30:	4907      	ldr	r1, [pc, #28]	; (20002e50 <__NVIC_EnableIRQ+0x38>)
20002e32:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002e36:	095b      	lsrs	r3, r3, #5
20002e38:	2001      	movs	r0, #1
20002e3a:	fa00 f202 	lsl.w	r2, r0, r2
20002e3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
20002e42:	bf00      	nop
20002e44:	370c      	adds	r7, #12
20002e46:	46bd      	mov	sp, r7
20002e48:	f85d 7b04 	ldr.w	r7, [sp], #4
20002e4c:	4770      	bx	lr
20002e4e:	bf00      	nop
20002e50:	e000e100 	.word	0xe000e100

20002e54 <__NVIC_DisableIRQ>:
{
20002e54:	b480      	push	{r7}
20002e56:	b083      	sub	sp, #12
20002e58:	af00      	add	r7, sp, #0
20002e5a:	4603      	mov	r3, r0
20002e5c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
20002e5e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002e62:	2b00      	cmp	r3, #0
20002e64:	db10      	blt.n	20002e88 <__NVIC_DisableIRQ+0x34>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
20002e66:	88fb      	ldrh	r3, [r7, #6]
20002e68:	f003 021f 	and.w	r2, r3, #31
20002e6c:	4909      	ldr	r1, [pc, #36]	; (20002e94 <__NVIC_DisableIRQ+0x40>)
20002e6e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002e72:	095b      	lsrs	r3, r3, #5
20002e74:	2001      	movs	r0, #1
20002e76:	fa00 f202 	lsl.w	r2, r0, r2
20002e7a:	3320      	adds	r3, #32
20002e7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
20002e80:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
20002e84:	f3bf 8f6f 	isb	sy
}
20002e88:	bf00      	nop
20002e8a:	370c      	adds	r7, #12
20002e8c:	46bd      	mov	sp, r7
20002e8e:	f85d 7b04 	ldr.w	r7, [sp], #4
20002e92:	4770      	bx	lr
20002e94:	e000e100 	.word	0xe000e100

20002e98 <__NVIC_GetPendingIRQ>:
{
20002e98:	b480      	push	{r7}
20002e9a:	b083      	sub	sp, #12
20002e9c:	af00      	add	r7, sp, #0
20002e9e:	4603      	mov	r3, r0
20002ea0:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
20002ea2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002ea6:	2b00      	cmp	r3, #0
20002ea8:	db0e      	blt.n	20002ec8 <__NVIC_GetPendingIRQ+0x30>
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
20002eaa:	4a0b      	ldr	r2, [pc, #44]	; (20002ed8 <__NVIC_GetPendingIRQ+0x40>)
20002eac:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002eb0:	095b      	lsrs	r3, r3, #5
20002eb2:	3340      	adds	r3, #64	; 0x40
20002eb4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
20002eb8:	88fb      	ldrh	r3, [r7, #6]
20002eba:	f003 031f 	and.w	r3, r3, #31
20002ebe:	fa22 f303 	lsr.w	r3, r2, r3
20002ec2:	f003 0301 	and.w	r3, r3, #1
20002ec6:	e000      	b.n	20002eca <__NVIC_GetPendingIRQ+0x32>
    return(0U);
20002ec8:	2300      	movs	r3, #0
}
20002eca:	4618      	mov	r0, r3
20002ecc:	370c      	adds	r7, #12
20002ece:	46bd      	mov	sp, r7
20002ed0:	f85d 7b04 	ldr.w	r7, [sp], #4
20002ed4:	4770      	bx	lr
20002ed6:	bf00      	nop
20002ed8:	e000e100 	.word	0xe000e100

20002edc <__NVIC_SetPendingIRQ>:
{
20002edc:	b480      	push	{r7}
20002ede:	b083      	sub	sp, #12
20002ee0:	af00      	add	r7, sp, #0
20002ee2:	4603      	mov	r3, r0
20002ee4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
20002ee6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002eea:	2b00      	cmp	r3, #0
20002eec:	db0c      	blt.n	20002f08 <__NVIC_SetPendingIRQ+0x2c>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
20002eee:	88fb      	ldrh	r3, [r7, #6]
20002ef0:	f003 021f 	and.w	r2, r3, #31
20002ef4:	4907      	ldr	r1, [pc, #28]	; (20002f14 <__NVIC_SetPendingIRQ+0x38>)
20002ef6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002efa:	095b      	lsrs	r3, r3, #5
20002efc:	2001      	movs	r0, #1
20002efe:	fa00 f202 	lsl.w	r2, r0, r2
20002f02:	3340      	adds	r3, #64	; 0x40
20002f04:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
20002f08:	bf00      	nop
20002f0a:	370c      	adds	r7, #12
20002f0c:	46bd      	mov	sp, r7
20002f0e:	f85d 7b04 	ldr.w	r7, [sp], #4
20002f12:	4770      	bx	lr
20002f14:	e000e100 	.word	0xe000e100

20002f18 <__NVIC_ClearPendingIRQ>:
{
20002f18:	b480      	push	{r7}
20002f1a:	b083      	sub	sp, #12
20002f1c:	af00      	add	r7, sp, #0
20002f1e:	4603      	mov	r3, r0
20002f20:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
20002f22:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002f26:	2b00      	cmp	r3, #0
20002f28:	db0c      	blt.n	20002f44 <__NVIC_ClearPendingIRQ+0x2c>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
20002f2a:	88fb      	ldrh	r3, [r7, #6]
20002f2c:	f003 021f 	and.w	r2, r3, #31
20002f30:	4907      	ldr	r1, [pc, #28]	; (20002f50 <__NVIC_ClearPendingIRQ+0x38>)
20002f32:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002f36:	095b      	lsrs	r3, r3, #5
20002f38:	2001      	movs	r0, #1
20002f3a:	fa00 f202 	lsl.w	r2, r0, r2
20002f3e:	3360      	adds	r3, #96	; 0x60
20002f40:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
20002f44:	bf00      	nop
20002f46:	370c      	adds	r7, #12
20002f48:	46bd      	mov	sp, r7
20002f4a:	f85d 7b04 	ldr.w	r7, [sp], #4
20002f4e:	4770      	bx	lr
20002f50:	e000e100 	.word	0xe000e100

20002f54 <__NVIC_GetActive>:
{
20002f54:	b480      	push	{r7}
20002f56:	b083      	sub	sp, #12
20002f58:	af00      	add	r7, sp, #0
20002f5a:	4603      	mov	r3, r0
20002f5c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
20002f5e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002f62:	2b00      	cmp	r3, #0
20002f64:	db0e      	blt.n	20002f84 <__NVIC_GetActive+0x30>
    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
20002f66:	4a0b      	ldr	r2, [pc, #44]	; (20002f94 <__NVIC_GetActive+0x40>)
20002f68:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002f6c:	095b      	lsrs	r3, r3, #5
20002f6e:	3380      	adds	r3, #128	; 0x80
20002f70:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
20002f74:	88fb      	ldrh	r3, [r7, #6]
20002f76:	f003 031f 	and.w	r3, r3, #31
20002f7a:	fa22 f303 	lsr.w	r3, r2, r3
20002f7e:	f003 0301 	and.w	r3, r3, #1
20002f82:	e000      	b.n	20002f86 <__NVIC_GetActive+0x32>
    return(0U);
20002f84:	2300      	movs	r3, #0
}
20002f86:	4618      	mov	r0, r3
20002f88:	370c      	adds	r7, #12
20002f8a:	46bd      	mov	sp, r7
20002f8c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002f90:	4770      	bx	lr
20002f92:	bf00      	nop
20002f94:	e000e100 	.word	0xe000e100

20002f98 <__NVIC_SetPriority>:
{
20002f98:	b480      	push	{r7}
20002f9a:	b083      	sub	sp, #12
20002f9c:	af00      	add	r7, sp, #0
20002f9e:	4603      	mov	r3, r0
20002fa0:	6039      	str	r1, [r7, #0]
20002fa2:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
20002fa4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002fa8:	2b00      	cmp	r3, #0
20002faa:	db0a      	blt.n	20002fc2 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
20002fac:	683b      	ldr	r3, [r7, #0]
20002fae:	b2da      	uxtb	r2, r3
20002fb0:	490c      	ldr	r1, [pc, #48]	; (20002fe4 <__NVIC_SetPriority+0x4c>)
20002fb2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002fb6:	0112      	lsls	r2, r2, #4
20002fb8:	b2d2      	uxtb	r2, r2
20002fba:	440b      	add	r3, r1
20002fbc:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
20002fc0:	e00a      	b.n	20002fd8 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
20002fc2:	683b      	ldr	r3, [r7, #0]
20002fc4:	b2da      	uxtb	r2, r3
20002fc6:	4908      	ldr	r1, [pc, #32]	; (20002fe8 <__NVIC_SetPriority+0x50>)
20002fc8:	88fb      	ldrh	r3, [r7, #6]
20002fca:	f003 030f 	and.w	r3, r3, #15
20002fce:	3b04      	subs	r3, #4
20002fd0:	0112      	lsls	r2, r2, #4
20002fd2:	b2d2      	uxtb	r2, r2
20002fd4:	440b      	add	r3, r1
20002fd6:	761a      	strb	r2, [r3, #24]
}
20002fd8:	bf00      	nop
20002fda:	370c      	adds	r7, #12
20002fdc:	46bd      	mov	sp, r7
20002fde:	f85d 7b04 	ldr.w	r7, [sp], #4
20002fe2:	4770      	bx	lr
20002fe4:	e000e100 	.word	0xe000e100
20002fe8:	e000ed00 	.word	0xe000ed00

20002fec <__NVIC_GetPriority>:
{
20002fec:	b480      	push	{r7}
20002fee:	b083      	sub	sp, #12
20002ff0:	af00      	add	r7, sp, #0
20002ff2:	4603      	mov	r3, r0
20002ff4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
20002ff6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20002ffa:	2b00      	cmp	r3, #0
20002ffc:	db09      	blt.n	20003012 <__NVIC_GetPriority+0x26>
    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]                >> (8U - __NVIC_PRIO_BITS)));
20002ffe:	4a0d      	ldr	r2, [pc, #52]	; (20003034 <__NVIC_GetPriority+0x48>)
20003000:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20003004:	4413      	add	r3, r2
20003006:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
2000300a:	b2db      	uxtb	r3, r3
2000300c:	091b      	lsrs	r3, r3, #4
2000300e:	b2db      	uxtb	r3, r3
20003010:	e009      	b.n	20003026 <__NVIC_GetPriority+0x3a>
    return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
20003012:	4a09      	ldr	r2, [pc, #36]	; (20003038 <__NVIC_GetPriority+0x4c>)
20003014:	88fb      	ldrh	r3, [r7, #6]
20003016:	f003 030f 	and.w	r3, r3, #15
2000301a:	3b04      	subs	r3, #4
2000301c:	4413      	add	r3, r2
2000301e:	7e1b      	ldrb	r3, [r3, #24]
20003020:	b2db      	uxtb	r3, r3
20003022:	091b      	lsrs	r3, r3, #4
20003024:	b2db      	uxtb	r3, r3
}
20003026:	4618      	mov	r0, r3
20003028:	370c      	adds	r7, #12
2000302a:	46bd      	mov	sp, r7
2000302c:	f85d 7b04 	ldr.w	r7, [sp], #4
20003030:	4770      	bx	lr
20003032:	bf00      	nop
20003034:	e000e100 	.word	0xe000e100
20003038:	e000ed00 	.word	0xe000ed00

2000303c <NVIC_EncodePriority>:
{
2000303c:	b480      	push	{r7}
2000303e:	b089      	sub	sp, #36	; 0x24
20003040:	af00      	add	r7, sp, #0
20003042:	60f8      	str	r0, [r7, #12]
20003044:	60b9      	str	r1, [r7, #8]
20003046:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
20003048:	68fb      	ldr	r3, [r7, #12]
2000304a:	f003 0307 	and.w	r3, r3, #7
2000304e:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
20003050:	69fb      	ldr	r3, [r7, #28]
20003052:	f1c3 0307 	rsb	r3, r3, #7
20003056:	2b04      	cmp	r3, #4
20003058:	bf28      	it	cs
2000305a:	2304      	movcs	r3, #4
2000305c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
2000305e:	69fb      	ldr	r3, [r7, #28]
20003060:	3304      	adds	r3, #4
20003062:	2b06      	cmp	r3, #6
20003064:	d902      	bls.n	2000306c <NVIC_EncodePriority+0x30>
20003066:	69fb      	ldr	r3, [r7, #28]
20003068:	3b03      	subs	r3, #3
2000306a:	e000      	b.n	2000306e <NVIC_EncodePriority+0x32>
2000306c:	2300      	movs	r3, #0
2000306e:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
20003070:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
20003074:	69bb      	ldr	r3, [r7, #24]
20003076:	fa02 f303 	lsl.w	r3, r2, r3
2000307a:	43da      	mvns	r2, r3
2000307c:	68bb      	ldr	r3, [r7, #8]
2000307e:	401a      	ands	r2, r3
20003080:	697b      	ldr	r3, [r7, #20]
20003082:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
20003084:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
20003088:	697b      	ldr	r3, [r7, #20]
2000308a:	fa01 f303 	lsl.w	r3, r1, r3
2000308e:	43d9      	mvns	r1, r3
20003090:	687b      	ldr	r3, [r7, #4]
20003092:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
20003094:	4313      	orrs	r3, r2
}
20003096:	4618      	mov	r0, r3
20003098:	3724      	adds	r7, #36	; 0x24
2000309a:	46bd      	mov	sp, r7
2000309c:	f85d 7b04 	ldr.w	r7, [sp], #4
200030a0:	4770      	bx	lr

200030a2 <NVIC_DecodePriority>:
{
200030a2:	b480      	push	{r7}
200030a4:	b089      	sub	sp, #36	; 0x24
200030a6:	af00      	add	r7, sp, #0
200030a8:	60f8      	str	r0, [r7, #12]
200030aa:	60b9      	str	r1, [r7, #8]
200030ac:	607a      	str	r2, [r7, #4]
200030ae:	603b      	str	r3, [r7, #0]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
200030b0:	68bb      	ldr	r3, [r7, #8]
200030b2:	f003 0307 	and.w	r3, r3, #7
200030b6:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
200030b8:	69fb      	ldr	r3, [r7, #28]
200030ba:	f1c3 0307 	rsb	r3, r3, #7
200030be:	2b04      	cmp	r3, #4
200030c0:	bf28      	it	cs
200030c2:	2304      	movcs	r3, #4
200030c4:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
200030c6:	69fb      	ldr	r3, [r7, #28]
200030c8:	3304      	adds	r3, #4
200030ca:	2b06      	cmp	r3, #6
200030cc:	d902      	bls.n	200030d4 <NVIC_DecodePriority+0x32>
200030ce:	69fb      	ldr	r3, [r7, #28]
200030d0:	3b03      	subs	r3, #3
200030d2:	e000      	b.n	200030d6 <NVIC_DecodePriority+0x34>
200030d4:	2300      	movs	r3, #0
200030d6:	617b      	str	r3, [r7, #20]
  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
200030d8:	68fa      	ldr	r2, [r7, #12]
200030da:	697b      	ldr	r3, [r7, #20]
200030dc:	40da      	lsrs	r2, r3
200030de:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
200030e2:	69bb      	ldr	r3, [r7, #24]
200030e4:	fa01 f303 	lsl.w	r3, r1, r3
200030e8:	43db      	mvns	r3, r3
200030ea:	401a      	ands	r2, r3
200030ec:	687b      	ldr	r3, [r7, #4]
200030ee:	601a      	str	r2, [r3, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
200030f0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
200030f4:	697b      	ldr	r3, [r7, #20]
200030f6:	fa02 f303 	lsl.w	r3, r2, r3
200030fa:	43da      	mvns	r2, r3
200030fc:	68fb      	ldr	r3, [r7, #12]
200030fe:	401a      	ands	r2, r3
20003100:	683b      	ldr	r3, [r7, #0]
20003102:	601a      	str	r2, [r3, #0]
}
20003104:	bf00      	nop
20003106:	3724      	adds	r7, #36	; 0x24
20003108:	46bd      	mov	sp, r7
2000310a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000310e:	4770      	bx	lr

20003110 <__NVIC_SystemReset>:
{
20003110:	b480      	push	{r7}
20003112:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
20003114:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
20003118:	4b05      	ldr	r3, [pc, #20]	; (20003130 <__NVIC_SystemReset+0x20>)
2000311a:	68db      	ldr	r3, [r3, #12]
2000311c:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
20003120:	4903      	ldr	r1, [pc, #12]	; (20003130 <__NVIC_SystemReset+0x20>)
20003122:	4b04      	ldr	r3, [pc, #16]	; (20003134 <__NVIC_SystemReset+0x24>)
20003124:	4313      	orrs	r3, r2
20003126:	60cb      	str	r3, [r1, #12]
20003128:	f3bf 8f4f 	dsb	sy
    __NOP();
2000312c:	bf00      	nop
2000312e:	e7fd      	b.n	2000312c <__NVIC_SystemReset+0x1c>
20003130:	e000ed00 	.word	0xe000ed00
20003134:	05fa0004 	.word	0x05fa0004

20003138 <SysTick_Config>:
{
20003138:	b580      	push	{r7, lr}
2000313a:	b082      	sub	sp, #8
2000313c:	af00      	add	r7, sp, #0
2000313e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
20003140:	687b      	ldr	r3, [r7, #4]
20003142:	3b01      	subs	r3, #1
20003144:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20003148:	d301      	bcc.n	2000314e <SysTick_Config+0x16>
    return (1UL);                                                   /* Reload value impossible */
2000314a:	2301      	movs	r3, #1
2000314c:	e00f      	b.n	2000316e <SysTick_Config+0x36>
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
2000314e:	4a0a      	ldr	r2, [pc, #40]	; (20003178 <SysTick_Config+0x40>)
20003150:	687b      	ldr	r3, [r7, #4]
20003152:	3b01      	subs	r3, #1
20003154:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
20003156:	210f      	movs	r1, #15
20003158:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
2000315c:	f7ff ff1c 	bl	20002f98 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
20003160:	4b05      	ldr	r3, [pc, #20]	; (20003178 <SysTick_Config+0x40>)
20003162:	2200      	movs	r2, #0
20003164:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
20003166:	4b04      	ldr	r3, [pc, #16]	; (20003178 <SysTick_Config+0x40>)
20003168:	2207      	movs	r2, #7
2000316a:	601a      	str	r2, [r3, #0]
  return (0UL);                                                     /* Function successful */
2000316c:	2300      	movs	r3, #0
}
2000316e:	4618      	mov	r0, r3
20003170:	3708      	adds	r7, #8
20003172:	46bd      	mov	sp, r7
20003174:	bd80      	pop	{r7, pc}
20003176:	bf00      	nop
20003178:	e000e010 	.word	0xe000e010

2000317c <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
2000317c:	b580      	push	{r7, lr}
2000317e:	b082      	sub	sp, #8
20003180:	af00      	add	r7, sp, #0
20003182:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
20003184:	687b      	ldr	r3, [r7, #4]
20003186:	2b07      	cmp	r3, #7
20003188:	d00f      	beq.n	200031aa <HAL_NVIC_SetPriorityGrouping+0x2e>
2000318a:	687b      	ldr	r3, [r7, #4]
2000318c:	2b06      	cmp	r3, #6
2000318e:	d00c      	beq.n	200031aa <HAL_NVIC_SetPriorityGrouping+0x2e>
20003190:	687b      	ldr	r3, [r7, #4]
20003192:	2b05      	cmp	r3, #5
20003194:	d009      	beq.n	200031aa <HAL_NVIC_SetPriorityGrouping+0x2e>
20003196:	687b      	ldr	r3, [r7, #4]
20003198:	2b04      	cmp	r3, #4
2000319a:	d006      	beq.n	200031aa <HAL_NVIC_SetPriorityGrouping+0x2e>
2000319c:	687b      	ldr	r3, [r7, #4]
2000319e:	2b03      	cmp	r3, #3
200031a0:	d003      	beq.n	200031aa <HAL_NVIC_SetPriorityGrouping+0x2e>
200031a2:	2192      	movs	r1, #146	; 0x92
200031a4:	4804      	ldr	r0, [pc, #16]	; (200031b8 <HAL_NVIC_SetPriorityGrouping+0x3c>)
200031a6:	f7fd fba5 	bl	200008f4 <assert_failed>

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
200031aa:	6878      	ldr	r0, [r7, #4]
200031ac:	f7ff fe02 	bl	20002db4 <__NVIC_SetPriorityGrouping>
}
200031b0:	bf00      	nop
200031b2:	3708      	adds	r7, #8
200031b4:	46bd      	mov	sp, r7
200031b6:	bd80      	pop	{r7, pc}
200031b8:	2001bf98 	.word	0x2001bf98

200031bc <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
200031bc:	b580      	push	{r7, lr}
200031be:	b086      	sub	sp, #24
200031c0:	af00      	add	r7, sp, #0
200031c2:	4603      	mov	r3, r0
200031c4:	60b9      	str	r1, [r7, #8]
200031c6:	607a      	str	r2, [r7, #4]
200031c8:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
200031ca:	687b      	ldr	r3, [r7, #4]
200031cc:	2b0f      	cmp	r3, #15
200031ce:	d903      	bls.n	200031d8 <HAL_NVIC_SetPriority+0x1c>
200031d0:	21aa      	movs	r1, #170	; 0xaa
200031d2:	480e      	ldr	r0, [pc, #56]	; (2000320c <HAL_NVIC_SetPriority+0x50>)
200031d4:	f7fd fb8e 	bl	200008f4 <assert_failed>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
200031d8:	68bb      	ldr	r3, [r7, #8]
200031da:	2b0f      	cmp	r3, #15
200031dc:	d903      	bls.n	200031e6 <HAL_NVIC_SetPriority+0x2a>
200031de:	21ab      	movs	r1, #171	; 0xab
200031e0:	480a      	ldr	r0, [pc, #40]	; (2000320c <HAL_NVIC_SetPriority+0x50>)
200031e2:	f7fd fb87 	bl	200008f4 <assert_failed>

  prioritygroup = NVIC_GetPriorityGrouping();
200031e6:	f7ff fe09 	bl	20002dfc <__NVIC_GetPriorityGrouping>
200031ea:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
200031ec:	687a      	ldr	r2, [r7, #4]
200031ee:	68b9      	ldr	r1, [r7, #8]
200031f0:	6978      	ldr	r0, [r7, #20]
200031f2:	f7ff ff23 	bl	2000303c <NVIC_EncodePriority>
200031f6:	4602      	mov	r2, r0
200031f8:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
200031fc:	4611      	mov	r1, r2
200031fe:	4618      	mov	r0, r3
20003200:	f7ff feca 	bl	20002f98 <__NVIC_SetPriority>
}
20003204:	bf00      	nop
20003206:	3718      	adds	r7, #24
20003208:	46bd      	mov	sp, r7
2000320a:	bd80      	pop	{r7, pc}
2000320c:	2001bf98 	.word	0x2001bf98

20003210 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
20003210:	b580      	push	{r7, lr}
20003212:	b082      	sub	sp, #8
20003214:	af00      	add	r7, sp, #0
20003216:	4603      	mov	r3, r0
20003218:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
2000321a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2000321e:	2b00      	cmp	r3, #0
20003220:	da03      	bge.n	2000322a <HAL_NVIC_EnableIRQ+0x1a>
20003222:	21be      	movs	r1, #190	; 0xbe
20003224:	4805      	ldr	r0, [pc, #20]	; (2000323c <HAL_NVIC_EnableIRQ+0x2c>)
20003226:	f7fd fb65 	bl	200008f4 <assert_failed>

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
2000322a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2000322e:	4618      	mov	r0, r3
20003230:	f7ff fdf2 	bl	20002e18 <__NVIC_EnableIRQ>
}
20003234:	bf00      	nop
20003236:	3708      	adds	r7, #8
20003238:	46bd      	mov	sp, r7
2000323a:	bd80      	pop	{r7, pc}
2000323c:	2001bf98 	.word	0x2001bf98

20003240 <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
20003240:	b580      	push	{r7, lr}
20003242:	b082      	sub	sp, #8
20003244:	af00      	add	r7, sp, #0
20003246:	4603      	mov	r3, r0
20003248:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
2000324a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2000324e:	2b00      	cmp	r3, #0
20003250:	da03      	bge.n	2000325a <HAL_NVIC_DisableIRQ+0x1a>
20003252:	21ce      	movs	r1, #206	; 0xce
20003254:	4805      	ldr	r0, [pc, #20]	; (2000326c <HAL_NVIC_DisableIRQ+0x2c>)
20003256:	f7fd fb4d 	bl	200008f4 <assert_failed>

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
2000325a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2000325e:	4618      	mov	r0, r3
20003260:	f7ff fdf8 	bl	20002e54 <__NVIC_DisableIRQ>
}
20003264:	bf00      	nop
20003266:	3708      	adds	r7, #8
20003268:	46bd      	mov	sp, r7
2000326a:	bd80      	pop	{r7, pc}
2000326c:	2001bf98 	.word	0x2001bf98

20003270 <HAL_NVIC_SystemReset>:
/**
  * @brief  Initiates a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
20003270:	b580      	push	{r7, lr}
20003272:	af00      	add	r7, sp, #0
  /* System Reset */
  NVIC_SystemReset();
20003274:	f7ff ff4c 	bl	20003110 <__NVIC_SystemReset>

20003278 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
20003278:	b580      	push	{r7, lr}
2000327a:	b082      	sub	sp, #8
2000327c:	af00      	add	r7, sp, #0
2000327e:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
20003280:	6878      	ldr	r0, [r7, #4]
20003282:	f7ff ff59 	bl	20003138 <SysTick_Config>
20003286:	4603      	mov	r3, r0
}
20003288:	4618      	mov	r0, r3
2000328a:	3708      	adds	r7, #8
2000328c:	46bd      	mov	sp, r7
2000328e:	bd80      	pop	{r7, pc}

20003290 <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
void HAL_MPU_Disable(void)
{
20003290:	b480      	push	{r7}
20003292:	af00      	add	r7, sp, #0
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
20003294:	f3bf 8f5f 	dmb	sy
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
20003298:	4b06      	ldr	r3, [pc, #24]	; (200032b4 <HAL_MPU_Disable+0x24>)
2000329a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000329c:	4a05      	ldr	r2, [pc, #20]	; (200032b4 <HAL_MPU_Disable+0x24>)
2000329e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
200032a2:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
200032a4:	4b04      	ldr	r3, [pc, #16]	; (200032b8 <HAL_MPU_Disable+0x28>)
200032a6:	2200      	movs	r2, #0
200032a8:	605a      	str	r2, [r3, #4]
}
200032aa:	bf00      	nop
200032ac:	46bd      	mov	sp, r7
200032ae:	f85d 7b04 	ldr.w	r7, [sp], #4
200032b2:	4770      	bx	lr
200032b4:	e000ed00 	.word	0xe000ed00
200032b8:	e000ed90 	.word	0xe000ed90

200032bc <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
200032bc:	b480      	push	{r7}
200032be:	b083      	sub	sp, #12
200032c0:	af00      	add	r7, sp, #0
200032c2:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
200032c4:	4a0a      	ldr	r2, [pc, #40]	; (200032f0 <HAL_MPU_Enable+0x34>)
200032c6:	687b      	ldr	r3, [r7, #4]
200032c8:	f043 0301 	orr.w	r3, r3, #1
200032cc:	6053      	str	r3, [r2, #4]

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
200032ce:	4b09      	ldr	r3, [pc, #36]	; (200032f4 <HAL_MPU_Enable+0x38>)
200032d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200032d2:	4a08      	ldr	r2, [pc, #32]	; (200032f4 <HAL_MPU_Enable+0x38>)
200032d4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200032d8:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
200032da:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
200032de:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
200032e2:	bf00      	nop
200032e4:	370c      	adds	r7, #12
200032e6:	46bd      	mov	sp, r7
200032e8:	f85d 7b04 	ldr.w	r7, [sp], #4
200032ec:	4770      	bx	lr
200032ee:	bf00      	nop
200032f0:	e000ed90 	.word	0xe000ed90
200032f4:	e000ed00 	.word	0xe000ed00

200032f8 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
200032f8:	b580      	push	{r7, lr}
200032fa:	b082      	sub	sp, #8
200032fc:	af00      	add	r7, sp, #0
200032fe:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
20003300:	687b      	ldr	r3, [r7, #4]
20003302:	785b      	ldrb	r3, [r3, #1]
20003304:	2b00      	cmp	r3, #0
20003306:	d040      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003308:	687b      	ldr	r3, [r7, #4]
2000330a:	785b      	ldrb	r3, [r3, #1]
2000330c:	2b01      	cmp	r3, #1
2000330e:	d03c      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003310:	687b      	ldr	r3, [r7, #4]
20003312:	785b      	ldrb	r3, [r3, #1]
20003314:	2b02      	cmp	r3, #2
20003316:	d038      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003318:	687b      	ldr	r3, [r7, #4]
2000331a:	785b      	ldrb	r3, [r3, #1]
2000331c:	2b03      	cmp	r3, #3
2000331e:	d034      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003320:	687b      	ldr	r3, [r7, #4]
20003322:	785b      	ldrb	r3, [r3, #1]
20003324:	2b04      	cmp	r3, #4
20003326:	d030      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003328:	687b      	ldr	r3, [r7, #4]
2000332a:	785b      	ldrb	r3, [r3, #1]
2000332c:	2b05      	cmp	r3, #5
2000332e:	d02c      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003330:	687b      	ldr	r3, [r7, #4]
20003332:	785b      	ldrb	r3, [r3, #1]
20003334:	2b06      	cmp	r3, #6
20003336:	d028      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003338:	687b      	ldr	r3, [r7, #4]
2000333a:	785b      	ldrb	r3, [r3, #1]
2000333c:	2b07      	cmp	r3, #7
2000333e:	d024      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003340:	687b      	ldr	r3, [r7, #4]
20003342:	785b      	ldrb	r3, [r3, #1]
20003344:	2b08      	cmp	r3, #8
20003346:	d020      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003348:	687b      	ldr	r3, [r7, #4]
2000334a:	785b      	ldrb	r3, [r3, #1]
2000334c:	2b09      	cmp	r3, #9
2000334e:	d01c      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003350:	687b      	ldr	r3, [r7, #4]
20003352:	785b      	ldrb	r3, [r3, #1]
20003354:	2b0a      	cmp	r3, #10
20003356:	d018      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003358:	687b      	ldr	r3, [r7, #4]
2000335a:	785b      	ldrb	r3, [r3, #1]
2000335c:	2b0b      	cmp	r3, #11
2000335e:	d014      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003360:	687b      	ldr	r3, [r7, #4]
20003362:	785b      	ldrb	r3, [r3, #1]
20003364:	2b0c      	cmp	r3, #12
20003366:	d010      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003368:	687b      	ldr	r3, [r7, #4]
2000336a:	785b      	ldrb	r3, [r3, #1]
2000336c:	2b0d      	cmp	r3, #13
2000336e:	d00c      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003370:	687b      	ldr	r3, [r7, #4]
20003372:	785b      	ldrb	r3, [r3, #1]
20003374:	2b0e      	cmp	r3, #14
20003376:	d008      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003378:	687b      	ldr	r3, [r7, #4]
2000337a:	785b      	ldrb	r3, [r3, #1]
2000337c:	2b0f      	cmp	r3, #15
2000337e:	d004      	beq.n	2000338a <HAL_MPU_ConfigRegion+0x92>
20003380:	f240 112d 	movw	r1, #301	; 0x12d
20003384:	4896      	ldr	r0, [pc, #600]	; (200035e0 <HAL_MPU_ConfigRegion+0x2e8>)
20003386:	f7fd fab5 	bl	200008f4 <assert_failed>
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
2000338a:	687b      	ldr	r3, [r7, #4]
2000338c:	781b      	ldrb	r3, [r3, #0]
2000338e:	2b01      	cmp	r3, #1
20003390:	d008      	beq.n	200033a4 <HAL_MPU_ConfigRegion+0xac>
20003392:	687b      	ldr	r3, [r7, #4]
20003394:	781b      	ldrb	r3, [r3, #0]
20003396:	2b00      	cmp	r3, #0
20003398:	d004      	beq.n	200033a4 <HAL_MPU_ConfigRegion+0xac>
2000339a:	f44f 7197 	mov.w	r1, #302	; 0x12e
2000339e:	4890      	ldr	r0, [pc, #576]	; (200035e0 <HAL_MPU_ConfigRegion+0x2e8>)
200033a0:	f7fd faa8 	bl	200008f4 <assert_failed>

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
200033a4:	687b      	ldr	r3, [r7, #4]
200033a6:	785a      	ldrb	r2, [r3, #1]
200033a8:	4b8e      	ldr	r3, [pc, #568]	; (200035e4 <HAL_MPU_ConfigRegion+0x2ec>)
200033aa:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
200033ac:	687b      	ldr	r3, [r7, #4]
200033ae:	781b      	ldrb	r3, [r3, #0]
200033b0:	2b00      	cmp	r3, #0
200033b2:	f000 810a 	beq.w	200035ca <HAL_MPU_ConfigRegion+0x2d2>
  {
    /* Check the parameters */
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
200033b6:	687b      	ldr	r3, [r7, #4]
200033b8:	7b1b      	ldrb	r3, [r3, #12]
200033ba:	2b00      	cmp	r3, #0
200033bc:	d008      	beq.n	200033d0 <HAL_MPU_ConfigRegion+0xd8>
200033be:	687b      	ldr	r3, [r7, #4]
200033c0:	7b1b      	ldrb	r3, [r3, #12]
200033c2:	2b01      	cmp	r3, #1
200033c4:	d004      	beq.n	200033d0 <HAL_MPU_ConfigRegion+0xd8>
200033c6:	f44f 719b 	mov.w	r1, #310	; 0x136
200033ca:	4885      	ldr	r0, [pc, #532]	; (200035e0 <HAL_MPU_ConfigRegion+0x2e8>)
200033cc:	f7fd fa92 	bl	200008f4 <assert_failed>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
200033d0:	687b      	ldr	r3, [r7, #4]
200033d2:	7adb      	ldrb	r3, [r3, #11]
200033d4:	2b00      	cmp	r3, #0
200033d6:	d018      	beq.n	2000340a <HAL_MPU_ConfigRegion+0x112>
200033d8:	687b      	ldr	r3, [r7, #4]
200033da:	7adb      	ldrb	r3, [r3, #11]
200033dc:	2b01      	cmp	r3, #1
200033de:	d014      	beq.n	2000340a <HAL_MPU_ConfigRegion+0x112>
200033e0:	687b      	ldr	r3, [r7, #4]
200033e2:	7adb      	ldrb	r3, [r3, #11]
200033e4:	2b02      	cmp	r3, #2
200033e6:	d010      	beq.n	2000340a <HAL_MPU_ConfigRegion+0x112>
200033e8:	687b      	ldr	r3, [r7, #4]
200033ea:	7adb      	ldrb	r3, [r3, #11]
200033ec:	2b03      	cmp	r3, #3
200033ee:	d00c      	beq.n	2000340a <HAL_MPU_ConfigRegion+0x112>
200033f0:	687b      	ldr	r3, [r7, #4]
200033f2:	7adb      	ldrb	r3, [r3, #11]
200033f4:	2b05      	cmp	r3, #5
200033f6:	d008      	beq.n	2000340a <HAL_MPU_ConfigRegion+0x112>
200033f8:	687b      	ldr	r3, [r7, #4]
200033fa:	7adb      	ldrb	r3, [r3, #11]
200033fc:	2b06      	cmp	r3, #6
200033fe:	d004      	beq.n	2000340a <HAL_MPU_ConfigRegion+0x112>
20003400:	f240 1137 	movw	r1, #311	; 0x137
20003404:	4876      	ldr	r0, [pc, #472]	; (200035e0 <HAL_MPU_ConfigRegion+0x2e8>)
20003406:	f7fd fa75 	bl	200008f4 <assert_failed>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
2000340a:	687b      	ldr	r3, [r7, #4]
2000340c:	7a9b      	ldrb	r3, [r3, #10]
2000340e:	2b00      	cmp	r3, #0
20003410:	d00c      	beq.n	2000342c <HAL_MPU_ConfigRegion+0x134>
20003412:	687b      	ldr	r3, [r7, #4]
20003414:	7a9b      	ldrb	r3, [r3, #10]
20003416:	2b01      	cmp	r3, #1
20003418:	d008      	beq.n	2000342c <HAL_MPU_ConfigRegion+0x134>
2000341a:	687b      	ldr	r3, [r7, #4]
2000341c:	7a9b      	ldrb	r3, [r3, #10]
2000341e:	2b02      	cmp	r3, #2
20003420:	d004      	beq.n	2000342c <HAL_MPU_ConfigRegion+0x134>
20003422:	f44f 719c 	mov.w	r1, #312	; 0x138
20003426:	486e      	ldr	r0, [pc, #440]	; (200035e0 <HAL_MPU_ConfigRegion+0x2e8>)
20003428:	f7fd fa64 	bl	200008f4 <assert_failed>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
2000342c:	687b      	ldr	r3, [r7, #4]
2000342e:	7b5b      	ldrb	r3, [r3, #13]
20003430:	2b01      	cmp	r3, #1
20003432:	d008      	beq.n	20003446 <HAL_MPU_ConfigRegion+0x14e>
20003434:	687b      	ldr	r3, [r7, #4]
20003436:	7b5b      	ldrb	r3, [r3, #13]
20003438:	2b00      	cmp	r3, #0
2000343a:	d004      	beq.n	20003446 <HAL_MPU_ConfigRegion+0x14e>
2000343c:	f240 1139 	movw	r1, #313	; 0x139
20003440:	4867      	ldr	r0, [pc, #412]	; (200035e0 <HAL_MPU_ConfigRegion+0x2e8>)
20003442:	f7fd fa57 	bl	200008f4 <assert_failed>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
20003446:	687b      	ldr	r3, [r7, #4]
20003448:	7b9b      	ldrb	r3, [r3, #14]
2000344a:	2b01      	cmp	r3, #1
2000344c:	d008      	beq.n	20003460 <HAL_MPU_ConfigRegion+0x168>
2000344e:	687b      	ldr	r3, [r7, #4]
20003450:	7b9b      	ldrb	r3, [r3, #14]
20003452:	2b00      	cmp	r3, #0
20003454:	d004      	beq.n	20003460 <HAL_MPU_ConfigRegion+0x168>
20003456:	f44f 719d 	mov.w	r1, #314	; 0x13a
2000345a:	4861      	ldr	r0, [pc, #388]	; (200035e0 <HAL_MPU_ConfigRegion+0x2e8>)
2000345c:	f7fd fa4a 	bl	200008f4 <assert_failed>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
20003460:	687b      	ldr	r3, [r7, #4]
20003462:	7bdb      	ldrb	r3, [r3, #15]
20003464:	2b01      	cmp	r3, #1
20003466:	d008      	beq.n	2000347a <HAL_MPU_ConfigRegion+0x182>
20003468:	687b      	ldr	r3, [r7, #4]
2000346a:	7bdb      	ldrb	r3, [r3, #15]
2000346c:	2b00      	cmp	r3, #0
2000346e:	d004      	beq.n	2000347a <HAL_MPU_ConfigRegion+0x182>
20003470:	f240 113b 	movw	r1, #315	; 0x13b
20003474:	485a      	ldr	r0, [pc, #360]	; (200035e0 <HAL_MPU_ConfigRegion+0x2e8>)
20003476:	f7fd fa3d 	bl	200008f4 <assert_failed>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
2000347a:	687b      	ldr	r3, [r7, #4]
2000347c:	7a5b      	ldrb	r3, [r3, #9]
2000347e:	2bff      	cmp	r3, #255	; 0xff
20003480:	d104      	bne.n	2000348c <HAL_MPU_ConfigRegion+0x194>
20003482:	f44f 719e 	mov.w	r1, #316	; 0x13c
20003486:	4856      	ldr	r0, [pc, #344]	; (200035e0 <HAL_MPU_ConfigRegion+0x2e8>)
20003488:	f7fd fa34 	bl	200008f4 <assert_failed>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
2000348c:	687b      	ldr	r3, [r7, #4]
2000348e:	7a1b      	ldrb	r3, [r3, #8]
20003490:	2b04      	cmp	r3, #4
20003492:	d070      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
20003494:	687b      	ldr	r3, [r7, #4]
20003496:	7a1b      	ldrb	r3, [r3, #8]
20003498:	2b05      	cmp	r3, #5
2000349a:	d06c      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
2000349c:	687b      	ldr	r3, [r7, #4]
2000349e:	7a1b      	ldrb	r3, [r3, #8]
200034a0:	2b06      	cmp	r3, #6
200034a2:	d068      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034a4:	687b      	ldr	r3, [r7, #4]
200034a6:	7a1b      	ldrb	r3, [r3, #8]
200034a8:	2b07      	cmp	r3, #7
200034aa:	d064      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034ac:	687b      	ldr	r3, [r7, #4]
200034ae:	7a1b      	ldrb	r3, [r3, #8]
200034b0:	2b08      	cmp	r3, #8
200034b2:	d060      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034b4:	687b      	ldr	r3, [r7, #4]
200034b6:	7a1b      	ldrb	r3, [r3, #8]
200034b8:	2b09      	cmp	r3, #9
200034ba:	d05c      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034bc:	687b      	ldr	r3, [r7, #4]
200034be:	7a1b      	ldrb	r3, [r3, #8]
200034c0:	2b0a      	cmp	r3, #10
200034c2:	d058      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034c4:	687b      	ldr	r3, [r7, #4]
200034c6:	7a1b      	ldrb	r3, [r3, #8]
200034c8:	2b0b      	cmp	r3, #11
200034ca:	d054      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034cc:	687b      	ldr	r3, [r7, #4]
200034ce:	7a1b      	ldrb	r3, [r3, #8]
200034d0:	2b0c      	cmp	r3, #12
200034d2:	d050      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034d4:	687b      	ldr	r3, [r7, #4]
200034d6:	7a1b      	ldrb	r3, [r3, #8]
200034d8:	2b0d      	cmp	r3, #13
200034da:	d04c      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034dc:	687b      	ldr	r3, [r7, #4]
200034de:	7a1b      	ldrb	r3, [r3, #8]
200034e0:	2b0e      	cmp	r3, #14
200034e2:	d048      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034e4:	687b      	ldr	r3, [r7, #4]
200034e6:	7a1b      	ldrb	r3, [r3, #8]
200034e8:	2b0f      	cmp	r3, #15
200034ea:	d044      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034ec:	687b      	ldr	r3, [r7, #4]
200034ee:	7a1b      	ldrb	r3, [r3, #8]
200034f0:	2b10      	cmp	r3, #16
200034f2:	d040      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034f4:	687b      	ldr	r3, [r7, #4]
200034f6:	7a1b      	ldrb	r3, [r3, #8]
200034f8:	2b11      	cmp	r3, #17
200034fa:	d03c      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
200034fc:	687b      	ldr	r3, [r7, #4]
200034fe:	7a1b      	ldrb	r3, [r3, #8]
20003500:	2b12      	cmp	r3, #18
20003502:	d038      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
20003504:	687b      	ldr	r3, [r7, #4]
20003506:	7a1b      	ldrb	r3, [r3, #8]
20003508:	2b13      	cmp	r3, #19
2000350a:	d034      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
2000350c:	687b      	ldr	r3, [r7, #4]
2000350e:	7a1b      	ldrb	r3, [r3, #8]
20003510:	2b14      	cmp	r3, #20
20003512:	d030      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
20003514:	687b      	ldr	r3, [r7, #4]
20003516:	7a1b      	ldrb	r3, [r3, #8]
20003518:	2b15      	cmp	r3, #21
2000351a:	d02c      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
2000351c:	687b      	ldr	r3, [r7, #4]
2000351e:	7a1b      	ldrb	r3, [r3, #8]
20003520:	2b16      	cmp	r3, #22
20003522:	d028      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
20003524:	687b      	ldr	r3, [r7, #4]
20003526:	7a1b      	ldrb	r3, [r3, #8]
20003528:	2b17      	cmp	r3, #23
2000352a:	d024      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
2000352c:	687b      	ldr	r3, [r7, #4]
2000352e:	7a1b      	ldrb	r3, [r3, #8]
20003530:	2b18      	cmp	r3, #24
20003532:	d020      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
20003534:	687b      	ldr	r3, [r7, #4]
20003536:	7a1b      	ldrb	r3, [r3, #8]
20003538:	2b19      	cmp	r3, #25
2000353a:	d01c      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
2000353c:	687b      	ldr	r3, [r7, #4]
2000353e:	7a1b      	ldrb	r3, [r3, #8]
20003540:	2b1a      	cmp	r3, #26
20003542:	d018      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
20003544:	687b      	ldr	r3, [r7, #4]
20003546:	7a1b      	ldrb	r3, [r3, #8]
20003548:	2b1b      	cmp	r3, #27
2000354a:	d014      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
2000354c:	687b      	ldr	r3, [r7, #4]
2000354e:	7a1b      	ldrb	r3, [r3, #8]
20003550:	2b1c      	cmp	r3, #28
20003552:	d010      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
20003554:	687b      	ldr	r3, [r7, #4]
20003556:	7a1b      	ldrb	r3, [r3, #8]
20003558:	2b1d      	cmp	r3, #29
2000355a:	d00c      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
2000355c:	687b      	ldr	r3, [r7, #4]
2000355e:	7a1b      	ldrb	r3, [r3, #8]
20003560:	2b1e      	cmp	r3, #30
20003562:	d008      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
20003564:	687b      	ldr	r3, [r7, #4]
20003566:	7a1b      	ldrb	r3, [r3, #8]
20003568:	2b1f      	cmp	r3, #31
2000356a:	d004      	beq.n	20003576 <HAL_MPU_ConfigRegion+0x27e>
2000356c:	f240 113d 	movw	r1, #317	; 0x13d
20003570:	481b      	ldr	r0, [pc, #108]	; (200035e0 <HAL_MPU_ConfigRegion+0x2e8>)
20003572:	f7fd f9bf 	bl	200008f4 <assert_failed>

    MPU->RBAR = MPU_Init->BaseAddress;
20003576:	4a1b      	ldr	r2, [pc, #108]	; (200035e4 <HAL_MPU_ConfigRegion+0x2ec>)
20003578:	687b      	ldr	r3, [r7, #4]
2000357a:	685b      	ldr	r3, [r3, #4]
2000357c:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
2000357e:	687b      	ldr	r3, [r7, #4]
20003580:	7b1b      	ldrb	r3, [r3, #12]
20003582:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
20003584:	687b      	ldr	r3, [r7, #4]
20003586:	7adb      	ldrb	r3, [r3, #11]
20003588:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
2000358a:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
2000358c:	687b      	ldr	r3, [r7, #4]
2000358e:	7a9b      	ldrb	r3, [r3, #10]
20003590:	04db      	lsls	r3, r3, #19
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
20003592:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
20003594:	687b      	ldr	r3, [r7, #4]
20003596:	7b5b      	ldrb	r3, [r3, #13]
20003598:	049b      	lsls	r3, r3, #18
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
2000359a:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
2000359c:	687b      	ldr	r3, [r7, #4]
2000359e:	7b9b      	ldrb	r3, [r3, #14]
200035a0:	045b      	lsls	r3, r3, #17
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
200035a2:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
200035a4:	687b      	ldr	r3, [r7, #4]
200035a6:	7bdb      	ldrb	r3, [r3, #15]
200035a8:	041b      	lsls	r3, r3, #16
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
200035aa:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
200035ac:	687b      	ldr	r3, [r7, #4]
200035ae:	7a5b      	ldrb	r3, [r3, #9]
200035b0:	021b      	lsls	r3, r3, #8
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
200035b2:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
200035b4:	687b      	ldr	r3, [r7, #4]
200035b6:	7a1b      	ldrb	r3, [r3, #8]
200035b8:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
200035ba:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
200035bc:	687a      	ldr	r2, [r7, #4]
200035be:	7812      	ldrb	r2, [r2, #0]
200035c0:	4611      	mov	r1, r2
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
200035c2:	4a08      	ldr	r2, [pc, #32]	; (200035e4 <HAL_MPU_ConfigRegion+0x2ec>)
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
200035c4:	430b      	orrs	r3, r1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
200035c6:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
200035c8:	e005      	b.n	200035d6 <HAL_MPU_ConfigRegion+0x2de>
    MPU->RBAR = 0x00;
200035ca:	4b06      	ldr	r3, [pc, #24]	; (200035e4 <HAL_MPU_ConfigRegion+0x2ec>)
200035cc:	2200      	movs	r2, #0
200035ce:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
200035d0:	4b04      	ldr	r3, [pc, #16]	; (200035e4 <HAL_MPU_ConfigRegion+0x2ec>)
200035d2:	2200      	movs	r2, #0
200035d4:	611a      	str	r2, [r3, #16]
}
200035d6:	bf00      	nop
200035d8:	3708      	adds	r7, #8
200035da:	46bd      	mov	sp, r7
200035dc:	bd80      	pop	{r7, pc}
200035de:	bf00      	nop
200035e0:	2001bf98 	.word	0x2001bf98
200035e4:	e000ed90 	.word	0xe000ed90

200035e8 <HAL_NVIC_GetPriorityGrouping>:
/**
  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.
  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
200035e8:	b580      	push	{r7, lr}
200035ea:	af00      	add	r7, sp, #0
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
200035ec:	f7ff fc06 	bl	20002dfc <__NVIC_GetPriorityGrouping>
200035f0:	4603      	mov	r3, r0
}
200035f2:	4618      	mov	r0, r3
200035f4:	bd80      	pop	{r7, pc}
	...

200035f8 <HAL_NVIC_GetPriority>:
  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
200035f8:	b580      	push	{r7, lr}
200035fa:	b084      	sub	sp, #16
200035fc:	af00      	add	r7, sp, #0
200035fe:	60b9      	str	r1, [r7, #8]
20003600:	607a      	str	r2, [r7, #4]
20003602:	603b      	str	r3, [r7, #0]
20003604:	4603      	mov	r3, r0
20003606:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
20003608:	68bb      	ldr	r3, [r7, #8]
2000360a:	2b07      	cmp	r3, #7
2000360c:	d010      	beq.n	20003630 <HAL_NVIC_GetPriority+0x38>
2000360e:	68bb      	ldr	r3, [r7, #8]
20003610:	2b06      	cmp	r3, #6
20003612:	d00d      	beq.n	20003630 <HAL_NVIC_GetPriority+0x38>
20003614:	68bb      	ldr	r3, [r7, #8]
20003616:	2b05      	cmp	r3, #5
20003618:	d00a      	beq.n	20003630 <HAL_NVIC_GetPriority+0x38>
2000361a:	68bb      	ldr	r3, [r7, #8]
2000361c:	2b04      	cmp	r3, #4
2000361e:	d007      	beq.n	20003630 <HAL_NVIC_GetPriority+0x38>
20003620:	68bb      	ldr	r3, [r7, #8]
20003622:	2b03      	cmp	r3, #3
20003624:	d004      	beq.n	20003630 <HAL_NVIC_GetPriority+0x38>
20003626:	f44f 71ba 	mov.w	r1, #372	; 0x174
2000362a:	4808      	ldr	r0, [pc, #32]	; (2000364c <HAL_NVIC_GetPriority+0x54>)
2000362c:	f7fd f962 	bl	200008f4 <assert_failed>
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
20003630:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
20003634:	4618      	mov	r0, r3
20003636:	f7ff fcd9 	bl	20002fec <__NVIC_GetPriority>
2000363a:	683b      	ldr	r3, [r7, #0]
2000363c:	687a      	ldr	r2, [r7, #4]
2000363e:	68b9      	ldr	r1, [r7, #8]
20003640:	f7ff fd2f 	bl	200030a2 <NVIC_DecodePriority>
}
20003644:	bf00      	nop
20003646:	3710      	adds	r7, #16
20003648:	46bd      	mov	sp, r7
2000364a:	bd80      	pop	{r7, pc}
2000364c:	2001bf98 	.word	0x2001bf98

20003650 <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
20003650:	b580      	push	{r7, lr}
20003652:	b082      	sub	sp, #8
20003654:	af00      	add	r7, sp, #0
20003656:	4603      	mov	r3, r0
20003658:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
2000365a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2000365e:	2b00      	cmp	r3, #0
20003660:	da04      	bge.n	2000366c <HAL_NVIC_SetPendingIRQ+0x1c>
20003662:	f240 1183 	movw	r1, #387	; 0x183
20003666:	4806      	ldr	r0, [pc, #24]	; (20003680 <HAL_NVIC_SetPendingIRQ+0x30>)
20003668:	f7fd f944 	bl	200008f4 <assert_failed>

  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
2000366c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20003670:	4618      	mov	r0, r3
20003672:	f7ff fc33 	bl	20002edc <__NVIC_SetPendingIRQ>
}
20003676:	bf00      	nop
20003678:	3708      	adds	r7, #8
2000367a:	46bd      	mov	sp, r7
2000367c:	bd80      	pop	{r7, pc}
2000367e:	bf00      	nop
20003680:	2001bf98 	.word	0x2001bf98

20003684 <HAL_NVIC_GetPendingIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval status  - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
20003684:	b580      	push	{r7, lr}
20003686:	b082      	sub	sp, #8
20003688:	af00      	add	r7, sp, #0
2000368a:	4603      	mov	r3, r0
2000368c:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
2000368e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
20003692:	2b00      	cmp	r3, #0
20003694:	da04      	bge.n	200036a0 <HAL_NVIC_GetPendingIRQ+0x1c>
20003696:	f240 1195 	movw	r1, #405	; 0x195
2000369a:	4806      	ldr	r0, [pc, #24]	; (200036b4 <HAL_NVIC_GetPendingIRQ+0x30>)
2000369c:	f7fd f92a 	bl	200008f4 <assert_failed>

  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
200036a0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
200036a4:	4618      	mov	r0, r3
200036a6:	f7ff fbf7 	bl	20002e98 <__NVIC_GetPendingIRQ>
200036aa:	4603      	mov	r3, r0
}
200036ac:	4618      	mov	r0, r3
200036ae:	3708      	adds	r7, #8
200036b0:	46bd      	mov	sp, r7
200036b2:	bd80      	pop	{r7, pc}
200036b4:	2001bf98 	.word	0x2001bf98

200036b8 <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
200036b8:	b580      	push	{r7, lr}
200036ba:	b082      	sub	sp, #8
200036bc:	af00      	add	r7, sp, #0
200036be:	4603      	mov	r3, r0
200036c0:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
200036c2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
200036c6:	2b00      	cmp	r3, #0
200036c8:	da04      	bge.n	200036d4 <HAL_NVIC_ClearPendingIRQ+0x1c>
200036ca:	f240 11a5 	movw	r1, #421	; 0x1a5
200036ce:	4806      	ldr	r0, [pc, #24]	; (200036e8 <HAL_NVIC_ClearPendingIRQ+0x30>)
200036d0:	f7fd f910 	bl	200008f4 <assert_failed>

  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
200036d4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
200036d8:	4618      	mov	r0, r3
200036da:	f7ff fc1d 	bl	20002f18 <__NVIC_ClearPendingIRQ>
}
200036de:	bf00      	nop
200036e0:	3708      	adds	r7, #8
200036e2:	46bd      	mov	sp, r7
200036e4:	bd80      	pop	{r7, pc}
200036e6:	bf00      	nop
200036e8:	2001bf98 	.word	0x2001bf98

200036ec <HAL_NVIC_GetActive>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval status  - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
200036ec:	b580      	push	{r7, lr}
200036ee:	b082      	sub	sp, #8
200036f0:	af00      	add	r7, sp, #0
200036f2:	4603      	mov	r3, r0
200036f4:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
200036f6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
200036fa:	2b00      	cmp	r3, #0
200036fc:	da04      	bge.n	20003708 <HAL_NVIC_GetActive+0x1c>
200036fe:	f44f 71db 	mov.w	r1, #438	; 0x1b6
20003702:	4806      	ldr	r0, [pc, #24]	; (2000371c <HAL_NVIC_GetActive+0x30>)
20003704:	f7fd f8f6 	bl	200008f4 <assert_failed>

  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
20003708:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2000370c:	4618      	mov	r0, r3
2000370e:	f7ff fc21 	bl	20002f54 <__NVIC_GetActive>
20003712:	4603      	mov	r3, r0
}
20003714:	4618      	mov	r0, r3
20003716:	3708      	adds	r7, #8
20003718:	46bd      	mov	sp, r7
2000371a:	bd80      	pop	{r7, pc}
2000371c:	2001bf98 	.word	0x2001bf98

20003720 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
20003720:	b580      	push	{r7, lr}
20003722:	b082      	sub	sp, #8
20003724:	af00      	add	r7, sp, #0
20003726:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
20003728:	687b      	ldr	r3, [r7, #4]
2000372a:	2b04      	cmp	r3, #4
2000372c:	d007      	beq.n	2000373e <HAL_SYSTICK_CLKSourceConfig+0x1e>
2000372e:	687b      	ldr	r3, [r7, #4]
20003730:	2b00      	cmp	r3, #0
20003732:	d004      	beq.n	2000373e <HAL_SYSTICK_CLKSourceConfig+0x1e>
20003734:	f240 11c7 	movw	r1, #455	; 0x1c7
20003738:	480b      	ldr	r0, [pc, #44]	; (20003768 <HAL_SYSTICK_CLKSourceConfig+0x48>)
2000373a:	f7fd f8db 	bl	200008f4 <assert_failed>
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
2000373e:	687b      	ldr	r3, [r7, #4]
20003740:	2b04      	cmp	r3, #4
20003742:	d106      	bne.n	20003752 <HAL_SYSTICK_CLKSourceConfig+0x32>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
20003744:	4b09      	ldr	r3, [pc, #36]	; (2000376c <HAL_SYSTICK_CLKSourceConfig+0x4c>)
20003746:	681b      	ldr	r3, [r3, #0]
20003748:	4a08      	ldr	r2, [pc, #32]	; (2000376c <HAL_SYSTICK_CLKSourceConfig+0x4c>)
2000374a:	f043 0304 	orr.w	r3, r3, #4
2000374e:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}
20003750:	e005      	b.n	2000375e <HAL_SYSTICK_CLKSourceConfig+0x3e>
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
20003752:	4b06      	ldr	r3, [pc, #24]	; (2000376c <HAL_SYSTICK_CLKSourceConfig+0x4c>)
20003754:	681b      	ldr	r3, [r3, #0]
20003756:	4a05      	ldr	r2, [pc, #20]	; (2000376c <HAL_SYSTICK_CLKSourceConfig+0x4c>)
20003758:	f023 0304 	bic.w	r3, r3, #4
2000375c:	6013      	str	r3, [r2, #0]
}
2000375e:	bf00      	nop
20003760:	3708      	adds	r7, #8
20003762:	46bd      	mov	sp, r7
20003764:	bd80      	pop	{r7, pc}
20003766:	bf00      	nop
20003768:	2001bf98 	.word	0x2001bf98
2000376c:	e000e010 	.word	0xe000e010

20003770 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
20003770:	b580      	push	{r7, lr}
20003772:	af00      	add	r7, sp, #0
  HAL_SYSTICK_Callback();
20003774:	f000 f802 	bl	2000377c <HAL_SYSTICK_Callback>
}
20003778:	bf00      	nop
2000377a:	bd80      	pop	{r7, pc}

2000377c <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
2000377c:	b480      	push	{r7}
2000377e:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
20003780:	bf00      	nop
20003782:	46bd      	mov	sp, r7
20003784:	f85d 7b04 	ldr.w	r7, [sp], #4
20003788:	4770      	bx	lr

2000378a <HAL_GetCurrentCPUID>:
/**
* @brief  Returns the current CPU ID.
* @retval CPU identifier
*/
uint32_t HAL_GetCurrentCPUID(void)
{
2000378a:	b480      	push	{r7}
2000378c:	af00      	add	r7, sp, #0
  return  CM7_CPUID;
2000378e:	2303      	movs	r3, #3
}
20003790:	4618      	mov	r0, r3
20003792:	46bd      	mov	sp, r7
20003794:	f85d 7b04 	ldr.w	r7, [sp], #4
20003798:	4770      	bx	lr
	...

2000379c <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
2000379c:	b580      	push	{r7, lr}
2000379e:	b086      	sub	sp, #24
200037a0:	af00      	add	r7, sp, #0
200037a2:	6078      	str	r0, [r7, #4]
  uint32_t registerValue;
  uint32_t tickstart = HAL_GetTick();
200037a4:	f7fe faa2 	bl	20001cec <HAL_GetTick>
200037a8:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
200037aa:	687b      	ldr	r3, [r7, #4]
200037ac:	2b00      	cmp	r3, #0
200037ae:	d102      	bne.n	200037b6 <HAL_DMA_Init+0x1a>
  {
    return HAL_ERROR;
200037b0:	2301      	movs	r3, #1
200037b2:	f000 bcb2 	b.w	2000411a <HAL_DMA_Init+0x97e>
  }

  /* Check the parameters */
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
200037b6:	687b      	ldr	r3, [r7, #4]
200037b8:	681b      	ldr	r3, [r3, #0]
200037ba:	4a96      	ldr	r2, [pc, #600]	; (20003a14 <HAL_DMA_Init+0x278>)
200037bc:	4293      	cmp	r3, r2
200037be:	d076      	beq.n	200038ae <HAL_DMA_Init+0x112>
200037c0:	687b      	ldr	r3, [r7, #4]
200037c2:	681b      	ldr	r3, [r3, #0]
200037c4:	4a94      	ldr	r2, [pc, #592]	; (20003a18 <HAL_DMA_Init+0x27c>)
200037c6:	4293      	cmp	r3, r2
200037c8:	d071      	beq.n	200038ae <HAL_DMA_Init+0x112>
200037ca:	687b      	ldr	r3, [r7, #4]
200037cc:	681b      	ldr	r3, [r3, #0]
200037ce:	4a93      	ldr	r2, [pc, #588]	; (20003a1c <HAL_DMA_Init+0x280>)
200037d0:	4293      	cmp	r3, r2
200037d2:	d06c      	beq.n	200038ae <HAL_DMA_Init+0x112>
200037d4:	687b      	ldr	r3, [r7, #4]
200037d6:	681b      	ldr	r3, [r3, #0]
200037d8:	4a91      	ldr	r2, [pc, #580]	; (20003a20 <HAL_DMA_Init+0x284>)
200037da:	4293      	cmp	r3, r2
200037dc:	d067      	beq.n	200038ae <HAL_DMA_Init+0x112>
200037de:	687b      	ldr	r3, [r7, #4]
200037e0:	681b      	ldr	r3, [r3, #0]
200037e2:	4a90      	ldr	r2, [pc, #576]	; (20003a24 <HAL_DMA_Init+0x288>)
200037e4:	4293      	cmp	r3, r2
200037e6:	d062      	beq.n	200038ae <HAL_DMA_Init+0x112>
200037e8:	687b      	ldr	r3, [r7, #4]
200037ea:	681b      	ldr	r3, [r3, #0]
200037ec:	4a8e      	ldr	r2, [pc, #568]	; (20003a28 <HAL_DMA_Init+0x28c>)
200037ee:	4293      	cmp	r3, r2
200037f0:	d05d      	beq.n	200038ae <HAL_DMA_Init+0x112>
200037f2:	687b      	ldr	r3, [r7, #4]
200037f4:	681b      	ldr	r3, [r3, #0]
200037f6:	4a8d      	ldr	r2, [pc, #564]	; (20003a2c <HAL_DMA_Init+0x290>)
200037f8:	4293      	cmp	r3, r2
200037fa:	d058      	beq.n	200038ae <HAL_DMA_Init+0x112>
200037fc:	687b      	ldr	r3, [r7, #4]
200037fe:	681b      	ldr	r3, [r3, #0]
20003800:	4a8b      	ldr	r2, [pc, #556]	; (20003a30 <HAL_DMA_Init+0x294>)
20003802:	4293      	cmp	r3, r2
20003804:	d053      	beq.n	200038ae <HAL_DMA_Init+0x112>
20003806:	687b      	ldr	r3, [r7, #4]
20003808:	681b      	ldr	r3, [r3, #0]
2000380a:	4a8a      	ldr	r2, [pc, #552]	; (20003a34 <HAL_DMA_Init+0x298>)
2000380c:	4293      	cmp	r3, r2
2000380e:	d04e      	beq.n	200038ae <HAL_DMA_Init+0x112>
20003810:	687b      	ldr	r3, [r7, #4]
20003812:	681b      	ldr	r3, [r3, #0]
20003814:	4a88      	ldr	r2, [pc, #544]	; (20003a38 <HAL_DMA_Init+0x29c>)
20003816:	4293      	cmp	r3, r2
20003818:	d049      	beq.n	200038ae <HAL_DMA_Init+0x112>
2000381a:	687b      	ldr	r3, [r7, #4]
2000381c:	681b      	ldr	r3, [r3, #0]
2000381e:	4a87      	ldr	r2, [pc, #540]	; (20003a3c <HAL_DMA_Init+0x2a0>)
20003820:	4293      	cmp	r3, r2
20003822:	d044      	beq.n	200038ae <HAL_DMA_Init+0x112>
20003824:	687b      	ldr	r3, [r7, #4]
20003826:	681b      	ldr	r3, [r3, #0]
20003828:	4a85      	ldr	r2, [pc, #532]	; (20003a40 <HAL_DMA_Init+0x2a4>)
2000382a:	4293      	cmp	r3, r2
2000382c:	d03f      	beq.n	200038ae <HAL_DMA_Init+0x112>
2000382e:	687b      	ldr	r3, [r7, #4]
20003830:	681b      	ldr	r3, [r3, #0]
20003832:	4a84      	ldr	r2, [pc, #528]	; (20003a44 <HAL_DMA_Init+0x2a8>)
20003834:	4293      	cmp	r3, r2
20003836:	d03a      	beq.n	200038ae <HAL_DMA_Init+0x112>
20003838:	687b      	ldr	r3, [r7, #4]
2000383a:	681b      	ldr	r3, [r3, #0]
2000383c:	4a82      	ldr	r2, [pc, #520]	; (20003a48 <HAL_DMA_Init+0x2ac>)
2000383e:	4293      	cmp	r3, r2
20003840:	d035      	beq.n	200038ae <HAL_DMA_Init+0x112>
20003842:	687b      	ldr	r3, [r7, #4]
20003844:	681b      	ldr	r3, [r3, #0]
20003846:	4a81      	ldr	r2, [pc, #516]	; (20003a4c <HAL_DMA_Init+0x2b0>)
20003848:	4293      	cmp	r3, r2
2000384a:	d030      	beq.n	200038ae <HAL_DMA_Init+0x112>
2000384c:	687b      	ldr	r3, [r7, #4]
2000384e:	681b      	ldr	r3, [r3, #0]
20003850:	4a7f      	ldr	r2, [pc, #508]	; (20003a50 <HAL_DMA_Init+0x2b4>)
20003852:	4293      	cmp	r3, r2
20003854:	d02b      	beq.n	200038ae <HAL_DMA_Init+0x112>
20003856:	687b      	ldr	r3, [r7, #4]
20003858:	681b      	ldr	r3, [r3, #0]
2000385a:	4a7e      	ldr	r2, [pc, #504]	; (20003a54 <HAL_DMA_Init+0x2b8>)
2000385c:	4293      	cmp	r3, r2
2000385e:	d026      	beq.n	200038ae <HAL_DMA_Init+0x112>
20003860:	687b      	ldr	r3, [r7, #4]
20003862:	681b      	ldr	r3, [r3, #0]
20003864:	4a7c      	ldr	r2, [pc, #496]	; (20003a58 <HAL_DMA_Init+0x2bc>)
20003866:	4293      	cmp	r3, r2
20003868:	d021      	beq.n	200038ae <HAL_DMA_Init+0x112>
2000386a:	687b      	ldr	r3, [r7, #4]
2000386c:	681b      	ldr	r3, [r3, #0]
2000386e:	4a7b      	ldr	r2, [pc, #492]	; (20003a5c <HAL_DMA_Init+0x2c0>)
20003870:	4293      	cmp	r3, r2
20003872:	d01c      	beq.n	200038ae <HAL_DMA_Init+0x112>
20003874:	687b      	ldr	r3, [r7, #4]
20003876:	681b      	ldr	r3, [r3, #0]
20003878:	4a79      	ldr	r2, [pc, #484]	; (20003a60 <HAL_DMA_Init+0x2c4>)
2000387a:	4293      	cmp	r3, r2
2000387c:	d017      	beq.n	200038ae <HAL_DMA_Init+0x112>
2000387e:	687b      	ldr	r3, [r7, #4]
20003880:	681b      	ldr	r3, [r3, #0]
20003882:	4a78      	ldr	r2, [pc, #480]	; (20003a64 <HAL_DMA_Init+0x2c8>)
20003884:	4293      	cmp	r3, r2
20003886:	d012      	beq.n	200038ae <HAL_DMA_Init+0x112>
20003888:	687b      	ldr	r3, [r7, #4]
2000388a:	681b      	ldr	r3, [r3, #0]
2000388c:	4a76      	ldr	r2, [pc, #472]	; (20003a68 <HAL_DMA_Init+0x2cc>)
2000388e:	4293      	cmp	r3, r2
20003890:	d00d      	beq.n	200038ae <HAL_DMA_Init+0x112>
20003892:	687b      	ldr	r3, [r7, #4]
20003894:	681b      	ldr	r3, [r3, #0]
20003896:	4a75      	ldr	r2, [pc, #468]	; (20003a6c <HAL_DMA_Init+0x2d0>)
20003898:	4293      	cmp	r3, r2
2000389a:	d008      	beq.n	200038ae <HAL_DMA_Init+0x112>
2000389c:	687b      	ldr	r3, [r7, #4]
2000389e:	681b      	ldr	r3, [r3, #0]
200038a0:	4a73      	ldr	r2, [pc, #460]	; (20003a70 <HAL_DMA_Init+0x2d4>)
200038a2:	4293      	cmp	r3, r2
200038a4:	d003      	beq.n	200038ae <HAL_DMA_Init+0x112>
200038a6:	21e1      	movs	r1, #225	; 0xe1
200038a8:	4872      	ldr	r0, [pc, #456]	; (20003a74 <HAL_DMA_Init+0x2d8>)
200038aa:	f7fd f823 	bl	200008f4 <assert_failed>
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
200038ae:	687b      	ldr	r3, [r7, #4]
200038b0:	689b      	ldr	r3, [r3, #8]
200038b2:	2b00      	cmp	r3, #0
200038b4:	d00b      	beq.n	200038ce <HAL_DMA_Init+0x132>
200038b6:	687b      	ldr	r3, [r7, #4]
200038b8:	689b      	ldr	r3, [r3, #8]
200038ba:	2b40      	cmp	r3, #64	; 0x40
200038bc:	d007      	beq.n	200038ce <HAL_DMA_Init+0x132>
200038be:	687b      	ldr	r3, [r7, #4]
200038c0:	689b      	ldr	r3, [r3, #8]
200038c2:	2b80      	cmp	r3, #128	; 0x80
200038c4:	d003      	beq.n	200038ce <HAL_DMA_Init+0x132>
200038c6:	21e2      	movs	r1, #226	; 0xe2
200038c8:	486a      	ldr	r0, [pc, #424]	; (20003a74 <HAL_DMA_Init+0x2d8>)
200038ca:	f7fd f813 	bl	200008f4 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
200038ce:	687b      	ldr	r3, [r7, #4]
200038d0:	68db      	ldr	r3, [r3, #12]
200038d2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
200038d6:	d007      	beq.n	200038e8 <HAL_DMA_Init+0x14c>
200038d8:	687b      	ldr	r3, [r7, #4]
200038da:	68db      	ldr	r3, [r3, #12]
200038dc:	2b00      	cmp	r3, #0
200038de:	d003      	beq.n	200038e8 <HAL_DMA_Init+0x14c>
200038e0:	21e3      	movs	r1, #227	; 0xe3
200038e2:	4864      	ldr	r0, [pc, #400]	; (20003a74 <HAL_DMA_Init+0x2d8>)
200038e4:	f7fd f806 	bl	200008f4 <assert_failed>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
200038e8:	687b      	ldr	r3, [r7, #4]
200038ea:	691b      	ldr	r3, [r3, #16]
200038ec:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
200038f0:	d007      	beq.n	20003902 <HAL_DMA_Init+0x166>
200038f2:	687b      	ldr	r3, [r7, #4]
200038f4:	691b      	ldr	r3, [r3, #16]
200038f6:	2b00      	cmp	r3, #0
200038f8:	d003      	beq.n	20003902 <HAL_DMA_Init+0x166>
200038fa:	21e4      	movs	r1, #228	; 0xe4
200038fc:	485d      	ldr	r0, [pc, #372]	; (20003a74 <HAL_DMA_Init+0x2d8>)
200038fe:	f7fc fff9 	bl	200008f4 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
20003902:	687b      	ldr	r3, [r7, #4]
20003904:	695b      	ldr	r3, [r3, #20]
20003906:	2b00      	cmp	r3, #0
20003908:	d00d      	beq.n	20003926 <HAL_DMA_Init+0x18a>
2000390a:	687b      	ldr	r3, [r7, #4]
2000390c:	695b      	ldr	r3, [r3, #20]
2000390e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
20003912:	d008      	beq.n	20003926 <HAL_DMA_Init+0x18a>
20003914:	687b      	ldr	r3, [r7, #4]
20003916:	695b      	ldr	r3, [r3, #20]
20003918:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2000391c:	d003      	beq.n	20003926 <HAL_DMA_Init+0x18a>
2000391e:	21e5      	movs	r1, #229	; 0xe5
20003920:	4854      	ldr	r0, [pc, #336]	; (20003a74 <HAL_DMA_Init+0x2d8>)
20003922:	f7fc ffe7 	bl	200008f4 <assert_failed>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
20003926:	687b      	ldr	r3, [r7, #4]
20003928:	699b      	ldr	r3, [r3, #24]
2000392a:	2b00      	cmp	r3, #0
2000392c:	d00d      	beq.n	2000394a <HAL_DMA_Init+0x1ae>
2000392e:	687b      	ldr	r3, [r7, #4]
20003930:	699b      	ldr	r3, [r3, #24]
20003932:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20003936:	d008      	beq.n	2000394a <HAL_DMA_Init+0x1ae>
20003938:	687b      	ldr	r3, [r7, #4]
2000393a:	699b      	ldr	r3, [r3, #24]
2000393c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20003940:	d003      	beq.n	2000394a <HAL_DMA_Init+0x1ae>
20003942:	21e6      	movs	r1, #230	; 0xe6
20003944:	484b      	ldr	r0, [pc, #300]	; (20003a74 <HAL_DMA_Init+0x2d8>)
20003946:	f7fc ffd5 	bl	200008f4 <assert_failed>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
2000394a:	687b      	ldr	r3, [r7, #4]
2000394c:	69db      	ldr	r3, [r3, #28]
2000394e:	2b00      	cmp	r3, #0
20003950:	d016      	beq.n	20003980 <HAL_DMA_Init+0x1e4>
20003952:	687b      	ldr	r3, [r7, #4]
20003954:	69db      	ldr	r3, [r3, #28]
20003956:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2000395a:	d011      	beq.n	20003980 <HAL_DMA_Init+0x1e4>
2000395c:	687b      	ldr	r3, [r7, #4]
2000395e:	69db      	ldr	r3, [r3, #28]
20003960:	2b20      	cmp	r3, #32
20003962:	d00d      	beq.n	20003980 <HAL_DMA_Init+0x1e4>
20003964:	687b      	ldr	r3, [r7, #4]
20003966:	69db      	ldr	r3, [r3, #28]
20003968:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
2000396c:	d008      	beq.n	20003980 <HAL_DMA_Init+0x1e4>
2000396e:	687b      	ldr	r3, [r7, #4]
20003970:	69db      	ldr	r3, [r3, #28]
20003972:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
20003976:	d003      	beq.n	20003980 <HAL_DMA_Init+0x1e4>
20003978:	21e7      	movs	r1, #231	; 0xe7
2000397a:	483e      	ldr	r0, [pc, #248]	; (20003a74 <HAL_DMA_Init+0x2d8>)
2000397c:	f7fc ffba 	bl	200008f4 <assert_failed>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
20003980:	687b      	ldr	r3, [r7, #4]
20003982:	6a1b      	ldr	r3, [r3, #32]
20003984:	2b00      	cmp	r3, #0
20003986:	d012      	beq.n	200039ae <HAL_DMA_Init+0x212>
20003988:	687b      	ldr	r3, [r7, #4]
2000398a:	6a1b      	ldr	r3, [r3, #32]
2000398c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20003990:	d00d      	beq.n	200039ae <HAL_DMA_Init+0x212>
20003992:	687b      	ldr	r3, [r7, #4]
20003994:	6a1b      	ldr	r3, [r3, #32]
20003996:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2000399a:	d008      	beq.n	200039ae <HAL_DMA_Init+0x212>
2000399c:	687b      	ldr	r3, [r7, #4]
2000399e:	6a1b      	ldr	r3, [r3, #32]
200039a0:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
200039a4:	d003      	beq.n	200039ae <HAL_DMA_Init+0x212>
200039a6:	21e8      	movs	r1, #232	; 0xe8
200039a8:	4832      	ldr	r0, [pc, #200]	; (20003a74 <HAL_DMA_Init+0x2d8>)
200039aa:	f7fc ffa3 	bl	200008f4 <assert_failed>

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
200039ae:	687b      	ldr	r3, [r7, #4]
200039b0:	681b      	ldr	r3, [r3, #0]
200039b2:	4a18      	ldr	r2, [pc, #96]	; (20003a14 <HAL_DMA_Init+0x278>)
200039b4:	4293      	cmp	r3, r2
200039b6:	d07d      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
200039b8:	687b      	ldr	r3, [r7, #4]
200039ba:	681b      	ldr	r3, [r3, #0]
200039bc:	4a16      	ldr	r2, [pc, #88]	; (20003a18 <HAL_DMA_Init+0x27c>)
200039be:	4293      	cmp	r3, r2
200039c0:	d078      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
200039c2:	687b      	ldr	r3, [r7, #4]
200039c4:	681b      	ldr	r3, [r3, #0]
200039c6:	4a15      	ldr	r2, [pc, #84]	; (20003a1c <HAL_DMA_Init+0x280>)
200039c8:	4293      	cmp	r3, r2
200039ca:	d073      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
200039cc:	687b      	ldr	r3, [r7, #4]
200039ce:	681b      	ldr	r3, [r3, #0]
200039d0:	4a13      	ldr	r2, [pc, #76]	; (20003a20 <HAL_DMA_Init+0x284>)
200039d2:	4293      	cmp	r3, r2
200039d4:	d06e      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
200039d6:	687b      	ldr	r3, [r7, #4]
200039d8:	681b      	ldr	r3, [r3, #0]
200039da:	4a12      	ldr	r2, [pc, #72]	; (20003a24 <HAL_DMA_Init+0x288>)
200039dc:	4293      	cmp	r3, r2
200039de:	d069      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
200039e0:	687b      	ldr	r3, [r7, #4]
200039e2:	681b      	ldr	r3, [r3, #0]
200039e4:	4a10      	ldr	r2, [pc, #64]	; (20003a28 <HAL_DMA_Init+0x28c>)
200039e6:	4293      	cmp	r3, r2
200039e8:	d064      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
200039ea:	687b      	ldr	r3, [r7, #4]
200039ec:	681b      	ldr	r3, [r3, #0]
200039ee:	4a0f      	ldr	r2, [pc, #60]	; (20003a2c <HAL_DMA_Init+0x290>)
200039f0:	4293      	cmp	r3, r2
200039f2:	d05f      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
200039f4:	687b      	ldr	r3, [r7, #4]
200039f6:	681b      	ldr	r3, [r3, #0]
200039f8:	4a0d      	ldr	r2, [pc, #52]	; (20003a30 <HAL_DMA_Init+0x294>)
200039fa:	4293      	cmp	r3, r2
200039fc:	d05a      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
200039fe:	687b      	ldr	r3, [r7, #4]
20003a00:	681b      	ldr	r3, [r3, #0]
20003a02:	4a0c      	ldr	r2, [pc, #48]	; (20003a34 <HAL_DMA_Init+0x298>)
20003a04:	4293      	cmp	r3, r2
20003a06:	d055      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
20003a08:	687b      	ldr	r3, [r7, #4]
20003a0a:	681b      	ldr	r3, [r3, #0]
20003a0c:	4a0a      	ldr	r2, [pc, #40]	; (20003a38 <HAL_DMA_Init+0x29c>)
20003a0e:	4293      	cmp	r3, r2
20003a10:	d050      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
20003a12:	e031      	b.n	20003a78 <HAL_DMA_Init+0x2dc>
20003a14:	40020010 	.word	0x40020010
20003a18:	40020028 	.word	0x40020028
20003a1c:	40020040 	.word	0x40020040
20003a20:	40020058 	.word	0x40020058
20003a24:	40020070 	.word	0x40020070
20003a28:	40020088 	.word	0x40020088
20003a2c:	400200a0 	.word	0x400200a0
20003a30:	400200b8 	.word	0x400200b8
20003a34:	40020410 	.word	0x40020410
20003a38:	40020428 	.word	0x40020428
20003a3c:	40020440 	.word	0x40020440
20003a40:	40020458 	.word	0x40020458
20003a44:	40020470 	.word	0x40020470
20003a48:	40020488 	.word	0x40020488
20003a4c:	400204a0 	.word	0x400204a0
20003a50:	400204b8 	.word	0x400204b8
20003a54:	58025408 	.word	0x58025408
20003a58:	5802541c 	.word	0x5802541c
20003a5c:	58025430 	.word	0x58025430
20003a60:	58025444 	.word	0x58025444
20003a64:	58025458 	.word	0x58025458
20003a68:	5802546c 	.word	0x5802546c
20003a6c:	58025480 	.word	0x58025480
20003a70:	58025494 	.word	0x58025494
20003a74:	2001bfd4 	.word	0x2001bfd4
20003a78:	687b      	ldr	r3, [r7, #4]
20003a7a:	681b      	ldr	r3, [r3, #0]
20003a7c:	4a7a      	ldr	r2, [pc, #488]	; (20003c68 <HAL_DMA_Init+0x4cc>)
20003a7e:	4293      	cmp	r3, r2
20003a80:	d018      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
20003a82:	687b      	ldr	r3, [r7, #4]
20003a84:	681b      	ldr	r3, [r3, #0]
20003a86:	4a79      	ldr	r2, [pc, #484]	; (20003c6c <HAL_DMA_Init+0x4d0>)
20003a88:	4293      	cmp	r3, r2
20003a8a:	d013      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
20003a8c:	687b      	ldr	r3, [r7, #4]
20003a8e:	681b      	ldr	r3, [r3, #0]
20003a90:	4a77      	ldr	r2, [pc, #476]	; (20003c70 <HAL_DMA_Init+0x4d4>)
20003a92:	4293      	cmp	r3, r2
20003a94:	d00e      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
20003a96:	687b      	ldr	r3, [r7, #4]
20003a98:	681b      	ldr	r3, [r3, #0]
20003a9a:	4a76      	ldr	r2, [pc, #472]	; (20003c74 <HAL_DMA_Init+0x4d8>)
20003a9c:	4293      	cmp	r3, r2
20003a9e:	d009      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
20003aa0:	687b      	ldr	r3, [r7, #4]
20003aa2:	681b      	ldr	r3, [r3, #0]
20003aa4:	4a74      	ldr	r2, [pc, #464]	; (20003c78 <HAL_DMA_Init+0x4dc>)
20003aa6:	4293      	cmp	r3, r2
20003aa8:	d004      	beq.n	20003ab4 <HAL_DMA_Init+0x318>
20003aaa:	687b      	ldr	r3, [r7, #4]
20003aac:	681b      	ldr	r3, [r3, #0]
20003aae:	4a73      	ldr	r2, [pc, #460]	; (20003c7c <HAL_DMA_Init+0x4e0>)
20003ab0:	4293      	cmp	r3, r2
20003ab2:	d101      	bne.n	20003ab8 <HAL_DMA_Init+0x31c>
20003ab4:	2301      	movs	r3, #1
20003ab6:	e000      	b.n	20003aba <HAL_DMA_Init+0x31e>
20003ab8:	2300      	movs	r3, #0
20003aba:	2b00      	cmp	r3, #0
20003abc:	f000 8197 	beq.w	20003dee <HAL_DMA_Init+0x652>
  {
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
20003ac0:	687b      	ldr	r3, [r7, #4]
20003ac2:	685b      	ldr	r3, [r3, #4]
20003ac4:	2b73      	cmp	r3, #115	; 0x73
20003ac6:	d903      	bls.n	20003ad0 <HAL_DMA_Init+0x334>
20003ac8:	21ec      	movs	r1, #236	; 0xec
20003aca:	486d      	ldr	r0, [pc, #436]	; (20003c80 <HAL_DMA_Init+0x4e4>)
20003acc:	f7fc ff12 	bl	200008f4 <assert_failed>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
20003ad0:	687b      	ldr	r3, [r7, #4]
20003ad2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20003ad4:	2b00      	cmp	r3, #0
20003ad6:	d007      	beq.n	20003ae8 <HAL_DMA_Init+0x34c>
20003ad8:	687b      	ldr	r3, [r7, #4]
20003ada:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20003adc:	2b04      	cmp	r3, #4
20003ade:	d003      	beq.n	20003ae8 <HAL_DMA_Init+0x34c>
20003ae0:	21ed      	movs	r1, #237	; 0xed
20003ae2:	4867      	ldr	r0, [pc, #412]	; (20003c80 <HAL_DMA_Init+0x4e4>)
20003ae4:	f7fc ff06 	bl	200008f4 <assert_failed>
    /* Check the memory burst, peripheral burst and FIFO threshold parameters only
       when FIFO mode is enabled */
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
20003ae8:	687b      	ldr	r3, [r7, #4]
20003aea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20003aec:	2b00      	cmp	r3, #0
20003aee:	d041      	beq.n	20003b74 <HAL_DMA_Init+0x3d8>
    {
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
20003af0:	687b      	ldr	r3, [r7, #4]
20003af2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20003af4:	2b00      	cmp	r3, #0
20003af6:	d00f      	beq.n	20003b18 <HAL_DMA_Init+0x37c>
20003af8:	687b      	ldr	r3, [r7, #4]
20003afa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20003afc:	2b01      	cmp	r3, #1
20003afe:	d00b      	beq.n	20003b18 <HAL_DMA_Init+0x37c>
20003b00:	687b      	ldr	r3, [r7, #4]
20003b02:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20003b04:	2b02      	cmp	r3, #2
20003b06:	d007      	beq.n	20003b18 <HAL_DMA_Init+0x37c>
20003b08:	687b      	ldr	r3, [r7, #4]
20003b0a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20003b0c:	2b03      	cmp	r3, #3
20003b0e:	d003      	beq.n	20003b18 <HAL_DMA_Init+0x37c>
20003b10:	21f2      	movs	r1, #242	; 0xf2
20003b12:	485b      	ldr	r0, [pc, #364]	; (20003c80 <HAL_DMA_Init+0x4e4>)
20003b14:	f7fc feee 	bl	200008f4 <assert_failed>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
20003b18:	687b      	ldr	r3, [r7, #4]
20003b1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003b1c:	2b00      	cmp	r3, #0
20003b1e:	d012      	beq.n	20003b46 <HAL_DMA_Init+0x3aa>
20003b20:	687b      	ldr	r3, [r7, #4]
20003b22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003b24:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
20003b28:	d00d      	beq.n	20003b46 <HAL_DMA_Init+0x3aa>
20003b2a:	687b      	ldr	r3, [r7, #4]
20003b2c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003b2e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20003b32:	d008      	beq.n	20003b46 <HAL_DMA_Init+0x3aa>
20003b34:	687b      	ldr	r3, [r7, #4]
20003b36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003b38:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
20003b3c:	d003      	beq.n	20003b46 <HAL_DMA_Init+0x3aa>
20003b3e:	21f3      	movs	r1, #243	; 0xf3
20003b40:	484f      	ldr	r0, [pc, #316]	; (20003c80 <HAL_DMA_Init+0x4e4>)
20003b42:	f7fc fed7 	bl	200008f4 <assert_failed>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
20003b46:	687b      	ldr	r3, [r7, #4]
20003b48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20003b4a:	2b00      	cmp	r3, #0
20003b4c:	d012      	beq.n	20003b74 <HAL_DMA_Init+0x3d8>
20003b4e:	687b      	ldr	r3, [r7, #4]
20003b50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20003b52:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
20003b56:	d00d      	beq.n	20003b74 <HAL_DMA_Init+0x3d8>
20003b58:	687b      	ldr	r3, [r7, #4]
20003b5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20003b5c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
20003b60:	d008      	beq.n	20003b74 <HAL_DMA_Init+0x3d8>
20003b62:	687b      	ldr	r3, [r7, #4]
20003b64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20003b66:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
20003b6a:	d003      	beq.n	20003b74 <HAL_DMA_Init+0x3d8>
20003b6c:	21f4      	movs	r1, #244	; 0xf4
20003b6e:	4844      	ldr	r0, [pc, #272]	; (20003c80 <HAL_DMA_Init+0x4e4>)
20003b70:	f7fc fec0 	bl	200008f4 <assert_failed>
    }

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
20003b74:	687b      	ldr	r3, [r7, #4]
20003b76:	2200      	movs	r2, #0
20003b78:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
20003b7c:	687b      	ldr	r3, [r7, #4]
20003b7e:	2202      	movs	r2, #2
20003b80:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
20003b84:	687b      	ldr	r3, [r7, #4]
20003b86:	681b      	ldr	r3, [r3, #0]
20003b88:	4a3e      	ldr	r2, [pc, #248]	; (20003c84 <HAL_DMA_Init+0x4e8>)
20003b8a:	4293      	cmp	r3, r2
20003b8c:	d04a      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003b8e:	687b      	ldr	r3, [r7, #4]
20003b90:	681b      	ldr	r3, [r3, #0]
20003b92:	4a3d      	ldr	r2, [pc, #244]	; (20003c88 <HAL_DMA_Init+0x4ec>)
20003b94:	4293      	cmp	r3, r2
20003b96:	d045      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003b98:	687b      	ldr	r3, [r7, #4]
20003b9a:	681b      	ldr	r3, [r3, #0]
20003b9c:	4a3b      	ldr	r2, [pc, #236]	; (20003c8c <HAL_DMA_Init+0x4f0>)
20003b9e:	4293      	cmp	r3, r2
20003ba0:	d040      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003ba2:	687b      	ldr	r3, [r7, #4]
20003ba4:	681b      	ldr	r3, [r3, #0]
20003ba6:	4a3a      	ldr	r2, [pc, #232]	; (20003c90 <HAL_DMA_Init+0x4f4>)
20003ba8:	4293      	cmp	r3, r2
20003baa:	d03b      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003bac:	687b      	ldr	r3, [r7, #4]
20003bae:	681b      	ldr	r3, [r3, #0]
20003bb0:	4a38      	ldr	r2, [pc, #224]	; (20003c94 <HAL_DMA_Init+0x4f8>)
20003bb2:	4293      	cmp	r3, r2
20003bb4:	d036      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003bb6:	687b      	ldr	r3, [r7, #4]
20003bb8:	681b      	ldr	r3, [r3, #0]
20003bba:	4a37      	ldr	r2, [pc, #220]	; (20003c98 <HAL_DMA_Init+0x4fc>)
20003bbc:	4293      	cmp	r3, r2
20003bbe:	d031      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003bc0:	687b      	ldr	r3, [r7, #4]
20003bc2:	681b      	ldr	r3, [r3, #0]
20003bc4:	4a35      	ldr	r2, [pc, #212]	; (20003c9c <HAL_DMA_Init+0x500>)
20003bc6:	4293      	cmp	r3, r2
20003bc8:	d02c      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003bca:	687b      	ldr	r3, [r7, #4]
20003bcc:	681b      	ldr	r3, [r3, #0]
20003bce:	4a34      	ldr	r2, [pc, #208]	; (20003ca0 <HAL_DMA_Init+0x504>)
20003bd0:	4293      	cmp	r3, r2
20003bd2:	d027      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003bd4:	687b      	ldr	r3, [r7, #4]
20003bd6:	681b      	ldr	r3, [r3, #0]
20003bd8:	4a32      	ldr	r2, [pc, #200]	; (20003ca4 <HAL_DMA_Init+0x508>)
20003bda:	4293      	cmp	r3, r2
20003bdc:	d022      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003bde:	687b      	ldr	r3, [r7, #4]
20003be0:	681b      	ldr	r3, [r3, #0]
20003be2:	4a31      	ldr	r2, [pc, #196]	; (20003ca8 <HAL_DMA_Init+0x50c>)
20003be4:	4293      	cmp	r3, r2
20003be6:	d01d      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003be8:	687b      	ldr	r3, [r7, #4]
20003bea:	681b      	ldr	r3, [r3, #0]
20003bec:	4a1e      	ldr	r2, [pc, #120]	; (20003c68 <HAL_DMA_Init+0x4cc>)
20003bee:	4293      	cmp	r3, r2
20003bf0:	d018      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003bf2:	687b      	ldr	r3, [r7, #4]
20003bf4:	681b      	ldr	r3, [r3, #0]
20003bf6:	4a1d      	ldr	r2, [pc, #116]	; (20003c6c <HAL_DMA_Init+0x4d0>)
20003bf8:	4293      	cmp	r3, r2
20003bfa:	d013      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003bfc:	687b      	ldr	r3, [r7, #4]
20003bfe:	681b      	ldr	r3, [r3, #0]
20003c00:	4a1b      	ldr	r2, [pc, #108]	; (20003c70 <HAL_DMA_Init+0x4d4>)
20003c02:	4293      	cmp	r3, r2
20003c04:	d00e      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003c06:	687b      	ldr	r3, [r7, #4]
20003c08:	681b      	ldr	r3, [r3, #0]
20003c0a:	4a1a      	ldr	r2, [pc, #104]	; (20003c74 <HAL_DMA_Init+0x4d8>)
20003c0c:	4293      	cmp	r3, r2
20003c0e:	d009      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003c10:	687b      	ldr	r3, [r7, #4]
20003c12:	681b      	ldr	r3, [r3, #0]
20003c14:	4a18      	ldr	r2, [pc, #96]	; (20003c78 <HAL_DMA_Init+0x4dc>)
20003c16:	4293      	cmp	r3, r2
20003c18:	d004      	beq.n	20003c24 <HAL_DMA_Init+0x488>
20003c1a:	687b      	ldr	r3, [r7, #4]
20003c1c:	681b      	ldr	r3, [r3, #0]
20003c1e:	4a17      	ldr	r2, [pc, #92]	; (20003c7c <HAL_DMA_Init+0x4e0>)
20003c20:	4293      	cmp	r3, r2
20003c22:	d108      	bne.n	20003c36 <HAL_DMA_Init+0x49a>
20003c24:	687b      	ldr	r3, [r7, #4]
20003c26:	681b      	ldr	r3, [r3, #0]
20003c28:	681a      	ldr	r2, [r3, #0]
20003c2a:	687b      	ldr	r3, [r7, #4]
20003c2c:	681b      	ldr	r3, [r3, #0]
20003c2e:	f022 0201 	bic.w	r2, r2, #1
20003c32:	601a      	str	r2, [r3, #0]
20003c34:	e007      	b.n	20003c46 <HAL_DMA_Init+0x4aa>
20003c36:	687b      	ldr	r3, [r7, #4]
20003c38:	681b      	ldr	r3, [r3, #0]
20003c3a:	681a      	ldr	r2, [r3, #0]
20003c3c:	687b      	ldr	r3, [r7, #4]
20003c3e:	681b      	ldr	r3, [r3, #0]
20003c40:	f022 0201 	bic.w	r2, r2, #1
20003c44:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
20003c46:	e031      	b.n	20003cac <HAL_DMA_Init+0x510>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
20003c48:	f7fe f850 	bl	20001cec <HAL_GetTick>
20003c4c:	4602      	mov	r2, r0
20003c4e:	693b      	ldr	r3, [r7, #16]
20003c50:	1ad3      	subs	r3, r2, r3
20003c52:	2b05      	cmp	r3, #5
20003c54:	d92a      	bls.n	20003cac <HAL_DMA_Init+0x510>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
20003c56:	687b      	ldr	r3, [r7, #4]
20003c58:	2220      	movs	r2, #32
20003c5a:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
20003c5c:	687b      	ldr	r3, [r7, #4]
20003c5e:	2203      	movs	r2, #3
20003c60:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        return HAL_ERROR;
20003c64:	2301      	movs	r3, #1
20003c66:	e258      	b.n	2000411a <HAL_DMA_Init+0x97e>
20003c68:	40020440 	.word	0x40020440
20003c6c:	40020458 	.word	0x40020458
20003c70:	40020470 	.word	0x40020470
20003c74:	40020488 	.word	0x40020488
20003c78:	400204a0 	.word	0x400204a0
20003c7c:	400204b8 	.word	0x400204b8
20003c80:	2001bfd4 	.word	0x2001bfd4
20003c84:	40020010 	.word	0x40020010
20003c88:	40020028 	.word	0x40020028
20003c8c:	40020040 	.word	0x40020040
20003c90:	40020058 	.word	0x40020058
20003c94:	40020070 	.word	0x40020070
20003c98:	40020088 	.word	0x40020088
20003c9c:	400200a0 	.word	0x400200a0
20003ca0:	400200b8 	.word	0x400200b8
20003ca4:	40020410 	.word	0x40020410
20003ca8:	40020428 	.word	0x40020428
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
20003cac:	687b      	ldr	r3, [r7, #4]
20003cae:	681b      	ldr	r3, [r3, #0]
20003cb0:	681b      	ldr	r3, [r3, #0]
20003cb2:	f003 0301 	and.w	r3, r3, #1
20003cb6:	2b00      	cmp	r3, #0
20003cb8:	d1c6      	bne.n	20003c48 <HAL_DMA_Init+0x4ac>
      }
    }

    /* Get the CR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
20003cba:	687b      	ldr	r3, [r7, #4]
20003cbc:	681b      	ldr	r3, [r3, #0]
20003cbe:	681b      	ldr	r3, [r3, #0]
20003cc0:	617b      	str	r3, [r7, #20]

    /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
20003cc2:	697a      	ldr	r2, [r7, #20]
20003cc4:	4b8a      	ldr	r3, [pc, #552]	; (20003ef0 <HAL_DMA_Init+0x754>)
20003cc6:	4013      	ands	r3, r2
20003cc8:	617b      	str	r3, [r7, #20]
                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

    /* Prepare the DMA Stream configuration */
    registerValue |=  hdma->Init.Direction           |
20003cca:	687b      	ldr	r3, [r7, #4]
20003ccc:	689a      	ldr	r2, [r3, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
20003cce:	687b      	ldr	r3, [r7, #4]
20003cd0:	68db      	ldr	r3, [r3, #12]
    registerValue |=  hdma->Init.Direction           |
20003cd2:	431a      	orrs	r2, r3
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
20003cd4:	687b      	ldr	r3, [r7, #4]
20003cd6:	691b      	ldr	r3, [r3, #16]
20003cd8:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
20003cda:	687b      	ldr	r3, [r7, #4]
20003cdc:	695b      	ldr	r3, [r3, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
20003cde:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
20003ce0:	687b      	ldr	r3, [r7, #4]
20003ce2:	699b      	ldr	r3, [r3, #24]
20003ce4:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
20003ce6:	687b      	ldr	r3, [r7, #4]
20003ce8:	69db      	ldr	r3, [r3, #28]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
20003cea:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
20003cec:	687b      	ldr	r3, [r7, #4]
20003cee:	6a1b      	ldr	r3, [r3, #32]
20003cf0:	4313      	orrs	r3, r2
    registerValue |=  hdma->Init.Direction           |
20003cf2:	697a      	ldr	r2, [r7, #20]
20003cf4:	4313      	orrs	r3, r2
20003cf6:	617b      	str	r3, [r7, #20]

    /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
20003cf8:	687b      	ldr	r3, [r7, #4]
20003cfa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20003cfc:	2b04      	cmp	r3, #4
20003cfe:	d107      	bne.n	20003d10 <HAL_DMA_Init+0x574>
    {
      /* Get memory burst and peripheral burst */
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
20003d00:	687b      	ldr	r3, [r7, #4]
20003d02:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20003d04:	687b      	ldr	r3, [r7, #4]
20003d06:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20003d08:	4313      	orrs	r3, r2
20003d0a:	697a      	ldr	r2, [r7, #20]
20003d0c:	4313      	orrs	r3, r2
20003d0e:	617b      	str	r3, [r7, #20]
    }

    /* Work around for Errata 2.22: UART/USART- DMA transfer lock: DMA stream could be
                                    lock when transfering data to/from USART/UART */
#if (STM32H7_DEV_ID == 0x450UL)
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
20003d10:	4b78      	ldr	r3, [pc, #480]	; (20003ef4 <HAL_DMA_Init+0x758>)
20003d12:	681a      	ldr	r2, [r3, #0]
20003d14:	4b78      	ldr	r3, [pc, #480]	; (20003ef8 <HAL_DMA_Init+0x75c>)
20003d16:	4013      	ands	r3, r2
20003d18:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20003d1c:	d328      	bcc.n	20003d70 <HAL_DMA_Init+0x5d4>
    {
#endif /* STM32H7_DEV_ID == 0x450UL */
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
20003d1e:	687b      	ldr	r3, [r7, #4]
20003d20:	685b      	ldr	r3, [r3, #4]
20003d22:	2b28      	cmp	r3, #40	; 0x28
20003d24:	d903      	bls.n	20003d2e <HAL_DMA_Init+0x592>
20003d26:	687b      	ldr	r3, [r7, #4]
20003d28:	685b      	ldr	r3, [r3, #4]
20003d2a:	2b2e      	cmp	r3, #46	; 0x2e
20003d2c:	d917      	bls.n	20003d5e <HAL_DMA_Init+0x5c2>
20003d2e:	687b      	ldr	r3, [r7, #4]
20003d30:	685b      	ldr	r3, [r3, #4]
20003d32:	2b3e      	cmp	r3, #62	; 0x3e
20003d34:	d903      	bls.n	20003d3e <HAL_DMA_Init+0x5a2>
20003d36:	687b      	ldr	r3, [r7, #4]
20003d38:	685b      	ldr	r3, [r3, #4]
20003d3a:	2b42      	cmp	r3, #66	; 0x42
20003d3c:	d90f      	bls.n	20003d5e <HAL_DMA_Init+0x5c2>
20003d3e:	687b      	ldr	r3, [r7, #4]
20003d40:	685b      	ldr	r3, [r3, #4]
20003d42:	2b46      	cmp	r3, #70	; 0x46
20003d44:	d903      	bls.n	20003d4e <HAL_DMA_Init+0x5b2>
20003d46:	687b      	ldr	r3, [r7, #4]
20003d48:	685b      	ldr	r3, [r3, #4]
20003d4a:	2b48      	cmp	r3, #72	; 0x48
20003d4c:	d907      	bls.n	20003d5e <HAL_DMA_Init+0x5c2>
20003d4e:	687b      	ldr	r3, [r7, #4]
20003d50:	685b      	ldr	r3, [r3, #4]
20003d52:	2b4e      	cmp	r3, #78	; 0x4e
20003d54:	d905      	bls.n	20003d62 <HAL_DMA_Init+0x5c6>
20003d56:	687b      	ldr	r3, [r7, #4]
20003d58:	685b      	ldr	r3, [r3, #4]
20003d5a:	2b52      	cmp	r3, #82	; 0x52
20003d5c:	d801      	bhi.n	20003d62 <HAL_DMA_Init+0x5c6>
20003d5e:	2301      	movs	r3, #1
20003d60:	e000      	b.n	20003d64 <HAL_DMA_Init+0x5c8>
20003d62:	2300      	movs	r3, #0
20003d64:	2b00      	cmp	r3, #0
20003d66:	d003      	beq.n	20003d70 <HAL_DMA_Init+0x5d4>
      {
        registerValue |= DMA_SxCR_TRBUFF;
20003d68:	697b      	ldr	r3, [r7, #20]
20003d6a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
20003d6e:	617b      	str	r3, [r7, #20]
#if (STM32H7_DEV_ID == 0x450UL)
    }
#endif /* STM32H7_DEV_ID == 0x450UL */

    /* Write to DMA Stream CR register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
20003d70:	687b      	ldr	r3, [r7, #4]
20003d72:	681b      	ldr	r3, [r3, #0]
20003d74:	697a      	ldr	r2, [r7, #20]
20003d76:	601a      	str	r2, [r3, #0]

    /* Get the FCR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
20003d78:	687b      	ldr	r3, [r7, #4]
20003d7a:	681b      	ldr	r3, [r3, #0]
20003d7c:	695b      	ldr	r3, [r3, #20]
20003d7e:	617b      	str	r3, [r7, #20]

    /* Clear Direct mode and FIFO threshold bits */
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
20003d80:	697b      	ldr	r3, [r7, #20]
20003d82:	f023 0307 	bic.w	r3, r3, #7
20003d86:	617b      	str	r3, [r7, #20]

    /* Prepare the DMA Stream FIFO configuration */
    registerValue |= hdma->Init.FIFOMode;
20003d88:	687b      	ldr	r3, [r7, #4]
20003d8a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20003d8c:	697a      	ldr	r2, [r7, #20]
20003d8e:	4313      	orrs	r3, r2
20003d90:	617b      	str	r3, [r7, #20]

    /* the FIFO threshold is not used when the FIFO mode is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
20003d92:	687b      	ldr	r3, [r7, #4]
20003d94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20003d96:	2b04      	cmp	r3, #4
20003d98:	d117      	bne.n	20003dca <HAL_DMA_Init+0x62e>
    {
      /* Get the FIFO threshold */
      registerValue |= hdma->Init.FIFOThreshold;
20003d9a:	687b      	ldr	r3, [r7, #4]
20003d9c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20003d9e:	697a      	ldr	r2, [r7, #20]
20003da0:	4313      	orrs	r3, r2
20003da2:	617b      	str	r3, [r7, #20]

      /* Check compatibility between FIFO threshold level and size of the memory burst */
      /* for INCR4, INCR8, INCR16 */
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
20003da4:	687b      	ldr	r3, [r7, #4]
20003da6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003da8:	2b00      	cmp	r3, #0
20003daa:	d00e      	beq.n	20003dca <HAL_DMA_Init+0x62e>
      {
        if (DMA_CheckFifoParam(hdma) != HAL_OK)
20003dac:	6878      	ldr	r0, [r7, #4]
20003dae:	f003 fb6d 	bl	2000748c <DMA_CheckFifoParam>
20003db2:	4603      	mov	r3, r0
20003db4:	2b00      	cmp	r3, #0
20003db6:	d008      	beq.n	20003dca <HAL_DMA_Init+0x62e>
        {
          /* Update error code */
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
20003db8:	687b      	ldr	r3, [r7, #4]
20003dba:	2240      	movs	r2, #64	; 0x40
20003dbc:	655a      	str	r2, [r3, #84]	; 0x54

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
20003dbe:	687b      	ldr	r3, [r7, #4]
20003dc0:	2201      	movs	r2, #1
20003dc2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          return HAL_ERROR;
20003dc6:	2301      	movs	r3, #1
20003dc8:	e1a7      	b.n	2000411a <HAL_DMA_Init+0x97e>
        }
      }
    }

    /* Write to DMA Stream FCR */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
20003dca:	687b      	ldr	r3, [r7, #4]
20003dcc:	681b      	ldr	r3, [r3, #0]
20003dce:	697a      	ldr	r2, [r7, #20]
20003dd0:	615a      	str	r2, [r3, #20]

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
       DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
20003dd2:	6878      	ldr	r0, [r7, #4]
20003dd4:	f003 faa8 	bl	20007328 <DMA_CalcBaseAndBitshift>
20003dd8:	4603      	mov	r3, r0
20003dda:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
20003ddc:	687b      	ldr	r3, [r7, #4]
20003dde:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20003de0:	f003 031f 	and.w	r3, r3, #31
20003de4:	223f      	movs	r2, #63	; 0x3f
20003de6:	409a      	lsls	r2, r3
20003de8:	68bb      	ldr	r3, [r7, #8]
20003dea:	609a      	str	r2, [r3, #8]
20003dec:	e0dd      	b.n	20003faa <HAL_DMA_Init+0x80e>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
20003dee:	687b      	ldr	r3, [r7, #4]
20003df0:	681b      	ldr	r3, [r3, #0]
20003df2:	4a42      	ldr	r2, [pc, #264]	; (20003efc <HAL_DMA_Init+0x760>)
20003df4:	4293      	cmp	r3, r2
20003df6:	d022      	beq.n	20003e3e <HAL_DMA_Init+0x6a2>
20003df8:	687b      	ldr	r3, [r7, #4]
20003dfa:	681b      	ldr	r3, [r3, #0]
20003dfc:	4a40      	ldr	r2, [pc, #256]	; (20003f00 <HAL_DMA_Init+0x764>)
20003dfe:	4293      	cmp	r3, r2
20003e00:	d01d      	beq.n	20003e3e <HAL_DMA_Init+0x6a2>
20003e02:	687b      	ldr	r3, [r7, #4]
20003e04:	681b      	ldr	r3, [r3, #0]
20003e06:	4a3f      	ldr	r2, [pc, #252]	; (20003f04 <HAL_DMA_Init+0x768>)
20003e08:	4293      	cmp	r3, r2
20003e0a:	d018      	beq.n	20003e3e <HAL_DMA_Init+0x6a2>
20003e0c:	687b      	ldr	r3, [r7, #4]
20003e0e:	681b      	ldr	r3, [r3, #0]
20003e10:	4a3d      	ldr	r2, [pc, #244]	; (20003f08 <HAL_DMA_Init+0x76c>)
20003e12:	4293      	cmp	r3, r2
20003e14:	d013      	beq.n	20003e3e <HAL_DMA_Init+0x6a2>
20003e16:	687b      	ldr	r3, [r7, #4]
20003e18:	681b      	ldr	r3, [r3, #0]
20003e1a:	4a3c      	ldr	r2, [pc, #240]	; (20003f0c <HAL_DMA_Init+0x770>)
20003e1c:	4293      	cmp	r3, r2
20003e1e:	d00e      	beq.n	20003e3e <HAL_DMA_Init+0x6a2>
20003e20:	687b      	ldr	r3, [r7, #4]
20003e22:	681b      	ldr	r3, [r3, #0]
20003e24:	4a3a      	ldr	r2, [pc, #232]	; (20003f10 <HAL_DMA_Init+0x774>)
20003e26:	4293      	cmp	r3, r2
20003e28:	d009      	beq.n	20003e3e <HAL_DMA_Init+0x6a2>
20003e2a:	687b      	ldr	r3, [r7, #4]
20003e2c:	681b      	ldr	r3, [r3, #0]
20003e2e:	4a39      	ldr	r2, [pc, #228]	; (20003f14 <HAL_DMA_Init+0x778>)
20003e30:	4293      	cmp	r3, r2
20003e32:	d004      	beq.n	20003e3e <HAL_DMA_Init+0x6a2>
20003e34:	687b      	ldr	r3, [r7, #4]
20003e36:	681b      	ldr	r3, [r3, #0]
20003e38:	4a37      	ldr	r2, [pc, #220]	; (20003f18 <HAL_DMA_Init+0x77c>)
20003e3a:	4293      	cmp	r3, r2
20003e3c:	d101      	bne.n	20003e42 <HAL_DMA_Init+0x6a6>
20003e3e:	2301      	movs	r3, #1
20003e40:	e000      	b.n	20003e44 <HAL_DMA_Init+0x6a8>
20003e42:	2300      	movs	r3, #0
20003e44:	2b00      	cmp	r3, #0
20003e46:	f000 80a7 	beq.w	20003f98 <HAL_DMA_Init+0x7fc>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
20003e4a:	687b      	ldr	r3, [r7, #4]
20003e4c:	681b      	ldr	r3, [r3, #0]
20003e4e:	4a2b      	ldr	r2, [pc, #172]	; (20003efc <HAL_DMA_Init+0x760>)
20003e50:	4293      	cmp	r3, r2
20003e52:	d022      	beq.n	20003e9a <HAL_DMA_Init+0x6fe>
20003e54:	687b      	ldr	r3, [r7, #4]
20003e56:	681b      	ldr	r3, [r3, #0]
20003e58:	4a29      	ldr	r2, [pc, #164]	; (20003f00 <HAL_DMA_Init+0x764>)
20003e5a:	4293      	cmp	r3, r2
20003e5c:	d01d      	beq.n	20003e9a <HAL_DMA_Init+0x6fe>
20003e5e:	687b      	ldr	r3, [r7, #4]
20003e60:	681b      	ldr	r3, [r3, #0]
20003e62:	4a28      	ldr	r2, [pc, #160]	; (20003f04 <HAL_DMA_Init+0x768>)
20003e64:	4293      	cmp	r3, r2
20003e66:	d018      	beq.n	20003e9a <HAL_DMA_Init+0x6fe>
20003e68:	687b      	ldr	r3, [r7, #4]
20003e6a:	681b      	ldr	r3, [r3, #0]
20003e6c:	4a26      	ldr	r2, [pc, #152]	; (20003f08 <HAL_DMA_Init+0x76c>)
20003e6e:	4293      	cmp	r3, r2
20003e70:	d013      	beq.n	20003e9a <HAL_DMA_Init+0x6fe>
20003e72:	687b      	ldr	r3, [r7, #4]
20003e74:	681b      	ldr	r3, [r3, #0]
20003e76:	4a25      	ldr	r2, [pc, #148]	; (20003f0c <HAL_DMA_Init+0x770>)
20003e78:	4293      	cmp	r3, r2
20003e7a:	d00e      	beq.n	20003e9a <HAL_DMA_Init+0x6fe>
20003e7c:	687b      	ldr	r3, [r7, #4]
20003e7e:	681b      	ldr	r3, [r3, #0]
20003e80:	4a23      	ldr	r2, [pc, #140]	; (20003f10 <HAL_DMA_Init+0x774>)
20003e82:	4293      	cmp	r3, r2
20003e84:	d009      	beq.n	20003e9a <HAL_DMA_Init+0x6fe>
20003e86:	687b      	ldr	r3, [r7, #4]
20003e88:	681b      	ldr	r3, [r3, #0]
20003e8a:	4a22      	ldr	r2, [pc, #136]	; (20003f14 <HAL_DMA_Init+0x778>)
20003e8c:	4293      	cmp	r3, r2
20003e8e:	d004      	beq.n	20003e9a <HAL_DMA_Init+0x6fe>
20003e90:	687b      	ldr	r3, [r7, #4]
20003e92:	681b      	ldr	r3, [r3, #0]
20003e94:	4a20      	ldr	r2, [pc, #128]	; (20003f18 <HAL_DMA_Init+0x77c>)
20003e96:	4293      	cmp	r3, r2
20003e98:	d101      	bne.n	20003e9e <HAL_DMA_Init+0x702>
20003e9a:	2301      	movs	r3, #1
20003e9c:	e000      	b.n	20003ea0 <HAL_DMA_Init+0x704>
20003e9e:	2300      	movs	r3, #0
20003ea0:	2b00      	cmp	r3, #0
20003ea2:	d008      	beq.n	20003eb6 <HAL_DMA_Init+0x71a>
    {
      /* Check the request parameter */
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
20003ea4:	687b      	ldr	r3, [r7, #4]
20003ea6:	685b      	ldr	r3, [r3, #4]
20003ea8:	2b11      	cmp	r3, #17
20003eaa:	d904      	bls.n	20003eb6 <HAL_DMA_Init+0x71a>
20003eac:	f44f 71b3 	mov.w	r1, #358	; 0x166
20003eb0:	481a      	ldr	r0, [pc, #104]	; (20003f1c <HAL_DMA_Init+0x780>)
20003eb2:	f7fc fd1f 	bl	200008f4 <assert_failed>
    }

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
20003eb6:	687b      	ldr	r3, [r7, #4]
20003eb8:	2200      	movs	r2, #0
20003eba:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
20003ebe:	687b      	ldr	r3, [r7, #4]
20003ec0:	2202      	movs	r2, #2
20003ec2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Get the CR register value */
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
20003ec6:	687b      	ldr	r3, [r7, #4]
20003ec8:	681b      	ldr	r3, [r3, #0]
20003eca:	681b      	ldr	r3, [r3, #0]
20003ecc:	617b      	str	r3, [r7, #20]

    /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, MEM2MEM, DBM and CT bits */
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
20003ece:	697a      	ldr	r2, [r7, #20]
20003ed0:	4b13      	ldr	r3, [pc, #76]	; (20003f20 <HAL_DMA_Init+0x784>)
20003ed2:	4013      	ands	r3, r2
20003ed4:	617b      	str	r3, [r7, #20]
                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \
                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \
                                  BDMA_CCR_CT));

    /* Prepare the DMA Channel configuration */
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
20003ed6:	687b      	ldr	r3, [r7, #4]
20003ed8:	689b      	ldr	r3, [r3, #8]
20003eda:	2b40      	cmp	r3, #64	; 0x40
20003edc:	d022      	beq.n	20003f24 <HAL_DMA_Init+0x788>
20003ede:	687b      	ldr	r3, [r7, #4]
20003ee0:	689b      	ldr	r3, [r3, #8]
20003ee2:	2b80      	cmp	r3, #128	; 0x80
20003ee4:	d102      	bne.n	20003eec <HAL_DMA_Init+0x750>
20003ee6:	f44f 4380 	mov.w	r3, #16384	; 0x4000
20003eea:	e01c      	b.n	20003f26 <HAL_DMA_Init+0x78a>
20003eec:	2300      	movs	r3, #0
20003eee:	e01a      	b.n	20003f26 <HAL_DMA_Init+0x78a>
20003ef0:	fe10803f 	.word	0xfe10803f
20003ef4:	5c001000 	.word	0x5c001000
20003ef8:	ffff0000 	.word	0xffff0000
20003efc:	58025408 	.word	0x58025408
20003f00:	5802541c 	.word	0x5802541c
20003f04:	58025430 	.word	0x58025430
20003f08:	58025444 	.word	0x58025444
20003f0c:	58025458 	.word	0x58025458
20003f10:	5802546c 	.word	0x5802546c
20003f14:	58025480 	.word	0x58025480
20003f18:	58025494 	.word	0x58025494
20003f1c:	2001bfd4 	.word	0x2001bfd4
20003f20:	fffe000f 	.word	0xfffe000f
20003f24:	2310      	movs	r3, #16
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
20003f26:	687a      	ldr	r2, [r7, #4]
20003f28:	68d2      	ldr	r2, [r2, #12]
20003f2a:	08d2      	lsrs	r2, r2, #3
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
20003f2c:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
20003f2e:	687b      	ldr	r3, [r7, #4]
20003f30:	691b      	ldr	r3, [r3, #16]
20003f32:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
20003f34:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
20003f36:	687b      	ldr	r3, [r7, #4]
20003f38:	695b      	ldr	r3, [r3, #20]
20003f3a:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
20003f3c:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
20003f3e:	687b      	ldr	r3, [r7, #4]
20003f40:	699b      	ldr	r3, [r3, #24]
20003f42:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
20003f44:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
20003f46:	687b      	ldr	r3, [r7, #4]
20003f48:	69db      	ldr	r3, [r3, #28]
20003f4a:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
20003f4c:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
20003f4e:	687b      	ldr	r3, [r7, #4]
20003f50:	6a1b      	ldr	r3, [r3, #32]
20003f52:	091b      	lsrs	r3, r3, #4
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
20003f54:	4313      	orrs	r3, r2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
20003f56:	697a      	ldr	r2, [r7, #20]
20003f58:	4313      	orrs	r3, r2
20003f5a:	617b      	str	r3, [r7, #20]

    /* Write to DMA Channel CR register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
20003f5c:	687b      	ldr	r3, [r7, #4]
20003f5e:	681b      	ldr	r3, [r3, #0]
20003f60:	697a      	ldr	r2, [r7, #20]
20003f62:	601a      	str	r2, [r3, #0]

    /* calculation of the channel index */
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
20003f64:	687b      	ldr	r3, [r7, #4]
20003f66:	681b      	ldr	r3, [r3, #0]
20003f68:	461a      	mov	r2, r3
20003f6a:	4b6e      	ldr	r3, [pc, #440]	; (20004124 <HAL_DMA_Init+0x988>)
20003f6c:	4413      	add	r3, r2
20003f6e:	4a6e      	ldr	r2, [pc, #440]	; (20004128 <HAL_DMA_Init+0x98c>)
20003f70:	fba2 2303 	umull	r2, r3, r2, r3
20003f74:	091b      	lsrs	r3, r3, #4
20003f76:	009a      	lsls	r2, r3, #2
20003f78:	687b      	ldr	r3, [r7, #4]
20003f7a:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
20003f7c:	6878      	ldr	r0, [r7, #4]
20003f7e:	f003 f9d3 	bl	20007328 <DMA_CalcBaseAndBitshift>
20003f82:	4603      	mov	r3, r0
20003f84:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
20003f86:	687b      	ldr	r3, [r7, #4]
20003f88:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20003f8a:	f003 031f 	and.w	r3, r3, #31
20003f8e:	2201      	movs	r2, #1
20003f90:	409a      	lsls	r2, r3
20003f92:	68fb      	ldr	r3, [r7, #12]
20003f94:	605a      	str	r2, [r3, #4]
20003f96:	e008      	b.n	20003faa <HAL_DMA_Init+0x80e>
  }
  else
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
20003f98:	687b      	ldr	r3, [r7, #4]
20003f9a:	2240      	movs	r2, #64	; 0x40
20003f9c:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
20003f9e:	687b      	ldr	r3, [r7, #4]
20003fa0:	2203      	movs	r2, #3
20003fa2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    return HAL_ERROR;
20003fa6:	2301      	movs	r3, #1
20003fa8:	e0b7      	b.n	2000411a <HAL_DMA_Init+0x97e>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
20003faa:	687b      	ldr	r3, [r7, #4]
20003fac:	681b      	ldr	r3, [r3, #0]
20003fae:	4a5f      	ldr	r2, [pc, #380]	; (2000412c <HAL_DMA_Init+0x990>)
20003fb0:	4293      	cmp	r3, r2
20003fb2:	d072      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20003fb4:	687b      	ldr	r3, [r7, #4]
20003fb6:	681b      	ldr	r3, [r3, #0]
20003fb8:	4a5d      	ldr	r2, [pc, #372]	; (20004130 <HAL_DMA_Init+0x994>)
20003fba:	4293      	cmp	r3, r2
20003fbc:	d06d      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20003fbe:	687b      	ldr	r3, [r7, #4]
20003fc0:	681b      	ldr	r3, [r3, #0]
20003fc2:	4a5c      	ldr	r2, [pc, #368]	; (20004134 <HAL_DMA_Init+0x998>)
20003fc4:	4293      	cmp	r3, r2
20003fc6:	d068      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20003fc8:	687b      	ldr	r3, [r7, #4]
20003fca:	681b      	ldr	r3, [r3, #0]
20003fcc:	4a5a      	ldr	r2, [pc, #360]	; (20004138 <HAL_DMA_Init+0x99c>)
20003fce:	4293      	cmp	r3, r2
20003fd0:	d063      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20003fd2:	687b      	ldr	r3, [r7, #4]
20003fd4:	681b      	ldr	r3, [r3, #0]
20003fd6:	4a59      	ldr	r2, [pc, #356]	; (2000413c <HAL_DMA_Init+0x9a0>)
20003fd8:	4293      	cmp	r3, r2
20003fda:	d05e      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20003fdc:	687b      	ldr	r3, [r7, #4]
20003fde:	681b      	ldr	r3, [r3, #0]
20003fe0:	4a57      	ldr	r2, [pc, #348]	; (20004140 <HAL_DMA_Init+0x9a4>)
20003fe2:	4293      	cmp	r3, r2
20003fe4:	d059      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20003fe6:	687b      	ldr	r3, [r7, #4]
20003fe8:	681b      	ldr	r3, [r3, #0]
20003fea:	4a56      	ldr	r2, [pc, #344]	; (20004144 <HAL_DMA_Init+0x9a8>)
20003fec:	4293      	cmp	r3, r2
20003fee:	d054      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20003ff0:	687b      	ldr	r3, [r7, #4]
20003ff2:	681b      	ldr	r3, [r3, #0]
20003ff4:	4a54      	ldr	r2, [pc, #336]	; (20004148 <HAL_DMA_Init+0x9ac>)
20003ff6:	4293      	cmp	r3, r2
20003ff8:	d04f      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20003ffa:	687b      	ldr	r3, [r7, #4]
20003ffc:	681b      	ldr	r3, [r3, #0]
20003ffe:	4a53      	ldr	r2, [pc, #332]	; (2000414c <HAL_DMA_Init+0x9b0>)
20004000:	4293      	cmp	r3, r2
20004002:	d04a      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20004004:	687b      	ldr	r3, [r7, #4]
20004006:	681b      	ldr	r3, [r3, #0]
20004008:	4a51      	ldr	r2, [pc, #324]	; (20004150 <HAL_DMA_Init+0x9b4>)
2000400a:	4293      	cmp	r3, r2
2000400c:	d045      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
2000400e:	687b      	ldr	r3, [r7, #4]
20004010:	681b      	ldr	r3, [r3, #0]
20004012:	4a50      	ldr	r2, [pc, #320]	; (20004154 <HAL_DMA_Init+0x9b8>)
20004014:	4293      	cmp	r3, r2
20004016:	d040      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20004018:	687b      	ldr	r3, [r7, #4]
2000401a:	681b      	ldr	r3, [r3, #0]
2000401c:	4a4e      	ldr	r2, [pc, #312]	; (20004158 <HAL_DMA_Init+0x9bc>)
2000401e:	4293      	cmp	r3, r2
20004020:	d03b      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20004022:	687b      	ldr	r3, [r7, #4]
20004024:	681b      	ldr	r3, [r3, #0]
20004026:	4a4d      	ldr	r2, [pc, #308]	; (2000415c <HAL_DMA_Init+0x9c0>)
20004028:	4293      	cmp	r3, r2
2000402a:	d036      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
2000402c:	687b      	ldr	r3, [r7, #4]
2000402e:	681b      	ldr	r3, [r3, #0]
20004030:	4a4b      	ldr	r2, [pc, #300]	; (20004160 <HAL_DMA_Init+0x9c4>)
20004032:	4293      	cmp	r3, r2
20004034:	d031      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20004036:	687b      	ldr	r3, [r7, #4]
20004038:	681b      	ldr	r3, [r3, #0]
2000403a:	4a4a      	ldr	r2, [pc, #296]	; (20004164 <HAL_DMA_Init+0x9c8>)
2000403c:	4293      	cmp	r3, r2
2000403e:	d02c      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20004040:	687b      	ldr	r3, [r7, #4]
20004042:	681b      	ldr	r3, [r3, #0]
20004044:	4a48      	ldr	r2, [pc, #288]	; (20004168 <HAL_DMA_Init+0x9cc>)
20004046:	4293      	cmp	r3, r2
20004048:	d027      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
2000404a:	687b      	ldr	r3, [r7, #4]
2000404c:	681b      	ldr	r3, [r3, #0]
2000404e:	4a47      	ldr	r2, [pc, #284]	; (2000416c <HAL_DMA_Init+0x9d0>)
20004050:	4293      	cmp	r3, r2
20004052:	d022      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20004054:	687b      	ldr	r3, [r7, #4]
20004056:	681b      	ldr	r3, [r3, #0]
20004058:	4a45      	ldr	r2, [pc, #276]	; (20004170 <HAL_DMA_Init+0x9d4>)
2000405a:	4293      	cmp	r3, r2
2000405c:	d01d      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
2000405e:	687b      	ldr	r3, [r7, #4]
20004060:	681b      	ldr	r3, [r3, #0]
20004062:	4a44      	ldr	r2, [pc, #272]	; (20004174 <HAL_DMA_Init+0x9d8>)
20004064:	4293      	cmp	r3, r2
20004066:	d018      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20004068:	687b      	ldr	r3, [r7, #4]
2000406a:	681b      	ldr	r3, [r3, #0]
2000406c:	4a42      	ldr	r2, [pc, #264]	; (20004178 <HAL_DMA_Init+0x9dc>)
2000406e:	4293      	cmp	r3, r2
20004070:	d013      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20004072:	687b      	ldr	r3, [r7, #4]
20004074:	681b      	ldr	r3, [r3, #0]
20004076:	4a41      	ldr	r2, [pc, #260]	; (2000417c <HAL_DMA_Init+0x9e0>)
20004078:	4293      	cmp	r3, r2
2000407a:	d00e      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
2000407c:	687b      	ldr	r3, [r7, #4]
2000407e:	681b      	ldr	r3, [r3, #0]
20004080:	4a3f      	ldr	r2, [pc, #252]	; (20004180 <HAL_DMA_Init+0x9e4>)
20004082:	4293      	cmp	r3, r2
20004084:	d009      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20004086:	687b      	ldr	r3, [r7, #4]
20004088:	681b      	ldr	r3, [r3, #0]
2000408a:	4a3e      	ldr	r2, [pc, #248]	; (20004184 <HAL_DMA_Init+0x9e8>)
2000408c:	4293      	cmp	r3, r2
2000408e:	d004      	beq.n	2000409a <HAL_DMA_Init+0x8fe>
20004090:	687b      	ldr	r3, [r7, #4]
20004092:	681b      	ldr	r3, [r3, #0]
20004094:	4a3c      	ldr	r2, [pc, #240]	; (20004188 <HAL_DMA_Init+0x9ec>)
20004096:	4293      	cmp	r3, r2
20004098:	d101      	bne.n	2000409e <HAL_DMA_Init+0x902>
2000409a:	2301      	movs	r3, #1
2000409c:	e000      	b.n	200040a0 <HAL_DMA_Init+0x904>
2000409e:	2300      	movs	r3, #0
200040a0:	2b00      	cmp	r3, #0
200040a2:	d032      	beq.n	2000410a <HAL_DMA_Init+0x96e>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
    */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
200040a4:	6878      	ldr	r0, [r7, #4]
200040a6:	f003 fa6d 	bl	20007584 <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
200040aa:	687b      	ldr	r3, [r7, #4]
200040ac:	689b      	ldr	r3, [r3, #8]
200040ae:	2b80      	cmp	r3, #128	; 0x80
200040b0:	d102      	bne.n	200040b8 <HAL_DMA_Init+0x91c>
    {
      /* if memory to memory force the request to 0*/
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
200040b2:	687b      	ldr	r3, [r7, #4]
200040b4:	2200      	movs	r2, #0
200040b6:	605a      	str	r2, [r3, #4]
    }

    /* Set peripheral request  to DMAMUX channel */
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
200040b8:	687b      	ldr	r3, [r7, #4]
200040ba:	685a      	ldr	r2, [r3, #4]
200040bc:	687b      	ldr	r3, [r7, #4]
200040be:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200040c0:	b2d2      	uxtb	r2, r2
200040c2:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
200040c4:	687b      	ldr	r3, [r7, #4]
200040c6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
200040c8:	687a      	ldr	r2, [r7, #4]
200040ca:	6e92      	ldr	r2, [r2, #104]	; 0x68
200040cc:	605a      	str	r2, [r3, #4]

    /* Initialize parameters for DMAMUX request generator :
    if the DMA request is DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR7
    */
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
200040ce:	687b      	ldr	r3, [r7, #4]
200040d0:	685b      	ldr	r3, [r3, #4]
200040d2:	2b00      	cmp	r3, #0
200040d4:	d010      	beq.n	200040f8 <HAL_DMA_Init+0x95c>
200040d6:	687b      	ldr	r3, [r7, #4]
200040d8:	685b      	ldr	r3, [r3, #4]
200040da:	2b08      	cmp	r3, #8
200040dc:	d80c      	bhi.n	200040f8 <HAL_DMA_Init+0x95c>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
200040de:	6878      	ldr	r0, [r7, #4]
200040e0:	f003 faea 	bl	200076b8 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
200040e4:	687b      	ldr	r3, [r7, #4]
200040e6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
200040e8:	2200      	movs	r2, #0
200040ea:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
200040ec:	687b      	ldr	r3, [r7, #4]
200040ee:	6f1b      	ldr	r3, [r3, #112]	; 0x70
200040f0:	687a      	ldr	r2, [r7, #4]
200040f2:	6f52      	ldr	r2, [r2, #116]	; 0x74
200040f4:	605a      	str	r2, [r3, #4]
200040f6:	e008      	b.n	2000410a <HAL_DMA_Init+0x96e>
    }
    else
    {
      hdma->DMAmuxRequestGen = 0U;
200040f8:	687b      	ldr	r3, [r7, #4]
200040fa:	2200      	movs	r2, #0
200040fc:	66da      	str	r2, [r3, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatus = 0U;
200040fe:	687b      	ldr	r3, [r7, #4]
20004100:	2200      	movs	r2, #0
20004102:	671a      	str	r2, [r3, #112]	; 0x70
      hdma->DMAmuxRequestGenStatusMask = 0U;
20004104:	687b      	ldr	r3, [r7, #4]
20004106:	2200      	movs	r2, #0
20004108:	675a      	str	r2, [r3, #116]	; 0x74
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
2000410a:	687b      	ldr	r3, [r7, #4]
2000410c:	2200      	movs	r2, #0
2000410e:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
20004110:	687b      	ldr	r3, [r7, #4]
20004112:	2201      	movs	r2, #1
20004114:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
20004118:	2300      	movs	r3, #0
}
2000411a:	4618      	mov	r0, r3
2000411c:	3718      	adds	r7, #24
2000411e:	46bd      	mov	sp, r7
20004120:	bd80      	pop	{r7, pc}
20004122:	bf00      	nop
20004124:	a7fdabf8 	.word	0xa7fdabf8
20004128:	cccccccd 	.word	0xcccccccd
2000412c:	40020010 	.word	0x40020010
20004130:	40020028 	.word	0x40020028
20004134:	40020040 	.word	0x40020040
20004138:	40020058 	.word	0x40020058
2000413c:	40020070 	.word	0x40020070
20004140:	40020088 	.word	0x40020088
20004144:	400200a0 	.word	0x400200a0
20004148:	400200b8 	.word	0x400200b8
2000414c:	40020410 	.word	0x40020410
20004150:	40020428 	.word	0x40020428
20004154:	40020440 	.word	0x40020440
20004158:	40020458 	.word	0x40020458
2000415c:	40020470 	.word	0x40020470
20004160:	40020488 	.word	0x40020488
20004164:	400204a0 	.word	0x400204a0
20004168:	400204b8 	.word	0x400204b8
2000416c:	58025408 	.word	0x58025408
20004170:	5802541c 	.word	0x5802541c
20004174:	58025430 	.word	0x58025430
20004178:	58025444 	.word	0x58025444
2000417c:	58025458 	.word	0x58025458
20004180:	5802546c 	.word	0x5802546c
20004184:	58025480 	.word	0x58025480
20004188:	58025494 	.word	0x58025494

2000418c <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
2000418c:	b580      	push	{r7, lr}
2000418e:	b084      	sub	sp, #16
20004190:	af00      	add	r7, sp, #0
20004192:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
20004194:	687b      	ldr	r3, [r7, #4]
20004196:	2b00      	cmp	r3, #0
20004198:	d101      	bne.n	2000419e <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
2000419a:	2301      	movs	r3, #1
2000419c:	e225      	b.n	200045ea <HAL_DMA_DeInit+0x45e>
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
2000419e:	687b      	ldr	r3, [r7, #4]
200041a0:	681b      	ldr	r3, [r3, #0]
200041a2:	4a82      	ldr	r2, [pc, #520]	; (200043ac <HAL_DMA_DeInit+0x220>)
200041a4:	4293      	cmp	r3, r2
200041a6:	d04a      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
200041a8:	687b      	ldr	r3, [r7, #4]
200041aa:	681b      	ldr	r3, [r3, #0]
200041ac:	4a80      	ldr	r2, [pc, #512]	; (200043b0 <HAL_DMA_DeInit+0x224>)
200041ae:	4293      	cmp	r3, r2
200041b0:	d045      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
200041b2:	687b      	ldr	r3, [r7, #4]
200041b4:	681b      	ldr	r3, [r3, #0]
200041b6:	4a7f      	ldr	r2, [pc, #508]	; (200043b4 <HAL_DMA_DeInit+0x228>)
200041b8:	4293      	cmp	r3, r2
200041ba:	d040      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
200041bc:	687b      	ldr	r3, [r7, #4]
200041be:	681b      	ldr	r3, [r3, #0]
200041c0:	4a7d      	ldr	r2, [pc, #500]	; (200043b8 <HAL_DMA_DeInit+0x22c>)
200041c2:	4293      	cmp	r3, r2
200041c4:	d03b      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
200041c6:	687b      	ldr	r3, [r7, #4]
200041c8:	681b      	ldr	r3, [r3, #0]
200041ca:	4a7c      	ldr	r2, [pc, #496]	; (200043bc <HAL_DMA_DeInit+0x230>)
200041cc:	4293      	cmp	r3, r2
200041ce:	d036      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
200041d0:	687b      	ldr	r3, [r7, #4]
200041d2:	681b      	ldr	r3, [r3, #0]
200041d4:	4a7a      	ldr	r2, [pc, #488]	; (200043c0 <HAL_DMA_DeInit+0x234>)
200041d6:	4293      	cmp	r3, r2
200041d8:	d031      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
200041da:	687b      	ldr	r3, [r7, #4]
200041dc:	681b      	ldr	r3, [r3, #0]
200041de:	4a79      	ldr	r2, [pc, #484]	; (200043c4 <HAL_DMA_DeInit+0x238>)
200041e0:	4293      	cmp	r3, r2
200041e2:	d02c      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
200041e4:	687b      	ldr	r3, [r7, #4]
200041e6:	681b      	ldr	r3, [r3, #0]
200041e8:	4a77      	ldr	r2, [pc, #476]	; (200043c8 <HAL_DMA_DeInit+0x23c>)
200041ea:	4293      	cmp	r3, r2
200041ec:	d027      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
200041ee:	687b      	ldr	r3, [r7, #4]
200041f0:	681b      	ldr	r3, [r3, #0]
200041f2:	4a76      	ldr	r2, [pc, #472]	; (200043cc <HAL_DMA_DeInit+0x240>)
200041f4:	4293      	cmp	r3, r2
200041f6:	d022      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
200041f8:	687b      	ldr	r3, [r7, #4]
200041fa:	681b      	ldr	r3, [r3, #0]
200041fc:	4a74      	ldr	r2, [pc, #464]	; (200043d0 <HAL_DMA_DeInit+0x244>)
200041fe:	4293      	cmp	r3, r2
20004200:	d01d      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
20004202:	687b      	ldr	r3, [r7, #4]
20004204:	681b      	ldr	r3, [r3, #0]
20004206:	4a73      	ldr	r2, [pc, #460]	; (200043d4 <HAL_DMA_DeInit+0x248>)
20004208:	4293      	cmp	r3, r2
2000420a:	d018      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
2000420c:	687b      	ldr	r3, [r7, #4]
2000420e:	681b      	ldr	r3, [r3, #0]
20004210:	4a71      	ldr	r2, [pc, #452]	; (200043d8 <HAL_DMA_DeInit+0x24c>)
20004212:	4293      	cmp	r3, r2
20004214:	d013      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
20004216:	687b      	ldr	r3, [r7, #4]
20004218:	681b      	ldr	r3, [r3, #0]
2000421a:	4a70      	ldr	r2, [pc, #448]	; (200043dc <HAL_DMA_DeInit+0x250>)
2000421c:	4293      	cmp	r3, r2
2000421e:	d00e      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
20004220:	687b      	ldr	r3, [r7, #4]
20004222:	681b      	ldr	r3, [r3, #0]
20004224:	4a6e      	ldr	r2, [pc, #440]	; (200043e0 <HAL_DMA_DeInit+0x254>)
20004226:	4293      	cmp	r3, r2
20004228:	d009      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
2000422a:	687b      	ldr	r3, [r7, #4]
2000422c:	681b      	ldr	r3, [r3, #0]
2000422e:	4a6d      	ldr	r2, [pc, #436]	; (200043e4 <HAL_DMA_DeInit+0x258>)
20004230:	4293      	cmp	r3, r2
20004232:	d004      	beq.n	2000423e <HAL_DMA_DeInit+0xb2>
20004234:	687b      	ldr	r3, [r7, #4]
20004236:	681b      	ldr	r3, [r3, #0]
20004238:	4a6b      	ldr	r2, [pc, #428]	; (200043e8 <HAL_DMA_DeInit+0x25c>)
2000423a:	4293      	cmp	r3, r2
2000423c:	d108      	bne.n	20004250 <HAL_DMA_DeInit+0xc4>
2000423e:	687b      	ldr	r3, [r7, #4]
20004240:	681b      	ldr	r3, [r3, #0]
20004242:	681a      	ldr	r2, [r3, #0]
20004244:	687b      	ldr	r3, [r7, #4]
20004246:	681b      	ldr	r3, [r3, #0]
20004248:	f022 0201 	bic.w	r2, r2, #1
2000424c:	601a      	str	r2, [r3, #0]
2000424e:	e007      	b.n	20004260 <HAL_DMA_DeInit+0xd4>
20004250:	687b      	ldr	r3, [r7, #4]
20004252:	681b      	ldr	r3, [r3, #0]
20004254:	681a      	ldr	r2, [r3, #0]
20004256:	687b      	ldr	r3, [r7, #4]
20004258:	681b      	ldr	r3, [r3, #0]
2000425a:	f022 0201 	bic.w	r2, r2, #1
2000425e:	601a      	str	r2, [r3, #0]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20004260:	687b      	ldr	r3, [r7, #4]
20004262:	681b      	ldr	r3, [r3, #0]
20004264:	4a51      	ldr	r2, [pc, #324]	; (200043ac <HAL_DMA_DeInit+0x220>)
20004266:	4293      	cmp	r3, r2
20004268:	d04a      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
2000426a:	687b      	ldr	r3, [r7, #4]
2000426c:	681b      	ldr	r3, [r3, #0]
2000426e:	4a50      	ldr	r2, [pc, #320]	; (200043b0 <HAL_DMA_DeInit+0x224>)
20004270:	4293      	cmp	r3, r2
20004272:	d045      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
20004274:	687b      	ldr	r3, [r7, #4]
20004276:	681b      	ldr	r3, [r3, #0]
20004278:	4a4e      	ldr	r2, [pc, #312]	; (200043b4 <HAL_DMA_DeInit+0x228>)
2000427a:	4293      	cmp	r3, r2
2000427c:	d040      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
2000427e:	687b      	ldr	r3, [r7, #4]
20004280:	681b      	ldr	r3, [r3, #0]
20004282:	4a4d      	ldr	r2, [pc, #308]	; (200043b8 <HAL_DMA_DeInit+0x22c>)
20004284:	4293      	cmp	r3, r2
20004286:	d03b      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
20004288:	687b      	ldr	r3, [r7, #4]
2000428a:	681b      	ldr	r3, [r3, #0]
2000428c:	4a4b      	ldr	r2, [pc, #300]	; (200043bc <HAL_DMA_DeInit+0x230>)
2000428e:	4293      	cmp	r3, r2
20004290:	d036      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
20004292:	687b      	ldr	r3, [r7, #4]
20004294:	681b      	ldr	r3, [r3, #0]
20004296:	4a4a      	ldr	r2, [pc, #296]	; (200043c0 <HAL_DMA_DeInit+0x234>)
20004298:	4293      	cmp	r3, r2
2000429a:	d031      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
2000429c:	687b      	ldr	r3, [r7, #4]
2000429e:	681b      	ldr	r3, [r3, #0]
200042a0:	4a48      	ldr	r2, [pc, #288]	; (200043c4 <HAL_DMA_DeInit+0x238>)
200042a2:	4293      	cmp	r3, r2
200042a4:	d02c      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
200042a6:	687b      	ldr	r3, [r7, #4]
200042a8:	681b      	ldr	r3, [r3, #0]
200042aa:	4a47      	ldr	r2, [pc, #284]	; (200043c8 <HAL_DMA_DeInit+0x23c>)
200042ac:	4293      	cmp	r3, r2
200042ae:	d027      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
200042b0:	687b      	ldr	r3, [r7, #4]
200042b2:	681b      	ldr	r3, [r3, #0]
200042b4:	4a45      	ldr	r2, [pc, #276]	; (200043cc <HAL_DMA_DeInit+0x240>)
200042b6:	4293      	cmp	r3, r2
200042b8:	d022      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
200042ba:	687b      	ldr	r3, [r7, #4]
200042bc:	681b      	ldr	r3, [r3, #0]
200042be:	4a44      	ldr	r2, [pc, #272]	; (200043d0 <HAL_DMA_DeInit+0x244>)
200042c0:	4293      	cmp	r3, r2
200042c2:	d01d      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
200042c4:	687b      	ldr	r3, [r7, #4]
200042c6:	681b      	ldr	r3, [r3, #0]
200042c8:	4a42      	ldr	r2, [pc, #264]	; (200043d4 <HAL_DMA_DeInit+0x248>)
200042ca:	4293      	cmp	r3, r2
200042cc:	d018      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
200042ce:	687b      	ldr	r3, [r7, #4]
200042d0:	681b      	ldr	r3, [r3, #0]
200042d2:	4a41      	ldr	r2, [pc, #260]	; (200043d8 <HAL_DMA_DeInit+0x24c>)
200042d4:	4293      	cmp	r3, r2
200042d6:	d013      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
200042d8:	687b      	ldr	r3, [r7, #4]
200042da:	681b      	ldr	r3, [r3, #0]
200042dc:	4a3f      	ldr	r2, [pc, #252]	; (200043dc <HAL_DMA_DeInit+0x250>)
200042de:	4293      	cmp	r3, r2
200042e0:	d00e      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
200042e2:	687b      	ldr	r3, [r7, #4]
200042e4:	681b      	ldr	r3, [r3, #0]
200042e6:	4a3e      	ldr	r2, [pc, #248]	; (200043e0 <HAL_DMA_DeInit+0x254>)
200042e8:	4293      	cmp	r3, r2
200042ea:	d009      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
200042ec:	687b      	ldr	r3, [r7, #4]
200042ee:	681b      	ldr	r3, [r3, #0]
200042f0:	4a3c      	ldr	r2, [pc, #240]	; (200043e4 <HAL_DMA_DeInit+0x258>)
200042f2:	4293      	cmp	r3, r2
200042f4:	d004      	beq.n	20004300 <HAL_DMA_DeInit+0x174>
200042f6:	687b      	ldr	r3, [r7, #4]
200042f8:	681b      	ldr	r3, [r3, #0]
200042fa:	4a3b      	ldr	r2, [pc, #236]	; (200043e8 <HAL_DMA_DeInit+0x25c>)
200042fc:	4293      	cmp	r3, r2
200042fe:	d101      	bne.n	20004304 <HAL_DMA_DeInit+0x178>
20004300:	2301      	movs	r3, #1
20004302:	e000      	b.n	20004306 <HAL_DMA_DeInit+0x17a>
20004304:	2300      	movs	r3, #0
20004306:	2b00      	cmp	r3, #0
20004308:	d025      	beq.n	20004356 <HAL_DMA_DeInit+0x1ca>
  {
    /* Reset DMA Streamx control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
2000430a:	687b      	ldr	r3, [r7, #4]
2000430c:	681b      	ldr	r3, [r3, #0]
2000430e:	2200      	movs	r2, #0
20004310:	601a      	str	r2, [r3, #0]

    /* Reset DMA Streamx number of data to transfer register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
20004312:	687b      	ldr	r3, [r7, #4]
20004314:	681b      	ldr	r3, [r3, #0]
20004316:	2200      	movs	r2, #0
20004318:	605a      	str	r2, [r3, #4]

    /* Reset DMA Streamx peripheral address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
2000431a:	687b      	ldr	r3, [r7, #4]
2000431c:	681b      	ldr	r3, [r3, #0]
2000431e:	2200      	movs	r2, #0
20004320:	609a      	str	r2, [r3, #8]

    /* Reset DMA Streamx memory 0 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
20004322:	687b      	ldr	r3, [r7, #4]
20004324:	681b      	ldr	r3, [r3, #0]
20004326:	2200      	movs	r2, #0
20004328:	60da      	str	r2, [r3, #12]

    /* Reset DMA Streamx memory 1 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
2000432a:	687b      	ldr	r3, [r7, #4]
2000432c:	681b      	ldr	r3, [r3, #0]
2000432e:	2200      	movs	r2, #0
20004330:	611a      	str	r2, [r3, #16]

    /* Reset DMA Streamx FIFO control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
20004332:	687b      	ldr	r3, [r7, #4]
20004334:	681b      	ldr	r3, [r3, #0]
20004336:	2221      	movs	r2, #33	; 0x21
20004338:	615a      	str	r2, [r3, #20]

    /* Get DMA steam Base Address */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
2000433a:	6878      	ldr	r0, [r7, #4]
2000433c:	f002 fff4 	bl	20007328 <DMA_CalcBaseAndBitshift>
20004340:	4603      	mov	r3, r0
20004342:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
20004344:	687b      	ldr	r3, [r7, #4]
20004346:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20004348:	f003 031f 	and.w	r3, r3, #31
2000434c:	223f      	movs	r2, #63	; 0x3f
2000434e:	409a      	lsls	r2, r3
20004350:	68bb      	ldr	r3, [r7, #8]
20004352:	609a      	str	r2, [r3, #8]
20004354:	e081      	b.n	2000445a <HAL_DMA_DeInit+0x2ce>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
20004356:	687b      	ldr	r3, [r7, #4]
20004358:	681b      	ldr	r3, [r3, #0]
2000435a:	4a24      	ldr	r2, [pc, #144]	; (200043ec <HAL_DMA_DeInit+0x260>)
2000435c:	4293      	cmp	r3, r2
2000435e:	d022      	beq.n	200043a6 <HAL_DMA_DeInit+0x21a>
20004360:	687b      	ldr	r3, [r7, #4]
20004362:	681b      	ldr	r3, [r3, #0]
20004364:	4a22      	ldr	r2, [pc, #136]	; (200043f0 <HAL_DMA_DeInit+0x264>)
20004366:	4293      	cmp	r3, r2
20004368:	d01d      	beq.n	200043a6 <HAL_DMA_DeInit+0x21a>
2000436a:	687b      	ldr	r3, [r7, #4]
2000436c:	681b      	ldr	r3, [r3, #0]
2000436e:	4a21      	ldr	r2, [pc, #132]	; (200043f4 <HAL_DMA_DeInit+0x268>)
20004370:	4293      	cmp	r3, r2
20004372:	d018      	beq.n	200043a6 <HAL_DMA_DeInit+0x21a>
20004374:	687b      	ldr	r3, [r7, #4]
20004376:	681b      	ldr	r3, [r3, #0]
20004378:	4a1f      	ldr	r2, [pc, #124]	; (200043f8 <HAL_DMA_DeInit+0x26c>)
2000437a:	4293      	cmp	r3, r2
2000437c:	d013      	beq.n	200043a6 <HAL_DMA_DeInit+0x21a>
2000437e:	687b      	ldr	r3, [r7, #4]
20004380:	681b      	ldr	r3, [r3, #0]
20004382:	4a1e      	ldr	r2, [pc, #120]	; (200043fc <HAL_DMA_DeInit+0x270>)
20004384:	4293      	cmp	r3, r2
20004386:	d00e      	beq.n	200043a6 <HAL_DMA_DeInit+0x21a>
20004388:	687b      	ldr	r3, [r7, #4]
2000438a:	681b      	ldr	r3, [r3, #0]
2000438c:	4a1c      	ldr	r2, [pc, #112]	; (20004400 <HAL_DMA_DeInit+0x274>)
2000438e:	4293      	cmp	r3, r2
20004390:	d009      	beq.n	200043a6 <HAL_DMA_DeInit+0x21a>
20004392:	687b      	ldr	r3, [r7, #4]
20004394:	681b      	ldr	r3, [r3, #0]
20004396:	4a1b      	ldr	r2, [pc, #108]	; (20004404 <HAL_DMA_DeInit+0x278>)
20004398:	4293      	cmp	r3, r2
2000439a:	d004      	beq.n	200043a6 <HAL_DMA_DeInit+0x21a>
2000439c:	687b      	ldr	r3, [r7, #4]
2000439e:	681b      	ldr	r3, [r3, #0]
200043a0:	4a19      	ldr	r2, [pc, #100]	; (20004408 <HAL_DMA_DeInit+0x27c>)
200043a2:	4293      	cmp	r3, r2
200043a4:	d132      	bne.n	2000440c <HAL_DMA_DeInit+0x280>
200043a6:	2301      	movs	r3, #1
200043a8:	e031      	b.n	2000440e <HAL_DMA_DeInit+0x282>
200043aa:	bf00      	nop
200043ac:	40020010 	.word	0x40020010
200043b0:	40020028 	.word	0x40020028
200043b4:	40020040 	.word	0x40020040
200043b8:	40020058 	.word	0x40020058
200043bc:	40020070 	.word	0x40020070
200043c0:	40020088 	.word	0x40020088
200043c4:	400200a0 	.word	0x400200a0
200043c8:	400200b8 	.word	0x400200b8
200043cc:	40020410 	.word	0x40020410
200043d0:	40020428 	.word	0x40020428
200043d4:	40020440 	.word	0x40020440
200043d8:	40020458 	.word	0x40020458
200043dc:	40020470 	.word	0x40020470
200043e0:	40020488 	.word	0x40020488
200043e4:	400204a0 	.word	0x400204a0
200043e8:	400204b8 	.word	0x400204b8
200043ec:	58025408 	.word	0x58025408
200043f0:	5802541c 	.word	0x5802541c
200043f4:	58025430 	.word	0x58025430
200043f8:	58025444 	.word	0x58025444
200043fc:	58025458 	.word	0x58025458
20004400:	5802546c 	.word	0x5802546c
20004404:	58025480 	.word	0x58025480
20004408:	58025494 	.word	0x58025494
2000440c:	2300      	movs	r3, #0
2000440e:	2b00      	cmp	r3, #0
20004410:	d021      	beq.n	20004456 <HAL_DMA_DeInit+0x2ca>
  {
    /* Reset DMA Channel control register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
20004412:	687b      	ldr	r3, [r7, #4]
20004414:	681b      	ldr	r3, [r3, #0]
20004416:	2200      	movs	r2, #0
20004418:	601a      	str	r2, [r3, #0]

    /* Reset DMA Channel Number of Data to Transfer register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
2000441a:	687b      	ldr	r3, [r7, #4]
2000441c:	681b      	ldr	r3, [r3, #0]
2000441e:	2200      	movs	r2, #0
20004420:	605a      	str	r2, [r3, #4]

    /* Reset DMA Channel peripheral address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
20004422:	687b      	ldr	r3, [r7, #4]
20004424:	681b      	ldr	r3, [r3, #0]
20004426:	2200      	movs	r2, #0
20004428:	609a      	str	r2, [r3, #8]

    /* Reset DMA Channel memory 0 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
2000442a:	687b      	ldr	r3, [r7, #4]
2000442c:	681b      	ldr	r3, [r3, #0]
2000442e:	2200      	movs	r2, #0
20004430:	60da      	str	r2, [r3, #12]

    /* Reset DMA Channel memory 1 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
20004432:	687b      	ldr	r3, [r7, #4]
20004434:	681b      	ldr	r3, [r3, #0]
20004436:	2200      	movs	r2, #0
20004438:	611a      	str	r2, [r3, #16]

    /* Get DMA steam Base Address */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
2000443a:	6878      	ldr	r0, [r7, #4]
2000443c:	f002 ff74 	bl	20007328 <DMA_CalcBaseAndBitshift>
20004440:	4603      	mov	r3, r0
20004442:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags at correct offset within the register */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
20004444:	687b      	ldr	r3, [r7, #4]
20004446:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20004448:	f003 031f 	and.w	r3, r3, #31
2000444c:	2201      	movs	r2, #1
2000444e:	409a      	lsls	r2, r3
20004450:	68fb      	ldr	r3, [r7, #12]
20004452:	605a      	str	r2, [r3, #4]
20004454:	e001      	b.n	2000445a <HAL_DMA_DeInit+0x2ce>
  }
  else
  {
    /* Return error status */
    return HAL_ERROR;
20004456:	2301      	movs	r3, #1
20004458:	e0c7      	b.n	200045ea <HAL_DMA_DeInit+0x45e>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2000445a:	687b      	ldr	r3, [r7, #4]
2000445c:	681b      	ldr	r3, [r3, #0]
2000445e:	4a65      	ldr	r2, [pc, #404]	; (200045f4 <HAL_DMA_DeInit+0x468>)
20004460:	4293      	cmp	r3, r2
20004462:	d072      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
20004464:	687b      	ldr	r3, [r7, #4]
20004466:	681b      	ldr	r3, [r3, #0]
20004468:	4a63      	ldr	r2, [pc, #396]	; (200045f8 <HAL_DMA_DeInit+0x46c>)
2000446a:	4293      	cmp	r3, r2
2000446c:	d06d      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
2000446e:	687b      	ldr	r3, [r7, #4]
20004470:	681b      	ldr	r3, [r3, #0]
20004472:	4a62      	ldr	r2, [pc, #392]	; (200045fc <HAL_DMA_DeInit+0x470>)
20004474:	4293      	cmp	r3, r2
20004476:	d068      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
20004478:	687b      	ldr	r3, [r7, #4]
2000447a:	681b      	ldr	r3, [r3, #0]
2000447c:	4a60      	ldr	r2, [pc, #384]	; (20004600 <HAL_DMA_DeInit+0x474>)
2000447e:	4293      	cmp	r3, r2
20004480:	d063      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
20004482:	687b      	ldr	r3, [r7, #4]
20004484:	681b      	ldr	r3, [r3, #0]
20004486:	4a5f      	ldr	r2, [pc, #380]	; (20004604 <HAL_DMA_DeInit+0x478>)
20004488:	4293      	cmp	r3, r2
2000448a:	d05e      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
2000448c:	687b      	ldr	r3, [r7, #4]
2000448e:	681b      	ldr	r3, [r3, #0]
20004490:	4a5d      	ldr	r2, [pc, #372]	; (20004608 <HAL_DMA_DeInit+0x47c>)
20004492:	4293      	cmp	r3, r2
20004494:	d059      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
20004496:	687b      	ldr	r3, [r7, #4]
20004498:	681b      	ldr	r3, [r3, #0]
2000449a:	4a5c      	ldr	r2, [pc, #368]	; (2000460c <HAL_DMA_DeInit+0x480>)
2000449c:	4293      	cmp	r3, r2
2000449e:	d054      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
200044a0:	687b      	ldr	r3, [r7, #4]
200044a2:	681b      	ldr	r3, [r3, #0]
200044a4:	4a5a      	ldr	r2, [pc, #360]	; (20004610 <HAL_DMA_DeInit+0x484>)
200044a6:	4293      	cmp	r3, r2
200044a8:	d04f      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
200044aa:	687b      	ldr	r3, [r7, #4]
200044ac:	681b      	ldr	r3, [r3, #0]
200044ae:	4a59      	ldr	r2, [pc, #356]	; (20004614 <HAL_DMA_DeInit+0x488>)
200044b0:	4293      	cmp	r3, r2
200044b2:	d04a      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
200044b4:	687b      	ldr	r3, [r7, #4]
200044b6:	681b      	ldr	r3, [r3, #0]
200044b8:	4a57      	ldr	r2, [pc, #348]	; (20004618 <HAL_DMA_DeInit+0x48c>)
200044ba:	4293      	cmp	r3, r2
200044bc:	d045      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
200044be:	687b      	ldr	r3, [r7, #4]
200044c0:	681b      	ldr	r3, [r3, #0]
200044c2:	4a56      	ldr	r2, [pc, #344]	; (2000461c <HAL_DMA_DeInit+0x490>)
200044c4:	4293      	cmp	r3, r2
200044c6:	d040      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
200044c8:	687b      	ldr	r3, [r7, #4]
200044ca:	681b      	ldr	r3, [r3, #0]
200044cc:	4a54      	ldr	r2, [pc, #336]	; (20004620 <HAL_DMA_DeInit+0x494>)
200044ce:	4293      	cmp	r3, r2
200044d0:	d03b      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
200044d2:	687b      	ldr	r3, [r7, #4]
200044d4:	681b      	ldr	r3, [r3, #0]
200044d6:	4a53      	ldr	r2, [pc, #332]	; (20004624 <HAL_DMA_DeInit+0x498>)
200044d8:	4293      	cmp	r3, r2
200044da:	d036      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
200044dc:	687b      	ldr	r3, [r7, #4]
200044de:	681b      	ldr	r3, [r3, #0]
200044e0:	4a51      	ldr	r2, [pc, #324]	; (20004628 <HAL_DMA_DeInit+0x49c>)
200044e2:	4293      	cmp	r3, r2
200044e4:	d031      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
200044e6:	687b      	ldr	r3, [r7, #4]
200044e8:	681b      	ldr	r3, [r3, #0]
200044ea:	4a50      	ldr	r2, [pc, #320]	; (2000462c <HAL_DMA_DeInit+0x4a0>)
200044ec:	4293      	cmp	r3, r2
200044ee:	d02c      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
200044f0:	687b      	ldr	r3, [r7, #4]
200044f2:	681b      	ldr	r3, [r3, #0]
200044f4:	4a4e      	ldr	r2, [pc, #312]	; (20004630 <HAL_DMA_DeInit+0x4a4>)
200044f6:	4293      	cmp	r3, r2
200044f8:	d027      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
200044fa:	687b      	ldr	r3, [r7, #4]
200044fc:	681b      	ldr	r3, [r3, #0]
200044fe:	4a4d      	ldr	r2, [pc, #308]	; (20004634 <HAL_DMA_DeInit+0x4a8>)
20004500:	4293      	cmp	r3, r2
20004502:	d022      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
20004504:	687b      	ldr	r3, [r7, #4]
20004506:	681b      	ldr	r3, [r3, #0]
20004508:	4a4b      	ldr	r2, [pc, #300]	; (20004638 <HAL_DMA_DeInit+0x4ac>)
2000450a:	4293      	cmp	r3, r2
2000450c:	d01d      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
2000450e:	687b      	ldr	r3, [r7, #4]
20004510:	681b      	ldr	r3, [r3, #0]
20004512:	4a4a      	ldr	r2, [pc, #296]	; (2000463c <HAL_DMA_DeInit+0x4b0>)
20004514:	4293      	cmp	r3, r2
20004516:	d018      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
20004518:	687b      	ldr	r3, [r7, #4]
2000451a:	681b      	ldr	r3, [r3, #0]
2000451c:	4a48      	ldr	r2, [pc, #288]	; (20004640 <HAL_DMA_DeInit+0x4b4>)
2000451e:	4293      	cmp	r3, r2
20004520:	d013      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
20004522:	687b      	ldr	r3, [r7, #4]
20004524:	681b      	ldr	r3, [r3, #0]
20004526:	4a47      	ldr	r2, [pc, #284]	; (20004644 <HAL_DMA_DeInit+0x4b8>)
20004528:	4293      	cmp	r3, r2
2000452a:	d00e      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
2000452c:	687b      	ldr	r3, [r7, #4]
2000452e:	681b      	ldr	r3, [r3, #0]
20004530:	4a45      	ldr	r2, [pc, #276]	; (20004648 <HAL_DMA_DeInit+0x4bc>)
20004532:	4293      	cmp	r3, r2
20004534:	d009      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
20004536:	687b      	ldr	r3, [r7, #4]
20004538:	681b      	ldr	r3, [r3, #0]
2000453a:	4a44      	ldr	r2, [pc, #272]	; (2000464c <HAL_DMA_DeInit+0x4c0>)
2000453c:	4293      	cmp	r3, r2
2000453e:	d004      	beq.n	2000454a <HAL_DMA_DeInit+0x3be>
20004540:	687b      	ldr	r3, [r7, #4]
20004542:	681b      	ldr	r3, [r3, #0]
20004544:	4a42      	ldr	r2, [pc, #264]	; (20004650 <HAL_DMA_DeInit+0x4c4>)
20004546:	4293      	cmp	r3, r2
20004548:	d101      	bne.n	2000454e <HAL_DMA_DeInit+0x3c2>
2000454a:	2301      	movs	r3, #1
2000454c:	e000      	b.n	20004550 <HAL_DMA_DeInit+0x3c4>
2000454e:	2300      	movs	r3, #0
20004550:	2b00      	cmp	r3, #0
20004552:	d02c      	beq.n	200045ae <HAL_DMA_DeInit+0x422>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
20004554:	6878      	ldr	r0, [r7, #4]
20004556:	f003 f815 	bl	20007584 <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->DMAmuxChannel != 0U)
2000455a:	687b      	ldr	r3, [r7, #4]
2000455c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2000455e:	2b00      	cmp	r3, #0
20004560:	d008      	beq.n	20004574 <HAL_DMA_DeInit+0x3e8>
    {
      /* Resett he DMAMUX channel that corresponds to the DMA stream */
      hdma->DMAmuxChannel->CCR = 0U;
20004562:	687b      	ldr	r3, [r7, #4]
20004564:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20004566:	2200      	movs	r2, #0
20004568:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
2000456a:	687b      	ldr	r3, [r7, #4]
2000456c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2000456e:	687a      	ldr	r2, [r7, #4]
20004570:	6e92      	ldr	r2, [r2, #104]	; 0x68
20004572:	605a      	str	r2, [r3, #4]
    }

    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
20004574:	687b      	ldr	r3, [r7, #4]
20004576:	685b      	ldr	r3, [r3, #4]
20004578:	2b00      	cmp	r3, #0
2000457a:	d00f      	beq.n	2000459c <HAL_DMA_DeInit+0x410>
2000457c:	687b      	ldr	r3, [r7, #4]
2000457e:	685b      	ldr	r3, [r3, #4]
20004580:	2b08      	cmp	r3, #8
20004582:	d80b      	bhi.n	2000459c <HAL_DMA_DeInit+0x410>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
20004584:	6878      	ldr	r0, [r7, #4]
20004586:	f003 f897 	bl	200076b8 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
2000458a:	687b      	ldr	r3, [r7, #4]
2000458c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2000458e:	2200      	movs	r2, #0
20004590:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
20004592:	687b      	ldr	r3, [r7, #4]
20004594:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20004596:	687a      	ldr	r2, [r7, #4]
20004598:	6f52      	ldr	r2, [r2, #116]	; 0x74
2000459a:	605a      	str	r2, [r3, #4]
    }

    hdma->DMAmuxRequestGen = 0U;
2000459c:	687b      	ldr	r3, [r7, #4]
2000459e:	2200      	movs	r2, #0
200045a0:	66da      	str	r2, [r3, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatus = 0U;
200045a2:	687b      	ldr	r3, [r7, #4]
200045a4:	2200      	movs	r2, #0
200045a6:	671a      	str	r2, [r3, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 0U;
200045a8:	687b      	ldr	r3, [r7, #4]
200045aa:	2200      	movs	r2, #0
200045ac:	675a      	str	r2, [r3, #116]	; 0x74
  }


  /* Clean callbacks */
  hdma->XferCpltCallback       = NULL;
200045ae:	687b      	ldr	r3, [r7, #4]
200045b0:	2200      	movs	r2, #0
200045b2:	63da      	str	r2, [r3, #60]	; 0x3c
  hdma->XferHalfCpltCallback   = NULL;
200045b4:	687b      	ldr	r3, [r7, #4]
200045b6:	2200      	movs	r2, #0
200045b8:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->XferM1CpltCallback     = NULL;
200045ba:	687b      	ldr	r3, [r7, #4]
200045bc:	2200      	movs	r2, #0
200045be:	645a      	str	r2, [r3, #68]	; 0x44
  hdma->XferM1HalfCpltCallback = NULL;
200045c0:	687b      	ldr	r3, [r7, #4]
200045c2:	2200      	movs	r2, #0
200045c4:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->XferErrorCallback      = NULL;
200045c6:	687b      	ldr	r3, [r7, #4]
200045c8:	2200      	movs	r2, #0
200045ca:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->XferAbortCallback      = NULL;
200045cc:	687b      	ldr	r3, [r7, #4]
200045ce:	2200      	movs	r2, #0
200045d0:	651a      	str	r2, [r3, #80]	; 0x50

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
200045d2:	687b      	ldr	r3, [r7, #4]
200045d4:	2200      	movs	r2, #0
200045d6:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
200045d8:	687b      	ldr	r3, [r7, #4]
200045da:	2200      	movs	r2, #0
200045dc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
200045e0:	687b      	ldr	r3, [r7, #4]
200045e2:	2200      	movs	r2, #0
200045e4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
200045e8:	2300      	movs	r3, #0
}
200045ea:	4618      	mov	r0, r3
200045ec:	3710      	adds	r7, #16
200045ee:	46bd      	mov	sp, r7
200045f0:	bd80      	pop	{r7, pc}
200045f2:	bf00      	nop
200045f4:	40020010 	.word	0x40020010
200045f8:	40020028 	.word	0x40020028
200045fc:	40020040 	.word	0x40020040
20004600:	40020058 	.word	0x40020058
20004604:	40020070 	.word	0x40020070
20004608:	40020088 	.word	0x40020088
2000460c:	400200a0 	.word	0x400200a0
20004610:	400200b8 	.word	0x400200b8
20004614:	40020410 	.word	0x40020410
20004618:	40020428 	.word	0x40020428
2000461c:	40020440 	.word	0x40020440
20004620:	40020458 	.word	0x40020458
20004624:	40020470 	.word	0x40020470
20004628:	40020488 	.word	0x40020488
2000462c:	400204a0 	.word	0x400204a0
20004630:	400204b8 	.word	0x400204b8
20004634:	58025408 	.word	0x58025408
20004638:	5802541c 	.word	0x5802541c
2000463c:	58025430 	.word	0x58025430
20004640:	58025444 	.word	0x58025444
20004644:	58025458 	.word	0x58025458
20004648:	5802546c 	.word	0x5802546c
2000464c:	58025480 	.word	0x58025480
20004650:	58025494 	.word	0x58025494

20004654 <HAL_DMA_Start>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
20004654:	b580      	push	{r7, lr}
20004656:	b086      	sub	sp, #24
20004658:	af00      	add	r7, sp, #0
2000465a:	60f8      	str	r0, [r7, #12]
2000465c:	60b9      	str	r1, [r7, #8]
2000465e:	607a      	str	r2, [r7, #4]
20004660:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20004662:	2300      	movs	r3, #0
20004664:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
20004666:	683b      	ldr	r3, [r7, #0]
20004668:	2b00      	cmp	r3, #0
2000466a:	d003      	beq.n	20004674 <HAL_DMA_Start+0x20>
2000466c:	683b      	ldr	r3, [r7, #0]
2000466e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20004672:	d304      	bcc.n	2000467e <HAL_DMA_Start+0x2a>
20004674:	f240 216f 	movw	r1, #623	; 0x26f
20004678:	487c      	ldr	r0, [pc, #496]	; (2000486c <HAL_DMA_Start+0x218>)
2000467a:	f7fc f93b 	bl	200008f4 <assert_failed>

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
2000467e:	68fb      	ldr	r3, [r7, #12]
20004680:	2b00      	cmp	r3, #0
20004682:	d101      	bne.n	20004688 <HAL_DMA_Start+0x34>
  {
    return HAL_ERROR;
20004684:	2301      	movs	r3, #1
20004686:	e0ec      	b.n	20004862 <HAL_DMA_Start+0x20e>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
20004688:	68fb      	ldr	r3, [r7, #12]
2000468a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
2000468e:	2b01      	cmp	r3, #1
20004690:	d101      	bne.n	20004696 <HAL_DMA_Start+0x42>
20004692:	2302      	movs	r3, #2
20004694:	e0e5      	b.n	20004862 <HAL_DMA_Start+0x20e>
20004696:	68fb      	ldr	r3, [r7, #12]
20004698:	2201      	movs	r2, #1
2000469a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
2000469e:	68fb      	ldr	r3, [r7, #12]
200046a0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
200046a4:	b2db      	uxtb	r3, r3
200046a6:	2b01      	cmp	r3, #1
200046a8:	f040 80d0 	bne.w	2000484c <HAL_DMA_Start+0x1f8>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
200046ac:	68fb      	ldr	r3, [r7, #12]
200046ae:	2202      	movs	r2, #2
200046b0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
200046b4:	68fb      	ldr	r3, [r7, #12]
200046b6:	2200      	movs	r2, #0
200046b8:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
200046ba:	68fb      	ldr	r3, [r7, #12]
200046bc:	681b      	ldr	r3, [r3, #0]
200046be:	4a6c      	ldr	r2, [pc, #432]	; (20004870 <HAL_DMA_Start+0x21c>)
200046c0:	4293      	cmp	r3, r2
200046c2:	d04a      	beq.n	2000475a <HAL_DMA_Start+0x106>
200046c4:	68fb      	ldr	r3, [r7, #12]
200046c6:	681b      	ldr	r3, [r3, #0]
200046c8:	4a6a      	ldr	r2, [pc, #424]	; (20004874 <HAL_DMA_Start+0x220>)
200046ca:	4293      	cmp	r3, r2
200046cc:	d045      	beq.n	2000475a <HAL_DMA_Start+0x106>
200046ce:	68fb      	ldr	r3, [r7, #12]
200046d0:	681b      	ldr	r3, [r3, #0]
200046d2:	4a69      	ldr	r2, [pc, #420]	; (20004878 <HAL_DMA_Start+0x224>)
200046d4:	4293      	cmp	r3, r2
200046d6:	d040      	beq.n	2000475a <HAL_DMA_Start+0x106>
200046d8:	68fb      	ldr	r3, [r7, #12]
200046da:	681b      	ldr	r3, [r3, #0]
200046dc:	4a67      	ldr	r2, [pc, #412]	; (2000487c <HAL_DMA_Start+0x228>)
200046de:	4293      	cmp	r3, r2
200046e0:	d03b      	beq.n	2000475a <HAL_DMA_Start+0x106>
200046e2:	68fb      	ldr	r3, [r7, #12]
200046e4:	681b      	ldr	r3, [r3, #0]
200046e6:	4a66      	ldr	r2, [pc, #408]	; (20004880 <HAL_DMA_Start+0x22c>)
200046e8:	4293      	cmp	r3, r2
200046ea:	d036      	beq.n	2000475a <HAL_DMA_Start+0x106>
200046ec:	68fb      	ldr	r3, [r7, #12]
200046ee:	681b      	ldr	r3, [r3, #0]
200046f0:	4a64      	ldr	r2, [pc, #400]	; (20004884 <HAL_DMA_Start+0x230>)
200046f2:	4293      	cmp	r3, r2
200046f4:	d031      	beq.n	2000475a <HAL_DMA_Start+0x106>
200046f6:	68fb      	ldr	r3, [r7, #12]
200046f8:	681b      	ldr	r3, [r3, #0]
200046fa:	4a63      	ldr	r2, [pc, #396]	; (20004888 <HAL_DMA_Start+0x234>)
200046fc:	4293      	cmp	r3, r2
200046fe:	d02c      	beq.n	2000475a <HAL_DMA_Start+0x106>
20004700:	68fb      	ldr	r3, [r7, #12]
20004702:	681b      	ldr	r3, [r3, #0]
20004704:	4a61      	ldr	r2, [pc, #388]	; (2000488c <HAL_DMA_Start+0x238>)
20004706:	4293      	cmp	r3, r2
20004708:	d027      	beq.n	2000475a <HAL_DMA_Start+0x106>
2000470a:	68fb      	ldr	r3, [r7, #12]
2000470c:	681b      	ldr	r3, [r3, #0]
2000470e:	4a60      	ldr	r2, [pc, #384]	; (20004890 <HAL_DMA_Start+0x23c>)
20004710:	4293      	cmp	r3, r2
20004712:	d022      	beq.n	2000475a <HAL_DMA_Start+0x106>
20004714:	68fb      	ldr	r3, [r7, #12]
20004716:	681b      	ldr	r3, [r3, #0]
20004718:	4a5e      	ldr	r2, [pc, #376]	; (20004894 <HAL_DMA_Start+0x240>)
2000471a:	4293      	cmp	r3, r2
2000471c:	d01d      	beq.n	2000475a <HAL_DMA_Start+0x106>
2000471e:	68fb      	ldr	r3, [r7, #12]
20004720:	681b      	ldr	r3, [r3, #0]
20004722:	4a5d      	ldr	r2, [pc, #372]	; (20004898 <HAL_DMA_Start+0x244>)
20004724:	4293      	cmp	r3, r2
20004726:	d018      	beq.n	2000475a <HAL_DMA_Start+0x106>
20004728:	68fb      	ldr	r3, [r7, #12]
2000472a:	681b      	ldr	r3, [r3, #0]
2000472c:	4a5b      	ldr	r2, [pc, #364]	; (2000489c <HAL_DMA_Start+0x248>)
2000472e:	4293      	cmp	r3, r2
20004730:	d013      	beq.n	2000475a <HAL_DMA_Start+0x106>
20004732:	68fb      	ldr	r3, [r7, #12]
20004734:	681b      	ldr	r3, [r3, #0]
20004736:	4a5a      	ldr	r2, [pc, #360]	; (200048a0 <HAL_DMA_Start+0x24c>)
20004738:	4293      	cmp	r3, r2
2000473a:	d00e      	beq.n	2000475a <HAL_DMA_Start+0x106>
2000473c:	68fb      	ldr	r3, [r7, #12]
2000473e:	681b      	ldr	r3, [r3, #0]
20004740:	4a58      	ldr	r2, [pc, #352]	; (200048a4 <HAL_DMA_Start+0x250>)
20004742:	4293      	cmp	r3, r2
20004744:	d009      	beq.n	2000475a <HAL_DMA_Start+0x106>
20004746:	68fb      	ldr	r3, [r7, #12]
20004748:	681b      	ldr	r3, [r3, #0]
2000474a:	4a57      	ldr	r2, [pc, #348]	; (200048a8 <HAL_DMA_Start+0x254>)
2000474c:	4293      	cmp	r3, r2
2000474e:	d004      	beq.n	2000475a <HAL_DMA_Start+0x106>
20004750:	68fb      	ldr	r3, [r7, #12]
20004752:	681b      	ldr	r3, [r3, #0]
20004754:	4a55      	ldr	r2, [pc, #340]	; (200048ac <HAL_DMA_Start+0x258>)
20004756:	4293      	cmp	r3, r2
20004758:	d108      	bne.n	2000476c <HAL_DMA_Start+0x118>
2000475a:	68fb      	ldr	r3, [r7, #12]
2000475c:	681b      	ldr	r3, [r3, #0]
2000475e:	681a      	ldr	r2, [r3, #0]
20004760:	68fb      	ldr	r3, [r7, #12]
20004762:	681b      	ldr	r3, [r3, #0]
20004764:	f022 0201 	bic.w	r2, r2, #1
20004768:	601a      	str	r2, [r3, #0]
2000476a:	e007      	b.n	2000477c <HAL_DMA_Start+0x128>
2000476c:	68fb      	ldr	r3, [r7, #12]
2000476e:	681b      	ldr	r3, [r3, #0]
20004770:	681a      	ldr	r2, [r3, #0]
20004772:	68fb      	ldr	r3, [r7, #12]
20004774:	681b      	ldr	r3, [r3, #0]
20004776:	f022 0201 	bic.w	r2, r2, #1
2000477a:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
2000477c:	683b      	ldr	r3, [r7, #0]
2000477e:	687a      	ldr	r2, [r7, #4]
20004780:	68b9      	ldr	r1, [r7, #8]
20004782:	68f8      	ldr	r0, [r7, #12]
20004784:	f002 fc24 	bl	20006fd0 <DMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
20004788:	68fb      	ldr	r3, [r7, #12]
2000478a:	681b      	ldr	r3, [r3, #0]
2000478c:	4a38      	ldr	r2, [pc, #224]	; (20004870 <HAL_DMA_Start+0x21c>)
2000478e:	4293      	cmp	r3, r2
20004790:	d04a      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
20004792:	68fb      	ldr	r3, [r7, #12]
20004794:	681b      	ldr	r3, [r3, #0]
20004796:	4a37      	ldr	r2, [pc, #220]	; (20004874 <HAL_DMA_Start+0x220>)
20004798:	4293      	cmp	r3, r2
2000479a:	d045      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
2000479c:	68fb      	ldr	r3, [r7, #12]
2000479e:	681b      	ldr	r3, [r3, #0]
200047a0:	4a35      	ldr	r2, [pc, #212]	; (20004878 <HAL_DMA_Start+0x224>)
200047a2:	4293      	cmp	r3, r2
200047a4:	d040      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
200047a6:	68fb      	ldr	r3, [r7, #12]
200047a8:	681b      	ldr	r3, [r3, #0]
200047aa:	4a34      	ldr	r2, [pc, #208]	; (2000487c <HAL_DMA_Start+0x228>)
200047ac:	4293      	cmp	r3, r2
200047ae:	d03b      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
200047b0:	68fb      	ldr	r3, [r7, #12]
200047b2:	681b      	ldr	r3, [r3, #0]
200047b4:	4a32      	ldr	r2, [pc, #200]	; (20004880 <HAL_DMA_Start+0x22c>)
200047b6:	4293      	cmp	r3, r2
200047b8:	d036      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
200047ba:	68fb      	ldr	r3, [r7, #12]
200047bc:	681b      	ldr	r3, [r3, #0]
200047be:	4a31      	ldr	r2, [pc, #196]	; (20004884 <HAL_DMA_Start+0x230>)
200047c0:	4293      	cmp	r3, r2
200047c2:	d031      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
200047c4:	68fb      	ldr	r3, [r7, #12]
200047c6:	681b      	ldr	r3, [r3, #0]
200047c8:	4a2f      	ldr	r2, [pc, #188]	; (20004888 <HAL_DMA_Start+0x234>)
200047ca:	4293      	cmp	r3, r2
200047cc:	d02c      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
200047ce:	68fb      	ldr	r3, [r7, #12]
200047d0:	681b      	ldr	r3, [r3, #0]
200047d2:	4a2e      	ldr	r2, [pc, #184]	; (2000488c <HAL_DMA_Start+0x238>)
200047d4:	4293      	cmp	r3, r2
200047d6:	d027      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
200047d8:	68fb      	ldr	r3, [r7, #12]
200047da:	681b      	ldr	r3, [r3, #0]
200047dc:	4a2c      	ldr	r2, [pc, #176]	; (20004890 <HAL_DMA_Start+0x23c>)
200047de:	4293      	cmp	r3, r2
200047e0:	d022      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
200047e2:	68fb      	ldr	r3, [r7, #12]
200047e4:	681b      	ldr	r3, [r3, #0]
200047e6:	4a2b      	ldr	r2, [pc, #172]	; (20004894 <HAL_DMA_Start+0x240>)
200047e8:	4293      	cmp	r3, r2
200047ea:	d01d      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
200047ec:	68fb      	ldr	r3, [r7, #12]
200047ee:	681b      	ldr	r3, [r3, #0]
200047f0:	4a29      	ldr	r2, [pc, #164]	; (20004898 <HAL_DMA_Start+0x244>)
200047f2:	4293      	cmp	r3, r2
200047f4:	d018      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
200047f6:	68fb      	ldr	r3, [r7, #12]
200047f8:	681b      	ldr	r3, [r3, #0]
200047fa:	4a28      	ldr	r2, [pc, #160]	; (2000489c <HAL_DMA_Start+0x248>)
200047fc:	4293      	cmp	r3, r2
200047fe:	d013      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
20004800:	68fb      	ldr	r3, [r7, #12]
20004802:	681b      	ldr	r3, [r3, #0]
20004804:	4a26      	ldr	r2, [pc, #152]	; (200048a0 <HAL_DMA_Start+0x24c>)
20004806:	4293      	cmp	r3, r2
20004808:	d00e      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
2000480a:	68fb      	ldr	r3, [r7, #12]
2000480c:	681b      	ldr	r3, [r3, #0]
2000480e:	4a25      	ldr	r2, [pc, #148]	; (200048a4 <HAL_DMA_Start+0x250>)
20004810:	4293      	cmp	r3, r2
20004812:	d009      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
20004814:	68fb      	ldr	r3, [r7, #12]
20004816:	681b      	ldr	r3, [r3, #0]
20004818:	4a23      	ldr	r2, [pc, #140]	; (200048a8 <HAL_DMA_Start+0x254>)
2000481a:	4293      	cmp	r3, r2
2000481c:	d004      	beq.n	20004828 <HAL_DMA_Start+0x1d4>
2000481e:	68fb      	ldr	r3, [r7, #12]
20004820:	681b      	ldr	r3, [r3, #0]
20004822:	4a22      	ldr	r2, [pc, #136]	; (200048ac <HAL_DMA_Start+0x258>)
20004824:	4293      	cmp	r3, r2
20004826:	d108      	bne.n	2000483a <HAL_DMA_Start+0x1e6>
20004828:	68fb      	ldr	r3, [r7, #12]
2000482a:	681b      	ldr	r3, [r3, #0]
2000482c:	681a      	ldr	r2, [r3, #0]
2000482e:	68fb      	ldr	r3, [r7, #12]
20004830:	681b      	ldr	r3, [r3, #0]
20004832:	f042 0201 	orr.w	r2, r2, #1
20004836:	601a      	str	r2, [r3, #0]
20004838:	e012      	b.n	20004860 <HAL_DMA_Start+0x20c>
2000483a:	68fb      	ldr	r3, [r7, #12]
2000483c:	681b      	ldr	r3, [r3, #0]
2000483e:	681a      	ldr	r2, [r3, #0]
20004840:	68fb      	ldr	r3, [r7, #12]
20004842:	681b      	ldr	r3, [r3, #0]
20004844:	f042 0201 	orr.w	r2, r2, #1
20004848:	601a      	str	r2, [r3, #0]
2000484a:	e009      	b.n	20004860 <HAL_DMA_Start+0x20c>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);
2000484c:	68fb      	ldr	r3, [r7, #12]
2000484e:	2200      	movs	r2, #0
20004850:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
20004854:	68fb      	ldr	r3, [r7, #12]
20004856:	f44f 6200 	mov.w	r2, #2048	; 0x800
2000485a:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
2000485c:	2301      	movs	r3, #1
2000485e:	75fb      	strb	r3, [r7, #23]
  }
  return status;
20004860:	7dfb      	ldrb	r3, [r7, #23]
}
20004862:	4618      	mov	r0, r3
20004864:	3718      	adds	r7, #24
20004866:	46bd      	mov	sp, r7
20004868:	bd80      	pop	{r7, pc}
2000486a:	bf00      	nop
2000486c:	2001bfd4 	.word	0x2001bfd4
20004870:	40020010 	.word	0x40020010
20004874:	40020028 	.word	0x40020028
20004878:	40020040 	.word	0x40020040
2000487c:	40020058 	.word	0x40020058
20004880:	40020070 	.word	0x40020070
20004884:	40020088 	.word	0x40020088
20004888:	400200a0 	.word	0x400200a0
2000488c:	400200b8 	.word	0x400200b8
20004890:	40020410 	.word	0x40020410
20004894:	40020428 	.word	0x40020428
20004898:	40020440 	.word	0x40020440
2000489c:	40020458 	.word	0x40020458
200048a0:	40020470 	.word	0x40020470
200048a4:	40020488 	.word	0x40020488
200048a8:	400204a0 	.word	0x400204a0
200048ac:	400204b8 	.word	0x400204b8

200048b0 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
200048b0:	b580      	push	{r7, lr}
200048b2:	b086      	sub	sp, #24
200048b4:	af00      	add	r7, sp, #0
200048b6:	60f8      	str	r0, [r7, #12]
200048b8:	60b9      	str	r1, [r7, #8]
200048ba:	607a      	str	r2, [r7, #4]
200048bc:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
200048be:	2300      	movs	r3, #0
200048c0:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
200048c2:	683b      	ldr	r3, [r7, #0]
200048c4:	2b00      	cmp	r3, #0
200048c6:	d003      	beq.n	200048d0 <HAL_DMA_Start_IT+0x20>
200048c8:	683b      	ldr	r3, [r7, #0]
200048ca:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
200048ce:	d304      	bcc.n	200048da <HAL_DMA_Start_IT+0x2a>
200048d0:	f240 21a7 	movw	r1, #679	; 0x2a7
200048d4:	4879      	ldr	r0, [pc, #484]	; (20004abc <HAL_DMA_Start_IT+0x20c>)
200048d6:	f7fc f80d 	bl	200008f4 <assert_failed>

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
200048da:	68fb      	ldr	r3, [r7, #12]
200048dc:	2b00      	cmp	r3, #0
200048de:	d101      	bne.n	200048e4 <HAL_DMA_Start_IT+0x34>
  {
    return HAL_ERROR;
200048e0:	2301      	movs	r3, #1
200048e2:	e228      	b.n	20004d36 <HAL_DMA_Start_IT+0x486>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
200048e4:	68fb      	ldr	r3, [r7, #12]
200048e6:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
200048ea:	2b01      	cmp	r3, #1
200048ec:	d101      	bne.n	200048f2 <HAL_DMA_Start_IT+0x42>
200048ee:	2302      	movs	r3, #2
200048f0:	e221      	b.n	20004d36 <HAL_DMA_Start_IT+0x486>
200048f2:	68fb      	ldr	r3, [r7, #12]
200048f4:	2201      	movs	r2, #1
200048f6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
200048fa:	68fb      	ldr	r3, [r7, #12]
200048fc:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20004900:	b2db      	uxtb	r3, r3
20004902:	2b01      	cmp	r3, #1
20004904:	f040 820c 	bne.w	20004d20 <HAL_DMA_Start_IT+0x470>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
20004908:	68fb      	ldr	r3, [r7, #12]
2000490a:	2202      	movs	r2, #2
2000490c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
20004910:	68fb      	ldr	r3, [r7, #12]
20004912:	2200      	movs	r2, #0
20004914:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
20004916:	68fb      	ldr	r3, [r7, #12]
20004918:	681b      	ldr	r3, [r3, #0]
2000491a:	4a69      	ldr	r2, [pc, #420]	; (20004ac0 <HAL_DMA_Start_IT+0x210>)
2000491c:	4293      	cmp	r3, r2
2000491e:	d04a      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
20004920:	68fb      	ldr	r3, [r7, #12]
20004922:	681b      	ldr	r3, [r3, #0]
20004924:	4a67      	ldr	r2, [pc, #412]	; (20004ac4 <HAL_DMA_Start_IT+0x214>)
20004926:	4293      	cmp	r3, r2
20004928:	d045      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
2000492a:	68fb      	ldr	r3, [r7, #12]
2000492c:	681b      	ldr	r3, [r3, #0]
2000492e:	4a66      	ldr	r2, [pc, #408]	; (20004ac8 <HAL_DMA_Start_IT+0x218>)
20004930:	4293      	cmp	r3, r2
20004932:	d040      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
20004934:	68fb      	ldr	r3, [r7, #12]
20004936:	681b      	ldr	r3, [r3, #0]
20004938:	4a64      	ldr	r2, [pc, #400]	; (20004acc <HAL_DMA_Start_IT+0x21c>)
2000493a:	4293      	cmp	r3, r2
2000493c:	d03b      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
2000493e:	68fb      	ldr	r3, [r7, #12]
20004940:	681b      	ldr	r3, [r3, #0]
20004942:	4a63      	ldr	r2, [pc, #396]	; (20004ad0 <HAL_DMA_Start_IT+0x220>)
20004944:	4293      	cmp	r3, r2
20004946:	d036      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
20004948:	68fb      	ldr	r3, [r7, #12]
2000494a:	681b      	ldr	r3, [r3, #0]
2000494c:	4a61      	ldr	r2, [pc, #388]	; (20004ad4 <HAL_DMA_Start_IT+0x224>)
2000494e:	4293      	cmp	r3, r2
20004950:	d031      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
20004952:	68fb      	ldr	r3, [r7, #12]
20004954:	681b      	ldr	r3, [r3, #0]
20004956:	4a60      	ldr	r2, [pc, #384]	; (20004ad8 <HAL_DMA_Start_IT+0x228>)
20004958:	4293      	cmp	r3, r2
2000495a:	d02c      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
2000495c:	68fb      	ldr	r3, [r7, #12]
2000495e:	681b      	ldr	r3, [r3, #0]
20004960:	4a5e      	ldr	r2, [pc, #376]	; (20004adc <HAL_DMA_Start_IT+0x22c>)
20004962:	4293      	cmp	r3, r2
20004964:	d027      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
20004966:	68fb      	ldr	r3, [r7, #12]
20004968:	681b      	ldr	r3, [r3, #0]
2000496a:	4a5d      	ldr	r2, [pc, #372]	; (20004ae0 <HAL_DMA_Start_IT+0x230>)
2000496c:	4293      	cmp	r3, r2
2000496e:	d022      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
20004970:	68fb      	ldr	r3, [r7, #12]
20004972:	681b      	ldr	r3, [r3, #0]
20004974:	4a5b      	ldr	r2, [pc, #364]	; (20004ae4 <HAL_DMA_Start_IT+0x234>)
20004976:	4293      	cmp	r3, r2
20004978:	d01d      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
2000497a:	68fb      	ldr	r3, [r7, #12]
2000497c:	681b      	ldr	r3, [r3, #0]
2000497e:	4a5a      	ldr	r2, [pc, #360]	; (20004ae8 <HAL_DMA_Start_IT+0x238>)
20004980:	4293      	cmp	r3, r2
20004982:	d018      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
20004984:	68fb      	ldr	r3, [r7, #12]
20004986:	681b      	ldr	r3, [r3, #0]
20004988:	4a58      	ldr	r2, [pc, #352]	; (20004aec <HAL_DMA_Start_IT+0x23c>)
2000498a:	4293      	cmp	r3, r2
2000498c:	d013      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
2000498e:	68fb      	ldr	r3, [r7, #12]
20004990:	681b      	ldr	r3, [r3, #0]
20004992:	4a57      	ldr	r2, [pc, #348]	; (20004af0 <HAL_DMA_Start_IT+0x240>)
20004994:	4293      	cmp	r3, r2
20004996:	d00e      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
20004998:	68fb      	ldr	r3, [r7, #12]
2000499a:	681b      	ldr	r3, [r3, #0]
2000499c:	4a55      	ldr	r2, [pc, #340]	; (20004af4 <HAL_DMA_Start_IT+0x244>)
2000499e:	4293      	cmp	r3, r2
200049a0:	d009      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
200049a2:	68fb      	ldr	r3, [r7, #12]
200049a4:	681b      	ldr	r3, [r3, #0]
200049a6:	4a54      	ldr	r2, [pc, #336]	; (20004af8 <HAL_DMA_Start_IT+0x248>)
200049a8:	4293      	cmp	r3, r2
200049aa:	d004      	beq.n	200049b6 <HAL_DMA_Start_IT+0x106>
200049ac:	68fb      	ldr	r3, [r7, #12]
200049ae:	681b      	ldr	r3, [r3, #0]
200049b0:	4a52      	ldr	r2, [pc, #328]	; (20004afc <HAL_DMA_Start_IT+0x24c>)
200049b2:	4293      	cmp	r3, r2
200049b4:	d108      	bne.n	200049c8 <HAL_DMA_Start_IT+0x118>
200049b6:	68fb      	ldr	r3, [r7, #12]
200049b8:	681b      	ldr	r3, [r3, #0]
200049ba:	681a      	ldr	r2, [r3, #0]
200049bc:	68fb      	ldr	r3, [r7, #12]
200049be:	681b      	ldr	r3, [r3, #0]
200049c0:	f022 0201 	bic.w	r2, r2, #1
200049c4:	601a      	str	r2, [r3, #0]
200049c6:	e007      	b.n	200049d8 <HAL_DMA_Start_IT+0x128>
200049c8:	68fb      	ldr	r3, [r7, #12]
200049ca:	681b      	ldr	r3, [r3, #0]
200049cc:	681a      	ldr	r2, [r3, #0]
200049ce:	68fb      	ldr	r3, [r7, #12]
200049d0:	681b      	ldr	r3, [r3, #0]
200049d2:	f022 0201 	bic.w	r2, r2, #1
200049d6:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
200049d8:	683b      	ldr	r3, [r7, #0]
200049da:	687a      	ldr	r2, [r7, #4]
200049dc:	68b9      	ldr	r1, [r7, #8]
200049de:	68f8      	ldr	r0, [r7, #12]
200049e0:	f002 faf6 	bl	20006fd0 <DMA_SetConfig>

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
200049e4:	68fb      	ldr	r3, [r7, #12]
200049e6:	681b      	ldr	r3, [r3, #0]
200049e8:	4a35      	ldr	r2, [pc, #212]	; (20004ac0 <HAL_DMA_Start_IT+0x210>)
200049ea:	4293      	cmp	r3, r2
200049ec:	d04a      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
200049ee:	68fb      	ldr	r3, [r7, #12]
200049f0:	681b      	ldr	r3, [r3, #0]
200049f2:	4a34      	ldr	r2, [pc, #208]	; (20004ac4 <HAL_DMA_Start_IT+0x214>)
200049f4:	4293      	cmp	r3, r2
200049f6:	d045      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
200049f8:	68fb      	ldr	r3, [r7, #12]
200049fa:	681b      	ldr	r3, [r3, #0]
200049fc:	4a32      	ldr	r2, [pc, #200]	; (20004ac8 <HAL_DMA_Start_IT+0x218>)
200049fe:	4293      	cmp	r3, r2
20004a00:	d040      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a02:	68fb      	ldr	r3, [r7, #12]
20004a04:	681b      	ldr	r3, [r3, #0]
20004a06:	4a31      	ldr	r2, [pc, #196]	; (20004acc <HAL_DMA_Start_IT+0x21c>)
20004a08:	4293      	cmp	r3, r2
20004a0a:	d03b      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a0c:	68fb      	ldr	r3, [r7, #12]
20004a0e:	681b      	ldr	r3, [r3, #0]
20004a10:	4a2f      	ldr	r2, [pc, #188]	; (20004ad0 <HAL_DMA_Start_IT+0x220>)
20004a12:	4293      	cmp	r3, r2
20004a14:	d036      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a16:	68fb      	ldr	r3, [r7, #12]
20004a18:	681b      	ldr	r3, [r3, #0]
20004a1a:	4a2e      	ldr	r2, [pc, #184]	; (20004ad4 <HAL_DMA_Start_IT+0x224>)
20004a1c:	4293      	cmp	r3, r2
20004a1e:	d031      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a20:	68fb      	ldr	r3, [r7, #12]
20004a22:	681b      	ldr	r3, [r3, #0]
20004a24:	4a2c      	ldr	r2, [pc, #176]	; (20004ad8 <HAL_DMA_Start_IT+0x228>)
20004a26:	4293      	cmp	r3, r2
20004a28:	d02c      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a2a:	68fb      	ldr	r3, [r7, #12]
20004a2c:	681b      	ldr	r3, [r3, #0]
20004a2e:	4a2b      	ldr	r2, [pc, #172]	; (20004adc <HAL_DMA_Start_IT+0x22c>)
20004a30:	4293      	cmp	r3, r2
20004a32:	d027      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a34:	68fb      	ldr	r3, [r7, #12]
20004a36:	681b      	ldr	r3, [r3, #0]
20004a38:	4a29      	ldr	r2, [pc, #164]	; (20004ae0 <HAL_DMA_Start_IT+0x230>)
20004a3a:	4293      	cmp	r3, r2
20004a3c:	d022      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a3e:	68fb      	ldr	r3, [r7, #12]
20004a40:	681b      	ldr	r3, [r3, #0]
20004a42:	4a28      	ldr	r2, [pc, #160]	; (20004ae4 <HAL_DMA_Start_IT+0x234>)
20004a44:	4293      	cmp	r3, r2
20004a46:	d01d      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a48:	68fb      	ldr	r3, [r7, #12]
20004a4a:	681b      	ldr	r3, [r3, #0]
20004a4c:	4a26      	ldr	r2, [pc, #152]	; (20004ae8 <HAL_DMA_Start_IT+0x238>)
20004a4e:	4293      	cmp	r3, r2
20004a50:	d018      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a52:	68fb      	ldr	r3, [r7, #12]
20004a54:	681b      	ldr	r3, [r3, #0]
20004a56:	4a25      	ldr	r2, [pc, #148]	; (20004aec <HAL_DMA_Start_IT+0x23c>)
20004a58:	4293      	cmp	r3, r2
20004a5a:	d013      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a5c:	68fb      	ldr	r3, [r7, #12]
20004a5e:	681b      	ldr	r3, [r3, #0]
20004a60:	4a23      	ldr	r2, [pc, #140]	; (20004af0 <HAL_DMA_Start_IT+0x240>)
20004a62:	4293      	cmp	r3, r2
20004a64:	d00e      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a66:	68fb      	ldr	r3, [r7, #12]
20004a68:	681b      	ldr	r3, [r3, #0]
20004a6a:	4a22      	ldr	r2, [pc, #136]	; (20004af4 <HAL_DMA_Start_IT+0x244>)
20004a6c:	4293      	cmp	r3, r2
20004a6e:	d009      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a70:	68fb      	ldr	r3, [r7, #12]
20004a72:	681b      	ldr	r3, [r3, #0]
20004a74:	4a20      	ldr	r2, [pc, #128]	; (20004af8 <HAL_DMA_Start_IT+0x248>)
20004a76:	4293      	cmp	r3, r2
20004a78:	d004      	beq.n	20004a84 <HAL_DMA_Start_IT+0x1d4>
20004a7a:	68fb      	ldr	r3, [r7, #12]
20004a7c:	681b      	ldr	r3, [r3, #0]
20004a7e:	4a1f      	ldr	r2, [pc, #124]	; (20004afc <HAL_DMA_Start_IT+0x24c>)
20004a80:	4293      	cmp	r3, r2
20004a82:	d101      	bne.n	20004a88 <HAL_DMA_Start_IT+0x1d8>
20004a84:	2301      	movs	r3, #1
20004a86:	e000      	b.n	20004a8a <HAL_DMA_Start_IT+0x1da>
20004a88:	2300      	movs	r3, #0
20004a8a:	2b00      	cmp	r3, #0
20004a8c:	d038      	beq.n	20004b00 <HAL_DMA_Start_IT+0x250>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
20004a8e:	68fb      	ldr	r3, [r7, #12]
20004a90:	681b      	ldr	r3, [r3, #0]
20004a92:	681b      	ldr	r3, [r3, #0]
20004a94:	f023 021e 	bic.w	r2, r3, #30
20004a98:	68fb      	ldr	r3, [r7, #12]
20004a9a:	681b      	ldr	r3, [r3, #0]
20004a9c:	f042 0216 	orr.w	r2, r2, #22
20004aa0:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
20004aa2:	68fb      	ldr	r3, [r7, #12]
20004aa4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20004aa6:	2b00      	cmp	r3, #0
20004aa8:	d040      	beq.n	20004b2c <HAL_DMA_Start_IT+0x27c>
      {
        /* Enable Half Transfer IT if corresponding Callback is set */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
20004aaa:	68fb      	ldr	r3, [r7, #12]
20004aac:	681b      	ldr	r3, [r3, #0]
20004aae:	681a      	ldr	r2, [r3, #0]
20004ab0:	68fb      	ldr	r3, [r7, #12]
20004ab2:	681b      	ldr	r3, [r3, #0]
20004ab4:	f042 0208 	orr.w	r2, r2, #8
20004ab8:	601a      	str	r2, [r3, #0]
20004aba:	e037      	b.n	20004b2c <HAL_DMA_Start_IT+0x27c>
20004abc:	2001bfd4 	.word	0x2001bfd4
20004ac0:	40020010 	.word	0x40020010
20004ac4:	40020028 	.word	0x40020028
20004ac8:	40020040 	.word	0x40020040
20004acc:	40020058 	.word	0x40020058
20004ad0:	40020070 	.word	0x40020070
20004ad4:	40020088 	.word	0x40020088
20004ad8:	400200a0 	.word	0x400200a0
20004adc:	400200b8 	.word	0x400200b8
20004ae0:	40020410 	.word	0x40020410
20004ae4:	40020428 	.word	0x40020428
20004ae8:	40020440 	.word	0x40020440
20004aec:	40020458 	.word	0x40020458
20004af0:	40020470 	.word	0x40020470
20004af4:	40020488 	.word	0x40020488
20004af8:	400204a0 	.word	0x400204a0
20004afc:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA channel */
    {
      /* Enable Common interrupts */
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
20004b00:	68fb      	ldr	r3, [r7, #12]
20004b02:	681b      	ldr	r3, [r3, #0]
20004b04:	681b      	ldr	r3, [r3, #0]
20004b06:	f023 020e 	bic.w	r2, r3, #14
20004b0a:	68fb      	ldr	r3, [r7, #12]
20004b0c:	681b      	ldr	r3, [r3, #0]
20004b0e:	f042 020a 	orr.w	r2, r2, #10
20004b12:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
20004b14:	68fb      	ldr	r3, [r7, #12]
20004b16:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20004b18:	2b00      	cmp	r3, #0
20004b1a:	d007      	beq.n	20004b2c <HAL_DMA_Start_IT+0x27c>
      {
        /*Enable Half Transfer IT if corresponding Callback is set */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
20004b1c:	68fb      	ldr	r3, [r7, #12]
20004b1e:	681b      	ldr	r3, [r3, #0]
20004b20:	681a      	ldr	r2, [r3, #0]
20004b22:	68fb      	ldr	r3, [r7, #12]
20004b24:	681b      	ldr	r3, [r3, #0]
20004b26:	f042 0204 	orr.w	r2, r2, #4
20004b2a:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
20004b2c:	68fb      	ldr	r3, [r7, #12]
20004b2e:	681b      	ldr	r3, [r3, #0]
20004b30:	4a83      	ldr	r2, [pc, #524]	; (20004d40 <HAL_DMA_Start_IT+0x490>)
20004b32:	4293      	cmp	r3, r2
20004b34:	d072      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b36:	68fb      	ldr	r3, [r7, #12]
20004b38:	681b      	ldr	r3, [r3, #0]
20004b3a:	4a82      	ldr	r2, [pc, #520]	; (20004d44 <HAL_DMA_Start_IT+0x494>)
20004b3c:	4293      	cmp	r3, r2
20004b3e:	d06d      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b40:	68fb      	ldr	r3, [r7, #12]
20004b42:	681b      	ldr	r3, [r3, #0]
20004b44:	4a80      	ldr	r2, [pc, #512]	; (20004d48 <HAL_DMA_Start_IT+0x498>)
20004b46:	4293      	cmp	r3, r2
20004b48:	d068      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b4a:	68fb      	ldr	r3, [r7, #12]
20004b4c:	681b      	ldr	r3, [r3, #0]
20004b4e:	4a7f      	ldr	r2, [pc, #508]	; (20004d4c <HAL_DMA_Start_IT+0x49c>)
20004b50:	4293      	cmp	r3, r2
20004b52:	d063      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b54:	68fb      	ldr	r3, [r7, #12]
20004b56:	681b      	ldr	r3, [r3, #0]
20004b58:	4a7d      	ldr	r2, [pc, #500]	; (20004d50 <HAL_DMA_Start_IT+0x4a0>)
20004b5a:	4293      	cmp	r3, r2
20004b5c:	d05e      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b5e:	68fb      	ldr	r3, [r7, #12]
20004b60:	681b      	ldr	r3, [r3, #0]
20004b62:	4a7c      	ldr	r2, [pc, #496]	; (20004d54 <HAL_DMA_Start_IT+0x4a4>)
20004b64:	4293      	cmp	r3, r2
20004b66:	d059      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b68:	68fb      	ldr	r3, [r7, #12]
20004b6a:	681b      	ldr	r3, [r3, #0]
20004b6c:	4a7a      	ldr	r2, [pc, #488]	; (20004d58 <HAL_DMA_Start_IT+0x4a8>)
20004b6e:	4293      	cmp	r3, r2
20004b70:	d054      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b72:	68fb      	ldr	r3, [r7, #12]
20004b74:	681b      	ldr	r3, [r3, #0]
20004b76:	4a79      	ldr	r2, [pc, #484]	; (20004d5c <HAL_DMA_Start_IT+0x4ac>)
20004b78:	4293      	cmp	r3, r2
20004b7a:	d04f      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b7c:	68fb      	ldr	r3, [r7, #12]
20004b7e:	681b      	ldr	r3, [r3, #0]
20004b80:	4a77      	ldr	r2, [pc, #476]	; (20004d60 <HAL_DMA_Start_IT+0x4b0>)
20004b82:	4293      	cmp	r3, r2
20004b84:	d04a      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b86:	68fb      	ldr	r3, [r7, #12]
20004b88:	681b      	ldr	r3, [r3, #0]
20004b8a:	4a76      	ldr	r2, [pc, #472]	; (20004d64 <HAL_DMA_Start_IT+0x4b4>)
20004b8c:	4293      	cmp	r3, r2
20004b8e:	d045      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b90:	68fb      	ldr	r3, [r7, #12]
20004b92:	681b      	ldr	r3, [r3, #0]
20004b94:	4a74      	ldr	r2, [pc, #464]	; (20004d68 <HAL_DMA_Start_IT+0x4b8>)
20004b96:	4293      	cmp	r3, r2
20004b98:	d040      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004b9a:	68fb      	ldr	r3, [r7, #12]
20004b9c:	681b      	ldr	r3, [r3, #0]
20004b9e:	4a73      	ldr	r2, [pc, #460]	; (20004d6c <HAL_DMA_Start_IT+0x4bc>)
20004ba0:	4293      	cmp	r3, r2
20004ba2:	d03b      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004ba4:	68fb      	ldr	r3, [r7, #12]
20004ba6:	681b      	ldr	r3, [r3, #0]
20004ba8:	4a71      	ldr	r2, [pc, #452]	; (20004d70 <HAL_DMA_Start_IT+0x4c0>)
20004baa:	4293      	cmp	r3, r2
20004bac:	d036      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004bae:	68fb      	ldr	r3, [r7, #12]
20004bb0:	681b      	ldr	r3, [r3, #0]
20004bb2:	4a70      	ldr	r2, [pc, #448]	; (20004d74 <HAL_DMA_Start_IT+0x4c4>)
20004bb4:	4293      	cmp	r3, r2
20004bb6:	d031      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004bb8:	68fb      	ldr	r3, [r7, #12]
20004bba:	681b      	ldr	r3, [r3, #0]
20004bbc:	4a6e      	ldr	r2, [pc, #440]	; (20004d78 <HAL_DMA_Start_IT+0x4c8>)
20004bbe:	4293      	cmp	r3, r2
20004bc0:	d02c      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004bc2:	68fb      	ldr	r3, [r7, #12]
20004bc4:	681b      	ldr	r3, [r3, #0]
20004bc6:	4a6d      	ldr	r2, [pc, #436]	; (20004d7c <HAL_DMA_Start_IT+0x4cc>)
20004bc8:	4293      	cmp	r3, r2
20004bca:	d027      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004bcc:	68fb      	ldr	r3, [r7, #12]
20004bce:	681b      	ldr	r3, [r3, #0]
20004bd0:	4a6b      	ldr	r2, [pc, #428]	; (20004d80 <HAL_DMA_Start_IT+0x4d0>)
20004bd2:	4293      	cmp	r3, r2
20004bd4:	d022      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004bd6:	68fb      	ldr	r3, [r7, #12]
20004bd8:	681b      	ldr	r3, [r3, #0]
20004bda:	4a6a      	ldr	r2, [pc, #424]	; (20004d84 <HAL_DMA_Start_IT+0x4d4>)
20004bdc:	4293      	cmp	r3, r2
20004bde:	d01d      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004be0:	68fb      	ldr	r3, [r7, #12]
20004be2:	681b      	ldr	r3, [r3, #0]
20004be4:	4a68      	ldr	r2, [pc, #416]	; (20004d88 <HAL_DMA_Start_IT+0x4d8>)
20004be6:	4293      	cmp	r3, r2
20004be8:	d018      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004bea:	68fb      	ldr	r3, [r7, #12]
20004bec:	681b      	ldr	r3, [r3, #0]
20004bee:	4a67      	ldr	r2, [pc, #412]	; (20004d8c <HAL_DMA_Start_IT+0x4dc>)
20004bf0:	4293      	cmp	r3, r2
20004bf2:	d013      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004bf4:	68fb      	ldr	r3, [r7, #12]
20004bf6:	681b      	ldr	r3, [r3, #0]
20004bf8:	4a65      	ldr	r2, [pc, #404]	; (20004d90 <HAL_DMA_Start_IT+0x4e0>)
20004bfa:	4293      	cmp	r3, r2
20004bfc:	d00e      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004bfe:	68fb      	ldr	r3, [r7, #12]
20004c00:	681b      	ldr	r3, [r3, #0]
20004c02:	4a64      	ldr	r2, [pc, #400]	; (20004d94 <HAL_DMA_Start_IT+0x4e4>)
20004c04:	4293      	cmp	r3, r2
20004c06:	d009      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004c08:	68fb      	ldr	r3, [r7, #12]
20004c0a:	681b      	ldr	r3, [r3, #0]
20004c0c:	4a62      	ldr	r2, [pc, #392]	; (20004d98 <HAL_DMA_Start_IT+0x4e8>)
20004c0e:	4293      	cmp	r3, r2
20004c10:	d004      	beq.n	20004c1c <HAL_DMA_Start_IT+0x36c>
20004c12:	68fb      	ldr	r3, [r7, #12]
20004c14:	681b      	ldr	r3, [r3, #0]
20004c16:	4a61      	ldr	r2, [pc, #388]	; (20004d9c <HAL_DMA_Start_IT+0x4ec>)
20004c18:	4293      	cmp	r3, r2
20004c1a:	d101      	bne.n	20004c20 <HAL_DMA_Start_IT+0x370>
20004c1c:	2301      	movs	r3, #1
20004c1e:	e000      	b.n	20004c22 <HAL_DMA_Start_IT+0x372>
20004c20:	2300      	movs	r3, #0
20004c22:	2b00      	cmp	r3, #0
20004c24:	d01a      	beq.n	20004c5c <HAL_DMA_Start_IT+0x3ac>
    {
      /* Check if DMAMUX Synchronization is enabled */
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
20004c26:	68fb      	ldr	r3, [r7, #12]
20004c28:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20004c2a:	681b      	ldr	r3, [r3, #0]
20004c2c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20004c30:	2b00      	cmp	r3, #0
20004c32:	d007      	beq.n	20004c44 <HAL_DMA_Start_IT+0x394>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
20004c34:	68fb      	ldr	r3, [r7, #12]
20004c36:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20004c38:	681a      	ldr	r2, [r3, #0]
20004c3a:	68fb      	ldr	r3, [r7, #12]
20004c3c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20004c3e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20004c42:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
20004c44:	68fb      	ldr	r3, [r7, #12]
20004c46:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20004c48:	2b00      	cmp	r3, #0
20004c4a:	d007      	beq.n	20004c5c <HAL_DMA_Start_IT+0x3ac>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
20004c4c:	68fb      	ldr	r3, [r7, #12]
20004c4e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20004c50:	681a      	ldr	r2, [r3, #0]
20004c52:	68fb      	ldr	r3, [r7, #12]
20004c54:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20004c56:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20004c5a:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
20004c5c:	68fb      	ldr	r3, [r7, #12]
20004c5e:	681b      	ldr	r3, [r3, #0]
20004c60:	4a37      	ldr	r2, [pc, #220]	; (20004d40 <HAL_DMA_Start_IT+0x490>)
20004c62:	4293      	cmp	r3, r2
20004c64:	d04a      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004c66:	68fb      	ldr	r3, [r7, #12]
20004c68:	681b      	ldr	r3, [r3, #0]
20004c6a:	4a36      	ldr	r2, [pc, #216]	; (20004d44 <HAL_DMA_Start_IT+0x494>)
20004c6c:	4293      	cmp	r3, r2
20004c6e:	d045      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004c70:	68fb      	ldr	r3, [r7, #12]
20004c72:	681b      	ldr	r3, [r3, #0]
20004c74:	4a34      	ldr	r2, [pc, #208]	; (20004d48 <HAL_DMA_Start_IT+0x498>)
20004c76:	4293      	cmp	r3, r2
20004c78:	d040      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004c7a:	68fb      	ldr	r3, [r7, #12]
20004c7c:	681b      	ldr	r3, [r3, #0]
20004c7e:	4a33      	ldr	r2, [pc, #204]	; (20004d4c <HAL_DMA_Start_IT+0x49c>)
20004c80:	4293      	cmp	r3, r2
20004c82:	d03b      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004c84:	68fb      	ldr	r3, [r7, #12]
20004c86:	681b      	ldr	r3, [r3, #0]
20004c88:	4a31      	ldr	r2, [pc, #196]	; (20004d50 <HAL_DMA_Start_IT+0x4a0>)
20004c8a:	4293      	cmp	r3, r2
20004c8c:	d036      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004c8e:	68fb      	ldr	r3, [r7, #12]
20004c90:	681b      	ldr	r3, [r3, #0]
20004c92:	4a30      	ldr	r2, [pc, #192]	; (20004d54 <HAL_DMA_Start_IT+0x4a4>)
20004c94:	4293      	cmp	r3, r2
20004c96:	d031      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004c98:	68fb      	ldr	r3, [r7, #12]
20004c9a:	681b      	ldr	r3, [r3, #0]
20004c9c:	4a2e      	ldr	r2, [pc, #184]	; (20004d58 <HAL_DMA_Start_IT+0x4a8>)
20004c9e:	4293      	cmp	r3, r2
20004ca0:	d02c      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004ca2:	68fb      	ldr	r3, [r7, #12]
20004ca4:	681b      	ldr	r3, [r3, #0]
20004ca6:	4a2d      	ldr	r2, [pc, #180]	; (20004d5c <HAL_DMA_Start_IT+0x4ac>)
20004ca8:	4293      	cmp	r3, r2
20004caa:	d027      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004cac:	68fb      	ldr	r3, [r7, #12]
20004cae:	681b      	ldr	r3, [r3, #0]
20004cb0:	4a2b      	ldr	r2, [pc, #172]	; (20004d60 <HAL_DMA_Start_IT+0x4b0>)
20004cb2:	4293      	cmp	r3, r2
20004cb4:	d022      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004cb6:	68fb      	ldr	r3, [r7, #12]
20004cb8:	681b      	ldr	r3, [r3, #0]
20004cba:	4a2a      	ldr	r2, [pc, #168]	; (20004d64 <HAL_DMA_Start_IT+0x4b4>)
20004cbc:	4293      	cmp	r3, r2
20004cbe:	d01d      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004cc0:	68fb      	ldr	r3, [r7, #12]
20004cc2:	681b      	ldr	r3, [r3, #0]
20004cc4:	4a28      	ldr	r2, [pc, #160]	; (20004d68 <HAL_DMA_Start_IT+0x4b8>)
20004cc6:	4293      	cmp	r3, r2
20004cc8:	d018      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004cca:	68fb      	ldr	r3, [r7, #12]
20004ccc:	681b      	ldr	r3, [r3, #0]
20004cce:	4a27      	ldr	r2, [pc, #156]	; (20004d6c <HAL_DMA_Start_IT+0x4bc>)
20004cd0:	4293      	cmp	r3, r2
20004cd2:	d013      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004cd4:	68fb      	ldr	r3, [r7, #12]
20004cd6:	681b      	ldr	r3, [r3, #0]
20004cd8:	4a25      	ldr	r2, [pc, #148]	; (20004d70 <HAL_DMA_Start_IT+0x4c0>)
20004cda:	4293      	cmp	r3, r2
20004cdc:	d00e      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004cde:	68fb      	ldr	r3, [r7, #12]
20004ce0:	681b      	ldr	r3, [r3, #0]
20004ce2:	4a24      	ldr	r2, [pc, #144]	; (20004d74 <HAL_DMA_Start_IT+0x4c4>)
20004ce4:	4293      	cmp	r3, r2
20004ce6:	d009      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004ce8:	68fb      	ldr	r3, [r7, #12]
20004cea:	681b      	ldr	r3, [r3, #0]
20004cec:	4a22      	ldr	r2, [pc, #136]	; (20004d78 <HAL_DMA_Start_IT+0x4c8>)
20004cee:	4293      	cmp	r3, r2
20004cf0:	d004      	beq.n	20004cfc <HAL_DMA_Start_IT+0x44c>
20004cf2:	68fb      	ldr	r3, [r7, #12]
20004cf4:	681b      	ldr	r3, [r3, #0]
20004cf6:	4a21      	ldr	r2, [pc, #132]	; (20004d7c <HAL_DMA_Start_IT+0x4cc>)
20004cf8:	4293      	cmp	r3, r2
20004cfa:	d108      	bne.n	20004d0e <HAL_DMA_Start_IT+0x45e>
20004cfc:	68fb      	ldr	r3, [r7, #12]
20004cfe:	681b      	ldr	r3, [r3, #0]
20004d00:	681a      	ldr	r2, [r3, #0]
20004d02:	68fb      	ldr	r3, [r7, #12]
20004d04:	681b      	ldr	r3, [r3, #0]
20004d06:	f042 0201 	orr.w	r2, r2, #1
20004d0a:	601a      	str	r2, [r3, #0]
20004d0c:	e012      	b.n	20004d34 <HAL_DMA_Start_IT+0x484>
20004d0e:	68fb      	ldr	r3, [r7, #12]
20004d10:	681b      	ldr	r3, [r3, #0]
20004d12:	681a      	ldr	r2, [r3, #0]
20004d14:	68fb      	ldr	r3, [r7, #12]
20004d16:	681b      	ldr	r3, [r3, #0]
20004d18:	f042 0201 	orr.w	r2, r2, #1
20004d1c:	601a      	str	r2, [r3, #0]
20004d1e:	e009      	b.n	20004d34 <HAL_DMA_Start_IT+0x484>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);
20004d20:	68fb      	ldr	r3, [r7, #12]
20004d22:	2200      	movs	r2, #0
20004d24:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
20004d28:	68fb      	ldr	r3, [r7, #12]
20004d2a:	f44f 6200 	mov.w	r2, #2048	; 0x800
20004d2e:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
20004d30:	2301      	movs	r3, #1
20004d32:	75fb      	strb	r3, [r7, #23]
  }

  return status;
20004d34:	7dfb      	ldrb	r3, [r7, #23]
}
20004d36:	4618      	mov	r0, r3
20004d38:	3718      	adds	r7, #24
20004d3a:	46bd      	mov	sp, r7
20004d3c:	bd80      	pop	{r7, pc}
20004d3e:	bf00      	nop
20004d40:	40020010 	.word	0x40020010
20004d44:	40020028 	.word	0x40020028
20004d48:	40020040 	.word	0x40020040
20004d4c:	40020058 	.word	0x40020058
20004d50:	40020070 	.word	0x40020070
20004d54:	40020088 	.word	0x40020088
20004d58:	400200a0 	.word	0x400200a0
20004d5c:	400200b8 	.word	0x400200b8
20004d60:	40020410 	.word	0x40020410
20004d64:	40020428 	.word	0x40020428
20004d68:	40020440 	.word	0x40020440
20004d6c:	40020458 	.word	0x40020458
20004d70:	40020470 	.word	0x40020470
20004d74:	40020488 	.word	0x40020488
20004d78:	400204a0 	.word	0x400204a0
20004d7c:	400204b8 	.word	0x400204b8
20004d80:	58025408 	.word	0x58025408
20004d84:	5802541c 	.word	0x5802541c
20004d88:	58025430 	.word	0x58025430
20004d8c:	58025444 	.word	0x58025444
20004d90:	58025458 	.word	0x58025458
20004d94:	5802546c 	.word	0x5802546c
20004d98:	58025480 	.word	0x58025480
20004d9c:	58025494 	.word	0x58025494

20004da0 <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
20004da0:	b580      	push	{r7, lr}
20004da2:	b086      	sub	sp, #24
20004da4:	af00      	add	r7, sp, #0
20004da6:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;
  const __IO uint32_t *enableRegister;

  uint32_t tickstart = HAL_GetTick();
20004da8:	f7fc ffa0 	bl	20001cec <HAL_GetTick>
20004dac:	6138      	str	r0, [r7, #16]

 /* Check the DMA peripheral handle */
  if(hdma == NULL)
20004dae:	687b      	ldr	r3, [r7, #4]
20004db0:	2b00      	cmp	r3, #0
20004db2:	d101      	bne.n	20004db8 <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
20004db4:	2301      	movs	r3, #1
20004db6:	e2dc      	b.n	20005372 <HAL_DMA_Abort+0x5d2>
  }

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
20004db8:	687b      	ldr	r3, [r7, #4]
20004dba:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20004dbe:	b2db      	uxtb	r3, r3
20004dc0:	2b02      	cmp	r3, #2
20004dc2:	d008      	beq.n	20004dd6 <HAL_DMA_Abort+0x36>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
20004dc4:	687b      	ldr	r3, [r7, #4]
20004dc6:	2280      	movs	r2, #128	; 0x80
20004dc8:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
20004dca:	687b      	ldr	r3, [r7, #4]
20004dcc:	2200      	movs	r2, #0
20004dce:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
20004dd2:	2301      	movs	r3, #1
20004dd4:	e2cd      	b.n	20005372 <HAL_DMA_Abort+0x5d2>
  }
  else
  {
    /* Disable all the transfer interrupts */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20004dd6:	687b      	ldr	r3, [r7, #4]
20004dd8:	681b      	ldr	r3, [r3, #0]
20004dda:	4a76      	ldr	r2, [pc, #472]	; (20004fb4 <HAL_DMA_Abort+0x214>)
20004ddc:	4293      	cmp	r3, r2
20004dde:	d04a      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004de0:	687b      	ldr	r3, [r7, #4]
20004de2:	681b      	ldr	r3, [r3, #0]
20004de4:	4a74      	ldr	r2, [pc, #464]	; (20004fb8 <HAL_DMA_Abort+0x218>)
20004de6:	4293      	cmp	r3, r2
20004de8:	d045      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004dea:	687b      	ldr	r3, [r7, #4]
20004dec:	681b      	ldr	r3, [r3, #0]
20004dee:	4a73      	ldr	r2, [pc, #460]	; (20004fbc <HAL_DMA_Abort+0x21c>)
20004df0:	4293      	cmp	r3, r2
20004df2:	d040      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004df4:	687b      	ldr	r3, [r7, #4]
20004df6:	681b      	ldr	r3, [r3, #0]
20004df8:	4a71      	ldr	r2, [pc, #452]	; (20004fc0 <HAL_DMA_Abort+0x220>)
20004dfa:	4293      	cmp	r3, r2
20004dfc:	d03b      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004dfe:	687b      	ldr	r3, [r7, #4]
20004e00:	681b      	ldr	r3, [r3, #0]
20004e02:	4a70      	ldr	r2, [pc, #448]	; (20004fc4 <HAL_DMA_Abort+0x224>)
20004e04:	4293      	cmp	r3, r2
20004e06:	d036      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e08:	687b      	ldr	r3, [r7, #4]
20004e0a:	681b      	ldr	r3, [r3, #0]
20004e0c:	4a6e      	ldr	r2, [pc, #440]	; (20004fc8 <HAL_DMA_Abort+0x228>)
20004e0e:	4293      	cmp	r3, r2
20004e10:	d031      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e12:	687b      	ldr	r3, [r7, #4]
20004e14:	681b      	ldr	r3, [r3, #0]
20004e16:	4a6d      	ldr	r2, [pc, #436]	; (20004fcc <HAL_DMA_Abort+0x22c>)
20004e18:	4293      	cmp	r3, r2
20004e1a:	d02c      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e1c:	687b      	ldr	r3, [r7, #4]
20004e1e:	681b      	ldr	r3, [r3, #0]
20004e20:	4a6b      	ldr	r2, [pc, #428]	; (20004fd0 <HAL_DMA_Abort+0x230>)
20004e22:	4293      	cmp	r3, r2
20004e24:	d027      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e26:	687b      	ldr	r3, [r7, #4]
20004e28:	681b      	ldr	r3, [r3, #0]
20004e2a:	4a6a      	ldr	r2, [pc, #424]	; (20004fd4 <HAL_DMA_Abort+0x234>)
20004e2c:	4293      	cmp	r3, r2
20004e2e:	d022      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e30:	687b      	ldr	r3, [r7, #4]
20004e32:	681b      	ldr	r3, [r3, #0]
20004e34:	4a68      	ldr	r2, [pc, #416]	; (20004fd8 <HAL_DMA_Abort+0x238>)
20004e36:	4293      	cmp	r3, r2
20004e38:	d01d      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e3a:	687b      	ldr	r3, [r7, #4]
20004e3c:	681b      	ldr	r3, [r3, #0]
20004e3e:	4a67      	ldr	r2, [pc, #412]	; (20004fdc <HAL_DMA_Abort+0x23c>)
20004e40:	4293      	cmp	r3, r2
20004e42:	d018      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e44:	687b      	ldr	r3, [r7, #4]
20004e46:	681b      	ldr	r3, [r3, #0]
20004e48:	4a65      	ldr	r2, [pc, #404]	; (20004fe0 <HAL_DMA_Abort+0x240>)
20004e4a:	4293      	cmp	r3, r2
20004e4c:	d013      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e4e:	687b      	ldr	r3, [r7, #4]
20004e50:	681b      	ldr	r3, [r3, #0]
20004e52:	4a64      	ldr	r2, [pc, #400]	; (20004fe4 <HAL_DMA_Abort+0x244>)
20004e54:	4293      	cmp	r3, r2
20004e56:	d00e      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e58:	687b      	ldr	r3, [r7, #4]
20004e5a:	681b      	ldr	r3, [r3, #0]
20004e5c:	4a62      	ldr	r2, [pc, #392]	; (20004fe8 <HAL_DMA_Abort+0x248>)
20004e5e:	4293      	cmp	r3, r2
20004e60:	d009      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e62:	687b      	ldr	r3, [r7, #4]
20004e64:	681b      	ldr	r3, [r3, #0]
20004e66:	4a61      	ldr	r2, [pc, #388]	; (20004fec <HAL_DMA_Abort+0x24c>)
20004e68:	4293      	cmp	r3, r2
20004e6a:	d004      	beq.n	20004e76 <HAL_DMA_Abort+0xd6>
20004e6c:	687b      	ldr	r3, [r7, #4]
20004e6e:	681b      	ldr	r3, [r3, #0]
20004e70:	4a5f      	ldr	r2, [pc, #380]	; (20004ff0 <HAL_DMA_Abort+0x250>)
20004e72:	4293      	cmp	r3, r2
20004e74:	d101      	bne.n	20004e7a <HAL_DMA_Abort+0xda>
20004e76:	2301      	movs	r3, #1
20004e78:	e000      	b.n	20004e7c <HAL_DMA_Abort+0xdc>
20004e7a:	2300      	movs	r3, #0
20004e7c:	2b00      	cmp	r3, #0
20004e7e:	d013      	beq.n	20004ea8 <HAL_DMA_Abort+0x108>
    {
       /* Disable DMA All Interrupts  */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
20004e80:	687b      	ldr	r3, [r7, #4]
20004e82:	681b      	ldr	r3, [r3, #0]
20004e84:	681a      	ldr	r2, [r3, #0]
20004e86:	687b      	ldr	r3, [r7, #4]
20004e88:	681b      	ldr	r3, [r3, #0]
20004e8a:	f022 021e 	bic.w	r2, r2, #30
20004e8e:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
20004e90:	687b      	ldr	r3, [r7, #4]
20004e92:	681b      	ldr	r3, [r3, #0]
20004e94:	695a      	ldr	r2, [r3, #20]
20004e96:	687b      	ldr	r3, [r7, #4]
20004e98:	681b      	ldr	r3, [r3, #0]
20004e9a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
20004e9e:	615a      	str	r2, [r3, #20]

      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));
20004ea0:	687b      	ldr	r3, [r7, #4]
20004ea2:	681b      	ldr	r3, [r3, #0]
20004ea4:	617b      	str	r3, [r7, #20]
20004ea6:	e00a      	b.n	20004ebe <HAL_DMA_Abort+0x11e>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
20004ea8:	687b      	ldr	r3, [r7, #4]
20004eaa:	681b      	ldr	r3, [r3, #0]
20004eac:	681a      	ldr	r2, [r3, #0]
20004eae:	687b      	ldr	r3, [r7, #4]
20004eb0:	681b      	ldr	r3, [r3, #0]
20004eb2:	f022 020e 	bic.w	r2, r2, #14
20004eb6:	601a      	str	r2, [r3, #0]

      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));
20004eb8:	687b      	ldr	r3, [r7, #4]
20004eba:	681b      	ldr	r3, [r3, #0]
20004ebc:	617b      	str	r3, [r7, #20]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
20004ebe:	687b      	ldr	r3, [r7, #4]
20004ec0:	681b      	ldr	r3, [r3, #0]
20004ec2:	4a3c      	ldr	r2, [pc, #240]	; (20004fb4 <HAL_DMA_Abort+0x214>)
20004ec4:	4293      	cmp	r3, r2
20004ec6:	d072      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004ec8:	687b      	ldr	r3, [r7, #4]
20004eca:	681b      	ldr	r3, [r3, #0]
20004ecc:	4a3a      	ldr	r2, [pc, #232]	; (20004fb8 <HAL_DMA_Abort+0x218>)
20004ece:	4293      	cmp	r3, r2
20004ed0:	d06d      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004ed2:	687b      	ldr	r3, [r7, #4]
20004ed4:	681b      	ldr	r3, [r3, #0]
20004ed6:	4a39      	ldr	r2, [pc, #228]	; (20004fbc <HAL_DMA_Abort+0x21c>)
20004ed8:	4293      	cmp	r3, r2
20004eda:	d068      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004edc:	687b      	ldr	r3, [r7, #4]
20004ede:	681b      	ldr	r3, [r3, #0]
20004ee0:	4a37      	ldr	r2, [pc, #220]	; (20004fc0 <HAL_DMA_Abort+0x220>)
20004ee2:	4293      	cmp	r3, r2
20004ee4:	d063      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004ee6:	687b      	ldr	r3, [r7, #4]
20004ee8:	681b      	ldr	r3, [r3, #0]
20004eea:	4a36      	ldr	r2, [pc, #216]	; (20004fc4 <HAL_DMA_Abort+0x224>)
20004eec:	4293      	cmp	r3, r2
20004eee:	d05e      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004ef0:	687b      	ldr	r3, [r7, #4]
20004ef2:	681b      	ldr	r3, [r3, #0]
20004ef4:	4a34      	ldr	r2, [pc, #208]	; (20004fc8 <HAL_DMA_Abort+0x228>)
20004ef6:	4293      	cmp	r3, r2
20004ef8:	d059      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004efa:	687b      	ldr	r3, [r7, #4]
20004efc:	681b      	ldr	r3, [r3, #0]
20004efe:	4a33      	ldr	r2, [pc, #204]	; (20004fcc <HAL_DMA_Abort+0x22c>)
20004f00:	4293      	cmp	r3, r2
20004f02:	d054      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f04:	687b      	ldr	r3, [r7, #4]
20004f06:	681b      	ldr	r3, [r3, #0]
20004f08:	4a31      	ldr	r2, [pc, #196]	; (20004fd0 <HAL_DMA_Abort+0x230>)
20004f0a:	4293      	cmp	r3, r2
20004f0c:	d04f      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f0e:	687b      	ldr	r3, [r7, #4]
20004f10:	681b      	ldr	r3, [r3, #0]
20004f12:	4a30      	ldr	r2, [pc, #192]	; (20004fd4 <HAL_DMA_Abort+0x234>)
20004f14:	4293      	cmp	r3, r2
20004f16:	d04a      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f18:	687b      	ldr	r3, [r7, #4]
20004f1a:	681b      	ldr	r3, [r3, #0]
20004f1c:	4a2e      	ldr	r2, [pc, #184]	; (20004fd8 <HAL_DMA_Abort+0x238>)
20004f1e:	4293      	cmp	r3, r2
20004f20:	d045      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f22:	687b      	ldr	r3, [r7, #4]
20004f24:	681b      	ldr	r3, [r3, #0]
20004f26:	4a2d      	ldr	r2, [pc, #180]	; (20004fdc <HAL_DMA_Abort+0x23c>)
20004f28:	4293      	cmp	r3, r2
20004f2a:	d040      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f2c:	687b      	ldr	r3, [r7, #4]
20004f2e:	681b      	ldr	r3, [r3, #0]
20004f30:	4a2b      	ldr	r2, [pc, #172]	; (20004fe0 <HAL_DMA_Abort+0x240>)
20004f32:	4293      	cmp	r3, r2
20004f34:	d03b      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f36:	687b      	ldr	r3, [r7, #4]
20004f38:	681b      	ldr	r3, [r3, #0]
20004f3a:	4a2a      	ldr	r2, [pc, #168]	; (20004fe4 <HAL_DMA_Abort+0x244>)
20004f3c:	4293      	cmp	r3, r2
20004f3e:	d036      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f40:	687b      	ldr	r3, [r7, #4]
20004f42:	681b      	ldr	r3, [r3, #0]
20004f44:	4a28      	ldr	r2, [pc, #160]	; (20004fe8 <HAL_DMA_Abort+0x248>)
20004f46:	4293      	cmp	r3, r2
20004f48:	d031      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f4a:	687b      	ldr	r3, [r7, #4]
20004f4c:	681b      	ldr	r3, [r3, #0]
20004f4e:	4a27      	ldr	r2, [pc, #156]	; (20004fec <HAL_DMA_Abort+0x24c>)
20004f50:	4293      	cmp	r3, r2
20004f52:	d02c      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f54:	687b      	ldr	r3, [r7, #4]
20004f56:	681b      	ldr	r3, [r3, #0]
20004f58:	4a25      	ldr	r2, [pc, #148]	; (20004ff0 <HAL_DMA_Abort+0x250>)
20004f5a:	4293      	cmp	r3, r2
20004f5c:	d027      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f5e:	687b      	ldr	r3, [r7, #4]
20004f60:	681b      	ldr	r3, [r3, #0]
20004f62:	4a24      	ldr	r2, [pc, #144]	; (20004ff4 <HAL_DMA_Abort+0x254>)
20004f64:	4293      	cmp	r3, r2
20004f66:	d022      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f68:	687b      	ldr	r3, [r7, #4]
20004f6a:	681b      	ldr	r3, [r3, #0]
20004f6c:	4a22      	ldr	r2, [pc, #136]	; (20004ff8 <HAL_DMA_Abort+0x258>)
20004f6e:	4293      	cmp	r3, r2
20004f70:	d01d      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f72:	687b      	ldr	r3, [r7, #4]
20004f74:	681b      	ldr	r3, [r3, #0]
20004f76:	4a21      	ldr	r2, [pc, #132]	; (20004ffc <HAL_DMA_Abort+0x25c>)
20004f78:	4293      	cmp	r3, r2
20004f7a:	d018      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f7c:	687b      	ldr	r3, [r7, #4]
20004f7e:	681b      	ldr	r3, [r3, #0]
20004f80:	4a1f      	ldr	r2, [pc, #124]	; (20005000 <HAL_DMA_Abort+0x260>)
20004f82:	4293      	cmp	r3, r2
20004f84:	d013      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f86:	687b      	ldr	r3, [r7, #4]
20004f88:	681b      	ldr	r3, [r3, #0]
20004f8a:	4a1e      	ldr	r2, [pc, #120]	; (20005004 <HAL_DMA_Abort+0x264>)
20004f8c:	4293      	cmp	r3, r2
20004f8e:	d00e      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f90:	687b      	ldr	r3, [r7, #4]
20004f92:	681b      	ldr	r3, [r3, #0]
20004f94:	4a1c      	ldr	r2, [pc, #112]	; (20005008 <HAL_DMA_Abort+0x268>)
20004f96:	4293      	cmp	r3, r2
20004f98:	d009      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004f9a:	687b      	ldr	r3, [r7, #4]
20004f9c:	681b      	ldr	r3, [r3, #0]
20004f9e:	4a1b      	ldr	r2, [pc, #108]	; (2000500c <HAL_DMA_Abort+0x26c>)
20004fa0:	4293      	cmp	r3, r2
20004fa2:	d004      	beq.n	20004fae <HAL_DMA_Abort+0x20e>
20004fa4:	687b      	ldr	r3, [r7, #4]
20004fa6:	681b      	ldr	r3, [r3, #0]
20004fa8:	4a19      	ldr	r2, [pc, #100]	; (20005010 <HAL_DMA_Abort+0x270>)
20004faa:	4293      	cmp	r3, r2
20004fac:	d132      	bne.n	20005014 <HAL_DMA_Abort+0x274>
20004fae:	2301      	movs	r3, #1
20004fb0:	e031      	b.n	20005016 <HAL_DMA_Abort+0x276>
20004fb2:	bf00      	nop
20004fb4:	40020010 	.word	0x40020010
20004fb8:	40020028 	.word	0x40020028
20004fbc:	40020040 	.word	0x40020040
20004fc0:	40020058 	.word	0x40020058
20004fc4:	40020070 	.word	0x40020070
20004fc8:	40020088 	.word	0x40020088
20004fcc:	400200a0 	.word	0x400200a0
20004fd0:	400200b8 	.word	0x400200b8
20004fd4:	40020410 	.word	0x40020410
20004fd8:	40020428 	.word	0x40020428
20004fdc:	40020440 	.word	0x40020440
20004fe0:	40020458 	.word	0x40020458
20004fe4:	40020470 	.word	0x40020470
20004fe8:	40020488 	.word	0x40020488
20004fec:	400204a0 	.word	0x400204a0
20004ff0:	400204b8 	.word	0x400204b8
20004ff4:	58025408 	.word	0x58025408
20004ff8:	5802541c 	.word	0x5802541c
20004ffc:	58025430 	.word	0x58025430
20005000:	58025444 	.word	0x58025444
20005004:	58025458 	.word	0x58025458
20005008:	5802546c 	.word	0x5802546c
2000500c:	58025480 	.word	0x58025480
20005010:	58025494 	.word	0x58025494
20005014:	2300      	movs	r3, #0
20005016:	2b00      	cmp	r3, #0
20005018:	d007      	beq.n	2000502a <HAL_DMA_Abort+0x28a>
    {
      /* disable the DMAMUX sync overrun IT */
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
2000501a:	687b      	ldr	r3, [r7, #4]
2000501c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2000501e:	681a      	ldr	r2, [r3, #0]
20005020:	687b      	ldr	r3, [r7, #4]
20005022:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20005024:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20005028:	601a      	str	r2, [r3, #0]
    }

    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
2000502a:	687b      	ldr	r3, [r7, #4]
2000502c:	681b      	ldr	r3, [r3, #0]
2000502e:	4a6d      	ldr	r2, [pc, #436]	; (200051e4 <HAL_DMA_Abort+0x444>)
20005030:	4293      	cmp	r3, r2
20005032:	d04a      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
20005034:	687b      	ldr	r3, [r7, #4]
20005036:	681b      	ldr	r3, [r3, #0]
20005038:	4a6b      	ldr	r2, [pc, #428]	; (200051e8 <HAL_DMA_Abort+0x448>)
2000503a:	4293      	cmp	r3, r2
2000503c:	d045      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
2000503e:	687b      	ldr	r3, [r7, #4]
20005040:	681b      	ldr	r3, [r3, #0]
20005042:	4a6a      	ldr	r2, [pc, #424]	; (200051ec <HAL_DMA_Abort+0x44c>)
20005044:	4293      	cmp	r3, r2
20005046:	d040      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
20005048:	687b      	ldr	r3, [r7, #4]
2000504a:	681b      	ldr	r3, [r3, #0]
2000504c:	4a68      	ldr	r2, [pc, #416]	; (200051f0 <HAL_DMA_Abort+0x450>)
2000504e:	4293      	cmp	r3, r2
20005050:	d03b      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
20005052:	687b      	ldr	r3, [r7, #4]
20005054:	681b      	ldr	r3, [r3, #0]
20005056:	4a67      	ldr	r2, [pc, #412]	; (200051f4 <HAL_DMA_Abort+0x454>)
20005058:	4293      	cmp	r3, r2
2000505a:	d036      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
2000505c:	687b      	ldr	r3, [r7, #4]
2000505e:	681b      	ldr	r3, [r3, #0]
20005060:	4a65      	ldr	r2, [pc, #404]	; (200051f8 <HAL_DMA_Abort+0x458>)
20005062:	4293      	cmp	r3, r2
20005064:	d031      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
20005066:	687b      	ldr	r3, [r7, #4]
20005068:	681b      	ldr	r3, [r3, #0]
2000506a:	4a64      	ldr	r2, [pc, #400]	; (200051fc <HAL_DMA_Abort+0x45c>)
2000506c:	4293      	cmp	r3, r2
2000506e:	d02c      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
20005070:	687b      	ldr	r3, [r7, #4]
20005072:	681b      	ldr	r3, [r3, #0]
20005074:	4a62      	ldr	r2, [pc, #392]	; (20005200 <HAL_DMA_Abort+0x460>)
20005076:	4293      	cmp	r3, r2
20005078:	d027      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
2000507a:	687b      	ldr	r3, [r7, #4]
2000507c:	681b      	ldr	r3, [r3, #0]
2000507e:	4a61      	ldr	r2, [pc, #388]	; (20005204 <HAL_DMA_Abort+0x464>)
20005080:	4293      	cmp	r3, r2
20005082:	d022      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
20005084:	687b      	ldr	r3, [r7, #4]
20005086:	681b      	ldr	r3, [r3, #0]
20005088:	4a5f      	ldr	r2, [pc, #380]	; (20005208 <HAL_DMA_Abort+0x468>)
2000508a:	4293      	cmp	r3, r2
2000508c:	d01d      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
2000508e:	687b      	ldr	r3, [r7, #4]
20005090:	681b      	ldr	r3, [r3, #0]
20005092:	4a5e      	ldr	r2, [pc, #376]	; (2000520c <HAL_DMA_Abort+0x46c>)
20005094:	4293      	cmp	r3, r2
20005096:	d018      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
20005098:	687b      	ldr	r3, [r7, #4]
2000509a:	681b      	ldr	r3, [r3, #0]
2000509c:	4a5c      	ldr	r2, [pc, #368]	; (20005210 <HAL_DMA_Abort+0x470>)
2000509e:	4293      	cmp	r3, r2
200050a0:	d013      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
200050a2:	687b      	ldr	r3, [r7, #4]
200050a4:	681b      	ldr	r3, [r3, #0]
200050a6:	4a5b      	ldr	r2, [pc, #364]	; (20005214 <HAL_DMA_Abort+0x474>)
200050a8:	4293      	cmp	r3, r2
200050aa:	d00e      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
200050ac:	687b      	ldr	r3, [r7, #4]
200050ae:	681b      	ldr	r3, [r3, #0]
200050b0:	4a59      	ldr	r2, [pc, #356]	; (20005218 <HAL_DMA_Abort+0x478>)
200050b2:	4293      	cmp	r3, r2
200050b4:	d009      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
200050b6:	687b      	ldr	r3, [r7, #4]
200050b8:	681b      	ldr	r3, [r3, #0]
200050ba:	4a58      	ldr	r2, [pc, #352]	; (2000521c <HAL_DMA_Abort+0x47c>)
200050bc:	4293      	cmp	r3, r2
200050be:	d004      	beq.n	200050ca <HAL_DMA_Abort+0x32a>
200050c0:	687b      	ldr	r3, [r7, #4]
200050c2:	681b      	ldr	r3, [r3, #0]
200050c4:	4a56      	ldr	r2, [pc, #344]	; (20005220 <HAL_DMA_Abort+0x480>)
200050c6:	4293      	cmp	r3, r2
200050c8:	d108      	bne.n	200050dc <HAL_DMA_Abort+0x33c>
200050ca:	687b      	ldr	r3, [r7, #4]
200050cc:	681b      	ldr	r3, [r3, #0]
200050ce:	681a      	ldr	r2, [r3, #0]
200050d0:	687b      	ldr	r3, [r7, #4]
200050d2:	681b      	ldr	r3, [r3, #0]
200050d4:	f022 0201 	bic.w	r2, r2, #1
200050d8:	601a      	str	r2, [r3, #0]
200050da:	e007      	b.n	200050ec <HAL_DMA_Abort+0x34c>
200050dc:	687b      	ldr	r3, [r7, #4]
200050de:	681b      	ldr	r3, [r3, #0]
200050e0:	681a      	ldr	r2, [r3, #0]
200050e2:	687b      	ldr	r3, [r7, #4]
200050e4:	681b      	ldr	r3, [r3, #0]
200050e6:	f022 0201 	bic.w	r2, r2, #1
200050ea:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
200050ec:	e013      	b.n	20005116 <HAL_DMA_Abort+0x376>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
200050ee:	f7fc fdfd 	bl	20001cec <HAL_GetTick>
200050f2:	4602      	mov	r2, r0
200050f4:	693b      	ldr	r3, [r7, #16]
200050f6:	1ad3      	subs	r3, r2, r3
200050f8:	2b05      	cmp	r3, #5
200050fa:	d90c      	bls.n	20005116 <HAL_DMA_Abort+0x376>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
200050fc:	687b      	ldr	r3, [r7, #4]
200050fe:	2220      	movs	r2, #32
20005100:	655a      	str	r2, [r3, #84]	; 0x54

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
20005102:	687b      	ldr	r3, [r7, #4]
20005104:	2200      	movs	r2, #0
20005106:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
2000510a:	687b      	ldr	r3, [r7, #4]
2000510c:	2203      	movs	r2, #3
2000510e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        return HAL_ERROR;
20005112:	2301      	movs	r3, #1
20005114:	e12d      	b.n	20005372 <HAL_DMA_Abort+0x5d2>
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
20005116:	697b      	ldr	r3, [r7, #20]
20005118:	681b      	ldr	r3, [r3, #0]
2000511a:	f003 0301 	and.w	r3, r3, #1
2000511e:	2b00      	cmp	r3, #0
20005120:	d1e5      	bne.n	200050ee <HAL_DMA_Abort+0x34e>
      }
    }

    /* Clear all interrupt flags at correct offset within the register */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20005122:	687b      	ldr	r3, [r7, #4]
20005124:	681b      	ldr	r3, [r3, #0]
20005126:	4a2f      	ldr	r2, [pc, #188]	; (200051e4 <HAL_DMA_Abort+0x444>)
20005128:	4293      	cmp	r3, r2
2000512a:	d04a      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
2000512c:	687b      	ldr	r3, [r7, #4]
2000512e:	681b      	ldr	r3, [r3, #0]
20005130:	4a2d      	ldr	r2, [pc, #180]	; (200051e8 <HAL_DMA_Abort+0x448>)
20005132:	4293      	cmp	r3, r2
20005134:	d045      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
20005136:	687b      	ldr	r3, [r7, #4]
20005138:	681b      	ldr	r3, [r3, #0]
2000513a:	4a2c      	ldr	r2, [pc, #176]	; (200051ec <HAL_DMA_Abort+0x44c>)
2000513c:	4293      	cmp	r3, r2
2000513e:	d040      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
20005140:	687b      	ldr	r3, [r7, #4]
20005142:	681b      	ldr	r3, [r3, #0]
20005144:	4a2a      	ldr	r2, [pc, #168]	; (200051f0 <HAL_DMA_Abort+0x450>)
20005146:	4293      	cmp	r3, r2
20005148:	d03b      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
2000514a:	687b      	ldr	r3, [r7, #4]
2000514c:	681b      	ldr	r3, [r3, #0]
2000514e:	4a29      	ldr	r2, [pc, #164]	; (200051f4 <HAL_DMA_Abort+0x454>)
20005150:	4293      	cmp	r3, r2
20005152:	d036      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
20005154:	687b      	ldr	r3, [r7, #4]
20005156:	681b      	ldr	r3, [r3, #0]
20005158:	4a27      	ldr	r2, [pc, #156]	; (200051f8 <HAL_DMA_Abort+0x458>)
2000515a:	4293      	cmp	r3, r2
2000515c:	d031      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
2000515e:	687b      	ldr	r3, [r7, #4]
20005160:	681b      	ldr	r3, [r3, #0]
20005162:	4a26      	ldr	r2, [pc, #152]	; (200051fc <HAL_DMA_Abort+0x45c>)
20005164:	4293      	cmp	r3, r2
20005166:	d02c      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
20005168:	687b      	ldr	r3, [r7, #4]
2000516a:	681b      	ldr	r3, [r3, #0]
2000516c:	4a24      	ldr	r2, [pc, #144]	; (20005200 <HAL_DMA_Abort+0x460>)
2000516e:	4293      	cmp	r3, r2
20005170:	d027      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
20005172:	687b      	ldr	r3, [r7, #4]
20005174:	681b      	ldr	r3, [r3, #0]
20005176:	4a23      	ldr	r2, [pc, #140]	; (20005204 <HAL_DMA_Abort+0x464>)
20005178:	4293      	cmp	r3, r2
2000517a:	d022      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
2000517c:	687b      	ldr	r3, [r7, #4]
2000517e:	681b      	ldr	r3, [r3, #0]
20005180:	4a21      	ldr	r2, [pc, #132]	; (20005208 <HAL_DMA_Abort+0x468>)
20005182:	4293      	cmp	r3, r2
20005184:	d01d      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
20005186:	687b      	ldr	r3, [r7, #4]
20005188:	681b      	ldr	r3, [r3, #0]
2000518a:	4a20      	ldr	r2, [pc, #128]	; (2000520c <HAL_DMA_Abort+0x46c>)
2000518c:	4293      	cmp	r3, r2
2000518e:	d018      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
20005190:	687b      	ldr	r3, [r7, #4]
20005192:	681b      	ldr	r3, [r3, #0]
20005194:	4a1e      	ldr	r2, [pc, #120]	; (20005210 <HAL_DMA_Abort+0x470>)
20005196:	4293      	cmp	r3, r2
20005198:	d013      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
2000519a:	687b      	ldr	r3, [r7, #4]
2000519c:	681b      	ldr	r3, [r3, #0]
2000519e:	4a1d      	ldr	r2, [pc, #116]	; (20005214 <HAL_DMA_Abort+0x474>)
200051a0:	4293      	cmp	r3, r2
200051a2:	d00e      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
200051a4:	687b      	ldr	r3, [r7, #4]
200051a6:	681b      	ldr	r3, [r3, #0]
200051a8:	4a1b      	ldr	r2, [pc, #108]	; (20005218 <HAL_DMA_Abort+0x478>)
200051aa:	4293      	cmp	r3, r2
200051ac:	d009      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
200051ae:	687b      	ldr	r3, [r7, #4]
200051b0:	681b      	ldr	r3, [r3, #0]
200051b2:	4a1a      	ldr	r2, [pc, #104]	; (2000521c <HAL_DMA_Abort+0x47c>)
200051b4:	4293      	cmp	r3, r2
200051b6:	d004      	beq.n	200051c2 <HAL_DMA_Abort+0x422>
200051b8:	687b      	ldr	r3, [r7, #4]
200051ba:	681b      	ldr	r3, [r3, #0]
200051bc:	4a18      	ldr	r2, [pc, #96]	; (20005220 <HAL_DMA_Abort+0x480>)
200051be:	4293      	cmp	r3, r2
200051c0:	d101      	bne.n	200051c6 <HAL_DMA_Abort+0x426>
200051c2:	2301      	movs	r3, #1
200051c4:	e000      	b.n	200051c8 <HAL_DMA_Abort+0x428>
200051c6:	2300      	movs	r3, #0
200051c8:	2b00      	cmp	r3, #0
200051ca:	d02b      	beq.n	20005224 <HAL_DMA_Abort+0x484>
    {
      regs_dma = (DMA_Base_Registers *)hdma->StreamBaseAddress;
200051cc:	687b      	ldr	r3, [r7, #4]
200051ce:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200051d0:	60bb      	str	r3, [r7, #8]
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
200051d2:	687b      	ldr	r3, [r7, #4]
200051d4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200051d6:	f003 031f 	and.w	r3, r3, #31
200051da:	223f      	movs	r2, #63	; 0x3f
200051dc:	409a      	lsls	r2, r3
200051de:	68bb      	ldr	r3, [r7, #8]
200051e0:	609a      	str	r2, [r3, #8]
200051e2:	e02a      	b.n	2000523a <HAL_DMA_Abort+0x49a>
200051e4:	40020010 	.word	0x40020010
200051e8:	40020028 	.word	0x40020028
200051ec:	40020040 	.word	0x40020040
200051f0:	40020058 	.word	0x40020058
200051f4:	40020070 	.word	0x40020070
200051f8:	40020088 	.word	0x40020088
200051fc:	400200a0 	.word	0x400200a0
20005200:	400200b8 	.word	0x400200b8
20005204:	40020410 	.word	0x40020410
20005208:	40020428 	.word	0x40020428
2000520c:	40020440 	.word	0x40020440
20005210:	40020458 	.word	0x40020458
20005214:	40020470 	.word	0x40020470
20005218:	40020488 	.word	0x40020488
2000521c:	400204a0 	.word	0x400204a0
20005220:	400204b8 	.word	0x400204b8
    }
    else /* BDMA channel */
    {
      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
20005224:	687b      	ldr	r3, [r7, #4]
20005226:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20005228:	60fb      	str	r3, [r7, #12]
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
2000522a:	687b      	ldr	r3, [r7, #4]
2000522c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2000522e:	f003 031f 	and.w	r3, r3, #31
20005232:	2201      	movs	r2, #1
20005234:	409a      	lsls	r2, r3
20005236:	68fb      	ldr	r3, [r7, #12]
20005238:	605a      	str	r2, [r3, #4]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2000523a:	687b      	ldr	r3, [r7, #4]
2000523c:	681b      	ldr	r3, [r3, #0]
2000523e:	4a4f      	ldr	r2, [pc, #316]	; (2000537c <HAL_DMA_Abort+0x5dc>)
20005240:	4293      	cmp	r3, r2
20005242:	d072      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
20005244:	687b      	ldr	r3, [r7, #4]
20005246:	681b      	ldr	r3, [r3, #0]
20005248:	4a4d      	ldr	r2, [pc, #308]	; (20005380 <HAL_DMA_Abort+0x5e0>)
2000524a:	4293      	cmp	r3, r2
2000524c:	d06d      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
2000524e:	687b      	ldr	r3, [r7, #4]
20005250:	681b      	ldr	r3, [r3, #0]
20005252:	4a4c      	ldr	r2, [pc, #304]	; (20005384 <HAL_DMA_Abort+0x5e4>)
20005254:	4293      	cmp	r3, r2
20005256:	d068      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
20005258:	687b      	ldr	r3, [r7, #4]
2000525a:	681b      	ldr	r3, [r3, #0]
2000525c:	4a4a      	ldr	r2, [pc, #296]	; (20005388 <HAL_DMA_Abort+0x5e8>)
2000525e:	4293      	cmp	r3, r2
20005260:	d063      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
20005262:	687b      	ldr	r3, [r7, #4]
20005264:	681b      	ldr	r3, [r3, #0]
20005266:	4a49      	ldr	r2, [pc, #292]	; (2000538c <HAL_DMA_Abort+0x5ec>)
20005268:	4293      	cmp	r3, r2
2000526a:	d05e      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
2000526c:	687b      	ldr	r3, [r7, #4]
2000526e:	681b      	ldr	r3, [r3, #0]
20005270:	4a47      	ldr	r2, [pc, #284]	; (20005390 <HAL_DMA_Abort+0x5f0>)
20005272:	4293      	cmp	r3, r2
20005274:	d059      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
20005276:	687b      	ldr	r3, [r7, #4]
20005278:	681b      	ldr	r3, [r3, #0]
2000527a:	4a46      	ldr	r2, [pc, #280]	; (20005394 <HAL_DMA_Abort+0x5f4>)
2000527c:	4293      	cmp	r3, r2
2000527e:	d054      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
20005280:	687b      	ldr	r3, [r7, #4]
20005282:	681b      	ldr	r3, [r3, #0]
20005284:	4a44      	ldr	r2, [pc, #272]	; (20005398 <HAL_DMA_Abort+0x5f8>)
20005286:	4293      	cmp	r3, r2
20005288:	d04f      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
2000528a:	687b      	ldr	r3, [r7, #4]
2000528c:	681b      	ldr	r3, [r3, #0]
2000528e:	4a43      	ldr	r2, [pc, #268]	; (2000539c <HAL_DMA_Abort+0x5fc>)
20005290:	4293      	cmp	r3, r2
20005292:	d04a      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
20005294:	687b      	ldr	r3, [r7, #4]
20005296:	681b      	ldr	r3, [r3, #0]
20005298:	4a41      	ldr	r2, [pc, #260]	; (200053a0 <HAL_DMA_Abort+0x600>)
2000529a:	4293      	cmp	r3, r2
2000529c:	d045      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
2000529e:	687b      	ldr	r3, [r7, #4]
200052a0:	681b      	ldr	r3, [r3, #0]
200052a2:	4a40      	ldr	r2, [pc, #256]	; (200053a4 <HAL_DMA_Abort+0x604>)
200052a4:	4293      	cmp	r3, r2
200052a6:	d040      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
200052a8:	687b      	ldr	r3, [r7, #4]
200052aa:	681b      	ldr	r3, [r3, #0]
200052ac:	4a3e      	ldr	r2, [pc, #248]	; (200053a8 <HAL_DMA_Abort+0x608>)
200052ae:	4293      	cmp	r3, r2
200052b0:	d03b      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
200052b2:	687b      	ldr	r3, [r7, #4]
200052b4:	681b      	ldr	r3, [r3, #0]
200052b6:	4a3d      	ldr	r2, [pc, #244]	; (200053ac <HAL_DMA_Abort+0x60c>)
200052b8:	4293      	cmp	r3, r2
200052ba:	d036      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
200052bc:	687b      	ldr	r3, [r7, #4]
200052be:	681b      	ldr	r3, [r3, #0]
200052c0:	4a3b      	ldr	r2, [pc, #236]	; (200053b0 <HAL_DMA_Abort+0x610>)
200052c2:	4293      	cmp	r3, r2
200052c4:	d031      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
200052c6:	687b      	ldr	r3, [r7, #4]
200052c8:	681b      	ldr	r3, [r3, #0]
200052ca:	4a3a      	ldr	r2, [pc, #232]	; (200053b4 <HAL_DMA_Abort+0x614>)
200052cc:	4293      	cmp	r3, r2
200052ce:	d02c      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
200052d0:	687b      	ldr	r3, [r7, #4]
200052d2:	681b      	ldr	r3, [r3, #0]
200052d4:	4a38      	ldr	r2, [pc, #224]	; (200053b8 <HAL_DMA_Abort+0x618>)
200052d6:	4293      	cmp	r3, r2
200052d8:	d027      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
200052da:	687b      	ldr	r3, [r7, #4]
200052dc:	681b      	ldr	r3, [r3, #0]
200052de:	4a37      	ldr	r2, [pc, #220]	; (200053bc <HAL_DMA_Abort+0x61c>)
200052e0:	4293      	cmp	r3, r2
200052e2:	d022      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
200052e4:	687b      	ldr	r3, [r7, #4]
200052e6:	681b      	ldr	r3, [r3, #0]
200052e8:	4a35      	ldr	r2, [pc, #212]	; (200053c0 <HAL_DMA_Abort+0x620>)
200052ea:	4293      	cmp	r3, r2
200052ec:	d01d      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
200052ee:	687b      	ldr	r3, [r7, #4]
200052f0:	681b      	ldr	r3, [r3, #0]
200052f2:	4a34      	ldr	r2, [pc, #208]	; (200053c4 <HAL_DMA_Abort+0x624>)
200052f4:	4293      	cmp	r3, r2
200052f6:	d018      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
200052f8:	687b      	ldr	r3, [r7, #4]
200052fa:	681b      	ldr	r3, [r3, #0]
200052fc:	4a32      	ldr	r2, [pc, #200]	; (200053c8 <HAL_DMA_Abort+0x628>)
200052fe:	4293      	cmp	r3, r2
20005300:	d013      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
20005302:	687b      	ldr	r3, [r7, #4]
20005304:	681b      	ldr	r3, [r3, #0]
20005306:	4a31      	ldr	r2, [pc, #196]	; (200053cc <HAL_DMA_Abort+0x62c>)
20005308:	4293      	cmp	r3, r2
2000530a:	d00e      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
2000530c:	687b      	ldr	r3, [r7, #4]
2000530e:	681b      	ldr	r3, [r3, #0]
20005310:	4a2f      	ldr	r2, [pc, #188]	; (200053d0 <HAL_DMA_Abort+0x630>)
20005312:	4293      	cmp	r3, r2
20005314:	d009      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
20005316:	687b      	ldr	r3, [r7, #4]
20005318:	681b      	ldr	r3, [r3, #0]
2000531a:	4a2e      	ldr	r2, [pc, #184]	; (200053d4 <HAL_DMA_Abort+0x634>)
2000531c:	4293      	cmp	r3, r2
2000531e:	d004      	beq.n	2000532a <HAL_DMA_Abort+0x58a>
20005320:	687b      	ldr	r3, [r7, #4]
20005322:	681b      	ldr	r3, [r3, #0]
20005324:	4a2c      	ldr	r2, [pc, #176]	; (200053d8 <HAL_DMA_Abort+0x638>)
20005326:	4293      	cmp	r3, r2
20005328:	d101      	bne.n	2000532e <HAL_DMA_Abort+0x58e>
2000532a:	2301      	movs	r3, #1
2000532c:	e000      	b.n	20005330 <HAL_DMA_Abort+0x590>
2000532e:	2300      	movs	r3, #0
20005330:	2b00      	cmp	r3, #0
20005332:	d015      	beq.n	20005360 <HAL_DMA_Abort+0x5c0>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
20005334:	687b      	ldr	r3, [r7, #4]
20005336:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20005338:	687a      	ldr	r2, [r7, #4]
2000533a:	6e92      	ldr	r2, [r2, #104]	; 0x68
2000533c:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
2000533e:	687b      	ldr	r3, [r7, #4]
20005340:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20005342:	2b00      	cmp	r3, #0
20005344:	d00c      	beq.n	20005360 <HAL_DMA_Abort+0x5c0>
      {
        /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT */
        /* disable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
20005346:	687b      	ldr	r3, [r7, #4]
20005348:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2000534a:	681a      	ldr	r2, [r3, #0]
2000534c:	687b      	ldr	r3, [r7, #4]
2000534e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20005350:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20005354:	601a      	str	r2, [r3, #0]

        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
20005356:	687b      	ldr	r3, [r7, #4]
20005358:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000535a:	687a      	ldr	r2, [r7, #4]
2000535c:	6f52      	ldr	r2, [r2, #116]	; 0x74
2000535e:	605a      	str	r2, [r3, #4]
      }
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
20005360:	687b      	ldr	r3, [r7, #4]
20005362:	2200      	movs	r2, #0
20005364:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
20005368:	687b      	ldr	r3, [r7, #4]
2000536a:	2201      	movs	r2, #1
2000536c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  }

  return HAL_OK;
20005370:	2300      	movs	r3, #0
}
20005372:	4618      	mov	r0, r3
20005374:	3718      	adds	r7, #24
20005376:	46bd      	mov	sp, r7
20005378:	bd80      	pop	{r7, pc}
2000537a:	bf00      	nop
2000537c:	40020010 	.word	0x40020010
20005380:	40020028 	.word	0x40020028
20005384:	40020040 	.word	0x40020040
20005388:	40020058 	.word	0x40020058
2000538c:	40020070 	.word	0x40020070
20005390:	40020088 	.word	0x40020088
20005394:	400200a0 	.word	0x400200a0
20005398:	400200b8 	.word	0x400200b8
2000539c:	40020410 	.word	0x40020410
200053a0:	40020428 	.word	0x40020428
200053a4:	40020440 	.word	0x40020440
200053a8:	40020458 	.word	0x40020458
200053ac:	40020470 	.word	0x40020470
200053b0:	40020488 	.word	0x40020488
200053b4:	400204a0 	.word	0x400204a0
200053b8:	400204b8 	.word	0x400204b8
200053bc:	58025408 	.word	0x58025408
200053c0:	5802541c 	.word	0x5802541c
200053c4:	58025430 	.word	0x58025430
200053c8:	58025444 	.word	0x58025444
200053cc:	58025458 	.word	0x58025458
200053d0:	5802546c 	.word	0x5802546c
200053d4:	58025480 	.word	0x58025480
200053d8:	58025494 	.word	0x58025494

200053dc <HAL_DMA_Abort_IT>:
  * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
200053dc:	b580      	push	{r7, lr}
200053de:	b084      	sub	sp, #16
200053e0:	af00      	add	r7, sp, #0
200053e2:	6078      	str	r0, [r7, #4]
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
200053e4:	687b      	ldr	r3, [r7, #4]
200053e6:	2b00      	cmp	r3, #0
200053e8:	d101      	bne.n	200053ee <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
200053ea:	2301      	movs	r3, #1
200053ec:	e205      	b.n	200057fa <HAL_DMA_Abort_IT+0x41e>
  }

  if(hdma->State != HAL_DMA_STATE_BUSY)
200053ee:	687b      	ldr	r3, [r7, #4]
200053f0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
200053f4:	b2db      	uxtb	r3, r3
200053f6:	2b02      	cmp	r3, #2
200053f8:	d004      	beq.n	20005404 <HAL_DMA_Abort_IT+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
200053fa:	687b      	ldr	r3, [r7, #4]
200053fc:	2280      	movs	r2, #128	; 0x80
200053fe:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
20005400:	2301      	movs	r3, #1
20005402:	e1fa      	b.n	200057fa <HAL_DMA_Abort_IT+0x41e>
  }
  else
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20005404:	687b      	ldr	r3, [r7, #4]
20005406:	681b      	ldr	r3, [r3, #0]
20005408:	4a8c      	ldr	r2, [pc, #560]	; (2000563c <HAL_DMA_Abort_IT+0x260>)
2000540a:	4293      	cmp	r3, r2
2000540c:	d04a      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
2000540e:	687b      	ldr	r3, [r7, #4]
20005410:	681b      	ldr	r3, [r3, #0]
20005412:	4a8b      	ldr	r2, [pc, #556]	; (20005640 <HAL_DMA_Abort_IT+0x264>)
20005414:	4293      	cmp	r3, r2
20005416:	d045      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
20005418:	687b      	ldr	r3, [r7, #4]
2000541a:	681b      	ldr	r3, [r3, #0]
2000541c:	4a89      	ldr	r2, [pc, #548]	; (20005644 <HAL_DMA_Abort_IT+0x268>)
2000541e:	4293      	cmp	r3, r2
20005420:	d040      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
20005422:	687b      	ldr	r3, [r7, #4]
20005424:	681b      	ldr	r3, [r3, #0]
20005426:	4a88      	ldr	r2, [pc, #544]	; (20005648 <HAL_DMA_Abort_IT+0x26c>)
20005428:	4293      	cmp	r3, r2
2000542a:	d03b      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
2000542c:	687b      	ldr	r3, [r7, #4]
2000542e:	681b      	ldr	r3, [r3, #0]
20005430:	4a86      	ldr	r2, [pc, #536]	; (2000564c <HAL_DMA_Abort_IT+0x270>)
20005432:	4293      	cmp	r3, r2
20005434:	d036      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
20005436:	687b      	ldr	r3, [r7, #4]
20005438:	681b      	ldr	r3, [r3, #0]
2000543a:	4a85      	ldr	r2, [pc, #532]	; (20005650 <HAL_DMA_Abort_IT+0x274>)
2000543c:	4293      	cmp	r3, r2
2000543e:	d031      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
20005440:	687b      	ldr	r3, [r7, #4]
20005442:	681b      	ldr	r3, [r3, #0]
20005444:	4a83      	ldr	r2, [pc, #524]	; (20005654 <HAL_DMA_Abort_IT+0x278>)
20005446:	4293      	cmp	r3, r2
20005448:	d02c      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
2000544a:	687b      	ldr	r3, [r7, #4]
2000544c:	681b      	ldr	r3, [r3, #0]
2000544e:	4a82      	ldr	r2, [pc, #520]	; (20005658 <HAL_DMA_Abort_IT+0x27c>)
20005450:	4293      	cmp	r3, r2
20005452:	d027      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
20005454:	687b      	ldr	r3, [r7, #4]
20005456:	681b      	ldr	r3, [r3, #0]
20005458:	4a80      	ldr	r2, [pc, #512]	; (2000565c <HAL_DMA_Abort_IT+0x280>)
2000545a:	4293      	cmp	r3, r2
2000545c:	d022      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
2000545e:	687b      	ldr	r3, [r7, #4]
20005460:	681b      	ldr	r3, [r3, #0]
20005462:	4a7f      	ldr	r2, [pc, #508]	; (20005660 <HAL_DMA_Abort_IT+0x284>)
20005464:	4293      	cmp	r3, r2
20005466:	d01d      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
20005468:	687b      	ldr	r3, [r7, #4]
2000546a:	681b      	ldr	r3, [r3, #0]
2000546c:	4a7d      	ldr	r2, [pc, #500]	; (20005664 <HAL_DMA_Abort_IT+0x288>)
2000546e:	4293      	cmp	r3, r2
20005470:	d018      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
20005472:	687b      	ldr	r3, [r7, #4]
20005474:	681b      	ldr	r3, [r3, #0]
20005476:	4a7c      	ldr	r2, [pc, #496]	; (20005668 <HAL_DMA_Abort_IT+0x28c>)
20005478:	4293      	cmp	r3, r2
2000547a:	d013      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
2000547c:	687b      	ldr	r3, [r7, #4]
2000547e:	681b      	ldr	r3, [r3, #0]
20005480:	4a7a      	ldr	r2, [pc, #488]	; (2000566c <HAL_DMA_Abort_IT+0x290>)
20005482:	4293      	cmp	r3, r2
20005484:	d00e      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
20005486:	687b      	ldr	r3, [r7, #4]
20005488:	681b      	ldr	r3, [r3, #0]
2000548a:	4a79      	ldr	r2, [pc, #484]	; (20005670 <HAL_DMA_Abort_IT+0x294>)
2000548c:	4293      	cmp	r3, r2
2000548e:	d009      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
20005490:	687b      	ldr	r3, [r7, #4]
20005492:	681b      	ldr	r3, [r3, #0]
20005494:	4a77      	ldr	r2, [pc, #476]	; (20005674 <HAL_DMA_Abort_IT+0x298>)
20005496:	4293      	cmp	r3, r2
20005498:	d004      	beq.n	200054a4 <HAL_DMA_Abort_IT+0xc8>
2000549a:	687b      	ldr	r3, [r7, #4]
2000549c:	681b      	ldr	r3, [r3, #0]
2000549e:	4a76      	ldr	r2, [pc, #472]	; (20005678 <HAL_DMA_Abort_IT+0x29c>)
200054a0:	4293      	cmp	r3, r2
200054a2:	d101      	bne.n	200054a8 <HAL_DMA_Abort_IT+0xcc>
200054a4:	2301      	movs	r3, #1
200054a6:	e000      	b.n	200054aa <HAL_DMA_Abort_IT+0xce>
200054a8:	2300      	movs	r3, #0
200054aa:	2b00      	cmp	r3, #0
200054ac:	d065      	beq.n	2000557a <HAL_DMA_Abort_IT+0x19e>
    {
      /* Set Abort State  */
      hdma->State = HAL_DMA_STATE_ABORT;
200054ae:	687b      	ldr	r3, [r7, #4]
200054b0:	2204      	movs	r2, #4
200054b2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
200054b6:	687b      	ldr	r3, [r7, #4]
200054b8:	681b      	ldr	r3, [r3, #0]
200054ba:	4a60      	ldr	r2, [pc, #384]	; (2000563c <HAL_DMA_Abort_IT+0x260>)
200054bc:	4293      	cmp	r3, r2
200054be:	d04a      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
200054c0:	687b      	ldr	r3, [r7, #4]
200054c2:	681b      	ldr	r3, [r3, #0]
200054c4:	4a5e      	ldr	r2, [pc, #376]	; (20005640 <HAL_DMA_Abort_IT+0x264>)
200054c6:	4293      	cmp	r3, r2
200054c8:	d045      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
200054ca:	687b      	ldr	r3, [r7, #4]
200054cc:	681b      	ldr	r3, [r3, #0]
200054ce:	4a5d      	ldr	r2, [pc, #372]	; (20005644 <HAL_DMA_Abort_IT+0x268>)
200054d0:	4293      	cmp	r3, r2
200054d2:	d040      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
200054d4:	687b      	ldr	r3, [r7, #4]
200054d6:	681b      	ldr	r3, [r3, #0]
200054d8:	4a5b      	ldr	r2, [pc, #364]	; (20005648 <HAL_DMA_Abort_IT+0x26c>)
200054da:	4293      	cmp	r3, r2
200054dc:	d03b      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
200054de:	687b      	ldr	r3, [r7, #4]
200054e0:	681b      	ldr	r3, [r3, #0]
200054e2:	4a5a      	ldr	r2, [pc, #360]	; (2000564c <HAL_DMA_Abort_IT+0x270>)
200054e4:	4293      	cmp	r3, r2
200054e6:	d036      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
200054e8:	687b      	ldr	r3, [r7, #4]
200054ea:	681b      	ldr	r3, [r3, #0]
200054ec:	4a58      	ldr	r2, [pc, #352]	; (20005650 <HAL_DMA_Abort_IT+0x274>)
200054ee:	4293      	cmp	r3, r2
200054f0:	d031      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
200054f2:	687b      	ldr	r3, [r7, #4]
200054f4:	681b      	ldr	r3, [r3, #0]
200054f6:	4a57      	ldr	r2, [pc, #348]	; (20005654 <HAL_DMA_Abort_IT+0x278>)
200054f8:	4293      	cmp	r3, r2
200054fa:	d02c      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
200054fc:	687b      	ldr	r3, [r7, #4]
200054fe:	681b      	ldr	r3, [r3, #0]
20005500:	4a55      	ldr	r2, [pc, #340]	; (20005658 <HAL_DMA_Abort_IT+0x27c>)
20005502:	4293      	cmp	r3, r2
20005504:	d027      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
20005506:	687b      	ldr	r3, [r7, #4]
20005508:	681b      	ldr	r3, [r3, #0]
2000550a:	4a54      	ldr	r2, [pc, #336]	; (2000565c <HAL_DMA_Abort_IT+0x280>)
2000550c:	4293      	cmp	r3, r2
2000550e:	d022      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
20005510:	687b      	ldr	r3, [r7, #4]
20005512:	681b      	ldr	r3, [r3, #0]
20005514:	4a52      	ldr	r2, [pc, #328]	; (20005660 <HAL_DMA_Abort_IT+0x284>)
20005516:	4293      	cmp	r3, r2
20005518:	d01d      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
2000551a:	687b      	ldr	r3, [r7, #4]
2000551c:	681b      	ldr	r3, [r3, #0]
2000551e:	4a51      	ldr	r2, [pc, #324]	; (20005664 <HAL_DMA_Abort_IT+0x288>)
20005520:	4293      	cmp	r3, r2
20005522:	d018      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
20005524:	687b      	ldr	r3, [r7, #4]
20005526:	681b      	ldr	r3, [r3, #0]
20005528:	4a4f      	ldr	r2, [pc, #316]	; (20005668 <HAL_DMA_Abort_IT+0x28c>)
2000552a:	4293      	cmp	r3, r2
2000552c:	d013      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
2000552e:	687b      	ldr	r3, [r7, #4]
20005530:	681b      	ldr	r3, [r3, #0]
20005532:	4a4e      	ldr	r2, [pc, #312]	; (2000566c <HAL_DMA_Abort_IT+0x290>)
20005534:	4293      	cmp	r3, r2
20005536:	d00e      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
20005538:	687b      	ldr	r3, [r7, #4]
2000553a:	681b      	ldr	r3, [r3, #0]
2000553c:	4a4c      	ldr	r2, [pc, #304]	; (20005670 <HAL_DMA_Abort_IT+0x294>)
2000553e:	4293      	cmp	r3, r2
20005540:	d009      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
20005542:	687b      	ldr	r3, [r7, #4]
20005544:	681b      	ldr	r3, [r3, #0]
20005546:	4a4b      	ldr	r2, [pc, #300]	; (20005674 <HAL_DMA_Abort_IT+0x298>)
20005548:	4293      	cmp	r3, r2
2000554a:	d004      	beq.n	20005556 <HAL_DMA_Abort_IT+0x17a>
2000554c:	687b      	ldr	r3, [r7, #4]
2000554e:	681b      	ldr	r3, [r3, #0]
20005550:	4a49      	ldr	r2, [pc, #292]	; (20005678 <HAL_DMA_Abort_IT+0x29c>)
20005552:	4293      	cmp	r3, r2
20005554:	d108      	bne.n	20005568 <HAL_DMA_Abort_IT+0x18c>
20005556:	687b      	ldr	r3, [r7, #4]
20005558:	681b      	ldr	r3, [r3, #0]
2000555a:	681a      	ldr	r2, [r3, #0]
2000555c:	687b      	ldr	r3, [r7, #4]
2000555e:	681b      	ldr	r3, [r3, #0]
20005560:	f022 0201 	bic.w	r2, r2, #1
20005564:	601a      	str	r2, [r3, #0]
20005566:	e147      	b.n	200057f8 <HAL_DMA_Abort_IT+0x41c>
20005568:	687b      	ldr	r3, [r7, #4]
2000556a:	681b      	ldr	r3, [r3, #0]
2000556c:	681a      	ldr	r2, [r3, #0]
2000556e:	687b      	ldr	r3, [r7, #4]
20005570:	681b      	ldr	r3, [r3, #0]
20005572:	f022 0201 	bic.w	r2, r2, #1
20005576:	601a      	str	r2, [r3, #0]
20005578:	e13e      	b.n	200057f8 <HAL_DMA_Abort_IT+0x41c>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts  */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
2000557a:	687b      	ldr	r3, [r7, #4]
2000557c:	681b      	ldr	r3, [r3, #0]
2000557e:	681a      	ldr	r2, [r3, #0]
20005580:	687b      	ldr	r3, [r7, #4]
20005582:	681b      	ldr	r3, [r3, #0]
20005584:	f022 020e 	bic.w	r2, r2, #14
20005588:	601a      	str	r2, [r3, #0]

      /* Disable the channel */
      __HAL_DMA_DISABLE(hdma);
2000558a:	687b      	ldr	r3, [r7, #4]
2000558c:	681b      	ldr	r3, [r3, #0]
2000558e:	4a2b      	ldr	r2, [pc, #172]	; (2000563c <HAL_DMA_Abort_IT+0x260>)
20005590:	4293      	cmp	r3, r2
20005592:	d04a      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
20005594:	687b      	ldr	r3, [r7, #4]
20005596:	681b      	ldr	r3, [r3, #0]
20005598:	4a29      	ldr	r2, [pc, #164]	; (20005640 <HAL_DMA_Abort_IT+0x264>)
2000559a:	4293      	cmp	r3, r2
2000559c:	d045      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
2000559e:	687b      	ldr	r3, [r7, #4]
200055a0:	681b      	ldr	r3, [r3, #0]
200055a2:	4a28      	ldr	r2, [pc, #160]	; (20005644 <HAL_DMA_Abort_IT+0x268>)
200055a4:	4293      	cmp	r3, r2
200055a6:	d040      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
200055a8:	687b      	ldr	r3, [r7, #4]
200055aa:	681b      	ldr	r3, [r3, #0]
200055ac:	4a26      	ldr	r2, [pc, #152]	; (20005648 <HAL_DMA_Abort_IT+0x26c>)
200055ae:	4293      	cmp	r3, r2
200055b0:	d03b      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
200055b2:	687b      	ldr	r3, [r7, #4]
200055b4:	681b      	ldr	r3, [r3, #0]
200055b6:	4a25      	ldr	r2, [pc, #148]	; (2000564c <HAL_DMA_Abort_IT+0x270>)
200055b8:	4293      	cmp	r3, r2
200055ba:	d036      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
200055bc:	687b      	ldr	r3, [r7, #4]
200055be:	681b      	ldr	r3, [r3, #0]
200055c0:	4a23      	ldr	r2, [pc, #140]	; (20005650 <HAL_DMA_Abort_IT+0x274>)
200055c2:	4293      	cmp	r3, r2
200055c4:	d031      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
200055c6:	687b      	ldr	r3, [r7, #4]
200055c8:	681b      	ldr	r3, [r3, #0]
200055ca:	4a22      	ldr	r2, [pc, #136]	; (20005654 <HAL_DMA_Abort_IT+0x278>)
200055cc:	4293      	cmp	r3, r2
200055ce:	d02c      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
200055d0:	687b      	ldr	r3, [r7, #4]
200055d2:	681b      	ldr	r3, [r3, #0]
200055d4:	4a20      	ldr	r2, [pc, #128]	; (20005658 <HAL_DMA_Abort_IT+0x27c>)
200055d6:	4293      	cmp	r3, r2
200055d8:	d027      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
200055da:	687b      	ldr	r3, [r7, #4]
200055dc:	681b      	ldr	r3, [r3, #0]
200055de:	4a1f      	ldr	r2, [pc, #124]	; (2000565c <HAL_DMA_Abort_IT+0x280>)
200055e0:	4293      	cmp	r3, r2
200055e2:	d022      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
200055e4:	687b      	ldr	r3, [r7, #4]
200055e6:	681b      	ldr	r3, [r3, #0]
200055e8:	4a1d      	ldr	r2, [pc, #116]	; (20005660 <HAL_DMA_Abort_IT+0x284>)
200055ea:	4293      	cmp	r3, r2
200055ec:	d01d      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
200055ee:	687b      	ldr	r3, [r7, #4]
200055f0:	681b      	ldr	r3, [r3, #0]
200055f2:	4a1c      	ldr	r2, [pc, #112]	; (20005664 <HAL_DMA_Abort_IT+0x288>)
200055f4:	4293      	cmp	r3, r2
200055f6:	d018      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
200055f8:	687b      	ldr	r3, [r7, #4]
200055fa:	681b      	ldr	r3, [r3, #0]
200055fc:	4a1a      	ldr	r2, [pc, #104]	; (20005668 <HAL_DMA_Abort_IT+0x28c>)
200055fe:	4293      	cmp	r3, r2
20005600:	d013      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
20005602:	687b      	ldr	r3, [r7, #4]
20005604:	681b      	ldr	r3, [r3, #0]
20005606:	4a19      	ldr	r2, [pc, #100]	; (2000566c <HAL_DMA_Abort_IT+0x290>)
20005608:	4293      	cmp	r3, r2
2000560a:	d00e      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
2000560c:	687b      	ldr	r3, [r7, #4]
2000560e:	681b      	ldr	r3, [r3, #0]
20005610:	4a17      	ldr	r2, [pc, #92]	; (20005670 <HAL_DMA_Abort_IT+0x294>)
20005612:	4293      	cmp	r3, r2
20005614:	d009      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
20005616:	687b      	ldr	r3, [r7, #4]
20005618:	681b      	ldr	r3, [r3, #0]
2000561a:	4a16      	ldr	r2, [pc, #88]	; (20005674 <HAL_DMA_Abort_IT+0x298>)
2000561c:	4293      	cmp	r3, r2
2000561e:	d004      	beq.n	2000562a <HAL_DMA_Abort_IT+0x24e>
20005620:	687b      	ldr	r3, [r7, #4]
20005622:	681b      	ldr	r3, [r3, #0]
20005624:	4a14      	ldr	r2, [pc, #80]	; (20005678 <HAL_DMA_Abort_IT+0x29c>)
20005626:	4293      	cmp	r3, r2
20005628:	d128      	bne.n	2000567c <HAL_DMA_Abort_IT+0x2a0>
2000562a:	687b      	ldr	r3, [r7, #4]
2000562c:	681b      	ldr	r3, [r3, #0]
2000562e:	681a      	ldr	r2, [r3, #0]
20005630:	687b      	ldr	r3, [r7, #4]
20005632:	681b      	ldr	r3, [r3, #0]
20005634:	f022 0201 	bic.w	r2, r2, #1
20005638:	601a      	str	r2, [r3, #0]
2000563a:	e027      	b.n	2000568c <HAL_DMA_Abort_IT+0x2b0>
2000563c:	40020010 	.word	0x40020010
20005640:	40020028 	.word	0x40020028
20005644:	40020040 	.word	0x40020040
20005648:	40020058 	.word	0x40020058
2000564c:	40020070 	.word	0x40020070
20005650:	40020088 	.word	0x40020088
20005654:	400200a0 	.word	0x400200a0
20005658:	400200b8 	.word	0x400200b8
2000565c:	40020410 	.word	0x40020410
20005660:	40020428 	.word	0x40020428
20005664:	40020440 	.word	0x40020440
20005668:	40020458 	.word	0x40020458
2000566c:	40020470 	.word	0x40020470
20005670:	40020488 	.word	0x40020488
20005674:	400204a0 	.word	0x400204a0
20005678:	400204b8 	.word	0x400204b8
2000567c:	687b      	ldr	r3, [r7, #4]
2000567e:	681b      	ldr	r3, [r3, #0]
20005680:	681a      	ldr	r2, [r3, #0]
20005682:	687b      	ldr	r3, [r7, #4]
20005684:	681b      	ldr	r3, [r3, #0]
20005686:	f022 0201 	bic.w	r2, r2, #1
2000568a:	601a      	str	r2, [r3, #0]

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2000568c:	687b      	ldr	r3, [r7, #4]
2000568e:	681b      	ldr	r3, [r3, #0]
20005690:	4a5c      	ldr	r2, [pc, #368]	; (20005804 <HAL_DMA_Abort_IT+0x428>)
20005692:	4293      	cmp	r3, r2
20005694:	d072      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
20005696:	687b      	ldr	r3, [r7, #4]
20005698:	681b      	ldr	r3, [r3, #0]
2000569a:	4a5b      	ldr	r2, [pc, #364]	; (20005808 <HAL_DMA_Abort_IT+0x42c>)
2000569c:	4293      	cmp	r3, r2
2000569e:	d06d      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
200056a0:	687b      	ldr	r3, [r7, #4]
200056a2:	681b      	ldr	r3, [r3, #0]
200056a4:	4a59      	ldr	r2, [pc, #356]	; (2000580c <HAL_DMA_Abort_IT+0x430>)
200056a6:	4293      	cmp	r3, r2
200056a8:	d068      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
200056aa:	687b      	ldr	r3, [r7, #4]
200056ac:	681b      	ldr	r3, [r3, #0]
200056ae:	4a58      	ldr	r2, [pc, #352]	; (20005810 <HAL_DMA_Abort_IT+0x434>)
200056b0:	4293      	cmp	r3, r2
200056b2:	d063      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
200056b4:	687b      	ldr	r3, [r7, #4]
200056b6:	681b      	ldr	r3, [r3, #0]
200056b8:	4a56      	ldr	r2, [pc, #344]	; (20005814 <HAL_DMA_Abort_IT+0x438>)
200056ba:	4293      	cmp	r3, r2
200056bc:	d05e      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
200056be:	687b      	ldr	r3, [r7, #4]
200056c0:	681b      	ldr	r3, [r3, #0]
200056c2:	4a55      	ldr	r2, [pc, #340]	; (20005818 <HAL_DMA_Abort_IT+0x43c>)
200056c4:	4293      	cmp	r3, r2
200056c6:	d059      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
200056c8:	687b      	ldr	r3, [r7, #4]
200056ca:	681b      	ldr	r3, [r3, #0]
200056cc:	4a53      	ldr	r2, [pc, #332]	; (2000581c <HAL_DMA_Abort_IT+0x440>)
200056ce:	4293      	cmp	r3, r2
200056d0:	d054      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
200056d2:	687b      	ldr	r3, [r7, #4]
200056d4:	681b      	ldr	r3, [r3, #0]
200056d6:	4a52      	ldr	r2, [pc, #328]	; (20005820 <HAL_DMA_Abort_IT+0x444>)
200056d8:	4293      	cmp	r3, r2
200056da:	d04f      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
200056dc:	687b      	ldr	r3, [r7, #4]
200056de:	681b      	ldr	r3, [r3, #0]
200056e0:	4a50      	ldr	r2, [pc, #320]	; (20005824 <HAL_DMA_Abort_IT+0x448>)
200056e2:	4293      	cmp	r3, r2
200056e4:	d04a      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
200056e6:	687b      	ldr	r3, [r7, #4]
200056e8:	681b      	ldr	r3, [r3, #0]
200056ea:	4a4f      	ldr	r2, [pc, #316]	; (20005828 <HAL_DMA_Abort_IT+0x44c>)
200056ec:	4293      	cmp	r3, r2
200056ee:	d045      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
200056f0:	687b      	ldr	r3, [r7, #4]
200056f2:	681b      	ldr	r3, [r3, #0]
200056f4:	4a4d      	ldr	r2, [pc, #308]	; (2000582c <HAL_DMA_Abort_IT+0x450>)
200056f6:	4293      	cmp	r3, r2
200056f8:	d040      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
200056fa:	687b      	ldr	r3, [r7, #4]
200056fc:	681b      	ldr	r3, [r3, #0]
200056fe:	4a4c      	ldr	r2, [pc, #304]	; (20005830 <HAL_DMA_Abort_IT+0x454>)
20005700:	4293      	cmp	r3, r2
20005702:	d03b      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
20005704:	687b      	ldr	r3, [r7, #4]
20005706:	681b      	ldr	r3, [r3, #0]
20005708:	4a4a      	ldr	r2, [pc, #296]	; (20005834 <HAL_DMA_Abort_IT+0x458>)
2000570a:	4293      	cmp	r3, r2
2000570c:	d036      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
2000570e:	687b      	ldr	r3, [r7, #4]
20005710:	681b      	ldr	r3, [r3, #0]
20005712:	4a49      	ldr	r2, [pc, #292]	; (20005838 <HAL_DMA_Abort_IT+0x45c>)
20005714:	4293      	cmp	r3, r2
20005716:	d031      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
20005718:	687b      	ldr	r3, [r7, #4]
2000571a:	681b      	ldr	r3, [r3, #0]
2000571c:	4a47      	ldr	r2, [pc, #284]	; (2000583c <HAL_DMA_Abort_IT+0x460>)
2000571e:	4293      	cmp	r3, r2
20005720:	d02c      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
20005722:	687b      	ldr	r3, [r7, #4]
20005724:	681b      	ldr	r3, [r3, #0]
20005726:	4a46      	ldr	r2, [pc, #280]	; (20005840 <HAL_DMA_Abort_IT+0x464>)
20005728:	4293      	cmp	r3, r2
2000572a:	d027      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
2000572c:	687b      	ldr	r3, [r7, #4]
2000572e:	681b      	ldr	r3, [r3, #0]
20005730:	4a44      	ldr	r2, [pc, #272]	; (20005844 <HAL_DMA_Abort_IT+0x468>)
20005732:	4293      	cmp	r3, r2
20005734:	d022      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
20005736:	687b      	ldr	r3, [r7, #4]
20005738:	681b      	ldr	r3, [r3, #0]
2000573a:	4a43      	ldr	r2, [pc, #268]	; (20005848 <HAL_DMA_Abort_IT+0x46c>)
2000573c:	4293      	cmp	r3, r2
2000573e:	d01d      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
20005740:	687b      	ldr	r3, [r7, #4]
20005742:	681b      	ldr	r3, [r3, #0]
20005744:	4a41      	ldr	r2, [pc, #260]	; (2000584c <HAL_DMA_Abort_IT+0x470>)
20005746:	4293      	cmp	r3, r2
20005748:	d018      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
2000574a:	687b      	ldr	r3, [r7, #4]
2000574c:	681b      	ldr	r3, [r3, #0]
2000574e:	4a40      	ldr	r2, [pc, #256]	; (20005850 <HAL_DMA_Abort_IT+0x474>)
20005750:	4293      	cmp	r3, r2
20005752:	d013      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
20005754:	687b      	ldr	r3, [r7, #4]
20005756:	681b      	ldr	r3, [r3, #0]
20005758:	4a3e      	ldr	r2, [pc, #248]	; (20005854 <HAL_DMA_Abort_IT+0x478>)
2000575a:	4293      	cmp	r3, r2
2000575c:	d00e      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
2000575e:	687b      	ldr	r3, [r7, #4]
20005760:	681b      	ldr	r3, [r3, #0]
20005762:	4a3d      	ldr	r2, [pc, #244]	; (20005858 <HAL_DMA_Abort_IT+0x47c>)
20005764:	4293      	cmp	r3, r2
20005766:	d009      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
20005768:	687b      	ldr	r3, [r7, #4]
2000576a:	681b      	ldr	r3, [r3, #0]
2000576c:	4a3b      	ldr	r2, [pc, #236]	; (2000585c <HAL_DMA_Abort_IT+0x480>)
2000576e:	4293      	cmp	r3, r2
20005770:	d004      	beq.n	2000577c <HAL_DMA_Abort_IT+0x3a0>
20005772:	687b      	ldr	r3, [r7, #4]
20005774:	681b      	ldr	r3, [r3, #0]
20005776:	4a3a      	ldr	r2, [pc, #232]	; (20005860 <HAL_DMA_Abort_IT+0x484>)
20005778:	4293      	cmp	r3, r2
2000577a:	d101      	bne.n	20005780 <HAL_DMA_Abort_IT+0x3a4>
2000577c:	2301      	movs	r3, #1
2000577e:	e000      	b.n	20005782 <HAL_DMA_Abort_IT+0x3a6>
20005780:	2300      	movs	r3, #0
20005782:	2b00      	cmp	r3, #0
20005784:	d028      	beq.n	200057d8 <HAL_DMA_Abort_IT+0x3fc>
      {
        /* disable the DMAMUX sync overrun IT */
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
20005786:	687b      	ldr	r3, [r7, #4]
20005788:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2000578a:	681a      	ldr	r2, [r3, #0]
2000578c:	687b      	ldr	r3, [r7, #4]
2000578e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20005790:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20005794:	601a      	str	r2, [r3, #0]

        /* Clear all flags */
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
20005796:	687b      	ldr	r3, [r7, #4]
20005798:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2000579a:	60fb      	str	r3, [r7, #12]
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
2000579c:	687b      	ldr	r3, [r7, #4]
2000579e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200057a0:	f003 031f 	and.w	r3, r3, #31
200057a4:	2201      	movs	r2, #1
200057a6:	409a      	lsls	r2, r3
200057a8:	68fb      	ldr	r3, [r7, #12]
200057aa:	605a      	str	r2, [r3, #4]

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
200057ac:	687b      	ldr	r3, [r7, #4]
200057ae:	6e5b      	ldr	r3, [r3, #100]	; 0x64
200057b0:	687a      	ldr	r2, [r7, #4]
200057b2:	6e92      	ldr	r2, [r2, #104]	; 0x68
200057b4:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
200057b6:	687b      	ldr	r3, [r7, #4]
200057b8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
200057ba:	2b00      	cmp	r3, #0
200057bc:	d00c      	beq.n	200057d8 <HAL_DMA_Abort_IT+0x3fc>
        {
          /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
          /* disable the request gen overrun IT */
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
200057be:	687b      	ldr	r3, [r7, #4]
200057c0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
200057c2:	681a      	ldr	r2, [r3, #0]
200057c4:	687b      	ldr	r3, [r7, #4]
200057c6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
200057c8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
200057cc:	601a      	str	r2, [r3, #0]

          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
200057ce:	687b      	ldr	r3, [r7, #4]
200057d0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
200057d2:	687a      	ldr	r2, [r7, #4]
200057d4:	6f52      	ldr	r2, [r2, #116]	; 0x74
200057d6:	605a      	str	r2, [r3, #4]
        }
      }

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
200057d8:	687b      	ldr	r3, [r7, #4]
200057da:	2200      	movs	r2, #0
200057dc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
200057e0:	687b      	ldr	r3, [r7, #4]
200057e2:	2201      	movs	r2, #1
200057e4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Call User Abort callback */
      if(hdma->XferAbortCallback != NULL)
200057e8:	687b      	ldr	r3, [r7, #4]
200057ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200057ec:	2b00      	cmp	r3, #0
200057ee:	d003      	beq.n	200057f8 <HAL_DMA_Abort_IT+0x41c>
      {
        hdma->XferAbortCallback(hdma);
200057f0:	687b      	ldr	r3, [r7, #4]
200057f2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200057f4:	6878      	ldr	r0, [r7, #4]
200057f6:	4798      	blx	r3
      }
    }
  }

  return HAL_OK;
200057f8:	2300      	movs	r3, #0
}
200057fa:	4618      	mov	r0, r3
200057fc:	3710      	adds	r7, #16
200057fe:	46bd      	mov	sp, r7
20005800:	bd80      	pop	{r7, pc}
20005802:	bf00      	nop
20005804:	40020010 	.word	0x40020010
20005808:	40020028 	.word	0x40020028
2000580c:	40020040 	.word	0x40020040
20005810:	40020058 	.word	0x40020058
20005814:	40020070 	.word	0x40020070
20005818:	40020088 	.word	0x40020088
2000581c:	400200a0 	.word	0x400200a0
20005820:	400200b8 	.word	0x400200b8
20005824:	40020410 	.word	0x40020410
20005828:	40020428 	.word	0x40020428
2000582c:	40020440 	.word	0x40020440
20005830:	40020458 	.word	0x40020458
20005834:	40020470 	.word	0x40020470
20005838:	40020488 	.word	0x40020488
2000583c:	400204a0 	.word	0x400204a0
20005840:	400204b8 	.word	0x400204b8
20005844:	58025408 	.word	0x58025408
20005848:	5802541c 	.word	0x5802541c
2000584c:	58025430 	.word	0x58025430
20005850:	58025444 	.word	0x58025444
20005854:	58025458 	.word	0x58025458
20005858:	5802546c 	.word	0x5802546c
2000585c:	58025480 	.word	0x58025480
20005860:	58025494 	.word	0x58025494

20005864 <HAL_DMA_PollForTransfer>:
  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode).
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
20005864:	b580      	push	{r7, lr}
20005866:	b08a      	sub	sp, #40	; 0x28
20005868:	af00      	add	r7, sp, #0
2000586a:	60f8      	str	r0, [r7, #12]
2000586c:	460b      	mov	r3, r1
2000586e:	607a      	str	r2, [r7, #4]
20005870:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
20005872:	2300      	movs	r3, #0
20005874:	76fb      	strb	r3, [r7, #27]
  uint32_t cpltlevel_mask;
  uint32_t tickstart = HAL_GetTick();
20005876:	f7fc fa39 	bl	20001cec <HAL_GetTick>
2000587a:	6178      	str	r0, [r7, #20]
  __IO uint32_t *isr_reg;
  /* IT clear flag register */
  __IO uint32_t *ifcr_reg;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
2000587c:	68fb      	ldr	r3, [r7, #12]
2000587e:	2b00      	cmp	r3, #0
20005880:	d101      	bne.n	20005886 <HAL_DMA_PollForTransfer+0x22>
  {
    return HAL_ERROR;
20005882:	2301      	movs	r3, #1
20005884:	e373      	b.n	20005f6e <HAL_DMA_PollForTransfer+0x70a>
  }

  if(HAL_DMA_STATE_BUSY != hdma->State)
20005886:	68fb      	ldr	r3, [r7, #12]
20005888:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2000588c:	b2db      	uxtb	r3, r3
2000588e:	2b02      	cmp	r3, #2
20005890:	d008      	beq.n	200058a4 <HAL_DMA_PollForTransfer+0x40>
  {
    /* No transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
20005892:	68fb      	ldr	r3, [r7, #12]
20005894:	2280      	movs	r2, #128	; 0x80
20005896:	655a      	str	r2, [r3, #84]	; 0x54
    __HAL_UNLOCK(hdma);
20005898:	68fb      	ldr	r3, [r7, #12]
2000589a:	2200      	movs	r2, #0
2000589c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
200058a0:	2301      	movs	r3, #1
200058a2:	e364      	b.n	20005f6e <HAL_DMA_PollForTransfer+0x70a>
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
200058a4:	68fb      	ldr	r3, [r7, #12]
200058a6:	681b      	ldr	r3, [r3, #0]
200058a8:	4a7b      	ldr	r2, [pc, #492]	; (20005a98 <HAL_DMA_PollForTransfer+0x234>)
200058aa:	4293      	cmp	r3, r2
200058ac:	d04a      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
200058ae:	68fb      	ldr	r3, [r7, #12]
200058b0:	681b      	ldr	r3, [r3, #0]
200058b2:	4a7a      	ldr	r2, [pc, #488]	; (20005a9c <HAL_DMA_PollForTransfer+0x238>)
200058b4:	4293      	cmp	r3, r2
200058b6:	d045      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
200058b8:	68fb      	ldr	r3, [r7, #12]
200058ba:	681b      	ldr	r3, [r3, #0]
200058bc:	4a78      	ldr	r2, [pc, #480]	; (20005aa0 <HAL_DMA_PollForTransfer+0x23c>)
200058be:	4293      	cmp	r3, r2
200058c0:	d040      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
200058c2:	68fb      	ldr	r3, [r7, #12]
200058c4:	681b      	ldr	r3, [r3, #0]
200058c6:	4a77      	ldr	r2, [pc, #476]	; (20005aa4 <HAL_DMA_PollForTransfer+0x240>)
200058c8:	4293      	cmp	r3, r2
200058ca:	d03b      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
200058cc:	68fb      	ldr	r3, [r7, #12]
200058ce:	681b      	ldr	r3, [r3, #0]
200058d0:	4a75      	ldr	r2, [pc, #468]	; (20005aa8 <HAL_DMA_PollForTransfer+0x244>)
200058d2:	4293      	cmp	r3, r2
200058d4:	d036      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
200058d6:	68fb      	ldr	r3, [r7, #12]
200058d8:	681b      	ldr	r3, [r3, #0]
200058da:	4a74      	ldr	r2, [pc, #464]	; (20005aac <HAL_DMA_PollForTransfer+0x248>)
200058dc:	4293      	cmp	r3, r2
200058de:	d031      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
200058e0:	68fb      	ldr	r3, [r7, #12]
200058e2:	681b      	ldr	r3, [r3, #0]
200058e4:	4a72      	ldr	r2, [pc, #456]	; (20005ab0 <HAL_DMA_PollForTransfer+0x24c>)
200058e6:	4293      	cmp	r3, r2
200058e8:	d02c      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
200058ea:	68fb      	ldr	r3, [r7, #12]
200058ec:	681b      	ldr	r3, [r3, #0]
200058ee:	4a71      	ldr	r2, [pc, #452]	; (20005ab4 <HAL_DMA_PollForTransfer+0x250>)
200058f0:	4293      	cmp	r3, r2
200058f2:	d027      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
200058f4:	68fb      	ldr	r3, [r7, #12]
200058f6:	681b      	ldr	r3, [r3, #0]
200058f8:	4a6f      	ldr	r2, [pc, #444]	; (20005ab8 <HAL_DMA_PollForTransfer+0x254>)
200058fa:	4293      	cmp	r3, r2
200058fc:	d022      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
200058fe:	68fb      	ldr	r3, [r7, #12]
20005900:	681b      	ldr	r3, [r3, #0]
20005902:	4a6e      	ldr	r2, [pc, #440]	; (20005abc <HAL_DMA_PollForTransfer+0x258>)
20005904:	4293      	cmp	r3, r2
20005906:	d01d      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
20005908:	68fb      	ldr	r3, [r7, #12]
2000590a:	681b      	ldr	r3, [r3, #0]
2000590c:	4a6c      	ldr	r2, [pc, #432]	; (20005ac0 <HAL_DMA_PollForTransfer+0x25c>)
2000590e:	4293      	cmp	r3, r2
20005910:	d018      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
20005912:	68fb      	ldr	r3, [r7, #12]
20005914:	681b      	ldr	r3, [r3, #0]
20005916:	4a6b      	ldr	r2, [pc, #428]	; (20005ac4 <HAL_DMA_PollForTransfer+0x260>)
20005918:	4293      	cmp	r3, r2
2000591a:	d013      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
2000591c:	68fb      	ldr	r3, [r7, #12]
2000591e:	681b      	ldr	r3, [r3, #0]
20005920:	4a69      	ldr	r2, [pc, #420]	; (20005ac8 <HAL_DMA_PollForTransfer+0x264>)
20005922:	4293      	cmp	r3, r2
20005924:	d00e      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
20005926:	68fb      	ldr	r3, [r7, #12]
20005928:	681b      	ldr	r3, [r3, #0]
2000592a:	4a68      	ldr	r2, [pc, #416]	; (20005acc <HAL_DMA_PollForTransfer+0x268>)
2000592c:	4293      	cmp	r3, r2
2000592e:	d009      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
20005930:	68fb      	ldr	r3, [r7, #12]
20005932:	681b      	ldr	r3, [r3, #0]
20005934:	4a66      	ldr	r2, [pc, #408]	; (20005ad0 <HAL_DMA_PollForTransfer+0x26c>)
20005936:	4293      	cmp	r3, r2
20005938:	d004      	beq.n	20005944 <HAL_DMA_PollForTransfer+0xe0>
2000593a:	68fb      	ldr	r3, [r7, #12]
2000593c:	681b      	ldr	r3, [r3, #0]
2000593e:	4a65      	ldr	r2, [pc, #404]	; (20005ad4 <HAL_DMA_PollForTransfer+0x270>)
20005940:	4293      	cmp	r3, r2
20005942:	d101      	bne.n	20005948 <HAL_DMA_PollForTransfer+0xe4>
20005944:	2301      	movs	r3, #1
20005946:	e000      	b.n	2000594a <HAL_DMA_PollForTransfer+0xe6>
20005948:	2300      	movs	r3, #0
2000594a:	2b00      	cmp	r3, #0
2000594c:	d028      	beq.n	200059a0 <HAL_DMA_PollForTransfer+0x13c>
  {
    /* Polling mode not supported in circular mode and double buffering mode */
    if ((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) != 0U)
2000594e:	68fb      	ldr	r3, [r7, #12]
20005950:	681b      	ldr	r3, [r3, #0]
20005952:	681b      	ldr	r3, [r3, #0]
20005954:	f403 7380 	and.w	r3, r3, #256	; 0x100
20005958:	2b00      	cmp	r3, #0
2000595a:	d005      	beq.n	20005968 <HAL_DMA_PollForTransfer+0x104>
    {
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
2000595c:	68fb      	ldr	r3, [r7, #12]
2000595e:	f44f 7280 	mov.w	r2, #256	; 0x100
20005962:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_ERROR;
20005964:	2301      	movs	r3, #1
20005966:	e302      	b.n	20005f6e <HAL_DMA_PollForTransfer+0x70a>
    }

    /* Get the level transfer complete flag */
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
20005968:	7afb      	ldrb	r3, [r7, #11]
2000596a:	2b00      	cmp	r3, #0
2000596c:	d108      	bne.n	20005980 <HAL_DMA_PollForTransfer+0x11c>
    {
      /* Transfer Complete flag */
      cpltlevel_mask = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
2000596e:	68fb      	ldr	r3, [r7, #12]
20005970:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005972:	f003 031f 	and.w	r3, r3, #31
20005976:	2220      	movs	r2, #32
20005978:	fa02 f303 	lsl.w	r3, r2, r3
2000597c:	627b      	str	r3, [r7, #36]	; 0x24
2000597e:	e007      	b.n	20005990 <HAL_DMA_PollForTransfer+0x12c>
    }
    else
    {
      /* Half Transfer Complete flag */
      cpltlevel_mask = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
20005980:	68fb      	ldr	r3, [r7, #12]
20005982:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005984:	f003 031f 	and.w	r3, r3, #31
20005988:	2210      	movs	r2, #16
2000598a:	fa02 f303 	lsl.w	r3, r2, r3
2000598e:	627b      	str	r3, [r7, #36]	; 0x24
    }

    isr_reg  = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
20005990:	68fb      	ldr	r3, [r7, #12]
20005992:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20005994:	623b      	str	r3, [r7, #32]
    ifcr_reg = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
20005996:	68fb      	ldr	r3, [r7, #12]
20005998:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2000599a:	3308      	adds	r3, #8
2000599c:	61fb      	str	r3, [r7, #28]
2000599e:	e1d5      	b.n	20005d4c <HAL_DMA_PollForTransfer+0x4e8>
  }
  else /* BDMA channel */
  {
    /* Polling mode not supported in circular mode */
    if ((((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR & BDMA_CCR_CIRC) != 0U)
200059a0:	68fb      	ldr	r3, [r7, #12]
200059a2:	681b      	ldr	r3, [r3, #0]
200059a4:	681b      	ldr	r3, [r3, #0]
200059a6:	f003 0320 	and.w	r3, r3, #32
200059aa:	2b00      	cmp	r3, #0
200059ac:	d005      	beq.n	200059ba <HAL_DMA_PollForTransfer+0x156>
    {
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
200059ae:	68fb      	ldr	r3, [r7, #12]
200059b0:	f44f 7280 	mov.w	r2, #256	; 0x100
200059b4:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_ERROR;
200059b6:	2301      	movs	r3, #1
200059b8:	e2d9      	b.n	20005f6e <HAL_DMA_PollForTransfer+0x70a>
    }

    /* Get the level transfer complete flag */
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
200059ba:	7afb      	ldrb	r3, [r7, #11]
200059bc:	2b00      	cmp	r3, #0
200059be:	d108      	bne.n	200059d2 <HAL_DMA_PollForTransfer+0x16e>
    {
      /* Transfer Complete flag */
      cpltlevel_mask = BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU);
200059c0:	68fb      	ldr	r3, [r7, #12]
200059c2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200059c4:	f003 031f 	and.w	r3, r3, #31
200059c8:	2202      	movs	r2, #2
200059ca:	fa02 f303 	lsl.w	r3, r2, r3
200059ce:	627b      	str	r3, [r7, #36]	; 0x24
200059d0:	e007      	b.n	200059e2 <HAL_DMA_PollForTransfer+0x17e>
    }
    else
    {
      /* Half Transfer Complete flag */
      cpltlevel_mask = BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU);
200059d2:	68fb      	ldr	r3, [r7, #12]
200059d4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200059d6:	f003 031f 	and.w	r3, r3, #31
200059da:	2204      	movs	r2, #4
200059dc:	fa02 f303 	lsl.w	r3, r2, r3
200059e0:	627b      	str	r3, [r7, #36]	; 0x24
    }

    isr_reg  = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
200059e2:	68fb      	ldr	r3, [r7, #12]
200059e4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200059e6:	623b      	str	r3, [r7, #32]
    ifcr_reg = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
200059e8:	68fb      	ldr	r3, [r7, #12]
200059ea:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200059ec:	3304      	adds	r3, #4
200059ee:	61fb      	str	r3, [r7, #28]
  }

  while(((*isr_reg) & cpltlevel_mask) == 0U)
200059f0:	e1ac      	b.n	20005d4c <HAL_DMA_PollForTransfer+0x4e8>
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
200059f2:	68fb      	ldr	r3, [r7, #12]
200059f4:	681b      	ldr	r3, [r3, #0]
200059f6:	4a28      	ldr	r2, [pc, #160]	; (20005a98 <HAL_DMA_PollForTransfer+0x234>)
200059f8:	4293      	cmp	r3, r2
200059fa:	d04a      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
200059fc:	68fb      	ldr	r3, [r7, #12]
200059fe:	681b      	ldr	r3, [r3, #0]
20005a00:	4a26      	ldr	r2, [pc, #152]	; (20005a9c <HAL_DMA_PollForTransfer+0x238>)
20005a02:	4293      	cmp	r3, r2
20005a04:	d045      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a06:	68fb      	ldr	r3, [r7, #12]
20005a08:	681b      	ldr	r3, [r3, #0]
20005a0a:	4a25      	ldr	r2, [pc, #148]	; (20005aa0 <HAL_DMA_PollForTransfer+0x23c>)
20005a0c:	4293      	cmp	r3, r2
20005a0e:	d040      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a10:	68fb      	ldr	r3, [r7, #12]
20005a12:	681b      	ldr	r3, [r3, #0]
20005a14:	4a23      	ldr	r2, [pc, #140]	; (20005aa4 <HAL_DMA_PollForTransfer+0x240>)
20005a16:	4293      	cmp	r3, r2
20005a18:	d03b      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a1a:	68fb      	ldr	r3, [r7, #12]
20005a1c:	681b      	ldr	r3, [r3, #0]
20005a1e:	4a22      	ldr	r2, [pc, #136]	; (20005aa8 <HAL_DMA_PollForTransfer+0x244>)
20005a20:	4293      	cmp	r3, r2
20005a22:	d036      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a24:	68fb      	ldr	r3, [r7, #12]
20005a26:	681b      	ldr	r3, [r3, #0]
20005a28:	4a20      	ldr	r2, [pc, #128]	; (20005aac <HAL_DMA_PollForTransfer+0x248>)
20005a2a:	4293      	cmp	r3, r2
20005a2c:	d031      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a2e:	68fb      	ldr	r3, [r7, #12]
20005a30:	681b      	ldr	r3, [r3, #0]
20005a32:	4a1f      	ldr	r2, [pc, #124]	; (20005ab0 <HAL_DMA_PollForTransfer+0x24c>)
20005a34:	4293      	cmp	r3, r2
20005a36:	d02c      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a38:	68fb      	ldr	r3, [r7, #12]
20005a3a:	681b      	ldr	r3, [r3, #0]
20005a3c:	4a1d      	ldr	r2, [pc, #116]	; (20005ab4 <HAL_DMA_PollForTransfer+0x250>)
20005a3e:	4293      	cmp	r3, r2
20005a40:	d027      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a42:	68fb      	ldr	r3, [r7, #12]
20005a44:	681b      	ldr	r3, [r3, #0]
20005a46:	4a1c      	ldr	r2, [pc, #112]	; (20005ab8 <HAL_DMA_PollForTransfer+0x254>)
20005a48:	4293      	cmp	r3, r2
20005a4a:	d022      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a4c:	68fb      	ldr	r3, [r7, #12]
20005a4e:	681b      	ldr	r3, [r3, #0]
20005a50:	4a1a      	ldr	r2, [pc, #104]	; (20005abc <HAL_DMA_PollForTransfer+0x258>)
20005a52:	4293      	cmp	r3, r2
20005a54:	d01d      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a56:	68fb      	ldr	r3, [r7, #12]
20005a58:	681b      	ldr	r3, [r3, #0]
20005a5a:	4a19      	ldr	r2, [pc, #100]	; (20005ac0 <HAL_DMA_PollForTransfer+0x25c>)
20005a5c:	4293      	cmp	r3, r2
20005a5e:	d018      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a60:	68fb      	ldr	r3, [r7, #12]
20005a62:	681b      	ldr	r3, [r3, #0]
20005a64:	4a17      	ldr	r2, [pc, #92]	; (20005ac4 <HAL_DMA_PollForTransfer+0x260>)
20005a66:	4293      	cmp	r3, r2
20005a68:	d013      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a6a:	68fb      	ldr	r3, [r7, #12]
20005a6c:	681b      	ldr	r3, [r3, #0]
20005a6e:	4a16      	ldr	r2, [pc, #88]	; (20005ac8 <HAL_DMA_PollForTransfer+0x264>)
20005a70:	4293      	cmp	r3, r2
20005a72:	d00e      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a74:	68fb      	ldr	r3, [r7, #12]
20005a76:	681b      	ldr	r3, [r3, #0]
20005a78:	4a14      	ldr	r2, [pc, #80]	; (20005acc <HAL_DMA_PollForTransfer+0x268>)
20005a7a:	4293      	cmp	r3, r2
20005a7c:	d009      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a7e:	68fb      	ldr	r3, [r7, #12]
20005a80:	681b      	ldr	r3, [r3, #0]
20005a82:	4a13      	ldr	r2, [pc, #76]	; (20005ad0 <HAL_DMA_PollForTransfer+0x26c>)
20005a84:	4293      	cmp	r3, r2
20005a86:	d004      	beq.n	20005a92 <HAL_DMA_PollForTransfer+0x22e>
20005a88:	68fb      	ldr	r3, [r7, #12]
20005a8a:	681b      	ldr	r3, [r3, #0]
20005a8c:	4a11      	ldr	r2, [pc, #68]	; (20005ad4 <HAL_DMA_PollForTransfer+0x270>)
20005a8e:	4293      	cmp	r3, r2
20005a90:	d122      	bne.n	20005ad8 <HAL_DMA_PollForTransfer+0x274>
20005a92:	2301      	movs	r3, #1
20005a94:	e021      	b.n	20005ada <HAL_DMA_PollForTransfer+0x276>
20005a96:	bf00      	nop
20005a98:	40020010 	.word	0x40020010
20005a9c:	40020028 	.word	0x40020028
20005aa0:	40020040 	.word	0x40020040
20005aa4:	40020058 	.word	0x40020058
20005aa8:	40020070 	.word	0x40020070
20005aac:	40020088 	.word	0x40020088
20005ab0:	400200a0 	.word	0x400200a0
20005ab4:	400200b8 	.word	0x400200b8
20005ab8:	40020410 	.word	0x40020410
20005abc:	40020428 	.word	0x40020428
20005ac0:	40020440 	.word	0x40020440
20005ac4:	40020458 	.word	0x40020458
20005ac8:	40020470 	.word	0x40020470
20005acc:	40020488 	.word	0x40020488
20005ad0:	400204a0 	.word	0x400204a0
20005ad4:	400204b8 	.word	0x400204b8
20005ad8:	2300      	movs	r3, #0
20005ada:	2b00      	cmp	r3, #0
20005adc:	d057      	beq.n	20005b8e <HAL_DMA_PollForTransfer+0x32a>
    {
      if(((*isr_reg) & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
20005ade:	6a3b      	ldr	r3, [r7, #32]
20005ae0:	681a      	ldr	r2, [r3, #0]
20005ae2:	68fb      	ldr	r3, [r7, #12]
20005ae4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005ae6:	f003 031f 	and.w	r3, r3, #31
20005aea:	fa22 f303 	lsr.w	r3, r2, r3
20005aee:	f003 0301 	and.w	r3, r3, #1
20005af2:	2b00      	cmp	r3, #0
20005af4:	d00d      	beq.n	20005b12 <HAL_DMA_PollForTransfer+0x2ae>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
20005af6:	68fb      	ldr	r3, [r7, #12]
20005af8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20005afa:	f043 0202 	orr.w	r2, r3, #2
20005afe:	68fb      	ldr	r3, [r7, #12]
20005b00:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the FIFO error flag */
        (*ifcr_reg) = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
20005b02:	68fb      	ldr	r3, [r7, #12]
20005b04:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005b06:	f003 031f 	and.w	r3, r3, #31
20005b0a:	2201      	movs	r2, #1
20005b0c:	409a      	lsls	r2, r3
20005b0e:	69fb      	ldr	r3, [r7, #28]
20005b10:	601a      	str	r2, [r3, #0]
      }

      if(((*isr_reg) & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
20005b12:	6a3b      	ldr	r3, [r7, #32]
20005b14:	681a      	ldr	r2, [r3, #0]
20005b16:	68fb      	ldr	r3, [r7, #12]
20005b18:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005b1a:	f003 031f 	and.w	r3, r3, #31
20005b1e:	2104      	movs	r1, #4
20005b20:	fa01 f303 	lsl.w	r3, r1, r3
20005b24:	4013      	ands	r3, r2
20005b26:	2b00      	cmp	r3, #0
20005b28:	d00d      	beq.n	20005b46 <HAL_DMA_PollForTransfer+0x2e2>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
20005b2a:	68fb      	ldr	r3, [r7, #12]
20005b2c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20005b2e:	f043 0204 	orr.w	r2, r3, #4
20005b32:	68fb      	ldr	r3, [r7, #12]
20005b34:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the Direct Mode error flag */
        (*ifcr_reg) = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
20005b36:	68fb      	ldr	r3, [r7, #12]
20005b38:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005b3a:	f003 031f 	and.w	r3, r3, #31
20005b3e:	2204      	movs	r2, #4
20005b40:	409a      	lsls	r2, r3
20005b42:	69fb      	ldr	r3, [r7, #28]
20005b44:	601a      	str	r2, [r3, #0]
      }

      if(((*isr_reg) & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
20005b46:	6a3b      	ldr	r3, [r7, #32]
20005b48:	681a      	ldr	r2, [r3, #0]
20005b4a:	68fb      	ldr	r3, [r7, #12]
20005b4c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005b4e:	f003 031f 	and.w	r3, r3, #31
20005b52:	2108      	movs	r1, #8
20005b54:	fa01 f303 	lsl.w	r3, r1, r3
20005b58:	4013      	ands	r3, r2
20005b5a:	2b00      	cmp	r3, #0
20005b5c:	d038      	beq.n	20005bd0 <HAL_DMA_PollForTransfer+0x36c>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
20005b5e:	68fb      	ldr	r3, [r7, #12]
20005b60:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20005b62:	f043 0201 	orr.w	r2, r3, #1
20005b66:	68fb      	ldr	r3, [r7, #12]
20005b68:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the transfer error flag */
        (*ifcr_reg) = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
20005b6a:	68fb      	ldr	r3, [r7, #12]
20005b6c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005b6e:	f003 031f 	and.w	r3, r3, #31
20005b72:	2208      	movs	r2, #8
20005b74:	409a      	lsls	r2, r3
20005b76:	69fb      	ldr	r3, [r7, #28]
20005b78:	601a      	str	r2, [r3, #0]

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
20005b7a:	68fb      	ldr	r3, [r7, #12]
20005b7c:	2201      	movs	r2, #1
20005b7e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
20005b82:	68fb      	ldr	r3, [r7, #12]
20005b84:	2200      	movs	r2, #0
20005b86:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
20005b8a:	2301      	movs	r3, #1
20005b8c:	e1ef      	b.n	20005f6e <HAL_DMA_PollForTransfer+0x70a>
      }
    }
    else /* BDMA channel */
    {
      if(((*isr_reg) & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U)
20005b8e:	6a3b      	ldr	r3, [r7, #32]
20005b90:	681a      	ldr	r2, [r3, #0]
20005b92:	68fb      	ldr	r3, [r7, #12]
20005b94:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005b96:	f003 031f 	and.w	r3, r3, #31
20005b9a:	2108      	movs	r1, #8
20005b9c:	fa01 f303 	lsl.w	r3, r1, r3
20005ba0:	4013      	ands	r3, r2
20005ba2:	2b00      	cmp	r3, #0
20005ba4:	d014      	beq.n	20005bd0 <HAL_DMA_PollForTransfer+0x36c>
      {
        /* When a DMA transfer error occurs */
        /* A hardware clear of its EN bits is performed */
        /* Clear all flags */
        (*isr_reg) = ((BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU));
20005ba6:	68fb      	ldr	r3, [r7, #12]
20005ba8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005baa:	f003 031f 	and.w	r3, r3, #31
20005bae:	2201      	movs	r2, #1
20005bb0:	409a      	lsls	r2, r3
20005bb2:	6a3b      	ldr	r3, [r7, #32]
20005bb4:	601a      	str	r2, [r3, #0]

        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TE;
20005bb6:	68fb      	ldr	r3, [r7, #12]
20005bb8:	2201      	movs	r2, #1
20005bba:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
20005bbc:	68fb      	ldr	r3, [r7, #12]
20005bbe:	2201      	movs	r2, #1
20005bc0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
20005bc4:	68fb      	ldr	r3, [r7, #12]
20005bc6:	2200      	movs	r2, #0
20005bc8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
20005bcc:	2301      	movs	r3, #1
20005bce:	e1ce      	b.n	20005f6e <HAL_DMA_PollForTransfer+0x70a>
      }
    }

    /* Check for the Timeout (Not applicable in circular mode)*/
    if(Timeout != HAL_MAX_DELAY)
20005bd0:	687b      	ldr	r3, [r7, #4]
20005bd2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
20005bd6:	d012      	beq.n	20005bfe <HAL_DMA_PollForTransfer+0x39a>
    {
      if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
20005bd8:	f7fc f888 	bl	20001cec <HAL_GetTick>
20005bdc:	4602      	mov	r2, r0
20005bde:	697b      	ldr	r3, [r7, #20]
20005be0:	1ad3      	subs	r3, r2, r3
20005be2:	687a      	ldr	r2, [r7, #4]
20005be4:	429a      	cmp	r2, r3
20005be6:	d302      	bcc.n	20005bee <HAL_DMA_PollForTransfer+0x38a>
20005be8:	687b      	ldr	r3, [r7, #4]
20005bea:	2b00      	cmp	r3, #0
20005bec:	d107      	bne.n	20005bfe <HAL_DMA_PollForTransfer+0x39a>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
20005bee:	68fb      	ldr	r3, [r7, #12]
20005bf0:	2220      	movs	r2, #32
20005bf2:	655a      	str	r2, [r3, #84]	; 0x54

        /* if timeout then abort the current transfer */
        /* No need to check return value: as in this case we will return HAL_ERROR with HAL_DMA_ERROR_TIMEOUT error code  */
        (void) HAL_DMA_Abort(hdma);
20005bf4:	68f8      	ldr	r0, [r7, #12]
20005bf6:	f7ff f8d3 	bl	20004da0 <HAL_DMA_Abort>
              - Clear the transfer error flags
              - Unlock
              - Set the State
          */

        return HAL_ERROR;
20005bfa:	2301      	movs	r3, #1
20005bfc:	e1b7      	b.n	20005f6e <HAL_DMA_PollForTransfer+0x70a>
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
20005bfe:	68fb      	ldr	r3, [r7, #12]
20005c00:	681b      	ldr	r3, [r3, #0]
20005c02:	4a8f      	ldr	r2, [pc, #572]	; (20005e40 <HAL_DMA_PollForTransfer+0x5dc>)
20005c04:	4293      	cmp	r3, r2
20005c06:	d072      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c08:	68fb      	ldr	r3, [r7, #12]
20005c0a:	681b      	ldr	r3, [r3, #0]
20005c0c:	4a8d      	ldr	r2, [pc, #564]	; (20005e44 <HAL_DMA_PollForTransfer+0x5e0>)
20005c0e:	4293      	cmp	r3, r2
20005c10:	d06d      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c12:	68fb      	ldr	r3, [r7, #12]
20005c14:	681b      	ldr	r3, [r3, #0]
20005c16:	4a8c      	ldr	r2, [pc, #560]	; (20005e48 <HAL_DMA_PollForTransfer+0x5e4>)
20005c18:	4293      	cmp	r3, r2
20005c1a:	d068      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c1c:	68fb      	ldr	r3, [r7, #12]
20005c1e:	681b      	ldr	r3, [r3, #0]
20005c20:	4a8a      	ldr	r2, [pc, #552]	; (20005e4c <HAL_DMA_PollForTransfer+0x5e8>)
20005c22:	4293      	cmp	r3, r2
20005c24:	d063      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c26:	68fb      	ldr	r3, [r7, #12]
20005c28:	681b      	ldr	r3, [r3, #0]
20005c2a:	4a89      	ldr	r2, [pc, #548]	; (20005e50 <HAL_DMA_PollForTransfer+0x5ec>)
20005c2c:	4293      	cmp	r3, r2
20005c2e:	d05e      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c30:	68fb      	ldr	r3, [r7, #12]
20005c32:	681b      	ldr	r3, [r3, #0]
20005c34:	4a87      	ldr	r2, [pc, #540]	; (20005e54 <HAL_DMA_PollForTransfer+0x5f0>)
20005c36:	4293      	cmp	r3, r2
20005c38:	d059      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c3a:	68fb      	ldr	r3, [r7, #12]
20005c3c:	681b      	ldr	r3, [r3, #0]
20005c3e:	4a86      	ldr	r2, [pc, #536]	; (20005e58 <HAL_DMA_PollForTransfer+0x5f4>)
20005c40:	4293      	cmp	r3, r2
20005c42:	d054      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c44:	68fb      	ldr	r3, [r7, #12]
20005c46:	681b      	ldr	r3, [r3, #0]
20005c48:	4a84      	ldr	r2, [pc, #528]	; (20005e5c <HAL_DMA_PollForTransfer+0x5f8>)
20005c4a:	4293      	cmp	r3, r2
20005c4c:	d04f      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c4e:	68fb      	ldr	r3, [r7, #12]
20005c50:	681b      	ldr	r3, [r3, #0]
20005c52:	4a83      	ldr	r2, [pc, #524]	; (20005e60 <HAL_DMA_PollForTransfer+0x5fc>)
20005c54:	4293      	cmp	r3, r2
20005c56:	d04a      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c58:	68fb      	ldr	r3, [r7, #12]
20005c5a:	681b      	ldr	r3, [r3, #0]
20005c5c:	4a81      	ldr	r2, [pc, #516]	; (20005e64 <HAL_DMA_PollForTransfer+0x600>)
20005c5e:	4293      	cmp	r3, r2
20005c60:	d045      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c62:	68fb      	ldr	r3, [r7, #12]
20005c64:	681b      	ldr	r3, [r3, #0]
20005c66:	4a80      	ldr	r2, [pc, #512]	; (20005e68 <HAL_DMA_PollForTransfer+0x604>)
20005c68:	4293      	cmp	r3, r2
20005c6a:	d040      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c6c:	68fb      	ldr	r3, [r7, #12]
20005c6e:	681b      	ldr	r3, [r3, #0]
20005c70:	4a7e      	ldr	r2, [pc, #504]	; (20005e6c <HAL_DMA_PollForTransfer+0x608>)
20005c72:	4293      	cmp	r3, r2
20005c74:	d03b      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c76:	68fb      	ldr	r3, [r7, #12]
20005c78:	681b      	ldr	r3, [r3, #0]
20005c7a:	4a7d      	ldr	r2, [pc, #500]	; (20005e70 <HAL_DMA_PollForTransfer+0x60c>)
20005c7c:	4293      	cmp	r3, r2
20005c7e:	d036      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c80:	68fb      	ldr	r3, [r7, #12]
20005c82:	681b      	ldr	r3, [r3, #0]
20005c84:	4a7b      	ldr	r2, [pc, #492]	; (20005e74 <HAL_DMA_PollForTransfer+0x610>)
20005c86:	4293      	cmp	r3, r2
20005c88:	d031      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c8a:	68fb      	ldr	r3, [r7, #12]
20005c8c:	681b      	ldr	r3, [r3, #0]
20005c8e:	4a7a      	ldr	r2, [pc, #488]	; (20005e78 <HAL_DMA_PollForTransfer+0x614>)
20005c90:	4293      	cmp	r3, r2
20005c92:	d02c      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c94:	68fb      	ldr	r3, [r7, #12]
20005c96:	681b      	ldr	r3, [r3, #0]
20005c98:	4a78      	ldr	r2, [pc, #480]	; (20005e7c <HAL_DMA_PollForTransfer+0x618>)
20005c9a:	4293      	cmp	r3, r2
20005c9c:	d027      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005c9e:	68fb      	ldr	r3, [r7, #12]
20005ca0:	681b      	ldr	r3, [r3, #0]
20005ca2:	4a77      	ldr	r2, [pc, #476]	; (20005e80 <HAL_DMA_PollForTransfer+0x61c>)
20005ca4:	4293      	cmp	r3, r2
20005ca6:	d022      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005ca8:	68fb      	ldr	r3, [r7, #12]
20005caa:	681b      	ldr	r3, [r3, #0]
20005cac:	4a75      	ldr	r2, [pc, #468]	; (20005e84 <HAL_DMA_PollForTransfer+0x620>)
20005cae:	4293      	cmp	r3, r2
20005cb0:	d01d      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005cb2:	68fb      	ldr	r3, [r7, #12]
20005cb4:	681b      	ldr	r3, [r3, #0]
20005cb6:	4a74      	ldr	r2, [pc, #464]	; (20005e88 <HAL_DMA_PollForTransfer+0x624>)
20005cb8:	4293      	cmp	r3, r2
20005cba:	d018      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005cbc:	68fb      	ldr	r3, [r7, #12]
20005cbe:	681b      	ldr	r3, [r3, #0]
20005cc0:	4a72      	ldr	r2, [pc, #456]	; (20005e8c <HAL_DMA_PollForTransfer+0x628>)
20005cc2:	4293      	cmp	r3, r2
20005cc4:	d013      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005cc6:	68fb      	ldr	r3, [r7, #12]
20005cc8:	681b      	ldr	r3, [r3, #0]
20005cca:	4a71      	ldr	r2, [pc, #452]	; (20005e90 <HAL_DMA_PollForTransfer+0x62c>)
20005ccc:	4293      	cmp	r3, r2
20005cce:	d00e      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005cd0:	68fb      	ldr	r3, [r7, #12]
20005cd2:	681b      	ldr	r3, [r3, #0]
20005cd4:	4a6f      	ldr	r2, [pc, #444]	; (20005e94 <HAL_DMA_PollForTransfer+0x630>)
20005cd6:	4293      	cmp	r3, r2
20005cd8:	d009      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005cda:	68fb      	ldr	r3, [r7, #12]
20005cdc:	681b      	ldr	r3, [r3, #0]
20005cde:	4a6e      	ldr	r2, [pc, #440]	; (20005e98 <HAL_DMA_PollForTransfer+0x634>)
20005ce0:	4293      	cmp	r3, r2
20005ce2:	d004      	beq.n	20005cee <HAL_DMA_PollForTransfer+0x48a>
20005ce4:	68fb      	ldr	r3, [r7, #12]
20005ce6:	681b      	ldr	r3, [r3, #0]
20005ce8:	4a6c      	ldr	r2, [pc, #432]	; (20005e9c <HAL_DMA_PollForTransfer+0x638>)
20005cea:	4293      	cmp	r3, r2
20005cec:	d101      	bne.n	20005cf2 <HAL_DMA_PollForTransfer+0x48e>
20005cee:	2301      	movs	r3, #1
20005cf0:	e000      	b.n	20005cf4 <HAL_DMA_PollForTransfer+0x490>
20005cf2:	2300      	movs	r3, #0
20005cf4:	2b00      	cmp	r3, #0
20005cf6:	d029      	beq.n	20005d4c <HAL_DMA_PollForTransfer+0x4e8>
    {
      /* Check for DMAMUX Request generator (if used) overrun status */
      if(hdma->DMAmuxRequestGen != 0U)
20005cf8:	68fb      	ldr	r3, [r7, #12]
20005cfa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20005cfc:	2b00      	cmp	r3, #0
20005cfe:	d012      	beq.n	20005d26 <HAL_DMA_PollForTransfer+0x4c2>
      {
        /* if using DMAMUX request generator Check for DMAMUX request generator overrun */
        if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
20005d00:	68fb      	ldr	r3, [r7, #12]
20005d02:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20005d04:	681a      	ldr	r2, [r3, #0]
20005d06:	68fb      	ldr	r3, [r7, #12]
20005d08:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20005d0a:	4013      	ands	r3, r2
20005d0c:	2b00      	cmp	r3, #0
20005d0e:	d00a      	beq.n	20005d26 <HAL_DMA_PollForTransfer+0x4c2>
        {
          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
20005d10:	68fb      	ldr	r3, [r7, #12]
20005d12:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20005d14:	68fa      	ldr	r2, [r7, #12]
20005d16:	6f52      	ldr	r2, [r2, #116]	; 0x74
20005d18:	605a      	str	r2, [r3, #4]

          /* Update error code */
          hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
20005d1a:	68fb      	ldr	r3, [r7, #12]
20005d1c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20005d1e:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
20005d22:	68fb      	ldr	r3, [r7, #12]
20005d24:	655a      	str	r2, [r3, #84]	; 0x54
        }
      }

      /* Check for DMAMUX Synchronization overrun */
      if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
20005d26:	68fb      	ldr	r3, [r7, #12]
20005d28:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20005d2a:	681a      	ldr	r2, [r3, #0]
20005d2c:	68fb      	ldr	r3, [r7, #12]
20005d2e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
20005d30:	4013      	ands	r3, r2
20005d32:	2b00      	cmp	r3, #0
20005d34:	d00a      	beq.n	20005d4c <HAL_DMA_PollForTransfer+0x4e8>
      {
        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
20005d36:	68fb      	ldr	r3, [r7, #12]
20005d38:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20005d3a:	68fa      	ldr	r2, [r7, #12]
20005d3c:	6e92      	ldr	r2, [r2, #104]	; 0x68
20005d3e:	605a      	str	r2, [r3, #4]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
20005d40:	68fb      	ldr	r3, [r7, #12]
20005d42:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20005d44:	f443 7200 	orr.w	r2, r3, #512	; 0x200
20005d48:	68fb      	ldr	r3, [r7, #12]
20005d4a:	655a      	str	r2, [r3, #84]	; 0x54
  while(((*isr_reg) & cpltlevel_mask) == 0U)
20005d4c:	6a3b      	ldr	r3, [r7, #32]
20005d4e:	681a      	ldr	r2, [r3, #0]
20005d50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20005d52:	4013      	ands	r3, r2
20005d54:	2b00      	cmp	r3, #0
20005d56:	f43f ae4c 	beq.w	200059f2 <HAL_DMA_PollForTransfer+0x18e>
    }
  }


  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
20005d5a:	7afb      	ldrb	r3, [r7, #11]
20005d5c:	2b00      	cmp	r3, #0
20005d5e:	f040 809f 	bne.w	20005ea0 <HAL_DMA_PollForTransfer+0x63c>
  {
    /* Clear the half transfer and transfer complete flags */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20005d62:	68fb      	ldr	r3, [r7, #12]
20005d64:	681b      	ldr	r3, [r3, #0]
20005d66:	4a36      	ldr	r2, [pc, #216]	; (20005e40 <HAL_DMA_PollForTransfer+0x5dc>)
20005d68:	4293      	cmp	r3, r2
20005d6a:	d04a      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005d6c:	68fb      	ldr	r3, [r7, #12]
20005d6e:	681b      	ldr	r3, [r3, #0]
20005d70:	4a34      	ldr	r2, [pc, #208]	; (20005e44 <HAL_DMA_PollForTransfer+0x5e0>)
20005d72:	4293      	cmp	r3, r2
20005d74:	d045      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005d76:	68fb      	ldr	r3, [r7, #12]
20005d78:	681b      	ldr	r3, [r3, #0]
20005d7a:	4a33      	ldr	r2, [pc, #204]	; (20005e48 <HAL_DMA_PollForTransfer+0x5e4>)
20005d7c:	4293      	cmp	r3, r2
20005d7e:	d040      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005d80:	68fb      	ldr	r3, [r7, #12]
20005d82:	681b      	ldr	r3, [r3, #0]
20005d84:	4a31      	ldr	r2, [pc, #196]	; (20005e4c <HAL_DMA_PollForTransfer+0x5e8>)
20005d86:	4293      	cmp	r3, r2
20005d88:	d03b      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005d8a:	68fb      	ldr	r3, [r7, #12]
20005d8c:	681b      	ldr	r3, [r3, #0]
20005d8e:	4a30      	ldr	r2, [pc, #192]	; (20005e50 <HAL_DMA_PollForTransfer+0x5ec>)
20005d90:	4293      	cmp	r3, r2
20005d92:	d036      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005d94:	68fb      	ldr	r3, [r7, #12]
20005d96:	681b      	ldr	r3, [r3, #0]
20005d98:	4a2e      	ldr	r2, [pc, #184]	; (20005e54 <HAL_DMA_PollForTransfer+0x5f0>)
20005d9a:	4293      	cmp	r3, r2
20005d9c:	d031      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005d9e:	68fb      	ldr	r3, [r7, #12]
20005da0:	681b      	ldr	r3, [r3, #0]
20005da2:	4a2d      	ldr	r2, [pc, #180]	; (20005e58 <HAL_DMA_PollForTransfer+0x5f4>)
20005da4:	4293      	cmp	r3, r2
20005da6:	d02c      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005da8:	68fb      	ldr	r3, [r7, #12]
20005daa:	681b      	ldr	r3, [r3, #0]
20005dac:	4a2b      	ldr	r2, [pc, #172]	; (20005e5c <HAL_DMA_PollForTransfer+0x5f8>)
20005dae:	4293      	cmp	r3, r2
20005db0:	d027      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005db2:	68fb      	ldr	r3, [r7, #12]
20005db4:	681b      	ldr	r3, [r3, #0]
20005db6:	4a2a      	ldr	r2, [pc, #168]	; (20005e60 <HAL_DMA_PollForTransfer+0x5fc>)
20005db8:	4293      	cmp	r3, r2
20005dba:	d022      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005dbc:	68fb      	ldr	r3, [r7, #12]
20005dbe:	681b      	ldr	r3, [r3, #0]
20005dc0:	4a28      	ldr	r2, [pc, #160]	; (20005e64 <HAL_DMA_PollForTransfer+0x600>)
20005dc2:	4293      	cmp	r3, r2
20005dc4:	d01d      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005dc6:	68fb      	ldr	r3, [r7, #12]
20005dc8:	681b      	ldr	r3, [r3, #0]
20005dca:	4a27      	ldr	r2, [pc, #156]	; (20005e68 <HAL_DMA_PollForTransfer+0x604>)
20005dcc:	4293      	cmp	r3, r2
20005dce:	d018      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005dd0:	68fb      	ldr	r3, [r7, #12]
20005dd2:	681b      	ldr	r3, [r3, #0]
20005dd4:	4a25      	ldr	r2, [pc, #148]	; (20005e6c <HAL_DMA_PollForTransfer+0x608>)
20005dd6:	4293      	cmp	r3, r2
20005dd8:	d013      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005dda:	68fb      	ldr	r3, [r7, #12]
20005ddc:	681b      	ldr	r3, [r3, #0]
20005dde:	4a24      	ldr	r2, [pc, #144]	; (20005e70 <HAL_DMA_PollForTransfer+0x60c>)
20005de0:	4293      	cmp	r3, r2
20005de2:	d00e      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005de4:	68fb      	ldr	r3, [r7, #12]
20005de6:	681b      	ldr	r3, [r3, #0]
20005de8:	4a22      	ldr	r2, [pc, #136]	; (20005e74 <HAL_DMA_PollForTransfer+0x610>)
20005dea:	4293      	cmp	r3, r2
20005dec:	d009      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005dee:	68fb      	ldr	r3, [r7, #12]
20005df0:	681b      	ldr	r3, [r3, #0]
20005df2:	4a21      	ldr	r2, [pc, #132]	; (20005e78 <HAL_DMA_PollForTransfer+0x614>)
20005df4:	4293      	cmp	r3, r2
20005df6:	d004      	beq.n	20005e02 <HAL_DMA_PollForTransfer+0x59e>
20005df8:	68fb      	ldr	r3, [r7, #12]
20005dfa:	681b      	ldr	r3, [r3, #0]
20005dfc:	4a1f      	ldr	r2, [pc, #124]	; (20005e7c <HAL_DMA_PollForTransfer+0x618>)
20005dfe:	4293      	cmp	r3, r2
20005e00:	d101      	bne.n	20005e06 <HAL_DMA_PollForTransfer+0x5a2>
20005e02:	2301      	movs	r3, #1
20005e04:	e000      	b.n	20005e08 <HAL_DMA_PollForTransfer+0x5a4>
20005e06:	2300      	movs	r3, #0
20005e08:	2b00      	cmp	r3, #0
20005e0a:	d008      	beq.n	20005e1e <HAL_DMA_PollForTransfer+0x5ba>
    {
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << (hdma->StreamIndex & 0x1FU);
20005e0c:	68fb      	ldr	r3, [r7, #12]
20005e0e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005e10:	f003 031f 	and.w	r3, r3, #31
20005e14:	2230      	movs	r2, #48	; 0x30
20005e16:	409a      	lsls	r2, r3
20005e18:	69fb      	ldr	r3, [r7, #28]
20005e1a:	601a      	str	r2, [r3, #0]
20005e1c:	e007      	b.n	20005e2e <HAL_DMA_PollForTransfer+0x5ca>
    }
    else /* BDMA channel */
    {
      (*ifcr_reg) = (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU));
20005e1e:	68fb      	ldr	r3, [r7, #12]
20005e20:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005e22:	f003 031f 	and.w	r3, r3, #31
20005e26:	2202      	movs	r2, #2
20005e28:	409a      	lsls	r2, r3
20005e2a:	69fb      	ldr	r3, [r7, #28]
20005e2c:	601a      	str	r2, [r3, #0]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
20005e2e:	68fb      	ldr	r3, [r7, #12]
20005e30:	2200      	movs	r2, #0
20005e32:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    hdma->State = HAL_DMA_STATE_READY;
20005e36:	68fb      	ldr	r3, [r7, #12]
20005e38:	2201      	movs	r2, #1
20005e3a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
20005e3e:	e095      	b.n	20005f6c <HAL_DMA_PollForTransfer+0x708>
20005e40:	40020010 	.word	0x40020010
20005e44:	40020028 	.word	0x40020028
20005e48:	40020040 	.word	0x40020040
20005e4c:	40020058 	.word	0x40020058
20005e50:	40020070 	.word	0x40020070
20005e54:	40020088 	.word	0x40020088
20005e58:	400200a0 	.word	0x400200a0
20005e5c:	400200b8 	.word	0x400200b8
20005e60:	40020410 	.word	0x40020410
20005e64:	40020428 	.word	0x40020428
20005e68:	40020440 	.word	0x40020440
20005e6c:	40020458 	.word	0x40020458
20005e70:	40020470 	.word	0x40020470
20005e74:	40020488 	.word	0x40020488
20005e78:	400204a0 	.word	0x400204a0
20005e7c:	400204b8 	.word	0x400204b8
20005e80:	58025408 	.word	0x58025408
20005e84:	5802541c 	.word	0x5802541c
20005e88:	58025430 	.word	0x58025430
20005e8c:	58025444 	.word	0x58025444
20005e90:	58025458 	.word	0x58025458
20005e94:	5802546c 	.word	0x5802546c
20005e98:	58025480 	.word	0x58025480
20005e9c:	58025494 	.word	0x58025494
  }
  else /*CompleteLevel = HAL_DMA_HALF_TRANSFER*/
  {
    /* Clear the half transfer and transfer complete flags */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20005ea0:	68fb      	ldr	r3, [r7, #12]
20005ea2:	681b      	ldr	r3, [r3, #0]
20005ea4:	4a34      	ldr	r2, [pc, #208]	; (20005f78 <HAL_DMA_PollForTransfer+0x714>)
20005ea6:	4293      	cmp	r3, r2
20005ea8:	d04a      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005eaa:	68fb      	ldr	r3, [r7, #12]
20005eac:	681b      	ldr	r3, [r3, #0]
20005eae:	4a33      	ldr	r2, [pc, #204]	; (20005f7c <HAL_DMA_PollForTransfer+0x718>)
20005eb0:	4293      	cmp	r3, r2
20005eb2:	d045      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005eb4:	68fb      	ldr	r3, [r7, #12]
20005eb6:	681b      	ldr	r3, [r3, #0]
20005eb8:	4a31      	ldr	r2, [pc, #196]	; (20005f80 <HAL_DMA_PollForTransfer+0x71c>)
20005eba:	4293      	cmp	r3, r2
20005ebc:	d040      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005ebe:	68fb      	ldr	r3, [r7, #12]
20005ec0:	681b      	ldr	r3, [r3, #0]
20005ec2:	4a30      	ldr	r2, [pc, #192]	; (20005f84 <HAL_DMA_PollForTransfer+0x720>)
20005ec4:	4293      	cmp	r3, r2
20005ec6:	d03b      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005ec8:	68fb      	ldr	r3, [r7, #12]
20005eca:	681b      	ldr	r3, [r3, #0]
20005ecc:	4a2e      	ldr	r2, [pc, #184]	; (20005f88 <HAL_DMA_PollForTransfer+0x724>)
20005ece:	4293      	cmp	r3, r2
20005ed0:	d036      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005ed2:	68fb      	ldr	r3, [r7, #12]
20005ed4:	681b      	ldr	r3, [r3, #0]
20005ed6:	4a2d      	ldr	r2, [pc, #180]	; (20005f8c <HAL_DMA_PollForTransfer+0x728>)
20005ed8:	4293      	cmp	r3, r2
20005eda:	d031      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005edc:	68fb      	ldr	r3, [r7, #12]
20005ede:	681b      	ldr	r3, [r3, #0]
20005ee0:	4a2b      	ldr	r2, [pc, #172]	; (20005f90 <HAL_DMA_PollForTransfer+0x72c>)
20005ee2:	4293      	cmp	r3, r2
20005ee4:	d02c      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005ee6:	68fb      	ldr	r3, [r7, #12]
20005ee8:	681b      	ldr	r3, [r3, #0]
20005eea:	4a2a      	ldr	r2, [pc, #168]	; (20005f94 <HAL_DMA_PollForTransfer+0x730>)
20005eec:	4293      	cmp	r3, r2
20005eee:	d027      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005ef0:	68fb      	ldr	r3, [r7, #12]
20005ef2:	681b      	ldr	r3, [r3, #0]
20005ef4:	4a28      	ldr	r2, [pc, #160]	; (20005f98 <HAL_DMA_PollForTransfer+0x734>)
20005ef6:	4293      	cmp	r3, r2
20005ef8:	d022      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005efa:	68fb      	ldr	r3, [r7, #12]
20005efc:	681b      	ldr	r3, [r3, #0]
20005efe:	4a27      	ldr	r2, [pc, #156]	; (20005f9c <HAL_DMA_PollForTransfer+0x738>)
20005f00:	4293      	cmp	r3, r2
20005f02:	d01d      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005f04:	68fb      	ldr	r3, [r7, #12]
20005f06:	681b      	ldr	r3, [r3, #0]
20005f08:	4a25      	ldr	r2, [pc, #148]	; (20005fa0 <HAL_DMA_PollForTransfer+0x73c>)
20005f0a:	4293      	cmp	r3, r2
20005f0c:	d018      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005f0e:	68fb      	ldr	r3, [r7, #12]
20005f10:	681b      	ldr	r3, [r3, #0]
20005f12:	4a24      	ldr	r2, [pc, #144]	; (20005fa4 <HAL_DMA_PollForTransfer+0x740>)
20005f14:	4293      	cmp	r3, r2
20005f16:	d013      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005f18:	68fb      	ldr	r3, [r7, #12]
20005f1a:	681b      	ldr	r3, [r3, #0]
20005f1c:	4a22      	ldr	r2, [pc, #136]	; (20005fa8 <HAL_DMA_PollForTransfer+0x744>)
20005f1e:	4293      	cmp	r3, r2
20005f20:	d00e      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005f22:	68fb      	ldr	r3, [r7, #12]
20005f24:	681b      	ldr	r3, [r3, #0]
20005f26:	4a21      	ldr	r2, [pc, #132]	; (20005fac <HAL_DMA_PollForTransfer+0x748>)
20005f28:	4293      	cmp	r3, r2
20005f2a:	d009      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005f2c:	68fb      	ldr	r3, [r7, #12]
20005f2e:	681b      	ldr	r3, [r3, #0]
20005f30:	4a1f      	ldr	r2, [pc, #124]	; (20005fb0 <HAL_DMA_PollForTransfer+0x74c>)
20005f32:	4293      	cmp	r3, r2
20005f34:	d004      	beq.n	20005f40 <HAL_DMA_PollForTransfer+0x6dc>
20005f36:	68fb      	ldr	r3, [r7, #12]
20005f38:	681b      	ldr	r3, [r3, #0]
20005f3a:	4a1e      	ldr	r2, [pc, #120]	; (20005fb4 <HAL_DMA_PollForTransfer+0x750>)
20005f3c:	4293      	cmp	r3, r2
20005f3e:	d101      	bne.n	20005f44 <HAL_DMA_PollForTransfer+0x6e0>
20005f40:	2301      	movs	r3, #1
20005f42:	e000      	b.n	20005f46 <HAL_DMA_PollForTransfer+0x6e2>
20005f44:	2300      	movs	r3, #0
20005f46:	2b00      	cmp	r3, #0
20005f48:	d008      	beq.n	20005f5c <HAL_DMA_PollForTransfer+0x6f8>
    {
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4) << (hdma->StreamIndex & 0x1FU);
20005f4a:	68fb      	ldr	r3, [r7, #12]
20005f4c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005f4e:	f003 031f 	and.w	r3, r3, #31
20005f52:	2210      	movs	r2, #16
20005f54:	409a      	lsls	r2, r3
20005f56:	69fb      	ldr	r3, [r7, #28]
20005f58:	601a      	str	r2, [r3, #0]
20005f5a:	e007      	b.n	20005f6c <HAL_DMA_PollForTransfer+0x708>
    }
    else /* BDMA channel */
    {
      (*ifcr_reg) = (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU));
20005f5c:	68fb      	ldr	r3, [r7, #12]
20005f5e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20005f60:	f003 031f 	and.w	r3, r3, #31
20005f64:	2204      	movs	r2, #4
20005f66:	409a      	lsls	r2, r3
20005f68:	69fb      	ldr	r3, [r7, #28]
20005f6a:	601a      	str	r2, [r3, #0]
    }
  }

  return status;
20005f6c:	7efb      	ldrb	r3, [r7, #27]
}
20005f6e:	4618      	mov	r0, r3
20005f70:	3728      	adds	r7, #40	; 0x28
20005f72:	46bd      	mov	sp, r7
20005f74:	bd80      	pop	{r7, pc}
20005f76:	bf00      	nop
20005f78:	40020010 	.word	0x40020010
20005f7c:	40020028 	.word	0x40020028
20005f80:	40020040 	.word	0x40020040
20005f84:	40020058 	.word	0x40020058
20005f88:	40020070 	.word	0x40020070
20005f8c:	40020088 	.word	0x40020088
20005f90:	400200a0 	.word	0x400200a0
20005f94:	400200b8 	.word	0x400200b8
20005f98:	40020410 	.word	0x40020410
20005f9c:	40020428 	.word	0x40020428
20005fa0:	40020440 	.word	0x40020440
20005fa4:	40020458 	.word	0x40020458
20005fa8:	40020470 	.word	0x40020470
20005fac:	40020488 	.word	0x40020488
20005fb0:	400204a0 	.word	0x400204a0
20005fb4:	400204b8 	.word	0x400204b8

20005fb8 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
20005fb8:	b580      	push	{r7, lr}
20005fba:	b08a      	sub	sp, #40	; 0x28
20005fbc:	af00      	add	r7, sp, #0
20005fbe:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr_dma, tmpisr_bdma;
  uint32_t ccr_reg;
  __IO uint32_t count = 0U;
20005fc0:	2300      	movs	r3, #0
20005fc2:	60fb      	str	r3, [r7, #12]
  uint32_t timeout = SystemCoreClock / 9600U;
20005fc4:	4b67      	ldr	r3, [pc, #412]	; (20006164 <HAL_DMA_IRQHandler+0x1ac>)
20005fc6:	681b      	ldr	r3, [r3, #0]
20005fc8:	4a67      	ldr	r2, [pc, #412]	; (20006168 <HAL_DMA_IRQHandler+0x1b0>)
20005fca:	fba2 2303 	umull	r2, r3, r2, r3
20005fce:	0a9b      	lsrs	r3, r3, #10
20005fd0:	627b      	str	r3, [r7, #36]	; 0x24

  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
20005fd2:	687b      	ldr	r3, [r7, #4]
20005fd4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20005fd6:	623b      	str	r3, [r7, #32]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
20005fd8:	687b      	ldr	r3, [r7, #4]
20005fda:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20005fdc:	61fb      	str	r3, [r7, #28]

  tmpisr_dma  = regs_dma->ISR;
20005fde:	6a3b      	ldr	r3, [r7, #32]
20005fe0:	681b      	ldr	r3, [r3, #0]
20005fe2:	61bb      	str	r3, [r7, #24]
  tmpisr_bdma = regs_bdma->ISR;
20005fe4:	69fb      	ldr	r3, [r7, #28]
20005fe6:	681b      	ldr	r3, [r3, #0]
20005fe8:	617b      	str	r3, [r7, #20]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
20005fea:	687b      	ldr	r3, [r7, #4]
20005fec:	681b      	ldr	r3, [r3, #0]
20005fee:	4a5f      	ldr	r2, [pc, #380]	; (2000616c <HAL_DMA_IRQHandler+0x1b4>)
20005ff0:	4293      	cmp	r3, r2
20005ff2:	d04a      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20005ff4:	687b      	ldr	r3, [r7, #4]
20005ff6:	681b      	ldr	r3, [r3, #0]
20005ff8:	4a5d      	ldr	r2, [pc, #372]	; (20006170 <HAL_DMA_IRQHandler+0x1b8>)
20005ffa:	4293      	cmp	r3, r2
20005ffc:	d045      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20005ffe:	687b      	ldr	r3, [r7, #4]
20006000:	681b      	ldr	r3, [r3, #0]
20006002:	4a5c      	ldr	r2, [pc, #368]	; (20006174 <HAL_DMA_IRQHandler+0x1bc>)
20006004:	4293      	cmp	r3, r2
20006006:	d040      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20006008:	687b      	ldr	r3, [r7, #4]
2000600a:	681b      	ldr	r3, [r3, #0]
2000600c:	4a5a      	ldr	r2, [pc, #360]	; (20006178 <HAL_DMA_IRQHandler+0x1c0>)
2000600e:	4293      	cmp	r3, r2
20006010:	d03b      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20006012:	687b      	ldr	r3, [r7, #4]
20006014:	681b      	ldr	r3, [r3, #0]
20006016:	4a59      	ldr	r2, [pc, #356]	; (2000617c <HAL_DMA_IRQHandler+0x1c4>)
20006018:	4293      	cmp	r3, r2
2000601a:	d036      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
2000601c:	687b      	ldr	r3, [r7, #4]
2000601e:	681b      	ldr	r3, [r3, #0]
20006020:	4a57      	ldr	r2, [pc, #348]	; (20006180 <HAL_DMA_IRQHandler+0x1c8>)
20006022:	4293      	cmp	r3, r2
20006024:	d031      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20006026:	687b      	ldr	r3, [r7, #4]
20006028:	681b      	ldr	r3, [r3, #0]
2000602a:	4a56      	ldr	r2, [pc, #344]	; (20006184 <HAL_DMA_IRQHandler+0x1cc>)
2000602c:	4293      	cmp	r3, r2
2000602e:	d02c      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20006030:	687b      	ldr	r3, [r7, #4]
20006032:	681b      	ldr	r3, [r3, #0]
20006034:	4a54      	ldr	r2, [pc, #336]	; (20006188 <HAL_DMA_IRQHandler+0x1d0>)
20006036:	4293      	cmp	r3, r2
20006038:	d027      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
2000603a:	687b      	ldr	r3, [r7, #4]
2000603c:	681b      	ldr	r3, [r3, #0]
2000603e:	4a53      	ldr	r2, [pc, #332]	; (2000618c <HAL_DMA_IRQHandler+0x1d4>)
20006040:	4293      	cmp	r3, r2
20006042:	d022      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20006044:	687b      	ldr	r3, [r7, #4]
20006046:	681b      	ldr	r3, [r3, #0]
20006048:	4a51      	ldr	r2, [pc, #324]	; (20006190 <HAL_DMA_IRQHandler+0x1d8>)
2000604a:	4293      	cmp	r3, r2
2000604c:	d01d      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
2000604e:	687b      	ldr	r3, [r7, #4]
20006050:	681b      	ldr	r3, [r3, #0]
20006052:	4a50      	ldr	r2, [pc, #320]	; (20006194 <HAL_DMA_IRQHandler+0x1dc>)
20006054:	4293      	cmp	r3, r2
20006056:	d018      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20006058:	687b      	ldr	r3, [r7, #4]
2000605a:	681b      	ldr	r3, [r3, #0]
2000605c:	4a4e      	ldr	r2, [pc, #312]	; (20006198 <HAL_DMA_IRQHandler+0x1e0>)
2000605e:	4293      	cmp	r3, r2
20006060:	d013      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20006062:	687b      	ldr	r3, [r7, #4]
20006064:	681b      	ldr	r3, [r3, #0]
20006066:	4a4d      	ldr	r2, [pc, #308]	; (2000619c <HAL_DMA_IRQHandler+0x1e4>)
20006068:	4293      	cmp	r3, r2
2000606a:	d00e      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
2000606c:	687b      	ldr	r3, [r7, #4]
2000606e:	681b      	ldr	r3, [r3, #0]
20006070:	4a4b      	ldr	r2, [pc, #300]	; (200061a0 <HAL_DMA_IRQHandler+0x1e8>)
20006072:	4293      	cmp	r3, r2
20006074:	d009      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20006076:	687b      	ldr	r3, [r7, #4]
20006078:	681b      	ldr	r3, [r3, #0]
2000607a:	4a4a      	ldr	r2, [pc, #296]	; (200061a4 <HAL_DMA_IRQHandler+0x1ec>)
2000607c:	4293      	cmp	r3, r2
2000607e:	d004      	beq.n	2000608a <HAL_DMA_IRQHandler+0xd2>
20006080:	687b      	ldr	r3, [r7, #4]
20006082:	681b      	ldr	r3, [r3, #0]
20006084:	4a48      	ldr	r2, [pc, #288]	; (200061a8 <HAL_DMA_IRQHandler+0x1f0>)
20006086:	4293      	cmp	r3, r2
20006088:	d101      	bne.n	2000608e <HAL_DMA_IRQHandler+0xd6>
2000608a:	2301      	movs	r3, #1
2000608c:	e000      	b.n	20006090 <HAL_DMA_IRQHandler+0xd8>
2000608e:	2300      	movs	r3, #0
20006090:	2b00      	cmp	r3, #0
20006092:	f000 842b 	beq.w	200068ec <HAL_DMA_IRQHandler+0x934>
  {
    /* Transfer Error Interrupt management ***************************************/
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
20006096:	687b      	ldr	r3, [r7, #4]
20006098:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2000609a:	f003 031f 	and.w	r3, r3, #31
2000609e:	2208      	movs	r2, #8
200060a0:	409a      	lsls	r2, r3
200060a2:	69bb      	ldr	r3, [r7, #24]
200060a4:	4013      	ands	r3, r2
200060a6:	2b00      	cmp	r3, #0
200060a8:	f000 80a2 	beq.w	200061f0 <HAL_DMA_IRQHandler+0x238>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
200060ac:	687b      	ldr	r3, [r7, #4]
200060ae:	681b      	ldr	r3, [r3, #0]
200060b0:	4a2e      	ldr	r2, [pc, #184]	; (2000616c <HAL_DMA_IRQHandler+0x1b4>)
200060b2:	4293      	cmp	r3, r2
200060b4:	d04a      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
200060b6:	687b      	ldr	r3, [r7, #4]
200060b8:	681b      	ldr	r3, [r3, #0]
200060ba:	4a2d      	ldr	r2, [pc, #180]	; (20006170 <HAL_DMA_IRQHandler+0x1b8>)
200060bc:	4293      	cmp	r3, r2
200060be:	d045      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
200060c0:	687b      	ldr	r3, [r7, #4]
200060c2:	681b      	ldr	r3, [r3, #0]
200060c4:	4a2b      	ldr	r2, [pc, #172]	; (20006174 <HAL_DMA_IRQHandler+0x1bc>)
200060c6:	4293      	cmp	r3, r2
200060c8:	d040      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
200060ca:	687b      	ldr	r3, [r7, #4]
200060cc:	681b      	ldr	r3, [r3, #0]
200060ce:	4a2a      	ldr	r2, [pc, #168]	; (20006178 <HAL_DMA_IRQHandler+0x1c0>)
200060d0:	4293      	cmp	r3, r2
200060d2:	d03b      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
200060d4:	687b      	ldr	r3, [r7, #4]
200060d6:	681b      	ldr	r3, [r3, #0]
200060d8:	4a28      	ldr	r2, [pc, #160]	; (2000617c <HAL_DMA_IRQHandler+0x1c4>)
200060da:	4293      	cmp	r3, r2
200060dc:	d036      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
200060de:	687b      	ldr	r3, [r7, #4]
200060e0:	681b      	ldr	r3, [r3, #0]
200060e2:	4a27      	ldr	r2, [pc, #156]	; (20006180 <HAL_DMA_IRQHandler+0x1c8>)
200060e4:	4293      	cmp	r3, r2
200060e6:	d031      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
200060e8:	687b      	ldr	r3, [r7, #4]
200060ea:	681b      	ldr	r3, [r3, #0]
200060ec:	4a25      	ldr	r2, [pc, #148]	; (20006184 <HAL_DMA_IRQHandler+0x1cc>)
200060ee:	4293      	cmp	r3, r2
200060f0:	d02c      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
200060f2:	687b      	ldr	r3, [r7, #4]
200060f4:	681b      	ldr	r3, [r3, #0]
200060f6:	4a24      	ldr	r2, [pc, #144]	; (20006188 <HAL_DMA_IRQHandler+0x1d0>)
200060f8:	4293      	cmp	r3, r2
200060fa:	d027      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
200060fc:	687b      	ldr	r3, [r7, #4]
200060fe:	681b      	ldr	r3, [r3, #0]
20006100:	4a22      	ldr	r2, [pc, #136]	; (2000618c <HAL_DMA_IRQHandler+0x1d4>)
20006102:	4293      	cmp	r3, r2
20006104:	d022      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
20006106:	687b      	ldr	r3, [r7, #4]
20006108:	681b      	ldr	r3, [r3, #0]
2000610a:	4a21      	ldr	r2, [pc, #132]	; (20006190 <HAL_DMA_IRQHandler+0x1d8>)
2000610c:	4293      	cmp	r3, r2
2000610e:	d01d      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
20006110:	687b      	ldr	r3, [r7, #4]
20006112:	681b      	ldr	r3, [r3, #0]
20006114:	4a1f      	ldr	r2, [pc, #124]	; (20006194 <HAL_DMA_IRQHandler+0x1dc>)
20006116:	4293      	cmp	r3, r2
20006118:	d018      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
2000611a:	687b      	ldr	r3, [r7, #4]
2000611c:	681b      	ldr	r3, [r3, #0]
2000611e:	4a1e      	ldr	r2, [pc, #120]	; (20006198 <HAL_DMA_IRQHandler+0x1e0>)
20006120:	4293      	cmp	r3, r2
20006122:	d013      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
20006124:	687b      	ldr	r3, [r7, #4]
20006126:	681b      	ldr	r3, [r3, #0]
20006128:	4a1c      	ldr	r2, [pc, #112]	; (2000619c <HAL_DMA_IRQHandler+0x1e4>)
2000612a:	4293      	cmp	r3, r2
2000612c:	d00e      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
2000612e:	687b      	ldr	r3, [r7, #4]
20006130:	681b      	ldr	r3, [r3, #0]
20006132:	4a1b      	ldr	r2, [pc, #108]	; (200061a0 <HAL_DMA_IRQHandler+0x1e8>)
20006134:	4293      	cmp	r3, r2
20006136:	d009      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
20006138:	687b      	ldr	r3, [r7, #4]
2000613a:	681b      	ldr	r3, [r3, #0]
2000613c:	4a19      	ldr	r2, [pc, #100]	; (200061a4 <HAL_DMA_IRQHandler+0x1ec>)
2000613e:	4293      	cmp	r3, r2
20006140:	d004      	beq.n	2000614c <HAL_DMA_IRQHandler+0x194>
20006142:	687b      	ldr	r3, [r7, #4]
20006144:	681b      	ldr	r3, [r3, #0]
20006146:	4a18      	ldr	r2, [pc, #96]	; (200061a8 <HAL_DMA_IRQHandler+0x1f0>)
20006148:	4293      	cmp	r3, r2
2000614a:	d12f      	bne.n	200061ac <HAL_DMA_IRQHandler+0x1f4>
2000614c:	687b      	ldr	r3, [r7, #4]
2000614e:	681b      	ldr	r3, [r3, #0]
20006150:	681b      	ldr	r3, [r3, #0]
20006152:	f003 0304 	and.w	r3, r3, #4
20006156:	2b00      	cmp	r3, #0
20006158:	bf14      	ite	ne
2000615a:	2301      	movne	r3, #1
2000615c:	2300      	moveq	r3, #0
2000615e:	b2db      	uxtb	r3, r3
20006160:	e02e      	b.n	200061c0 <HAL_DMA_IRQHandler+0x208>
20006162:	bf00      	nop
20006164:	2001c978 	.word	0x2001c978
20006168:	1b4e81b5 	.word	0x1b4e81b5
2000616c:	40020010 	.word	0x40020010
20006170:	40020028 	.word	0x40020028
20006174:	40020040 	.word	0x40020040
20006178:	40020058 	.word	0x40020058
2000617c:	40020070 	.word	0x40020070
20006180:	40020088 	.word	0x40020088
20006184:	400200a0 	.word	0x400200a0
20006188:	400200b8 	.word	0x400200b8
2000618c:	40020410 	.word	0x40020410
20006190:	40020428 	.word	0x40020428
20006194:	40020440 	.word	0x40020440
20006198:	40020458 	.word	0x40020458
2000619c:	40020470 	.word	0x40020470
200061a0:	40020488 	.word	0x40020488
200061a4:	400204a0 	.word	0x400204a0
200061a8:	400204b8 	.word	0x400204b8
200061ac:	687b      	ldr	r3, [r7, #4]
200061ae:	681b      	ldr	r3, [r3, #0]
200061b0:	681b      	ldr	r3, [r3, #0]
200061b2:	f003 0308 	and.w	r3, r3, #8
200061b6:	2b00      	cmp	r3, #0
200061b8:	bf14      	ite	ne
200061ba:	2301      	movne	r3, #1
200061bc:	2300      	moveq	r3, #0
200061be:	b2db      	uxtb	r3, r3
200061c0:	2b00      	cmp	r3, #0
200061c2:	d015      	beq.n	200061f0 <HAL_DMA_IRQHandler+0x238>
      {
        /* Disable the transfer error interrupt */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
200061c4:	687b      	ldr	r3, [r7, #4]
200061c6:	681b      	ldr	r3, [r3, #0]
200061c8:	681a      	ldr	r2, [r3, #0]
200061ca:	687b      	ldr	r3, [r7, #4]
200061cc:	681b      	ldr	r3, [r3, #0]
200061ce:	f022 0204 	bic.w	r2, r2, #4
200061d2:	601a      	str	r2, [r3, #0]

        /* Clear the transfer error flag */
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
200061d4:	687b      	ldr	r3, [r7, #4]
200061d6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200061d8:	f003 031f 	and.w	r3, r3, #31
200061dc:	2208      	movs	r2, #8
200061de:	409a      	lsls	r2, r3
200061e0:	6a3b      	ldr	r3, [r7, #32]
200061e2:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
200061e4:	687b      	ldr	r3, [r7, #4]
200061e6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
200061e8:	f043 0201 	orr.w	r2, r3, #1
200061ec:	687b      	ldr	r3, [r7, #4]
200061ee:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* FIFO Error Interrupt management ******************************************/
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
200061f0:	687b      	ldr	r3, [r7, #4]
200061f2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200061f4:	f003 031f 	and.w	r3, r3, #31
200061f8:	69ba      	ldr	r2, [r7, #24]
200061fa:	fa22 f303 	lsr.w	r3, r2, r3
200061fe:	f003 0301 	and.w	r3, r3, #1
20006202:	2b00      	cmp	r3, #0
20006204:	d06e      	beq.n	200062e4 <HAL_DMA_IRQHandler+0x32c>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
20006206:	687b      	ldr	r3, [r7, #4]
20006208:	681b      	ldr	r3, [r3, #0]
2000620a:	4a69      	ldr	r2, [pc, #420]	; (200063b0 <HAL_DMA_IRQHandler+0x3f8>)
2000620c:	4293      	cmp	r3, r2
2000620e:	d04a      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
20006210:	687b      	ldr	r3, [r7, #4]
20006212:	681b      	ldr	r3, [r3, #0]
20006214:	4a67      	ldr	r2, [pc, #412]	; (200063b4 <HAL_DMA_IRQHandler+0x3fc>)
20006216:	4293      	cmp	r3, r2
20006218:	d045      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
2000621a:	687b      	ldr	r3, [r7, #4]
2000621c:	681b      	ldr	r3, [r3, #0]
2000621e:	4a66      	ldr	r2, [pc, #408]	; (200063b8 <HAL_DMA_IRQHandler+0x400>)
20006220:	4293      	cmp	r3, r2
20006222:	d040      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
20006224:	687b      	ldr	r3, [r7, #4]
20006226:	681b      	ldr	r3, [r3, #0]
20006228:	4a64      	ldr	r2, [pc, #400]	; (200063bc <HAL_DMA_IRQHandler+0x404>)
2000622a:	4293      	cmp	r3, r2
2000622c:	d03b      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
2000622e:	687b      	ldr	r3, [r7, #4]
20006230:	681b      	ldr	r3, [r3, #0]
20006232:	4a63      	ldr	r2, [pc, #396]	; (200063c0 <HAL_DMA_IRQHandler+0x408>)
20006234:	4293      	cmp	r3, r2
20006236:	d036      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
20006238:	687b      	ldr	r3, [r7, #4]
2000623a:	681b      	ldr	r3, [r3, #0]
2000623c:	4a61      	ldr	r2, [pc, #388]	; (200063c4 <HAL_DMA_IRQHandler+0x40c>)
2000623e:	4293      	cmp	r3, r2
20006240:	d031      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
20006242:	687b      	ldr	r3, [r7, #4]
20006244:	681b      	ldr	r3, [r3, #0]
20006246:	4a60      	ldr	r2, [pc, #384]	; (200063c8 <HAL_DMA_IRQHandler+0x410>)
20006248:	4293      	cmp	r3, r2
2000624a:	d02c      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
2000624c:	687b      	ldr	r3, [r7, #4]
2000624e:	681b      	ldr	r3, [r3, #0]
20006250:	4a5e      	ldr	r2, [pc, #376]	; (200063cc <HAL_DMA_IRQHandler+0x414>)
20006252:	4293      	cmp	r3, r2
20006254:	d027      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
20006256:	687b      	ldr	r3, [r7, #4]
20006258:	681b      	ldr	r3, [r3, #0]
2000625a:	4a5d      	ldr	r2, [pc, #372]	; (200063d0 <HAL_DMA_IRQHandler+0x418>)
2000625c:	4293      	cmp	r3, r2
2000625e:	d022      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
20006260:	687b      	ldr	r3, [r7, #4]
20006262:	681b      	ldr	r3, [r3, #0]
20006264:	4a5b      	ldr	r2, [pc, #364]	; (200063d4 <HAL_DMA_IRQHandler+0x41c>)
20006266:	4293      	cmp	r3, r2
20006268:	d01d      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
2000626a:	687b      	ldr	r3, [r7, #4]
2000626c:	681b      	ldr	r3, [r3, #0]
2000626e:	4a5a      	ldr	r2, [pc, #360]	; (200063d8 <HAL_DMA_IRQHandler+0x420>)
20006270:	4293      	cmp	r3, r2
20006272:	d018      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
20006274:	687b      	ldr	r3, [r7, #4]
20006276:	681b      	ldr	r3, [r3, #0]
20006278:	4a58      	ldr	r2, [pc, #352]	; (200063dc <HAL_DMA_IRQHandler+0x424>)
2000627a:	4293      	cmp	r3, r2
2000627c:	d013      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
2000627e:	687b      	ldr	r3, [r7, #4]
20006280:	681b      	ldr	r3, [r3, #0]
20006282:	4a57      	ldr	r2, [pc, #348]	; (200063e0 <HAL_DMA_IRQHandler+0x428>)
20006284:	4293      	cmp	r3, r2
20006286:	d00e      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
20006288:	687b      	ldr	r3, [r7, #4]
2000628a:	681b      	ldr	r3, [r3, #0]
2000628c:	4a55      	ldr	r2, [pc, #340]	; (200063e4 <HAL_DMA_IRQHandler+0x42c>)
2000628e:	4293      	cmp	r3, r2
20006290:	d009      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
20006292:	687b      	ldr	r3, [r7, #4]
20006294:	681b      	ldr	r3, [r3, #0]
20006296:	4a54      	ldr	r2, [pc, #336]	; (200063e8 <HAL_DMA_IRQHandler+0x430>)
20006298:	4293      	cmp	r3, r2
2000629a:	d004      	beq.n	200062a6 <HAL_DMA_IRQHandler+0x2ee>
2000629c:	687b      	ldr	r3, [r7, #4]
2000629e:	681b      	ldr	r3, [r3, #0]
200062a0:	4a52      	ldr	r2, [pc, #328]	; (200063ec <HAL_DMA_IRQHandler+0x434>)
200062a2:	4293      	cmp	r3, r2
200062a4:	d10a      	bne.n	200062bc <HAL_DMA_IRQHandler+0x304>
200062a6:	687b      	ldr	r3, [r7, #4]
200062a8:	681b      	ldr	r3, [r3, #0]
200062aa:	695b      	ldr	r3, [r3, #20]
200062ac:	f003 0380 	and.w	r3, r3, #128	; 0x80
200062b0:	2b00      	cmp	r3, #0
200062b2:	bf14      	ite	ne
200062b4:	2301      	movne	r3, #1
200062b6:	2300      	moveq	r3, #0
200062b8:	b2db      	uxtb	r3, r3
200062ba:	e003      	b.n	200062c4 <HAL_DMA_IRQHandler+0x30c>
200062bc:	687b      	ldr	r3, [r7, #4]
200062be:	681b      	ldr	r3, [r3, #0]
200062c0:	681b      	ldr	r3, [r3, #0]
200062c2:	2300      	movs	r3, #0
200062c4:	2b00      	cmp	r3, #0
200062c6:	d00d      	beq.n	200062e4 <HAL_DMA_IRQHandler+0x32c>
      {
        /* Clear the FIFO error flag */
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
200062c8:	687b      	ldr	r3, [r7, #4]
200062ca:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200062cc:	f003 031f 	and.w	r3, r3, #31
200062d0:	2201      	movs	r2, #1
200062d2:	409a      	lsls	r2, r3
200062d4:	6a3b      	ldr	r3, [r7, #32]
200062d6:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
200062d8:	687b      	ldr	r3, [r7, #4]
200062da:	6d5b      	ldr	r3, [r3, #84]	; 0x54
200062dc:	f043 0202 	orr.w	r2, r3, #2
200062e0:	687b      	ldr	r3, [r7, #4]
200062e2:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Direct Mode Error Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
200062e4:	687b      	ldr	r3, [r7, #4]
200062e6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200062e8:	f003 031f 	and.w	r3, r3, #31
200062ec:	2204      	movs	r2, #4
200062ee:	409a      	lsls	r2, r3
200062f0:	69bb      	ldr	r3, [r7, #24]
200062f2:	4013      	ands	r3, r2
200062f4:	2b00      	cmp	r3, #0
200062f6:	f000 808f 	beq.w	20006418 <HAL_DMA_IRQHandler+0x460>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
200062fa:	687b      	ldr	r3, [r7, #4]
200062fc:	681b      	ldr	r3, [r3, #0]
200062fe:	4a2c      	ldr	r2, [pc, #176]	; (200063b0 <HAL_DMA_IRQHandler+0x3f8>)
20006300:	4293      	cmp	r3, r2
20006302:	d04a      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
20006304:	687b      	ldr	r3, [r7, #4]
20006306:	681b      	ldr	r3, [r3, #0]
20006308:	4a2a      	ldr	r2, [pc, #168]	; (200063b4 <HAL_DMA_IRQHandler+0x3fc>)
2000630a:	4293      	cmp	r3, r2
2000630c:	d045      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
2000630e:	687b      	ldr	r3, [r7, #4]
20006310:	681b      	ldr	r3, [r3, #0]
20006312:	4a29      	ldr	r2, [pc, #164]	; (200063b8 <HAL_DMA_IRQHandler+0x400>)
20006314:	4293      	cmp	r3, r2
20006316:	d040      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
20006318:	687b      	ldr	r3, [r7, #4]
2000631a:	681b      	ldr	r3, [r3, #0]
2000631c:	4a27      	ldr	r2, [pc, #156]	; (200063bc <HAL_DMA_IRQHandler+0x404>)
2000631e:	4293      	cmp	r3, r2
20006320:	d03b      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
20006322:	687b      	ldr	r3, [r7, #4]
20006324:	681b      	ldr	r3, [r3, #0]
20006326:	4a26      	ldr	r2, [pc, #152]	; (200063c0 <HAL_DMA_IRQHandler+0x408>)
20006328:	4293      	cmp	r3, r2
2000632a:	d036      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
2000632c:	687b      	ldr	r3, [r7, #4]
2000632e:	681b      	ldr	r3, [r3, #0]
20006330:	4a24      	ldr	r2, [pc, #144]	; (200063c4 <HAL_DMA_IRQHandler+0x40c>)
20006332:	4293      	cmp	r3, r2
20006334:	d031      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
20006336:	687b      	ldr	r3, [r7, #4]
20006338:	681b      	ldr	r3, [r3, #0]
2000633a:	4a23      	ldr	r2, [pc, #140]	; (200063c8 <HAL_DMA_IRQHandler+0x410>)
2000633c:	4293      	cmp	r3, r2
2000633e:	d02c      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
20006340:	687b      	ldr	r3, [r7, #4]
20006342:	681b      	ldr	r3, [r3, #0]
20006344:	4a21      	ldr	r2, [pc, #132]	; (200063cc <HAL_DMA_IRQHandler+0x414>)
20006346:	4293      	cmp	r3, r2
20006348:	d027      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
2000634a:	687b      	ldr	r3, [r7, #4]
2000634c:	681b      	ldr	r3, [r3, #0]
2000634e:	4a20      	ldr	r2, [pc, #128]	; (200063d0 <HAL_DMA_IRQHandler+0x418>)
20006350:	4293      	cmp	r3, r2
20006352:	d022      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
20006354:	687b      	ldr	r3, [r7, #4]
20006356:	681b      	ldr	r3, [r3, #0]
20006358:	4a1e      	ldr	r2, [pc, #120]	; (200063d4 <HAL_DMA_IRQHandler+0x41c>)
2000635a:	4293      	cmp	r3, r2
2000635c:	d01d      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
2000635e:	687b      	ldr	r3, [r7, #4]
20006360:	681b      	ldr	r3, [r3, #0]
20006362:	4a1d      	ldr	r2, [pc, #116]	; (200063d8 <HAL_DMA_IRQHandler+0x420>)
20006364:	4293      	cmp	r3, r2
20006366:	d018      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
20006368:	687b      	ldr	r3, [r7, #4]
2000636a:	681b      	ldr	r3, [r3, #0]
2000636c:	4a1b      	ldr	r2, [pc, #108]	; (200063dc <HAL_DMA_IRQHandler+0x424>)
2000636e:	4293      	cmp	r3, r2
20006370:	d013      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
20006372:	687b      	ldr	r3, [r7, #4]
20006374:	681b      	ldr	r3, [r3, #0]
20006376:	4a1a      	ldr	r2, [pc, #104]	; (200063e0 <HAL_DMA_IRQHandler+0x428>)
20006378:	4293      	cmp	r3, r2
2000637a:	d00e      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
2000637c:	687b      	ldr	r3, [r7, #4]
2000637e:	681b      	ldr	r3, [r3, #0]
20006380:	4a18      	ldr	r2, [pc, #96]	; (200063e4 <HAL_DMA_IRQHandler+0x42c>)
20006382:	4293      	cmp	r3, r2
20006384:	d009      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
20006386:	687b      	ldr	r3, [r7, #4]
20006388:	681b      	ldr	r3, [r3, #0]
2000638a:	4a17      	ldr	r2, [pc, #92]	; (200063e8 <HAL_DMA_IRQHandler+0x430>)
2000638c:	4293      	cmp	r3, r2
2000638e:	d004      	beq.n	2000639a <HAL_DMA_IRQHandler+0x3e2>
20006390:	687b      	ldr	r3, [r7, #4]
20006392:	681b      	ldr	r3, [r3, #0]
20006394:	4a15      	ldr	r2, [pc, #84]	; (200063ec <HAL_DMA_IRQHandler+0x434>)
20006396:	4293      	cmp	r3, r2
20006398:	d12a      	bne.n	200063f0 <HAL_DMA_IRQHandler+0x438>
2000639a:	687b      	ldr	r3, [r7, #4]
2000639c:	681b      	ldr	r3, [r3, #0]
2000639e:	681b      	ldr	r3, [r3, #0]
200063a0:	f003 0302 	and.w	r3, r3, #2
200063a4:	2b00      	cmp	r3, #0
200063a6:	bf14      	ite	ne
200063a8:	2301      	movne	r3, #1
200063aa:	2300      	moveq	r3, #0
200063ac:	b2db      	uxtb	r3, r3
200063ae:	e023      	b.n	200063f8 <HAL_DMA_IRQHandler+0x440>
200063b0:	40020010 	.word	0x40020010
200063b4:	40020028 	.word	0x40020028
200063b8:	40020040 	.word	0x40020040
200063bc:	40020058 	.word	0x40020058
200063c0:	40020070 	.word	0x40020070
200063c4:	40020088 	.word	0x40020088
200063c8:	400200a0 	.word	0x400200a0
200063cc:	400200b8 	.word	0x400200b8
200063d0:	40020410 	.word	0x40020410
200063d4:	40020428 	.word	0x40020428
200063d8:	40020440 	.word	0x40020440
200063dc:	40020458 	.word	0x40020458
200063e0:	40020470 	.word	0x40020470
200063e4:	40020488 	.word	0x40020488
200063e8:	400204a0 	.word	0x400204a0
200063ec:	400204b8 	.word	0x400204b8
200063f0:	687b      	ldr	r3, [r7, #4]
200063f2:	681b      	ldr	r3, [r3, #0]
200063f4:	681b      	ldr	r3, [r3, #0]
200063f6:	2300      	movs	r3, #0
200063f8:	2b00      	cmp	r3, #0
200063fa:	d00d      	beq.n	20006418 <HAL_DMA_IRQHandler+0x460>
      {
        /* Clear the direct mode error flag */
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
200063fc:	687b      	ldr	r3, [r7, #4]
200063fe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20006400:	f003 031f 	and.w	r3, r3, #31
20006404:	2204      	movs	r2, #4
20006406:	409a      	lsls	r2, r3
20006408:	6a3b      	ldr	r3, [r7, #32]
2000640a:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
2000640c:	687b      	ldr	r3, [r7, #4]
2000640e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20006410:	f043 0204 	orr.w	r2, r3, #4
20006414:	687b      	ldr	r3, [r7, #4]
20006416:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Half Transfer Complete Interrupt management ******************************/
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
20006418:	687b      	ldr	r3, [r7, #4]
2000641a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2000641c:	f003 031f 	and.w	r3, r3, #31
20006420:	2210      	movs	r2, #16
20006422:	409a      	lsls	r2, r3
20006424:	69bb      	ldr	r3, [r7, #24]
20006426:	4013      	ands	r3, r2
20006428:	2b00      	cmp	r3, #0
2000642a:	f000 80a6 	beq.w	2000657a <HAL_DMA_IRQHandler+0x5c2>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
2000642e:	687b      	ldr	r3, [r7, #4]
20006430:	681b      	ldr	r3, [r3, #0]
20006432:	4a85      	ldr	r2, [pc, #532]	; (20006648 <HAL_DMA_IRQHandler+0x690>)
20006434:	4293      	cmp	r3, r2
20006436:	d04a      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
20006438:	687b      	ldr	r3, [r7, #4]
2000643a:	681b      	ldr	r3, [r3, #0]
2000643c:	4a83      	ldr	r2, [pc, #524]	; (2000664c <HAL_DMA_IRQHandler+0x694>)
2000643e:	4293      	cmp	r3, r2
20006440:	d045      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
20006442:	687b      	ldr	r3, [r7, #4]
20006444:	681b      	ldr	r3, [r3, #0]
20006446:	4a82      	ldr	r2, [pc, #520]	; (20006650 <HAL_DMA_IRQHandler+0x698>)
20006448:	4293      	cmp	r3, r2
2000644a:	d040      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
2000644c:	687b      	ldr	r3, [r7, #4]
2000644e:	681b      	ldr	r3, [r3, #0]
20006450:	4a80      	ldr	r2, [pc, #512]	; (20006654 <HAL_DMA_IRQHandler+0x69c>)
20006452:	4293      	cmp	r3, r2
20006454:	d03b      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
20006456:	687b      	ldr	r3, [r7, #4]
20006458:	681b      	ldr	r3, [r3, #0]
2000645a:	4a7f      	ldr	r2, [pc, #508]	; (20006658 <HAL_DMA_IRQHandler+0x6a0>)
2000645c:	4293      	cmp	r3, r2
2000645e:	d036      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
20006460:	687b      	ldr	r3, [r7, #4]
20006462:	681b      	ldr	r3, [r3, #0]
20006464:	4a7d      	ldr	r2, [pc, #500]	; (2000665c <HAL_DMA_IRQHandler+0x6a4>)
20006466:	4293      	cmp	r3, r2
20006468:	d031      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
2000646a:	687b      	ldr	r3, [r7, #4]
2000646c:	681b      	ldr	r3, [r3, #0]
2000646e:	4a7c      	ldr	r2, [pc, #496]	; (20006660 <HAL_DMA_IRQHandler+0x6a8>)
20006470:	4293      	cmp	r3, r2
20006472:	d02c      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
20006474:	687b      	ldr	r3, [r7, #4]
20006476:	681b      	ldr	r3, [r3, #0]
20006478:	4a7a      	ldr	r2, [pc, #488]	; (20006664 <HAL_DMA_IRQHandler+0x6ac>)
2000647a:	4293      	cmp	r3, r2
2000647c:	d027      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
2000647e:	687b      	ldr	r3, [r7, #4]
20006480:	681b      	ldr	r3, [r3, #0]
20006482:	4a79      	ldr	r2, [pc, #484]	; (20006668 <HAL_DMA_IRQHandler+0x6b0>)
20006484:	4293      	cmp	r3, r2
20006486:	d022      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
20006488:	687b      	ldr	r3, [r7, #4]
2000648a:	681b      	ldr	r3, [r3, #0]
2000648c:	4a77      	ldr	r2, [pc, #476]	; (2000666c <HAL_DMA_IRQHandler+0x6b4>)
2000648e:	4293      	cmp	r3, r2
20006490:	d01d      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
20006492:	687b      	ldr	r3, [r7, #4]
20006494:	681b      	ldr	r3, [r3, #0]
20006496:	4a76      	ldr	r2, [pc, #472]	; (20006670 <HAL_DMA_IRQHandler+0x6b8>)
20006498:	4293      	cmp	r3, r2
2000649a:	d018      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
2000649c:	687b      	ldr	r3, [r7, #4]
2000649e:	681b      	ldr	r3, [r3, #0]
200064a0:	4a74      	ldr	r2, [pc, #464]	; (20006674 <HAL_DMA_IRQHandler+0x6bc>)
200064a2:	4293      	cmp	r3, r2
200064a4:	d013      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
200064a6:	687b      	ldr	r3, [r7, #4]
200064a8:	681b      	ldr	r3, [r3, #0]
200064aa:	4a73      	ldr	r2, [pc, #460]	; (20006678 <HAL_DMA_IRQHandler+0x6c0>)
200064ac:	4293      	cmp	r3, r2
200064ae:	d00e      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
200064b0:	687b      	ldr	r3, [r7, #4]
200064b2:	681b      	ldr	r3, [r3, #0]
200064b4:	4a71      	ldr	r2, [pc, #452]	; (2000667c <HAL_DMA_IRQHandler+0x6c4>)
200064b6:	4293      	cmp	r3, r2
200064b8:	d009      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
200064ba:	687b      	ldr	r3, [r7, #4]
200064bc:	681b      	ldr	r3, [r3, #0]
200064be:	4a70      	ldr	r2, [pc, #448]	; (20006680 <HAL_DMA_IRQHandler+0x6c8>)
200064c0:	4293      	cmp	r3, r2
200064c2:	d004      	beq.n	200064ce <HAL_DMA_IRQHandler+0x516>
200064c4:	687b      	ldr	r3, [r7, #4]
200064c6:	681b      	ldr	r3, [r3, #0]
200064c8:	4a6e      	ldr	r2, [pc, #440]	; (20006684 <HAL_DMA_IRQHandler+0x6cc>)
200064ca:	4293      	cmp	r3, r2
200064cc:	d10a      	bne.n	200064e4 <HAL_DMA_IRQHandler+0x52c>
200064ce:	687b      	ldr	r3, [r7, #4]
200064d0:	681b      	ldr	r3, [r3, #0]
200064d2:	681b      	ldr	r3, [r3, #0]
200064d4:	f003 0308 	and.w	r3, r3, #8
200064d8:	2b00      	cmp	r3, #0
200064da:	bf14      	ite	ne
200064dc:	2301      	movne	r3, #1
200064de:	2300      	moveq	r3, #0
200064e0:	b2db      	uxtb	r3, r3
200064e2:	e009      	b.n	200064f8 <HAL_DMA_IRQHandler+0x540>
200064e4:	687b      	ldr	r3, [r7, #4]
200064e6:	681b      	ldr	r3, [r3, #0]
200064e8:	681b      	ldr	r3, [r3, #0]
200064ea:	f003 0304 	and.w	r3, r3, #4
200064ee:	2b00      	cmp	r3, #0
200064f0:	bf14      	ite	ne
200064f2:	2301      	movne	r3, #1
200064f4:	2300      	moveq	r3, #0
200064f6:	b2db      	uxtb	r3, r3
200064f8:	2b00      	cmp	r3, #0
200064fa:	d03e      	beq.n	2000657a <HAL_DMA_IRQHandler+0x5c2>
      {
        /* Clear the half transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
200064fc:	687b      	ldr	r3, [r7, #4]
200064fe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20006500:	f003 031f 	and.w	r3, r3, #31
20006504:	2210      	movs	r2, #16
20006506:	409a      	lsls	r2, r3
20006508:	6a3b      	ldr	r3, [r7, #32]
2000650a:	609a      	str	r2, [r3, #8]

        /* Multi_Buffering mode enabled */
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
2000650c:	687b      	ldr	r3, [r7, #4]
2000650e:	681b      	ldr	r3, [r3, #0]
20006510:	681b      	ldr	r3, [r3, #0]
20006512:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
20006516:	2b00      	cmp	r3, #0
20006518:	d018      	beq.n	2000654c <HAL_DMA_IRQHandler+0x594>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
2000651a:	687b      	ldr	r3, [r7, #4]
2000651c:	681b      	ldr	r3, [r3, #0]
2000651e:	681b      	ldr	r3, [r3, #0]
20006520:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
20006524:	2b00      	cmp	r3, #0
20006526:	d108      	bne.n	2000653a <HAL_DMA_IRQHandler+0x582>
          {
            if(hdma->XferHalfCpltCallback != NULL)
20006528:	687b      	ldr	r3, [r7, #4]
2000652a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000652c:	2b00      	cmp	r3, #0
2000652e:	d024      	beq.n	2000657a <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferHalfCpltCallback(hdma);
20006530:	687b      	ldr	r3, [r7, #4]
20006532:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20006534:	6878      	ldr	r0, [r7, #4]
20006536:	4798      	blx	r3
20006538:	e01f      	b.n	2000657a <HAL_DMA_IRQHandler+0x5c2>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferM1HalfCpltCallback != NULL)
2000653a:	687b      	ldr	r3, [r7, #4]
2000653c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000653e:	2b00      	cmp	r3, #0
20006540:	d01b      	beq.n	2000657a <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferM1HalfCpltCallback(hdma);
20006542:	687b      	ldr	r3, [r7, #4]
20006544:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20006546:	6878      	ldr	r0, [r7, #4]
20006548:	4798      	blx	r3
2000654a:	e016      	b.n	2000657a <HAL_DMA_IRQHandler+0x5c2>
          }
        }
        else
        {
          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
2000654c:	687b      	ldr	r3, [r7, #4]
2000654e:	681b      	ldr	r3, [r3, #0]
20006550:	681b      	ldr	r3, [r3, #0]
20006552:	f403 7380 	and.w	r3, r3, #256	; 0x100
20006556:	2b00      	cmp	r3, #0
20006558:	d107      	bne.n	2000656a <HAL_DMA_IRQHandler+0x5b2>
          {
            /* Disable the half transfer interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
2000655a:	687b      	ldr	r3, [r7, #4]
2000655c:	681b      	ldr	r3, [r3, #0]
2000655e:	681a      	ldr	r2, [r3, #0]
20006560:	687b      	ldr	r3, [r7, #4]
20006562:	681b      	ldr	r3, [r3, #0]
20006564:	f022 0208 	bic.w	r2, r2, #8
20006568:	601a      	str	r2, [r3, #0]
          }

          if(hdma->XferHalfCpltCallback != NULL)
2000656a:	687b      	ldr	r3, [r7, #4]
2000656c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000656e:	2b00      	cmp	r3, #0
20006570:	d003      	beq.n	2000657a <HAL_DMA_IRQHandler+0x5c2>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
20006572:	687b      	ldr	r3, [r7, #4]
20006574:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20006576:	6878      	ldr	r0, [r7, #4]
20006578:	4798      	blx	r3
          }
        }
      }
    }
    /* Transfer Complete Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
2000657a:	687b      	ldr	r3, [r7, #4]
2000657c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2000657e:	f003 031f 	and.w	r3, r3, #31
20006582:	2220      	movs	r2, #32
20006584:	409a      	lsls	r2, r3
20006586:	69bb      	ldr	r3, [r7, #24]
20006588:	4013      	ands	r3, r2
2000658a:	2b00      	cmp	r3, #0
2000658c:	f000 8110 	beq.w	200067b0 <HAL_DMA_IRQHandler+0x7f8>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
20006590:	687b      	ldr	r3, [r7, #4]
20006592:	681b      	ldr	r3, [r3, #0]
20006594:	4a2c      	ldr	r2, [pc, #176]	; (20006648 <HAL_DMA_IRQHandler+0x690>)
20006596:	4293      	cmp	r3, r2
20006598:	d04a      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
2000659a:	687b      	ldr	r3, [r7, #4]
2000659c:	681b      	ldr	r3, [r3, #0]
2000659e:	4a2b      	ldr	r2, [pc, #172]	; (2000664c <HAL_DMA_IRQHandler+0x694>)
200065a0:	4293      	cmp	r3, r2
200065a2:	d045      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
200065a4:	687b      	ldr	r3, [r7, #4]
200065a6:	681b      	ldr	r3, [r3, #0]
200065a8:	4a29      	ldr	r2, [pc, #164]	; (20006650 <HAL_DMA_IRQHandler+0x698>)
200065aa:	4293      	cmp	r3, r2
200065ac:	d040      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
200065ae:	687b      	ldr	r3, [r7, #4]
200065b0:	681b      	ldr	r3, [r3, #0]
200065b2:	4a28      	ldr	r2, [pc, #160]	; (20006654 <HAL_DMA_IRQHandler+0x69c>)
200065b4:	4293      	cmp	r3, r2
200065b6:	d03b      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
200065b8:	687b      	ldr	r3, [r7, #4]
200065ba:	681b      	ldr	r3, [r3, #0]
200065bc:	4a26      	ldr	r2, [pc, #152]	; (20006658 <HAL_DMA_IRQHandler+0x6a0>)
200065be:	4293      	cmp	r3, r2
200065c0:	d036      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
200065c2:	687b      	ldr	r3, [r7, #4]
200065c4:	681b      	ldr	r3, [r3, #0]
200065c6:	4a25      	ldr	r2, [pc, #148]	; (2000665c <HAL_DMA_IRQHandler+0x6a4>)
200065c8:	4293      	cmp	r3, r2
200065ca:	d031      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
200065cc:	687b      	ldr	r3, [r7, #4]
200065ce:	681b      	ldr	r3, [r3, #0]
200065d0:	4a23      	ldr	r2, [pc, #140]	; (20006660 <HAL_DMA_IRQHandler+0x6a8>)
200065d2:	4293      	cmp	r3, r2
200065d4:	d02c      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
200065d6:	687b      	ldr	r3, [r7, #4]
200065d8:	681b      	ldr	r3, [r3, #0]
200065da:	4a22      	ldr	r2, [pc, #136]	; (20006664 <HAL_DMA_IRQHandler+0x6ac>)
200065dc:	4293      	cmp	r3, r2
200065de:	d027      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
200065e0:	687b      	ldr	r3, [r7, #4]
200065e2:	681b      	ldr	r3, [r3, #0]
200065e4:	4a20      	ldr	r2, [pc, #128]	; (20006668 <HAL_DMA_IRQHandler+0x6b0>)
200065e6:	4293      	cmp	r3, r2
200065e8:	d022      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
200065ea:	687b      	ldr	r3, [r7, #4]
200065ec:	681b      	ldr	r3, [r3, #0]
200065ee:	4a1f      	ldr	r2, [pc, #124]	; (2000666c <HAL_DMA_IRQHandler+0x6b4>)
200065f0:	4293      	cmp	r3, r2
200065f2:	d01d      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
200065f4:	687b      	ldr	r3, [r7, #4]
200065f6:	681b      	ldr	r3, [r3, #0]
200065f8:	4a1d      	ldr	r2, [pc, #116]	; (20006670 <HAL_DMA_IRQHandler+0x6b8>)
200065fa:	4293      	cmp	r3, r2
200065fc:	d018      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
200065fe:	687b      	ldr	r3, [r7, #4]
20006600:	681b      	ldr	r3, [r3, #0]
20006602:	4a1c      	ldr	r2, [pc, #112]	; (20006674 <HAL_DMA_IRQHandler+0x6bc>)
20006604:	4293      	cmp	r3, r2
20006606:	d013      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
20006608:	687b      	ldr	r3, [r7, #4]
2000660a:	681b      	ldr	r3, [r3, #0]
2000660c:	4a1a      	ldr	r2, [pc, #104]	; (20006678 <HAL_DMA_IRQHandler+0x6c0>)
2000660e:	4293      	cmp	r3, r2
20006610:	d00e      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
20006612:	687b      	ldr	r3, [r7, #4]
20006614:	681b      	ldr	r3, [r3, #0]
20006616:	4a19      	ldr	r2, [pc, #100]	; (2000667c <HAL_DMA_IRQHandler+0x6c4>)
20006618:	4293      	cmp	r3, r2
2000661a:	d009      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
2000661c:	687b      	ldr	r3, [r7, #4]
2000661e:	681b      	ldr	r3, [r3, #0]
20006620:	4a17      	ldr	r2, [pc, #92]	; (20006680 <HAL_DMA_IRQHandler+0x6c8>)
20006622:	4293      	cmp	r3, r2
20006624:	d004      	beq.n	20006630 <HAL_DMA_IRQHandler+0x678>
20006626:	687b      	ldr	r3, [r7, #4]
20006628:	681b      	ldr	r3, [r3, #0]
2000662a:	4a16      	ldr	r2, [pc, #88]	; (20006684 <HAL_DMA_IRQHandler+0x6cc>)
2000662c:	4293      	cmp	r3, r2
2000662e:	d12b      	bne.n	20006688 <HAL_DMA_IRQHandler+0x6d0>
20006630:	687b      	ldr	r3, [r7, #4]
20006632:	681b      	ldr	r3, [r3, #0]
20006634:	681b      	ldr	r3, [r3, #0]
20006636:	f003 0310 	and.w	r3, r3, #16
2000663a:	2b00      	cmp	r3, #0
2000663c:	bf14      	ite	ne
2000663e:	2301      	movne	r3, #1
20006640:	2300      	moveq	r3, #0
20006642:	b2db      	uxtb	r3, r3
20006644:	e02a      	b.n	2000669c <HAL_DMA_IRQHandler+0x6e4>
20006646:	bf00      	nop
20006648:	40020010 	.word	0x40020010
2000664c:	40020028 	.word	0x40020028
20006650:	40020040 	.word	0x40020040
20006654:	40020058 	.word	0x40020058
20006658:	40020070 	.word	0x40020070
2000665c:	40020088 	.word	0x40020088
20006660:	400200a0 	.word	0x400200a0
20006664:	400200b8 	.word	0x400200b8
20006668:	40020410 	.word	0x40020410
2000666c:	40020428 	.word	0x40020428
20006670:	40020440 	.word	0x40020440
20006674:	40020458 	.word	0x40020458
20006678:	40020470 	.word	0x40020470
2000667c:	40020488 	.word	0x40020488
20006680:	400204a0 	.word	0x400204a0
20006684:	400204b8 	.word	0x400204b8
20006688:	687b      	ldr	r3, [r7, #4]
2000668a:	681b      	ldr	r3, [r3, #0]
2000668c:	681b      	ldr	r3, [r3, #0]
2000668e:	f003 0302 	and.w	r3, r3, #2
20006692:	2b00      	cmp	r3, #0
20006694:	bf14      	ite	ne
20006696:	2301      	movne	r3, #1
20006698:	2300      	moveq	r3, #0
2000669a:	b2db      	uxtb	r3, r3
2000669c:	2b00      	cmp	r3, #0
2000669e:	f000 8087 	beq.w	200067b0 <HAL_DMA_IRQHandler+0x7f8>
      {
        /* Clear the transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
200066a2:	687b      	ldr	r3, [r7, #4]
200066a4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200066a6:	f003 031f 	and.w	r3, r3, #31
200066aa:	2220      	movs	r2, #32
200066ac:	409a      	lsls	r2, r3
200066ae:	6a3b      	ldr	r3, [r7, #32]
200066b0:	609a      	str	r2, [r3, #8]

        if(HAL_DMA_STATE_ABORT == hdma->State)
200066b2:	687b      	ldr	r3, [r7, #4]
200066b4:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
200066b8:	b2db      	uxtb	r3, r3
200066ba:	2b04      	cmp	r3, #4
200066bc:	d139      	bne.n	20006732 <HAL_DMA_IRQHandler+0x77a>
        {
          /* Disable all the transfer interrupts */
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
200066be:	687b      	ldr	r3, [r7, #4]
200066c0:	681b      	ldr	r3, [r3, #0]
200066c2:	681a      	ldr	r2, [r3, #0]
200066c4:	687b      	ldr	r3, [r7, #4]
200066c6:	681b      	ldr	r3, [r3, #0]
200066c8:	f022 0216 	bic.w	r2, r2, #22
200066cc:	601a      	str	r2, [r3, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
200066ce:	687b      	ldr	r3, [r7, #4]
200066d0:	681b      	ldr	r3, [r3, #0]
200066d2:	695a      	ldr	r2, [r3, #20]
200066d4:	687b      	ldr	r3, [r7, #4]
200066d6:	681b      	ldr	r3, [r3, #0]
200066d8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
200066dc:	615a      	str	r2, [r3, #20]

          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
200066de:	687b      	ldr	r3, [r7, #4]
200066e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200066e2:	2b00      	cmp	r3, #0
200066e4:	d103      	bne.n	200066ee <HAL_DMA_IRQHandler+0x736>
200066e6:	687b      	ldr	r3, [r7, #4]
200066e8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200066ea:	2b00      	cmp	r3, #0
200066ec:	d007      	beq.n	200066fe <HAL_DMA_IRQHandler+0x746>
          {
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
200066ee:	687b      	ldr	r3, [r7, #4]
200066f0:	681b      	ldr	r3, [r3, #0]
200066f2:	681a      	ldr	r2, [r3, #0]
200066f4:	687b      	ldr	r3, [r7, #4]
200066f6:	681b      	ldr	r3, [r3, #0]
200066f8:	f022 0208 	bic.w	r2, r2, #8
200066fc:	601a      	str	r2, [r3, #0]
          }

          /* Clear all interrupt flags at correct offset within the register */
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
200066fe:	687b      	ldr	r3, [r7, #4]
20006700:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20006702:	f003 031f 	and.w	r3, r3, #31
20006706:	223f      	movs	r2, #63	; 0x3f
20006708:	409a      	lsls	r2, r3
2000670a:	6a3b      	ldr	r3, [r7, #32]
2000670c:	609a      	str	r2, [r3, #8]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
2000670e:	687b      	ldr	r3, [r7, #4]
20006710:	2200      	movs	r2, #0
20006712:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
20006716:	687b      	ldr	r3, [r7, #4]
20006718:	2201      	movs	r2, #1
2000671a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          if(hdma->XferAbortCallback != NULL)
2000671e:	687b      	ldr	r3, [r7, #4]
20006720:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20006722:	2b00      	cmp	r3, #0
20006724:	f000 834a 	beq.w	20006dbc <HAL_DMA_IRQHandler+0xe04>
          {
            hdma->XferAbortCallback(hdma);
20006728:	687b      	ldr	r3, [r7, #4]
2000672a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000672c:	6878      	ldr	r0, [r7, #4]
2000672e:	4798      	blx	r3
          }
          return;
20006730:	e344      	b.n	20006dbc <HAL_DMA_IRQHandler+0xe04>
        }

        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
20006732:	687b      	ldr	r3, [r7, #4]
20006734:	681b      	ldr	r3, [r3, #0]
20006736:	681b      	ldr	r3, [r3, #0]
20006738:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2000673c:	2b00      	cmp	r3, #0
2000673e:	d018      	beq.n	20006772 <HAL_DMA_IRQHandler+0x7ba>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
20006740:	687b      	ldr	r3, [r7, #4]
20006742:	681b      	ldr	r3, [r3, #0]
20006744:	681b      	ldr	r3, [r3, #0]
20006746:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
2000674a:	2b00      	cmp	r3, #0
2000674c:	d108      	bne.n	20006760 <HAL_DMA_IRQHandler+0x7a8>
          {
            if(hdma->XferM1CpltCallback != NULL)
2000674e:	687b      	ldr	r3, [r7, #4]
20006750:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006752:	2b00      	cmp	r3, #0
20006754:	d02c      	beq.n	200067b0 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory1 */
              hdma->XferM1CpltCallback(hdma);
20006756:	687b      	ldr	r3, [r7, #4]
20006758:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000675a:	6878      	ldr	r0, [r7, #4]
2000675c:	4798      	blx	r3
2000675e:	e027      	b.n	200067b0 <HAL_DMA_IRQHandler+0x7f8>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferCpltCallback != NULL)
20006760:	687b      	ldr	r3, [r7, #4]
20006762:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006764:	2b00      	cmp	r3, #0
20006766:	d023      	beq.n	200067b0 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory0 */
              hdma->XferCpltCallback(hdma);
20006768:	687b      	ldr	r3, [r7, #4]
2000676a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000676c:	6878      	ldr	r0, [r7, #4]
2000676e:	4798      	blx	r3
20006770:	e01e      	b.n	200067b0 <HAL_DMA_IRQHandler+0x7f8>
          }
        }
        /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
        else
        {
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
20006772:	687b      	ldr	r3, [r7, #4]
20006774:	681b      	ldr	r3, [r3, #0]
20006776:	681b      	ldr	r3, [r3, #0]
20006778:	f403 7380 	and.w	r3, r3, #256	; 0x100
2000677c:	2b00      	cmp	r3, #0
2000677e:	d10f      	bne.n	200067a0 <HAL_DMA_IRQHandler+0x7e8>
          {
            /* Disable the transfer complete interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
20006780:	687b      	ldr	r3, [r7, #4]
20006782:	681b      	ldr	r3, [r3, #0]
20006784:	681a      	ldr	r2, [r3, #0]
20006786:	687b      	ldr	r3, [r7, #4]
20006788:	681b      	ldr	r3, [r3, #0]
2000678a:	f022 0210 	bic.w	r2, r2, #16
2000678e:	601a      	str	r2, [r3, #0]

            /* Process Unlocked */
            __HAL_UNLOCK(hdma);
20006790:	687b      	ldr	r3, [r7, #4]
20006792:	2200      	movs	r2, #0
20006794:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

            /* Change the DMA state */
            hdma->State = HAL_DMA_STATE_READY;
20006798:	687b      	ldr	r3, [r7, #4]
2000679a:	2201      	movs	r2, #1
2000679c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
          }

          if(hdma->XferCpltCallback != NULL)
200067a0:	687b      	ldr	r3, [r7, #4]
200067a2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200067a4:	2b00      	cmp	r3, #0
200067a6:	d003      	beq.n	200067b0 <HAL_DMA_IRQHandler+0x7f8>
          {
            /* Transfer complete callback */
            hdma->XferCpltCallback(hdma);
200067a8:	687b      	ldr	r3, [r7, #4]
200067aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200067ac:	6878      	ldr	r0, [r7, #4]
200067ae:	4798      	blx	r3
        }
      }
    }

    /* manage error case */
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
200067b0:	687b      	ldr	r3, [r7, #4]
200067b2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
200067b4:	2b00      	cmp	r3, #0
200067b6:	f000 8306 	beq.w	20006dc6 <HAL_DMA_IRQHandler+0xe0e>
    {
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
200067ba:	687b      	ldr	r3, [r7, #4]
200067bc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
200067be:	f003 0301 	and.w	r3, r3, #1
200067c2:	2b00      	cmp	r3, #0
200067c4:	f000 8088 	beq.w	200068d8 <HAL_DMA_IRQHandler+0x920>
      {
        hdma->State = HAL_DMA_STATE_ABORT;
200067c8:	687b      	ldr	r3, [r7, #4]
200067ca:	2204      	movs	r2, #4
200067cc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Disable the stream */
        __HAL_DMA_DISABLE(hdma);
200067d0:	687b      	ldr	r3, [r7, #4]
200067d2:	681b      	ldr	r3, [r3, #0]
200067d4:	4a7a      	ldr	r2, [pc, #488]	; (200069c0 <HAL_DMA_IRQHandler+0xa08>)
200067d6:	4293      	cmp	r3, r2
200067d8:	d04a      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
200067da:	687b      	ldr	r3, [r7, #4]
200067dc:	681b      	ldr	r3, [r3, #0]
200067de:	4a79      	ldr	r2, [pc, #484]	; (200069c4 <HAL_DMA_IRQHandler+0xa0c>)
200067e0:	4293      	cmp	r3, r2
200067e2:	d045      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
200067e4:	687b      	ldr	r3, [r7, #4]
200067e6:	681b      	ldr	r3, [r3, #0]
200067e8:	4a77      	ldr	r2, [pc, #476]	; (200069c8 <HAL_DMA_IRQHandler+0xa10>)
200067ea:	4293      	cmp	r3, r2
200067ec:	d040      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
200067ee:	687b      	ldr	r3, [r7, #4]
200067f0:	681b      	ldr	r3, [r3, #0]
200067f2:	4a76      	ldr	r2, [pc, #472]	; (200069cc <HAL_DMA_IRQHandler+0xa14>)
200067f4:	4293      	cmp	r3, r2
200067f6:	d03b      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
200067f8:	687b      	ldr	r3, [r7, #4]
200067fa:	681b      	ldr	r3, [r3, #0]
200067fc:	4a74      	ldr	r2, [pc, #464]	; (200069d0 <HAL_DMA_IRQHandler+0xa18>)
200067fe:	4293      	cmp	r3, r2
20006800:	d036      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
20006802:	687b      	ldr	r3, [r7, #4]
20006804:	681b      	ldr	r3, [r3, #0]
20006806:	4a73      	ldr	r2, [pc, #460]	; (200069d4 <HAL_DMA_IRQHandler+0xa1c>)
20006808:	4293      	cmp	r3, r2
2000680a:	d031      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
2000680c:	687b      	ldr	r3, [r7, #4]
2000680e:	681b      	ldr	r3, [r3, #0]
20006810:	4a71      	ldr	r2, [pc, #452]	; (200069d8 <HAL_DMA_IRQHandler+0xa20>)
20006812:	4293      	cmp	r3, r2
20006814:	d02c      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
20006816:	687b      	ldr	r3, [r7, #4]
20006818:	681b      	ldr	r3, [r3, #0]
2000681a:	4a70      	ldr	r2, [pc, #448]	; (200069dc <HAL_DMA_IRQHandler+0xa24>)
2000681c:	4293      	cmp	r3, r2
2000681e:	d027      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
20006820:	687b      	ldr	r3, [r7, #4]
20006822:	681b      	ldr	r3, [r3, #0]
20006824:	4a6e      	ldr	r2, [pc, #440]	; (200069e0 <HAL_DMA_IRQHandler+0xa28>)
20006826:	4293      	cmp	r3, r2
20006828:	d022      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
2000682a:	687b      	ldr	r3, [r7, #4]
2000682c:	681b      	ldr	r3, [r3, #0]
2000682e:	4a6d      	ldr	r2, [pc, #436]	; (200069e4 <HAL_DMA_IRQHandler+0xa2c>)
20006830:	4293      	cmp	r3, r2
20006832:	d01d      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
20006834:	687b      	ldr	r3, [r7, #4]
20006836:	681b      	ldr	r3, [r3, #0]
20006838:	4a6b      	ldr	r2, [pc, #428]	; (200069e8 <HAL_DMA_IRQHandler+0xa30>)
2000683a:	4293      	cmp	r3, r2
2000683c:	d018      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
2000683e:	687b      	ldr	r3, [r7, #4]
20006840:	681b      	ldr	r3, [r3, #0]
20006842:	4a6a      	ldr	r2, [pc, #424]	; (200069ec <HAL_DMA_IRQHandler+0xa34>)
20006844:	4293      	cmp	r3, r2
20006846:	d013      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
20006848:	687b      	ldr	r3, [r7, #4]
2000684a:	681b      	ldr	r3, [r3, #0]
2000684c:	4a68      	ldr	r2, [pc, #416]	; (200069f0 <HAL_DMA_IRQHandler+0xa38>)
2000684e:	4293      	cmp	r3, r2
20006850:	d00e      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
20006852:	687b      	ldr	r3, [r7, #4]
20006854:	681b      	ldr	r3, [r3, #0]
20006856:	4a67      	ldr	r2, [pc, #412]	; (200069f4 <HAL_DMA_IRQHandler+0xa3c>)
20006858:	4293      	cmp	r3, r2
2000685a:	d009      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
2000685c:	687b      	ldr	r3, [r7, #4]
2000685e:	681b      	ldr	r3, [r3, #0]
20006860:	4a65      	ldr	r2, [pc, #404]	; (200069f8 <HAL_DMA_IRQHandler+0xa40>)
20006862:	4293      	cmp	r3, r2
20006864:	d004      	beq.n	20006870 <HAL_DMA_IRQHandler+0x8b8>
20006866:	687b      	ldr	r3, [r7, #4]
20006868:	681b      	ldr	r3, [r3, #0]
2000686a:	4a64      	ldr	r2, [pc, #400]	; (200069fc <HAL_DMA_IRQHandler+0xa44>)
2000686c:	4293      	cmp	r3, r2
2000686e:	d108      	bne.n	20006882 <HAL_DMA_IRQHandler+0x8ca>
20006870:	687b      	ldr	r3, [r7, #4]
20006872:	681b      	ldr	r3, [r3, #0]
20006874:	681a      	ldr	r2, [r3, #0]
20006876:	687b      	ldr	r3, [r7, #4]
20006878:	681b      	ldr	r3, [r3, #0]
2000687a:	f022 0201 	bic.w	r2, r2, #1
2000687e:	601a      	str	r2, [r3, #0]
20006880:	e007      	b.n	20006892 <HAL_DMA_IRQHandler+0x8da>
20006882:	687b      	ldr	r3, [r7, #4]
20006884:	681b      	ldr	r3, [r3, #0]
20006886:	681a      	ldr	r2, [r3, #0]
20006888:	687b      	ldr	r3, [r7, #4]
2000688a:	681b      	ldr	r3, [r3, #0]
2000688c:	f022 0201 	bic.w	r2, r2, #1
20006890:	601a      	str	r2, [r3, #0]

        do
        {
          if (++count > timeout)
20006892:	68fb      	ldr	r3, [r7, #12]
20006894:	3301      	adds	r3, #1
20006896:	60fb      	str	r3, [r7, #12]
20006898:	6a7a      	ldr	r2, [r7, #36]	; 0x24
2000689a:	429a      	cmp	r2, r3
2000689c:	d307      	bcc.n	200068ae <HAL_DMA_IRQHandler+0x8f6>
          {
            break;
          }
        }
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
2000689e:	687b      	ldr	r3, [r7, #4]
200068a0:	681b      	ldr	r3, [r3, #0]
200068a2:	681b      	ldr	r3, [r3, #0]
200068a4:	f003 0301 	and.w	r3, r3, #1
200068a8:	2b00      	cmp	r3, #0
200068aa:	d1f2      	bne.n	20006892 <HAL_DMA_IRQHandler+0x8da>
200068ac:	e000      	b.n	200068b0 <HAL_DMA_IRQHandler+0x8f8>
            break;
200068ae:	bf00      	nop

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
200068b0:	687b      	ldr	r3, [r7, #4]
200068b2:	2200      	movs	r2, #0
200068b4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
200068b8:	687b      	ldr	r3, [r7, #4]
200068ba:	681b      	ldr	r3, [r3, #0]
200068bc:	681b      	ldr	r3, [r3, #0]
200068be:	f003 0301 	and.w	r3, r3, #1
200068c2:	2b00      	cmp	r3, #0
200068c4:	d004      	beq.n	200068d0 <HAL_DMA_IRQHandler+0x918>
        {
          /* Change the DMA state to error if DMA disable fails */
          hdma->State = HAL_DMA_STATE_ERROR;
200068c6:	687b      	ldr	r3, [r7, #4]
200068c8:	2203      	movs	r2, #3
200068ca:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
200068ce:	e003      	b.n	200068d8 <HAL_DMA_IRQHandler+0x920>
        }
        else
        {
          /* Change the DMA state to Ready if DMA disable success */
          hdma->State = HAL_DMA_STATE_READY;
200068d0:	687b      	ldr	r3, [r7, #4]
200068d2:	2201      	movs	r2, #1
200068d4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }
      }

      if(hdma->XferErrorCallback != NULL)
200068d8:	687b      	ldr	r3, [r7, #4]
200068da:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
200068dc:	2b00      	cmp	r3, #0
200068de:	f000 8272 	beq.w	20006dc6 <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
200068e2:	687b      	ldr	r3, [r7, #4]
200068e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
200068e6:	6878      	ldr	r0, [r7, #4]
200068e8:	4798      	blx	r3
200068ea:	e26c      	b.n	20006dc6 <HAL_DMA_IRQHandler+0xe0e>
      }
    }
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
200068ec:	687b      	ldr	r3, [r7, #4]
200068ee:	681b      	ldr	r3, [r3, #0]
200068f0:	4a43      	ldr	r2, [pc, #268]	; (20006a00 <HAL_DMA_IRQHandler+0xa48>)
200068f2:	4293      	cmp	r3, r2
200068f4:	d022      	beq.n	2000693c <HAL_DMA_IRQHandler+0x984>
200068f6:	687b      	ldr	r3, [r7, #4]
200068f8:	681b      	ldr	r3, [r3, #0]
200068fa:	4a42      	ldr	r2, [pc, #264]	; (20006a04 <HAL_DMA_IRQHandler+0xa4c>)
200068fc:	4293      	cmp	r3, r2
200068fe:	d01d      	beq.n	2000693c <HAL_DMA_IRQHandler+0x984>
20006900:	687b      	ldr	r3, [r7, #4]
20006902:	681b      	ldr	r3, [r3, #0]
20006904:	4a40      	ldr	r2, [pc, #256]	; (20006a08 <HAL_DMA_IRQHandler+0xa50>)
20006906:	4293      	cmp	r3, r2
20006908:	d018      	beq.n	2000693c <HAL_DMA_IRQHandler+0x984>
2000690a:	687b      	ldr	r3, [r7, #4]
2000690c:	681b      	ldr	r3, [r3, #0]
2000690e:	4a3f      	ldr	r2, [pc, #252]	; (20006a0c <HAL_DMA_IRQHandler+0xa54>)
20006910:	4293      	cmp	r3, r2
20006912:	d013      	beq.n	2000693c <HAL_DMA_IRQHandler+0x984>
20006914:	687b      	ldr	r3, [r7, #4]
20006916:	681b      	ldr	r3, [r3, #0]
20006918:	4a3d      	ldr	r2, [pc, #244]	; (20006a10 <HAL_DMA_IRQHandler+0xa58>)
2000691a:	4293      	cmp	r3, r2
2000691c:	d00e      	beq.n	2000693c <HAL_DMA_IRQHandler+0x984>
2000691e:	687b      	ldr	r3, [r7, #4]
20006920:	681b      	ldr	r3, [r3, #0]
20006922:	4a3c      	ldr	r2, [pc, #240]	; (20006a14 <HAL_DMA_IRQHandler+0xa5c>)
20006924:	4293      	cmp	r3, r2
20006926:	d009      	beq.n	2000693c <HAL_DMA_IRQHandler+0x984>
20006928:	687b      	ldr	r3, [r7, #4]
2000692a:	681b      	ldr	r3, [r3, #0]
2000692c:	4a3a      	ldr	r2, [pc, #232]	; (20006a18 <HAL_DMA_IRQHandler+0xa60>)
2000692e:	4293      	cmp	r3, r2
20006930:	d004      	beq.n	2000693c <HAL_DMA_IRQHandler+0x984>
20006932:	687b      	ldr	r3, [r7, #4]
20006934:	681b      	ldr	r3, [r3, #0]
20006936:	4a39      	ldr	r2, [pc, #228]	; (20006a1c <HAL_DMA_IRQHandler+0xa64>)
20006938:	4293      	cmp	r3, r2
2000693a:	d101      	bne.n	20006940 <HAL_DMA_IRQHandler+0x988>
2000693c:	2301      	movs	r3, #1
2000693e:	e000      	b.n	20006942 <HAL_DMA_IRQHandler+0x98a>
20006940:	2300      	movs	r3, #0
20006942:	2b00      	cmp	r3, #0
20006944:	f000 823f 	beq.w	20006dc6 <HAL_DMA_IRQHandler+0xe0e>
  {
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
20006948:	687b      	ldr	r3, [r7, #4]
2000694a:	681b      	ldr	r3, [r3, #0]
2000694c:	681b      	ldr	r3, [r3, #0]
2000694e:	613b      	str	r3, [r7, #16]

    /* Half Transfer Complete Interrupt management ******************************/
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
20006950:	687b      	ldr	r3, [r7, #4]
20006952:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20006954:	f003 031f 	and.w	r3, r3, #31
20006958:	2204      	movs	r2, #4
2000695a:	409a      	lsls	r2, r3
2000695c:	697b      	ldr	r3, [r7, #20]
2000695e:	4013      	ands	r3, r2
20006960:	2b00      	cmp	r3, #0
20006962:	f000 80cd 	beq.w	20006b00 <HAL_DMA_IRQHandler+0xb48>
20006966:	693b      	ldr	r3, [r7, #16]
20006968:	f003 0304 	and.w	r3, r3, #4
2000696c:	2b00      	cmp	r3, #0
2000696e:	f000 80c7 	beq.w	20006b00 <HAL_DMA_IRQHandler+0xb48>
    {
      /* Clear the half transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
20006972:	687b      	ldr	r3, [r7, #4]
20006974:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20006976:	f003 031f 	and.w	r3, r3, #31
2000697a:	2204      	movs	r2, #4
2000697c:	409a      	lsls	r2, r3
2000697e:	69fb      	ldr	r3, [r7, #28]
20006980:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
20006982:	693b      	ldr	r3, [r7, #16]
20006984:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
20006988:	2b00      	cmp	r3, #0
2000698a:	d049      	beq.n	20006a20 <HAL_DMA_IRQHandler+0xa68>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
2000698c:	693b      	ldr	r3, [r7, #16]
2000698e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20006992:	2b00      	cmp	r3, #0
20006994:	d109      	bne.n	200069aa <HAL_DMA_IRQHandler+0x9f2>
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
20006996:	687b      	ldr	r3, [r7, #4]
20006998:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000699a:	2b00      	cmp	r3, #0
2000699c:	f000 8210 	beq.w	20006dc0 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 1 */
            hdma->XferM1HalfCpltCallback(hdma);
200069a0:	687b      	ldr	r3, [r7, #4]
200069a2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200069a4:	6878      	ldr	r0, [r7, #4]
200069a6:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
200069a8:	e20a      	b.n	20006dc0 <HAL_DMA_IRQHandler+0xe08>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferHalfCpltCallback != NULL)
200069aa:	687b      	ldr	r3, [r7, #4]
200069ac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200069ae:	2b00      	cmp	r3, #0
200069b0:	f000 8206 	beq.w	20006dc0 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 0 */
            hdma->XferHalfCpltCallback(hdma);
200069b4:	687b      	ldr	r3, [r7, #4]
200069b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200069b8:	6878      	ldr	r0, [r7, #4]
200069ba:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
200069bc:	e200      	b.n	20006dc0 <HAL_DMA_IRQHandler+0xe08>
200069be:	bf00      	nop
200069c0:	40020010 	.word	0x40020010
200069c4:	40020028 	.word	0x40020028
200069c8:	40020040 	.word	0x40020040
200069cc:	40020058 	.word	0x40020058
200069d0:	40020070 	.word	0x40020070
200069d4:	40020088 	.word	0x40020088
200069d8:	400200a0 	.word	0x400200a0
200069dc:	400200b8 	.word	0x400200b8
200069e0:	40020410 	.word	0x40020410
200069e4:	40020428 	.word	0x40020428
200069e8:	40020440 	.word	0x40020440
200069ec:	40020458 	.word	0x40020458
200069f0:	40020470 	.word	0x40020470
200069f4:	40020488 	.word	0x40020488
200069f8:	400204a0 	.word	0x400204a0
200069fc:	400204b8 	.word	0x400204b8
20006a00:	58025408 	.word	0x58025408
20006a04:	5802541c 	.word	0x5802541c
20006a08:	58025430 	.word	0x58025430
20006a0c:	58025444 	.word	0x58025444
20006a10:	58025458 	.word	0x58025458
20006a14:	5802546c 	.word	0x5802546c
20006a18:	58025480 	.word	0x58025480
20006a1c:	58025494 	.word	0x58025494
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
20006a20:	693b      	ldr	r3, [r7, #16]
20006a22:	f003 0320 	and.w	r3, r3, #32
20006a26:	2b00      	cmp	r3, #0
20006a28:	d160      	bne.n	20006aec <HAL_DMA_IRQHandler+0xb34>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
20006a2a:	687b      	ldr	r3, [r7, #4]
20006a2c:	681b      	ldr	r3, [r3, #0]
20006a2e:	4a8c      	ldr	r2, [pc, #560]	; (20006c60 <HAL_DMA_IRQHandler+0xca8>)
20006a30:	4293      	cmp	r3, r2
20006a32:	d04a      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a34:	687b      	ldr	r3, [r7, #4]
20006a36:	681b      	ldr	r3, [r3, #0]
20006a38:	4a8a      	ldr	r2, [pc, #552]	; (20006c64 <HAL_DMA_IRQHandler+0xcac>)
20006a3a:	4293      	cmp	r3, r2
20006a3c:	d045      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a3e:	687b      	ldr	r3, [r7, #4]
20006a40:	681b      	ldr	r3, [r3, #0]
20006a42:	4a89      	ldr	r2, [pc, #548]	; (20006c68 <HAL_DMA_IRQHandler+0xcb0>)
20006a44:	4293      	cmp	r3, r2
20006a46:	d040      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a48:	687b      	ldr	r3, [r7, #4]
20006a4a:	681b      	ldr	r3, [r3, #0]
20006a4c:	4a87      	ldr	r2, [pc, #540]	; (20006c6c <HAL_DMA_IRQHandler+0xcb4>)
20006a4e:	4293      	cmp	r3, r2
20006a50:	d03b      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a52:	687b      	ldr	r3, [r7, #4]
20006a54:	681b      	ldr	r3, [r3, #0]
20006a56:	4a86      	ldr	r2, [pc, #536]	; (20006c70 <HAL_DMA_IRQHandler+0xcb8>)
20006a58:	4293      	cmp	r3, r2
20006a5a:	d036      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a5c:	687b      	ldr	r3, [r7, #4]
20006a5e:	681b      	ldr	r3, [r3, #0]
20006a60:	4a84      	ldr	r2, [pc, #528]	; (20006c74 <HAL_DMA_IRQHandler+0xcbc>)
20006a62:	4293      	cmp	r3, r2
20006a64:	d031      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a66:	687b      	ldr	r3, [r7, #4]
20006a68:	681b      	ldr	r3, [r3, #0]
20006a6a:	4a83      	ldr	r2, [pc, #524]	; (20006c78 <HAL_DMA_IRQHandler+0xcc0>)
20006a6c:	4293      	cmp	r3, r2
20006a6e:	d02c      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a70:	687b      	ldr	r3, [r7, #4]
20006a72:	681b      	ldr	r3, [r3, #0]
20006a74:	4a81      	ldr	r2, [pc, #516]	; (20006c7c <HAL_DMA_IRQHandler+0xcc4>)
20006a76:	4293      	cmp	r3, r2
20006a78:	d027      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a7a:	687b      	ldr	r3, [r7, #4]
20006a7c:	681b      	ldr	r3, [r3, #0]
20006a7e:	4a80      	ldr	r2, [pc, #512]	; (20006c80 <HAL_DMA_IRQHandler+0xcc8>)
20006a80:	4293      	cmp	r3, r2
20006a82:	d022      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a84:	687b      	ldr	r3, [r7, #4]
20006a86:	681b      	ldr	r3, [r3, #0]
20006a88:	4a7e      	ldr	r2, [pc, #504]	; (20006c84 <HAL_DMA_IRQHandler+0xccc>)
20006a8a:	4293      	cmp	r3, r2
20006a8c:	d01d      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a8e:	687b      	ldr	r3, [r7, #4]
20006a90:	681b      	ldr	r3, [r3, #0]
20006a92:	4a7d      	ldr	r2, [pc, #500]	; (20006c88 <HAL_DMA_IRQHandler+0xcd0>)
20006a94:	4293      	cmp	r3, r2
20006a96:	d018      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006a98:	687b      	ldr	r3, [r7, #4]
20006a9a:	681b      	ldr	r3, [r3, #0]
20006a9c:	4a7b      	ldr	r2, [pc, #492]	; (20006c8c <HAL_DMA_IRQHandler+0xcd4>)
20006a9e:	4293      	cmp	r3, r2
20006aa0:	d013      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006aa2:	687b      	ldr	r3, [r7, #4]
20006aa4:	681b      	ldr	r3, [r3, #0]
20006aa6:	4a7a      	ldr	r2, [pc, #488]	; (20006c90 <HAL_DMA_IRQHandler+0xcd8>)
20006aa8:	4293      	cmp	r3, r2
20006aaa:	d00e      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006aac:	687b      	ldr	r3, [r7, #4]
20006aae:	681b      	ldr	r3, [r3, #0]
20006ab0:	4a78      	ldr	r2, [pc, #480]	; (20006c94 <HAL_DMA_IRQHandler+0xcdc>)
20006ab2:	4293      	cmp	r3, r2
20006ab4:	d009      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006ab6:	687b      	ldr	r3, [r7, #4]
20006ab8:	681b      	ldr	r3, [r3, #0]
20006aba:	4a77      	ldr	r2, [pc, #476]	; (20006c98 <HAL_DMA_IRQHandler+0xce0>)
20006abc:	4293      	cmp	r3, r2
20006abe:	d004      	beq.n	20006aca <HAL_DMA_IRQHandler+0xb12>
20006ac0:	687b      	ldr	r3, [r7, #4]
20006ac2:	681b      	ldr	r3, [r3, #0]
20006ac4:	4a75      	ldr	r2, [pc, #468]	; (20006c9c <HAL_DMA_IRQHandler+0xce4>)
20006ac6:	4293      	cmp	r3, r2
20006ac8:	d108      	bne.n	20006adc <HAL_DMA_IRQHandler+0xb24>
20006aca:	687b      	ldr	r3, [r7, #4]
20006acc:	681b      	ldr	r3, [r3, #0]
20006ace:	681a      	ldr	r2, [r3, #0]
20006ad0:	687b      	ldr	r3, [r7, #4]
20006ad2:	681b      	ldr	r3, [r3, #0]
20006ad4:	f022 0208 	bic.w	r2, r2, #8
20006ad8:	601a      	str	r2, [r3, #0]
20006ada:	e007      	b.n	20006aec <HAL_DMA_IRQHandler+0xb34>
20006adc:	687b      	ldr	r3, [r7, #4]
20006ade:	681b      	ldr	r3, [r3, #0]
20006ae0:	681a      	ldr	r2, [r3, #0]
20006ae2:	687b      	ldr	r3, [r7, #4]
20006ae4:	681b      	ldr	r3, [r3, #0]
20006ae6:	f022 0204 	bic.w	r2, r2, #4
20006aea:	601a      	str	r2, [r3, #0]
        }

        /* DMA peripheral state is not updated in Half Transfer */
        /* but in Transfer Complete case */

       if(hdma->XferHalfCpltCallback != NULL)
20006aec:	687b      	ldr	r3, [r7, #4]
20006aee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20006af0:	2b00      	cmp	r3, #0
20006af2:	f000 8165 	beq.w	20006dc0 <HAL_DMA_IRQHandler+0xe08>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
20006af6:	687b      	ldr	r3, [r7, #4]
20006af8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20006afa:	6878      	ldr	r0, [r7, #4]
20006afc:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
20006afe:	e15f      	b.n	20006dc0 <HAL_DMA_IRQHandler+0xe08>
        }
      }
    }

    /* Transfer Complete Interrupt management ***********************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
20006b00:	687b      	ldr	r3, [r7, #4]
20006b02:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20006b04:	f003 031f 	and.w	r3, r3, #31
20006b08:	2202      	movs	r2, #2
20006b0a:	409a      	lsls	r2, r3
20006b0c:	697b      	ldr	r3, [r7, #20]
20006b0e:	4013      	ands	r3, r2
20006b10:	2b00      	cmp	r3, #0
20006b12:	f000 80c5 	beq.w	20006ca0 <HAL_DMA_IRQHandler+0xce8>
20006b16:	693b      	ldr	r3, [r7, #16]
20006b18:	f003 0302 	and.w	r3, r3, #2
20006b1c:	2b00      	cmp	r3, #0
20006b1e:	f000 80bf 	beq.w	20006ca0 <HAL_DMA_IRQHandler+0xce8>
    {
      /* Clear the transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
20006b22:	687b      	ldr	r3, [r7, #4]
20006b24:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20006b26:	f003 031f 	and.w	r3, r3, #31
20006b2a:	2202      	movs	r2, #2
20006b2c:	409a      	lsls	r2, r3
20006b2e:	69fb      	ldr	r3, [r7, #28]
20006b30:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
20006b32:	693b      	ldr	r3, [r7, #16]
20006b34:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
20006b38:	2b00      	cmp	r3, #0
20006b3a:	d018      	beq.n	20006b6e <HAL_DMA_IRQHandler+0xbb6>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
20006b3c:	693b      	ldr	r3, [r7, #16]
20006b3e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20006b42:	2b00      	cmp	r3, #0
20006b44:	d109      	bne.n	20006b5a <HAL_DMA_IRQHandler+0xba2>
        {
          if(hdma->XferM1CpltCallback != NULL)
20006b46:	687b      	ldr	r3, [r7, #4]
20006b48:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006b4a:	2b00      	cmp	r3, #0
20006b4c:	f000 813a 	beq.w	20006dc4 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 1 */
            hdma->XferM1CpltCallback(hdma);
20006b50:	687b      	ldr	r3, [r7, #4]
20006b52:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006b54:	6878      	ldr	r0, [r7, #4]
20006b56:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
20006b58:	e134      	b.n	20006dc4 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
20006b5a:	687b      	ldr	r3, [r7, #4]
20006b5c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006b5e:	2b00      	cmp	r3, #0
20006b60:	f000 8130 	beq.w	20006dc4 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 0 */
            hdma->XferCpltCallback(hdma);
20006b64:	687b      	ldr	r3, [r7, #4]
20006b66:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006b68:	6878      	ldr	r0, [r7, #4]
20006b6a:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
20006b6c:	e12a      	b.n	20006dc4 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
20006b6e:	693b      	ldr	r3, [r7, #16]
20006b70:	f003 0320 	and.w	r3, r3, #32
20006b74:	2b00      	cmp	r3, #0
20006b76:	d168      	bne.n	20006c4a <HAL_DMA_IRQHandler+0xc92>
        {
          /* Disable the transfer complete and error interrupt, if the DMA mode is not CIRCULAR */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
20006b78:	687b      	ldr	r3, [r7, #4]
20006b7a:	681b      	ldr	r3, [r3, #0]
20006b7c:	4a38      	ldr	r2, [pc, #224]	; (20006c60 <HAL_DMA_IRQHandler+0xca8>)
20006b7e:	4293      	cmp	r3, r2
20006b80:	d04a      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006b82:	687b      	ldr	r3, [r7, #4]
20006b84:	681b      	ldr	r3, [r3, #0]
20006b86:	4a37      	ldr	r2, [pc, #220]	; (20006c64 <HAL_DMA_IRQHandler+0xcac>)
20006b88:	4293      	cmp	r3, r2
20006b8a:	d045      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006b8c:	687b      	ldr	r3, [r7, #4]
20006b8e:	681b      	ldr	r3, [r3, #0]
20006b90:	4a35      	ldr	r2, [pc, #212]	; (20006c68 <HAL_DMA_IRQHandler+0xcb0>)
20006b92:	4293      	cmp	r3, r2
20006b94:	d040      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006b96:	687b      	ldr	r3, [r7, #4]
20006b98:	681b      	ldr	r3, [r3, #0]
20006b9a:	4a34      	ldr	r2, [pc, #208]	; (20006c6c <HAL_DMA_IRQHandler+0xcb4>)
20006b9c:	4293      	cmp	r3, r2
20006b9e:	d03b      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006ba0:	687b      	ldr	r3, [r7, #4]
20006ba2:	681b      	ldr	r3, [r3, #0]
20006ba4:	4a32      	ldr	r2, [pc, #200]	; (20006c70 <HAL_DMA_IRQHandler+0xcb8>)
20006ba6:	4293      	cmp	r3, r2
20006ba8:	d036      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006baa:	687b      	ldr	r3, [r7, #4]
20006bac:	681b      	ldr	r3, [r3, #0]
20006bae:	4a31      	ldr	r2, [pc, #196]	; (20006c74 <HAL_DMA_IRQHandler+0xcbc>)
20006bb0:	4293      	cmp	r3, r2
20006bb2:	d031      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006bb4:	687b      	ldr	r3, [r7, #4]
20006bb6:	681b      	ldr	r3, [r3, #0]
20006bb8:	4a2f      	ldr	r2, [pc, #188]	; (20006c78 <HAL_DMA_IRQHandler+0xcc0>)
20006bba:	4293      	cmp	r3, r2
20006bbc:	d02c      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006bbe:	687b      	ldr	r3, [r7, #4]
20006bc0:	681b      	ldr	r3, [r3, #0]
20006bc2:	4a2e      	ldr	r2, [pc, #184]	; (20006c7c <HAL_DMA_IRQHandler+0xcc4>)
20006bc4:	4293      	cmp	r3, r2
20006bc6:	d027      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006bc8:	687b      	ldr	r3, [r7, #4]
20006bca:	681b      	ldr	r3, [r3, #0]
20006bcc:	4a2c      	ldr	r2, [pc, #176]	; (20006c80 <HAL_DMA_IRQHandler+0xcc8>)
20006bce:	4293      	cmp	r3, r2
20006bd0:	d022      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006bd2:	687b      	ldr	r3, [r7, #4]
20006bd4:	681b      	ldr	r3, [r3, #0]
20006bd6:	4a2b      	ldr	r2, [pc, #172]	; (20006c84 <HAL_DMA_IRQHandler+0xccc>)
20006bd8:	4293      	cmp	r3, r2
20006bda:	d01d      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006bdc:	687b      	ldr	r3, [r7, #4]
20006bde:	681b      	ldr	r3, [r3, #0]
20006be0:	4a29      	ldr	r2, [pc, #164]	; (20006c88 <HAL_DMA_IRQHandler+0xcd0>)
20006be2:	4293      	cmp	r3, r2
20006be4:	d018      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006be6:	687b      	ldr	r3, [r7, #4]
20006be8:	681b      	ldr	r3, [r3, #0]
20006bea:	4a28      	ldr	r2, [pc, #160]	; (20006c8c <HAL_DMA_IRQHandler+0xcd4>)
20006bec:	4293      	cmp	r3, r2
20006bee:	d013      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006bf0:	687b      	ldr	r3, [r7, #4]
20006bf2:	681b      	ldr	r3, [r3, #0]
20006bf4:	4a26      	ldr	r2, [pc, #152]	; (20006c90 <HAL_DMA_IRQHandler+0xcd8>)
20006bf6:	4293      	cmp	r3, r2
20006bf8:	d00e      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006bfa:	687b      	ldr	r3, [r7, #4]
20006bfc:	681b      	ldr	r3, [r3, #0]
20006bfe:	4a25      	ldr	r2, [pc, #148]	; (20006c94 <HAL_DMA_IRQHandler+0xcdc>)
20006c00:	4293      	cmp	r3, r2
20006c02:	d009      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006c04:	687b      	ldr	r3, [r7, #4]
20006c06:	681b      	ldr	r3, [r3, #0]
20006c08:	4a23      	ldr	r2, [pc, #140]	; (20006c98 <HAL_DMA_IRQHandler+0xce0>)
20006c0a:	4293      	cmp	r3, r2
20006c0c:	d004      	beq.n	20006c18 <HAL_DMA_IRQHandler+0xc60>
20006c0e:	687b      	ldr	r3, [r7, #4]
20006c10:	681b      	ldr	r3, [r3, #0]
20006c12:	4a22      	ldr	r2, [pc, #136]	; (20006c9c <HAL_DMA_IRQHandler+0xce4>)
20006c14:	4293      	cmp	r3, r2
20006c16:	d108      	bne.n	20006c2a <HAL_DMA_IRQHandler+0xc72>
20006c18:	687b      	ldr	r3, [r7, #4]
20006c1a:	681b      	ldr	r3, [r3, #0]
20006c1c:	681a      	ldr	r2, [r3, #0]
20006c1e:	687b      	ldr	r3, [r7, #4]
20006c20:	681b      	ldr	r3, [r3, #0]
20006c22:	f022 0214 	bic.w	r2, r2, #20
20006c26:	601a      	str	r2, [r3, #0]
20006c28:	e007      	b.n	20006c3a <HAL_DMA_IRQHandler+0xc82>
20006c2a:	687b      	ldr	r3, [r7, #4]
20006c2c:	681b      	ldr	r3, [r3, #0]
20006c2e:	681a      	ldr	r2, [r3, #0]
20006c30:	687b      	ldr	r3, [r7, #4]
20006c32:	681b      	ldr	r3, [r3, #0]
20006c34:	f022 020a 	bic.w	r2, r2, #10
20006c38:	601a      	str	r2, [r3, #0]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
20006c3a:	687b      	ldr	r3, [r7, #4]
20006c3c:	2200      	movs	r2, #0
20006c3e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
20006c42:	687b      	ldr	r3, [r7, #4]
20006c44:	2201      	movs	r2, #1
20006c46:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        if(hdma->XferCpltCallback != NULL)
20006c4a:	687b      	ldr	r3, [r7, #4]
20006c4c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006c4e:	2b00      	cmp	r3, #0
20006c50:	f000 80b8 	beq.w	20006dc4 <HAL_DMA_IRQHandler+0xe0c>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
20006c54:	687b      	ldr	r3, [r7, #4]
20006c56:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006c58:	6878      	ldr	r0, [r7, #4]
20006c5a:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
20006c5c:	e0b2      	b.n	20006dc4 <HAL_DMA_IRQHandler+0xe0c>
20006c5e:	bf00      	nop
20006c60:	40020010 	.word	0x40020010
20006c64:	40020028 	.word	0x40020028
20006c68:	40020040 	.word	0x40020040
20006c6c:	40020058 	.word	0x40020058
20006c70:	40020070 	.word	0x40020070
20006c74:	40020088 	.word	0x40020088
20006c78:	400200a0 	.word	0x400200a0
20006c7c:	400200b8 	.word	0x400200b8
20006c80:	40020410 	.word	0x40020410
20006c84:	40020428 	.word	0x40020428
20006c88:	40020440 	.word	0x40020440
20006c8c:	40020458 	.word	0x40020458
20006c90:	40020470 	.word	0x40020470
20006c94:	40020488 	.word	0x40020488
20006c98:	400204a0 	.word	0x400204a0
20006c9c:	400204b8 	.word	0x400204b8
        }
      }
    }
    /* Transfer Error Interrupt management **************************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
20006ca0:	687b      	ldr	r3, [r7, #4]
20006ca2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20006ca4:	f003 031f 	and.w	r3, r3, #31
20006ca8:	2208      	movs	r2, #8
20006caa:	409a      	lsls	r2, r3
20006cac:	697b      	ldr	r3, [r7, #20]
20006cae:	4013      	ands	r3, r2
20006cb0:	2b00      	cmp	r3, #0
20006cb2:	f000 8088 	beq.w	20006dc6 <HAL_DMA_IRQHandler+0xe0e>
20006cb6:	693b      	ldr	r3, [r7, #16]
20006cb8:	f003 0308 	and.w	r3, r3, #8
20006cbc:	2b00      	cmp	r3, #0
20006cbe:	f000 8082 	beq.w	20006dc6 <HAL_DMA_IRQHandler+0xe0e>
    {
      /* When a DMA transfer error occurs */
      /* A hardware clear of its EN bits is performed */
      /* Disable ALL DMA IT */
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
20006cc2:	687b      	ldr	r3, [r7, #4]
20006cc4:	681b      	ldr	r3, [r3, #0]
20006cc6:	4a41      	ldr	r2, [pc, #260]	; (20006dcc <HAL_DMA_IRQHandler+0xe14>)
20006cc8:	4293      	cmp	r3, r2
20006cca:	d04a      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006ccc:	687b      	ldr	r3, [r7, #4]
20006cce:	681b      	ldr	r3, [r3, #0]
20006cd0:	4a3f      	ldr	r2, [pc, #252]	; (20006dd0 <HAL_DMA_IRQHandler+0xe18>)
20006cd2:	4293      	cmp	r3, r2
20006cd4:	d045      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006cd6:	687b      	ldr	r3, [r7, #4]
20006cd8:	681b      	ldr	r3, [r3, #0]
20006cda:	4a3e      	ldr	r2, [pc, #248]	; (20006dd4 <HAL_DMA_IRQHandler+0xe1c>)
20006cdc:	4293      	cmp	r3, r2
20006cde:	d040      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006ce0:	687b      	ldr	r3, [r7, #4]
20006ce2:	681b      	ldr	r3, [r3, #0]
20006ce4:	4a3c      	ldr	r2, [pc, #240]	; (20006dd8 <HAL_DMA_IRQHandler+0xe20>)
20006ce6:	4293      	cmp	r3, r2
20006ce8:	d03b      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006cea:	687b      	ldr	r3, [r7, #4]
20006cec:	681b      	ldr	r3, [r3, #0]
20006cee:	4a3b      	ldr	r2, [pc, #236]	; (20006ddc <HAL_DMA_IRQHandler+0xe24>)
20006cf0:	4293      	cmp	r3, r2
20006cf2:	d036      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006cf4:	687b      	ldr	r3, [r7, #4]
20006cf6:	681b      	ldr	r3, [r3, #0]
20006cf8:	4a39      	ldr	r2, [pc, #228]	; (20006de0 <HAL_DMA_IRQHandler+0xe28>)
20006cfa:	4293      	cmp	r3, r2
20006cfc:	d031      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006cfe:	687b      	ldr	r3, [r7, #4]
20006d00:	681b      	ldr	r3, [r3, #0]
20006d02:	4a38      	ldr	r2, [pc, #224]	; (20006de4 <HAL_DMA_IRQHandler+0xe2c>)
20006d04:	4293      	cmp	r3, r2
20006d06:	d02c      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006d08:	687b      	ldr	r3, [r7, #4]
20006d0a:	681b      	ldr	r3, [r3, #0]
20006d0c:	4a36      	ldr	r2, [pc, #216]	; (20006de8 <HAL_DMA_IRQHandler+0xe30>)
20006d0e:	4293      	cmp	r3, r2
20006d10:	d027      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006d12:	687b      	ldr	r3, [r7, #4]
20006d14:	681b      	ldr	r3, [r3, #0]
20006d16:	4a35      	ldr	r2, [pc, #212]	; (20006dec <HAL_DMA_IRQHandler+0xe34>)
20006d18:	4293      	cmp	r3, r2
20006d1a:	d022      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006d1c:	687b      	ldr	r3, [r7, #4]
20006d1e:	681b      	ldr	r3, [r3, #0]
20006d20:	4a33      	ldr	r2, [pc, #204]	; (20006df0 <HAL_DMA_IRQHandler+0xe38>)
20006d22:	4293      	cmp	r3, r2
20006d24:	d01d      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006d26:	687b      	ldr	r3, [r7, #4]
20006d28:	681b      	ldr	r3, [r3, #0]
20006d2a:	4a32      	ldr	r2, [pc, #200]	; (20006df4 <HAL_DMA_IRQHandler+0xe3c>)
20006d2c:	4293      	cmp	r3, r2
20006d2e:	d018      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006d30:	687b      	ldr	r3, [r7, #4]
20006d32:	681b      	ldr	r3, [r3, #0]
20006d34:	4a30      	ldr	r2, [pc, #192]	; (20006df8 <HAL_DMA_IRQHandler+0xe40>)
20006d36:	4293      	cmp	r3, r2
20006d38:	d013      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006d3a:	687b      	ldr	r3, [r7, #4]
20006d3c:	681b      	ldr	r3, [r3, #0]
20006d3e:	4a2f      	ldr	r2, [pc, #188]	; (20006dfc <HAL_DMA_IRQHandler+0xe44>)
20006d40:	4293      	cmp	r3, r2
20006d42:	d00e      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006d44:	687b      	ldr	r3, [r7, #4]
20006d46:	681b      	ldr	r3, [r3, #0]
20006d48:	4a2d      	ldr	r2, [pc, #180]	; (20006e00 <HAL_DMA_IRQHandler+0xe48>)
20006d4a:	4293      	cmp	r3, r2
20006d4c:	d009      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006d4e:	687b      	ldr	r3, [r7, #4]
20006d50:	681b      	ldr	r3, [r3, #0]
20006d52:	4a2c      	ldr	r2, [pc, #176]	; (20006e04 <HAL_DMA_IRQHandler+0xe4c>)
20006d54:	4293      	cmp	r3, r2
20006d56:	d004      	beq.n	20006d62 <HAL_DMA_IRQHandler+0xdaa>
20006d58:	687b      	ldr	r3, [r7, #4]
20006d5a:	681b      	ldr	r3, [r3, #0]
20006d5c:	4a2a      	ldr	r2, [pc, #168]	; (20006e08 <HAL_DMA_IRQHandler+0xe50>)
20006d5e:	4293      	cmp	r3, r2
20006d60:	d108      	bne.n	20006d74 <HAL_DMA_IRQHandler+0xdbc>
20006d62:	687b      	ldr	r3, [r7, #4]
20006d64:	681b      	ldr	r3, [r3, #0]
20006d66:	681a      	ldr	r2, [r3, #0]
20006d68:	687b      	ldr	r3, [r7, #4]
20006d6a:	681b      	ldr	r3, [r3, #0]
20006d6c:	f022 021c 	bic.w	r2, r2, #28
20006d70:	601a      	str	r2, [r3, #0]
20006d72:	e007      	b.n	20006d84 <HAL_DMA_IRQHandler+0xdcc>
20006d74:	687b      	ldr	r3, [r7, #4]
20006d76:	681b      	ldr	r3, [r3, #0]
20006d78:	681a      	ldr	r2, [r3, #0]
20006d7a:	687b      	ldr	r3, [r7, #4]
20006d7c:	681b      	ldr	r3, [r3, #0]
20006d7e:	f022 020e 	bic.w	r2, r2, #14
20006d82:	601a      	str	r2, [r3, #0]

      /* Clear all flags */
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
20006d84:	687b      	ldr	r3, [r7, #4]
20006d86:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20006d88:	f003 031f 	and.w	r3, r3, #31
20006d8c:	2201      	movs	r2, #1
20006d8e:	409a      	lsls	r2, r3
20006d90:	69fb      	ldr	r3, [r7, #28]
20006d92:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
20006d94:	687b      	ldr	r3, [r7, #4]
20006d96:	2201      	movs	r2, #1
20006d98:	655a      	str	r2, [r3, #84]	; 0x54

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
20006d9a:	687b      	ldr	r3, [r7, #4]
20006d9c:	2200      	movs	r2, #0
20006d9e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
20006da2:	687b      	ldr	r3, [r7, #4]
20006da4:	2201      	movs	r2, #1
20006da6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      if (hdma->XferErrorCallback != NULL)
20006daa:	687b      	ldr	r3, [r7, #4]
20006dac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20006dae:	2b00      	cmp	r3, #0
20006db0:	d009      	beq.n	20006dc6 <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
20006db2:	687b      	ldr	r3, [r7, #4]
20006db4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20006db6:	6878      	ldr	r0, [r7, #4]
20006db8:	4798      	blx	r3
20006dba:	e004      	b.n	20006dc6 <HAL_DMA_IRQHandler+0xe0e>
          return;
20006dbc:	bf00      	nop
20006dbe:	e002      	b.n	20006dc6 <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
20006dc0:	bf00      	nop
20006dc2:	e000      	b.n	20006dc6 <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
20006dc4:	bf00      	nop
  }
  else
  {
    /* Nothing To Do */
  }
}
20006dc6:	3728      	adds	r7, #40	; 0x28
20006dc8:	46bd      	mov	sp, r7
20006dca:	bd80      	pop	{r7, pc}
20006dcc:	40020010 	.word	0x40020010
20006dd0:	40020028 	.word	0x40020028
20006dd4:	40020040 	.word	0x40020040
20006dd8:	40020058 	.word	0x40020058
20006ddc:	40020070 	.word	0x40020070
20006de0:	40020088 	.word	0x40020088
20006de4:	400200a0 	.word	0x400200a0
20006de8:	400200b8 	.word	0x400200b8
20006dec:	40020410 	.word	0x40020410
20006df0:	40020428 	.word	0x40020428
20006df4:	40020440 	.word	0x40020440
20006df8:	40020458 	.word	0x40020458
20006dfc:	40020470 	.word	0x40020470
20006e00:	40020488 	.word	0x40020488
20006e04:	400204a0 	.word	0x400204a0
20006e08:	400204b8 	.word	0x400204b8

20006e0c <HAL_DMA_RegisterCallback>:
  * @param  pCallback:            pointer to private callback function which has pointer to
  *                               a DMA_HandleTypeDef structure as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
{
20006e0c:	b480      	push	{r7}
20006e0e:	b087      	sub	sp, #28
20006e10:	af00      	add	r7, sp, #0
20006e12:	60f8      	str	r0, [r7, #12]
20006e14:	460b      	mov	r3, r1
20006e16:	607a      	str	r2, [r7, #4]
20006e18:	72fb      	strb	r3, [r7, #11]

  HAL_StatusTypeDef status = HAL_OK;
20006e1a:	2300      	movs	r3, #0
20006e1c:	75fb      	strb	r3, [r7, #23]

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
20006e1e:	68fb      	ldr	r3, [r7, #12]
20006e20:	2b00      	cmp	r3, #0
20006e22:	d101      	bne.n	20006e28 <HAL_DMA_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
20006e24:	2301      	movs	r3, #1
20006e26:	e044      	b.n	20006eb2 <HAL_DMA_RegisterCallback+0xa6>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
20006e28:	68fb      	ldr	r3, [r7, #12]
20006e2a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
20006e2e:	2b01      	cmp	r3, #1
20006e30:	d101      	bne.n	20006e36 <HAL_DMA_RegisterCallback+0x2a>
20006e32:	2302      	movs	r3, #2
20006e34:	e03d      	b.n	20006eb2 <HAL_DMA_RegisterCallback+0xa6>
20006e36:	68fb      	ldr	r3, [r7, #12]
20006e38:	2201      	movs	r2, #1
20006e3a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
20006e3e:	68fb      	ldr	r3, [r7, #12]
20006e40:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20006e44:	b2db      	uxtb	r3, r3
20006e46:	2b01      	cmp	r3, #1
20006e48:	d12a      	bne.n	20006ea0 <HAL_DMA_RegisterCallback+0x94>
  {
    switch (CallbackID)
20006e4a:	7afb      	ldrb	r3, [r7, #11]
20006e4c:	2b05      	cmp	r3, #5
20006e4e:	d82a      	bhi.n	20006ea6 <HAL_DMA_RegisterCallback+0x9a>
20006e50:	a201      	add	r2, pc, #4	; (adr r2, 20006e58 <HAL_DMA_RegisterCallback+0x4c>)
20006e52:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20006e56:	bf00      	nop
20006e58:	20006e71 	.word	0x20006e71
20006e5c:	20006e79 	.word	0x20006e79
20006e60:	20006e81 	.word	0x20006e81
20006e64:	20006e89 	.word	0x20006e89
20006e68:	20006e91 	.word	0x20006e91
20006e6c:	20006e99 	.word	0x20006e99
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = pCallback;
20006e70:	68fb      	ldr	r3, [r7, #12]
20006e72:	687a      	ldr	r2, [r7, #4]
20006e74:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
20006e76:	e017      	b.n	20006ea8 <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = pCallback;
20006e78:	68fb      	ldr	r3, [r7, #12]
20006e7a:	687a      	ldr	r2, [r7, #4]
20006e7c:	641a      	str	r2, [r3, #64]	; 0x40
      break;
20006e7e:	e013      	b.n	20006ea8 <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = pCallback;
20006e80:	68fb      	ldr	r3, [r7, #12]
20006e82:	687a      	ldr	r2, [r7, #4]
20006e84:	645a      	str	r2, [r3, #68]	; 0x44
      break;
20006e86:	e00f      	b.n	20006ea8 <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = pCallback;
20006e88:	68fb      	ldr	r3, [r7, #12]
20006e8a:	687a      	ldr	r2, [r7, #4]
20006e8c:	649a      	str	r2, [r3, #72]	; 0x48
      break;
20006e8e:	e00b      	b.n	20006ea8 <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = pCallback;
20006e90:	68fb      	ldr	r3, [r7, #12]
20006e92:	687a      	ldr	r2, [r7, #4]
20006e94:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
20006e96:	e007      	b.n	20006ea8 <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = pCallback;
20006e98:	68fb      	ldr	r3, [r7, #12]
20006e9a:	687a      	ldr	r2, [r7, #4]
20006e9c:	651a      	str	r2, [r3, #80]	; 0x50
      break;
20006e9e:	e003      	b.n	20006ea8 <HAL_DMA_RegisterCallback+0x9c>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
20006ea0:	2301      	movs	r3, #1
20006ea2:	75fb      	strb	r3, [r7, #23]
20006ea4:	e000      	b.n	20006ea8 <HAL_DMA_RegisterCallback+0x9c>
      break;
20006ea6:	bf00      	nop
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
20006ea8:	68fb      	ldr	r3, [r7, #12]
20006eaa:	2200      	movs	r2, #0
20006eac:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
20006eb0:	7dfb      	ldrb	r3, [r7, #23]
}
20006eb2:	4618      	mov	r0, r3
20006eb4:	371c      	adds	r7, #28
20006eb6:	46bd      	mov	sp, r7
20006eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
20006ebc:	4770      	bx	lr
20006ebe:	bf00      	nop

20006ec0 <HAL_DMA_UnRegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
{
20006ec0:	b480      	push	{r7}
20006ec2:	b085      	sub	sp, #20
20006ec4:	af00      	add	r7, sp, #0
20006ec6:	6078      	str	r0, [r7, #4]
20006ec8:	460b      	mov	r3, r1
20006eca:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
20006ecc:	2300      	movs	r3, #0
20006ece:	73fb      	strb	r3, [r7, #15]

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
20006ed0:	687b      	ldr	r3, [r7, #4]
20006ed2:	2b00      	cmp	r3, #0
20006ed4:	d101      	bne.n	20006eda <HAL_DMA_UnRegisterCallback+0x1a>
  {
    return HAL_ERROR;
20006ed6:	2301      	movs	r3, #1
20006ed8:	e05a      	b.n	20006f90 <HAL_DMA_UnRegisterCallback+0xd0>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
20006eda:	687b      	ldr	r3, [r7, #4]
20006edc:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
20006ee0:	2b01      	cmp	r3, #1
20006ee2:	d101      	bne.n	20006ee8 <HAL_DMA_UnRegisterCallback+0x28>
20006ee4:	2302      	movs	r3, #2
20006ee6:	e053      	b.n	20006f90 <HAL_DMA_UnRegisterCallback+0xd0>
20006ee8:	687b      	ldr	r3, [r7, #4]
20006eea:	2201      	movs	r2, #1
20006eec:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
20006ef0:	687b      	ldr	r3, [r7, #4]
20006ef2:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20006ef6:	b2db      	uxtb	r3, r3
20006ef8:	2b01      	cmp	r3, #1
20006efa:	d142      	bne.n	20006f82 <HAL_DMA_UnRegisterCallback+0xc2>
  {
    switch (CallbackID)
20006efc:	78fb      	ldrb	r3, [r7, #3]
20006efe:	2b06      	cmp	r3, #6
20006f00:	d83b      	bhi.n	20006f7a <HAL_DMA_UnRegisterCallback+0xba>
20006f02:	a201      	add	r2, pc, #4	; (adr r2, 20006f08 <HAL_DMA_UnRegisterCallback+0x48>)
20006f04:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20006f08:	20006f25 	.word	0x20006f25
20006f0c:	20006f2d 	.word	0x20006f2d
20006f10:	20006f35 	.word	0x20006f35
20006f14:	20006f3d 	.word	0x20006f3d
20006f18:	20006f45 	.word	0x20006f45
20006f1c:	20006f4d 	.word	0x20006f4d
20006f20:	20006f55 	.word	0x20006f55
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = NULL;
20006f24:	687b      	ldr	r3, [r7, #4]
20006f26:	2200      	movs	r2, #0
20006f28:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
20006f2a:	e02c      	b.n	20006f86 <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = NULL;
20006f2c:	687b      	ldr	r3, [r7, #4]
20006f2e:	2200      	movs	r2, #0
20006f30:	641a      	str	r2, [r3, #64]	; 0x40
      break;
20006f32:	e028      	b.n	20006f86 <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = NULL;
20006f34:	687b      	ldr	r3, [r7, #4]
20006f36:	2200      	movs	r2, #0
20006f38:	645a      	str	r2, [r3, #68]	; 0x44
      break;
20006f3a:	e024      	b.n	20006f86 <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = NULL;
20006f3c:	687b      	ldr	r3, [r7, #4]
20006f3e:	2200      	movs	r2, #0
20006f40:	649a      	str	r2, [r3, #72]	; 0x48
      break;
20006f42:	e020      	b.n	20006f86 <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = NULL;
20006f44:	687b      	ldr	r3, [r7, #4]
20006f46:	2200      	movs	r2, #0
20006f48:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
20006f4a:	e01c      	b.n	20006f86 <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = NULL;
20006f4c:	687b      	ldr	r3, [r7, #4]
20006f4e:	2200      	movs	r2, #0
20006f50:	651a      	str	r2, [r3, #80]	; 0x50
      break;
20006f52:	e018      	b.n	20006f86 <HAL_DMA_UnRegisterCallback+0xc6>

    case   HAL_DMA_XFER_ALL_CB_ID:
      hdma->XferCpltCallback = NULL;
20006f54:	687b      	ldr	r3, [r7, #4]
20006f56:	2200      	movs	r2, #0
20006f58:	63da      	str	r2, [r3, #60]	; 0x3c
      hdma->XferHalfCpltCallback = NULL;
20006f5a:	687b      	ldr	r3, [r7, #4]
20006f5c:	2200      	movs	r2, #0
20006f5e:	641a      	str	r2, [r3, #64]	; 0x40
      hdma->XferM1CpltCallback = NULL;
20006f60:	687b      	ldr	r3, [r7, #4]
20006f62:	2200      	movs	r2, #0
20006f64:	645a      	str	r2, [r3, #68]	; 0x44
      hdma->XferM1HalfCpltCallback = NULL;
20006f66:	687b      	ldr	r3, [r7, #4]
20006f68:	2200      	movs	r2, #0
20006f6a:	649a      	str	r2, [r3, #72]	; 0x48
      hdma->XferErrorCallback = NULL;
20006f6c:	687b      	ldr	r3, [r7, #4]
20006f6e:	2200      	movs	r2, #0
20006f70:	64da      	str	r2, [r3, #76]	; 0x4c
      hdma->XferAbortCallback = NULL;
20006f72:	687b      	ldr	r3, [r7, #4]
20006f74:	2200      	movs	r2, #0
20006f76:	651a      	str	r2, [r3, #80]	; 0x50
      break;
20006f78:	e005      	b.n	20006f86 <HAL_DMA_UnRegisterCallback+0xc6>

    default:
      status = HAL_ERROR;
20006f7a:	2301      	movs	r3, #1
20006f7c:	73fb      	strb	r3, [r7, #15]
      break;
20006f7e:	bf00      	nop
20006f80:	e001      	b.n	20006f86 <HAL_DMA_UnRegisterCallback+0xc6>
    }
  }
  else
  {
    status = HAL_ERROR;
20006f82:	2301      	movs	r3, #1
20006f84:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
20006f86:	687b      	ldr	r3, [r7, #4]
20006f88:	2200      	movs	r2, #0
20006f8a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
20006f8e:	7bfb      	ldrb	r3, [r7, #15]
}
20006f90:	4618      	mov	r0, r3
20006f92:	3714      	adds	r7, #20
20006f94:	46bd      	mov	sp, r7
20006f96:	f85d 7b04 	ldr.w	r7, [sp], #4
20006f9a:	4770      	bx	lr

20006f9c <HAL_DMA_GetState>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
20006f9c:	b480      	push	{r7}
20006f9e:	b083      	sub	sp, #12
20006fa0:	af00      	add	r7, sp, #0
20006fa2:	6078      	str	r0, [r7, #4]
  return hdma->State;
20006fa4:	687b      	ldr	r3, [r7, #4]
20006fa6:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20006faa:	b2db      	uxtb	r3, r3
}
20006fac:	4618      	mov	r0, r3
20006fae:	370c      	adds	r7, #12
20006fb0:	46bd      	mov	sp, r7
20006fb2:	f85d 7b04 	ldr.w	r7, [sp], #4
20006fb6:	4770      	bx	lr

20006fb8 <HAL_DMA_GetError>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
20006fb8:	b480      	push	{r7}
20006fba:	b083      	sub	sp, #12
20006fbc:	af00      	add	r7, sp, #0
20006fbe:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
20006fc0:	687b      	ldr	r3, [r7, #4]
20006fc2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
}
20006fc4:	4618      	mov	r0, r3
20006fc6:	370c      	adds	r7, #12
20006fc8:	46bd      	mov	sp, r7
20006fca:	f85d 7b04 	ldr.w	r7, [sp], #4
20006fce:	4770      	bx	lr

20006fd0 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval None
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
20006fd0:	b480      	push	{r7}
20006fd2:	b087      	sub	sp, #28
20006fd4:	af00      	add	r7, sp, #0
20006fd6:	60f8      	str	r0, [r7, #12]
20006fd8:	60b9      	str	r1, [r7, #8]
20006fda:	607a      	str	r2, [r7, #4]
20006fdc:	603b      	str	r3, [r7, #0]
  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
20006fde:	68fb      	ldr	r3, [r7, #12]
20006fe0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20006fe2:	617b      	str	r3, [r7, #20]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
20006fe4:	68fb      	ldr	r3, [r7, #12]
20006fe6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20006fe8:	613b      	str	r3, [r7, #16]

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
20006fea:	68fb      	ldr	r3, [r7, #12]
20006fec:	681b      	ldr	r3, [r3, #0]
20006fee:	4a84      	ldr	r2, [pc, #528]	; (20007200 <DMA_SetConfig+0x230>)
20006ff0:	4293      	cmp	r3, r2
20006ff2:	d072      	beq.n	200070da <DMA_SetConfig+0x10a>
20006ff4:	68fb      	ldr	r3, [r7, #12]
20006ff6:	681b      	ldr	r3, [r3, #0]
20006ff8:	4a82      	ldr	r2, [pc, #520]	; (20007204 <DMA_SetConfig+0x234>)
20006ffa:	4293      	cmp	r3, r2
20006ffc:	d06d      	beq.n	200070da <DMA_SetConfig+0x10a>
20006ffe:	68fb      	ldr	r3, [r7, #12]
20007000:	681b      	ldr	r3, [r3, #0]
20007002:	4a81      	ldr	r2, [pc, #516]	; (20007208 <DMA_SetConfig+0x238>)
20007004:	4293      	cmp	r3, r2
20007006:	d068      	beq.n	200070da <DMA_SetConfig+0x10a>
20007008:	68fb      	ldr	r3, [r7, #12]
2000700a:	681b      	ldr	r3, [r3, #0]
2000700c:	4a7f      	ldr	r2, [pc, #508]	; (2000720c <DMA_SetConfig+0x23c>)
2000700e:	4293      	cmp	r3, r2
20007010:	d063      	beq.n	200070da <DMA_SetConfig+0x10a>
20007012:	68fb      	ldr	r3, [r7, #12]
20007014:	681b      	ldr	r3, [r3, #0]
20007016:	4a7e      	ldr	r2, [pc, #504]	; (20007210 <DMA_SetConfig+0x240>)
20007018:	4293      	cmp	r3, r2
2000701a:	d05e      	beq.n	200070da <DMA_SetConfig+0x10a>
2000701c:	68fb      	ldr	r3, [r7, #12]
2000701e:	681b      	ldr	r3, [r3, #0]
20007020:	4a7c      	ldr	r2, [pc, #496]	; (20007214 <DMA_SetConfig+0x244>)
20007022:	4293      	cmp	r3, r2
20007024:	d059      	beq.n	200070da <DMA_SetConfig+0x10a>
20007026:	68fb      	ldr	r3, [r7, #12]
20007028:	681b      	ldr	r3, [r3, #0]
2000702a:	4a7b      	ldr	r2, [pc, #492]	; (20007218 <DMA_SetConfig+0x248>)
2000702c:	4293      	cmp	r3, r2
2000702e:	d054      	beq.n	200070da <DMA_SetConfig+0x10a>
20007030:	68fb      	ldr	r3, [r7, #12]
20007032:	681b      	ldr	r3, [r3, #0]
20007034:	4a79      	ldr	r2, [pc, #484]	; (2000721c <DMA_SetConfig+0x24c>)
20007036:	4293      	cmp	r3, r2
20007038:	d04f      	beq.n	200070da <DMA_SetConfig+0x10a>
2000703a:	68fb      	ldr	r3, [r7, #12]
2000703c:	681b      	ldr	r3, [r3, #0]
2000703e:	4a78      	ldr	r2, [pc, #480]	; (20007220 <DMA_SetConfig+0x250>)
20007040:	4293      	cmp	r3, r2
20007042:	d04a      	beq.n	200070da <DMA_SetConfig+0x10a>
20007044:	68fb      	ldr	r3, [r7, #12]
20007046:	681b      	ldr	r3, [r3, #0]
20007048:	4a76      	ldr	r2, [pc, #472]	; (20007224 <DMA_SetConfig+0x254>)
2000704a:	4293      	cmp	r3, r2
2000704c:	d045      	beq.n	200070da <DMA_SetConfig+0x10a>
2000704e:	68fb      	ldr	r3, [r7, #12]
20007050:	681b      	ldr	r3, [r3, #0]
20007052:	4a75      	ldr	r2, [pc, #468]	; (20007228 <DMA_SetConfig+0x258>)
20007054:	4293      	cmp	r3, r2
20007056:	d040      	beq.n	200070da <DMA_SetConfig+0x10a>
20007058:	68fb      	ldr	r3, [r7, #12]
2000705a:	681b      	ldr	r3, [r3, #0]
2000705c:	4a73      	ldr	r2, [pc, #460]	; (2000722c <DMA_SetConfig+0x25c>)
2000705e:	4293      	cmp	r3, r2
20007060:	d03b      	beq.n	200070da <DMA_SetConfig+0x10a>
20007062:	68fb      	ldr	r3, [r7, #12]
20007064:	681b      	ldr	r3, [r3, #0]
20007066:	4a72      	ldr	r2, [pc, #456]	; (20007230 <DMA_SetConfig+0x260>)
20007068:	4293      	cmp	r3, r2
2000706a:	d036      	beq.n	200070da <DMA_SetConfig+0x10a>
2000706c:	68fb      	ldr	r3, [r7, #12]
2000706e:	681b      	ldr	r3, [r3, #0]
20007070:	4a70      	ldr	r2, [pc, #448]	; (20007234 <DMA_SetConfig+0x264>)
20007072:	4293      	cmp	r3, r2
20007074:	d031      	beq.n	200070da <DMA_SetConfig+0x10a>
20007076:	68fb      	ldr	r3, [r7, #12]
20007078:	681b      	ldr	r3, [r3, #0]
2000707a:	4a6f      	ldr	r2, [pc, #444]	; (20007238 <DMA_SetConfig+0x268>)
2000707c:	4293      	cmp	r3, r2
2000707e:	d02c      	beq.n	200070da <DMA_SetConfig+0x10a>
20007080:	68fb      	ldr	r3, [r7, #12]
20007082:	681b      	ldr	r3, [r3, #0]
20007084:	4a6d      	ldr	r2, [pc, #436]	; (2000723c <DMA_SetConfig+0x26c>)
20007086:	4293      	cmp	r3, r2
20007088:	d027      	beq.n	200070da <DMA_SetConfig+0x10a>
2000708a:	68fb      	ldr	r3, [r7, #12]
2000708c:	681b      	ldr	r3, [r3, #0]
2000708e:	4a6c      	ldr	r2, [pc, #432]	; (20007240 <DMA_SetConfig+0x270>)
20007090:	4293      	cmp	r3, r2
20007092:	d022      	beq.n	200070da <DMA_SetConfig+0x10a>
20007094:	68fb      	ldr	r3, [r7, #12]
20007096:	681b      	ldr	r3, [r3, #0]
20007098:	4a6a      	ldr	r2, [pc, #424]	; (20007244 <DMA_SetConfig+0x274>)
2000709a:	4293      	cmp	r3, r2
2000709c:	d01d      	beq.n	200070da <DMA_SetConfig+0x10a>
2000709e:	68fb      	ldr	r3, [r7, #12]
200070a0:	681b      	ldr	r3, [r3, #0]
200070a2:	4a69      	ldr	r2, [pc, #420]	; (20007248 <DMA_SetConfig+0x278>)
200070a4:	4293      	cmp	r3, r2
200070a6:	d018      	beq.n	200070da <DMA_SetConfig+0x10a>
200070a8:	68fb      	ldr	r3, [r7, #12]
200070aa:	681b      	ldr	r3, [r3, #0]
200070ac:	4a67      	ldr	r2, [pc, #412]	; (2000724c <DMA_SetConfig+0x27c>)
200070ae:	4293      	cmp	r3, r2
200070b0:	d013      	beq.n	200070da <DMA_SetConfig+0x10a>
200070b2:	68fb      	ldr	r3, [r7, #12]
200070b4:	681b      	ldr	r3, [r3, #0]
200070b6:	4a66      	ldr	r2, [pc, #408]	; (20007250 <DMA_SetConfig+0x280>)
200070b8:	4293      	cmp	r3, r2
200070ba:	d00e      	beq.n	200070da <DMA_SetConfig+0x10a>
200070bc:	68fb      	ldr	r3, [r7, #12]
200070be:	681b      	ldr	r3, [r3, #0]
200070c0:	4a64      	ldr	r2, [pc, #400]	; (20007254 <DMA_SetConfig+0x284>)
200070c2:	4293      	cmp	r3, r2
200070c4:	d009      	beq.n	200070da <DMA_SetConfig+0x10a>
200070c6:	68fb      	ldr	r3, [r7, #12]
200070c8:	681b      	ldr	r3, [r3, #0]
200070ca:	4a63      	ldr	r2, [pc, #396]	; (20007258 <DMA_SetConfig+0x288>)
200070cc:	4293      	cmp	r3, r2
200070ce:	d004      	beq.n	200070da <DMA_SetConfig+0x10a>
200070d0:	68fb      	ldr	r3, [r7, #12]
200070d2:	681b      	ldr	r3, [r3, #0]
200070d4:	4a61      	ldr	r2, [pc, #388]	; (2000725c <DMA_SetConfig+0x28c>)
200070d6:	4293      	cmp	r3, r2
200070d8:	d101      	bne.n	200070de <DMA_SetConfig+0x10e>
200070da:	2301      	movs	r3, #1
200070dc:	e000      	b.n	200070e0 <DMA_SetConfig+0x110>
200070de:	2300      	movs	r3, #0
200070e0:	2b00      	cmp	r3, #0
200070e2:	d00d      	beq.n	20007100 <DMA_SetConfig+0x130>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
200070e4:	68fb      	ldr	r3, [r7, #12]
200070e6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
200070e8:	68fa      	ldr	r2, [r7, #12]
200070ea:	6e92      	ldr	r2, [r2, #104]	; 0x68
200070ec:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
200070ee:	68fb      	ldr	r3, [r7, #12]
200070f0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
200070f2:	2b00      	cmp	r3, #0
200070f4:	d004      	beq.n	20007100 <DMA_SetConfig+0x130>
    {
      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
200070f6:	68fb      	ldr	r3, [r7, #12]
200070f8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
200070fa:	68fa      	ldr	r2, [r7, #12]
200070fc:	6f52      	ldr	r2, [r2, #116]	; 0x74
200070fe:	605a      	str	r2, [r3, #4]
    }
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20007100:	68fb      	ldr	r3, [r7, #12]
20007102:	681b      	ldr	r3, [r3, #0]
20007104:	4a3e      	ldr	r2, [pc, #248]	; (20007200 <DMA_SetConfig+0x230>)
20007106:	4293      	cmp	r3, r2
20007108:	d04a      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
2000710a:	68fb      	ldr	r3, [r7, #12]
2000710c:	681b      	ldr	r3, [r3, #0]
2000710e:	4a3d      	ldr	r2, [pc, #244]	; (20007204 <DMA_SetConfig+0x234>)
20007110:	4293      	cmp	r3, r2
20007112:	d045      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
20007114:	68fb      	ldr	r3, [r7, #12]
20007116:	681b      	ldr	r3, [r3, #0]
20007118:	4a3b      	ldr	r2, [pc, #236]	; (20007208 <DMA_SetConfig+0x238>)
2000711a:	4293      	cmp	r3, r2
2000711c:	d040      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
2000711e:	68fb      	ldr	r3, [r7, #12]
20007120:	681b      	ldr	r3, [r3, #0]
20007122:	4a3a      	ldr	r2, [pc, #232]	; (2000720c <DMA_SetConfig+0x23c>)
20007124:	4293      	cmp	r3, r2
20007126:	d03b      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
20007128:	68fb      	ldr	r3, [r7, #12]
2000712a:	681b      	ldr	r3, [r3, #0]
2000712c:	4a38      	ldr	r2, [pc, #224]	; (20007210 <DMA_SetConfig+0x240>)
2000712e:	4293      	cmp	r3, r2
20007130:	d036      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
20007132:	68fb      	ldr	r3, [r7, #12]
20007134:	681b      	ldr	r3, [r3, #0]
20007136:	4a37      	ldr	r2, [pc, #220]	; (20007214 <DMA_SetConfig+0x244>)
20007138:	4293      	cmp	r3, r2
2000713a:	d031      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
2000713c:	68fb      	ldr	r3, [r7, #12]
2000713e:	681b      	ldr	r3, [r3, #0]
20007140:	4a35      	ldr	r2, [pc, #212]	; (20007218 <DMA_SetConfig+0x248>)
20007142:	4293      	cmp	r3, r2
20007144:	d02c      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
20007146:	68fb      	ldr	r3, [r7, #12]
20007148:	681b      	ldr	r3, [r3, #0]
2000714a:	4a34      	ldr	r2, [pc, #208]	; (2000721c <DMA_SetConfig+0x24c>)
2000714c:	4293      	cmp	r3, r2
2000714e:	d027      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
20007150:	68fb      	ldr	r3, [r7, #12]
20007152:	681b      	ldr	r3, [r3, #0]
20007154:	4a32      	ldr	r2, [pc, #200]	; (20007220 <DMA_SetConfig+0x250>)
20007156:	4293      	cmp	r3, r2
20007158:	d022      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
2000715a:	68fb      	ldr	r3, [r7, #12]
2000715c:	681b      	ldr	r3, [r3, #0]
2000715e:	4a31      	ldr	r2, [pc, #196]	; (20007224 <DMA_SetConfig+0x254>)
20007160:	4293      	cmp	r3, r2
20007162:	d01d      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
20007164:	68fb      	ldr	r3, [r7, #12]
20007166:	681b      	ldr	r3, [r3, #0]
20007168:	4a2f      	ldr	r2, [pc, #188]	; (20007228 <DMA_SetConfig+0x258>)
2000716a:	4293      	cmp	r3, r2
2000716c:	d018      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
2000716e:	68fb      	ldr	r3, [r7, #12]
20007170:	681b      	ldr	r3, [r3, #0]
20007172:	4a2e      	ldr	r2, [pc, #184]	; (2000722c <DMA_SetConfig+0x25c>)
20007174:	4293      	cmp	r3, r2
20007176:	d013      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
20007178:	68fb      	ldr	r3, [r7, #12]
2000717a:	681b      	ldr	r3, [r3, #0]
2000717c:	4a2c      	ldr	r2, [pc, #176]	; (20007230 <DMA_SetConfig+0x260>)
2000717e:	4293      	cmp	r3, r2
20007180:	d00e      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
20007182:	68fb      	ldr	r3, [r7, #12]
20007184:	681b      	ldr	r3, [r3, #0]
20007186:	4a2b      	ldr	r2, [pc, #172]	; (20007234 <DMA_SetConfig+0x264>)
20007188:	4293      	cmp	r3, r2
2000718a:	d009      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
2000718c:	68fb      	ldr	r3, [r7, #12]
2000718e:	681b      	ldr	r3, [r3, #0]
20007190:	4a29      	ldr	r2, [pc, #164]	; (20007238 <DMA_SetConfig+0x268>)
20007192:	4293      	cmp	r3, r2
20007194:	d004      	beq.n	200071a0 <DMA_SetConfig+0x1d0>
20007196:	68fb      	ldr	r3, [r7, #12]
20007198:	681b      	ldr	r3, [r3, #0]
2000719a:	4a28      	ldr	r2, [pc, #160]	; (2000723c <DMA_SetConfig+0x26c>)
2000719c:	4293      	cmp	r3, r2
2000719e:	d101      	bne.n	200071a4 <DMA_SetConfig+0x1d4>
200071a0:	2301      	movs	r3, #1
200071a2:	e000      	b.n	200071a6 <DMA_SetConfig+0x1d6>
200071a4:	2300      	movs	r3, #0
200071a6:	2b00      	cmp	r3, #0
200071a8:	d05a      	beq.n	20007260 <DMA_SetConfig+0x290>
  {
    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
200071aa:	68fb      	ldr	r3, [r7, #12]
200071ac:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200071ae:	f003 031f 	and.w	r3, r3, #31
200071b2:	223f      	movs	r2, #63	; 0x3f
200071b4:	409a      	lsls	r2, r3
200071b6:	697b      	ldr	r3, [r7, #20]
200071b8:	609a      	str	r2, [r3, #8]

    /* Clear DBM bit */
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
200071ba:	68fb      	ldr	r3, [r7, #12]
200071bc:	681b      	ldr	r3, [r3, #0]
200071be:	681a      	ldr	r2, [r3, #0]
200071c0:	68fb      	ldr	r3, [r7, #12]
200071c2:	681b      	ldr	r3, [r3, #0]
200071c4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
200071c8:	601a      	str	r2, [r3, #0]

    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;
200071ca:	68fb      	ldr	r3, [r7, #12]
200071cc:	681b      	ldr	r3, [r3, #0]
200071ce:	683a      	ldr	r2, [r7, #0]
200071d0:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
200071d2:	68fb      	ldr	r3, [r7, #12]
200071d4:	689b      	ldr	r3, [r3, #8]
200071d6:	2b40      	cmp	r3, #64	; 0x40
200071d8:	d108      	bne.n	200071ec <DMA_SetConfig+0x21c>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;
200071da:	68fb      	ldr	r3, [r7, #12]
200071dc:	681b      	ldr	r3, [r3, #0]
200071de:	687a      	ldr	r2, [r7, #4]
200071e0:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;
200071e2:	68fb      	ldr	r3, [r7, #12]
200071e4:	681b      	ldr	r3, [r3, #0]
200071e6:	68ba      	ldr	r2, [r7, #8]
200071e8:	60da      	str	r2, [r3, #12]
  }
  else
  {
    /* Nothing To Do */
  }
}
200071ea:	e087      	b.n	200072fc <DMA_SetConfig+0x32c>
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;
200071ec:	68fb      	ldr	r3, [r7, #12]
200071ee:	681b      	ldr	r3, [r3, #0]
200071f0:	68ba      	ldr	r2, [r7, #8]
200071f2:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
200071f4:	68fb      	ldr	r3, [r7, #12]
200071f6:	681b      	ldr	r3, [r3, #0]
200071f8:	687a      	ldr	r2, [r7, #4]
200071fa:	60da      	str	r2, [r3, #12]
}
200071fc:	e07e      	b.n	200072fc <DMA_SetConfig+0x32c>
200071fe:	bf00      	nop
20007200:	40020010 	.word	0x40020010
20007204:	40020028 	.word	0x40020028
20007208:	40020040 	.word	0x40020040
2000720c:	40020058 	.word	0x40020058
20007210:	40020070 	.word	0x40020070
20007214:	40020088 	.word	0x40020088
20007218:	400200a0 	.word	0x400200a0
2000721c:	400200b8 	.word	0x400200b8
20007220:	40020410 	.word	0x40020410
20007224:	40020428 	.word	0x40020428
20007228:	40020440 	.word	0x40020440
2000722c:	40020458 	.word	0x40020458
20007230:	40020470 	.word	0x40020470
20007234:	40020488 	.word	0x40020488
20007238:	400204a0 	.word	0x400204a0
2000723c:	400204b8 	.word	0x400204b8
20007240:	58025408 	.word	0x58025408
20007244:	5802541c 	.word	0x5802541c
20007248:	58025430 	.word	0x58025430
2000724c:	58025444 	.word	0x58025444
20007250:	58025458 	.word	0x58025458
20007254:	5802546c 	.word	0x5802546c
20007258:	58025480 	.word	0x58025480
2000725c:	58025494 	.word	0x58025494
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
20007260:	68fb      	ldr	r3, [r7, #12]
20007262:	681b      	ldr	r3, [r3, #0]
20007264:	4a28      	ldr	r2, [pc, #160]	; (20007308 <DMA_SetConfig+0x338>)
20007266:	4293      	cmp	r3, r2
20007268:	d022      	beq.n	200072b0 <DMA_SetConfig+0x2e0>
2000726a:	68fb      	ldr	r3, [r7, #12]
2000726c:	681b      	ldr	r3, [r3, #0]
2000726e:	4a27      	ldr	r2, [pc, #156]	; (2000730c <DMA_SetConfig+0x33c>)
20007270:	4293      	cmp	r3, r2
20007272:	d01d      	beq.n	200072b0 <DMA_SetConfig+0x2e0>
20007274:	68fb      	ldr	r3, [r7, #12]
20007276:	681b      	ldr	r3, [r3, #0]
20007278:	4a25      	ldr	r2, [pc, #148]	; (20007310 <DMA_SetConfig+0x340>)
2000727a:	4293      	cmp	r3, r2
2000727c:	d018      	beq.n	200072b0 <DMA_SetConfig+0x2e0>
2000727e:	68fb      	ldr	r3, [r7, #12]
20007280:	681b      	ldr	r3, [r3, #0]
20007282:	4a24      	ldr	r2, [pc, #144]	; (20007314 <DMA_SetConfig+0x344>)
20007284:	4293      	cmp	r3, r2
20007286:	d013      	beq.n	200072b0 <DMA_SetConfig+0x2e0>
20007288:	68fb      	ldr	r3, [r7, #12]
2000728a:	681b      	ldr	r3, [r3, #0]
2000728c:	4a22      	ldr	r2, [pc, #136]	; (20007318 <DMA_SetConfig+0x348>)
2000728e:	4293      	cmp	r3, r2
20007290:	d00e      	beq.n	200072b0 <DMA_SetConfig+0x2e0>
20007292:	68fb      	ldr	r3, [r7, #12]
20007294:	681b      	ldr	r3, [r3, #0]
20007296:	4a21      	ldr	r2, [pc, #132]	; (2000731c <DMA_SetConfig+0x34c>)
20007298:	4293      	cmp	r3, r2
2000729a:	d009      	beq.n	200072b0 <DMA_SetConfig+0x2e0>
2000729c:	68fb      	ldr	r3, [r7, #12]
2000729e:	681b      	ldr	r3, [r3, #0]
200072a0:	4a1f      	ldr	r2, [pc, #124]	; (20007320 <DMA_SetConfig+0x350>)
200072a2:	4293      	cmp	r3, r2
200072a4:	d004      	beq.n	200072b0 <DMA_SetConfig+0x2e0>
200072a6:	68fb      	ldr	r3, [r7, #12]
200072a8:	681b      	ldr	r3, [r3, #0]
200072aa:	4a1e      	ldr	r2, [pc, #120]	; (20007324 <DMA_SetConfig+0x354>)
200072ac:	4293      	cmp	r3, r2
200072ae:	d101      	bne.n	200072b4 <DMA_SetConfig+0x2e4>
200072b0:	2301      	movs	r3, #1
200072b2:	e000      	b.n	200072b6 <DMA_SetConfig+0x2e6>
200072b4:	2300      	movs	r3, #0
200072b6:	2b00      	cmp	r3, #0
200072b8:	d020      	beq.n	200072fc <DMA_SetConfig+0x32c>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
200072ba:	68fb      	ldr	r3, [r7, #12]
200072bc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200072be:	f003 031f 	and.w	r3, r3, #31
200072c2:	2201      	movs	r2, #1
200072c4:	409a      	lsls	r2, r3
200072c6:	693b      	ldr	r3, [r7, #16]
200072c8:	605a      	str	r2, [r3, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
200072ca:	68fb      	ldr	r3, [r7, #12]
200072cc:	681b      	ldr	r3, [r3, #0]
200072ce:	683a      	ldr	r2, [r7, #0]
200072d0:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
200072d2:	68fb      	ldr	r3, [r7, #12]
200072d4:	689b      	ldr	r3, [r3, #8]
200072d6:	2b40      	cmp	r3, #64	; 0x40
200072d8:	d108      	bne.n	200072ec <DMA_SetConfig+0x31c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
200072da:	68fb      	ldr	r3, [r7, #12]
200072dc:	681b      	ldr	r3, [r3, #0]
200072de:	687a      	ldr	r2, [r7, #4]
200072e0:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
200072e2:	68fb      	ldr	r3, [r7, #12]
200072e4:	681b      	ldr	r3, [r3, #0]
200072e6:	68ba      	ldr	r2, [r7, #8]
200072e8:	60da      	str	r2, [r3, #12]
}
200072ea:	e007      	b.n	200072fc <DMA_SetConfig+0x32c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
200072ec:	68fb      	ldr	r3, [r7, #12]
200072ee:	681b      	ldr	r3, [r3, #0]
200072f0:	68ba      	ldr	r2, [r7, #8]
200072f2:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
200072f4:	68fb      	ldr	r3, [r7, #12]
200072f6:	681b      	ldr	r3, [r3, #0]
200072f8:	687a      	ldr	r2, [r7, #4]
200072fa:	60da      	str	r2, [r3, #12]
}
200072fc:	bf00      	nop
200072fe:	371c      	adds	r7, #28
20007300:	46bd      	mov	sp, r7
20007302:	f85d 7b04 	ldr.w	r7, [sp], #4
20007306:	4770      	bx	lr
20007308:	58025408 	.word	0x58025408
2000730c:	5802541c 	.word	0x5802541c
20007310:	58025430 	.word	0x58025430
20007314:	58025444 	.word	0x58025444
20007318:	58025458 	.word	0x58025458
2000731c:	5802546c 	.word	0x5802546c
20007320:	58025480 	.word	0x58025480
20007324:	58025494 	.word	0x58025494

20007328 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
20007328:	b480      	push	{r7}
2000732a:	b085      	sub	sp, #20
2000732c:	af00      	add	r7, sp, #0
2000732e:	6078      	str	r0, [r7, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20007330:	687b      	ldr	r3, [r7, #4]
20007332:	681b      	ldr	r3, [r3, #0]
20007334:	4a42      	ldr	r2, [pc, #264]	; (20007440 <DMA_CalcBaseAndBitshift+0x118>)
20007336:	4293      	cmp	r3, r2
20007338:	d04a      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
2000733a:	687b      	ldr	r3, [r7, #4]
2000733c:	681b      	ldr	r3, [r3, #0]
2000733e:	4a41      	ldr	r2, [pc, #260]	; (20007444 <DMA_CalcBaseAndBitshift+0x11c>)
20007340:	4293      	cmp	r3, r2
20007342:	d045      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
20007344:	687b      	ldr	r3, [r7, #4]
20007346:	681b      	ldr	r3, [r3, #0]
20007348:	4a3f      	ldr	r2, [pc, #252]	; (20007448 <DMA_CalcBaseAndBitshift+0x120>)
2000734a:	4293      	cmp	r3, r2
2000734c:	d040      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
2000734e:	687b      	ldr	r3, [r7, #4]
20007350:	681b      	ldr	r3, [r3, #0]
20007352:	4a3e      	ldr	r2, [pc, #248]	; (2000744c <DMA_CalcBaseAndBitshift+0x124>)
20007354:	4293      	cmp	r3, r2
20007356:	d03b      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
20007358:	687b      	ldr	r3, [r7, #4]
2000735a:	681b      	ldr	r3, [r3, #0]
2000735c:	4a3c      	ldr	r2, [pc, #240]	; (20007450 <DMA_CalcBaseAndBitshift+0x128>)
2000735e:	4293      	cmp	r3, r2
20007360:	d036      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
20007362:	687b      	ldr	r3, [r7, #4]
20007364:	681b      	ldr	r3, [r3, #0]
20007366:	4a3b      	ldr	r2, [pc, #236]	; (20007454 <DMA_CalcBaseAndBitshift+0x12c>)
20007368:	4293      	cmp	r3, r2
2000736a:	d031      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
2000736c:	687b      	ldr	r3, [r7, #4]
2000736e:	681b      	ldr	r3, [r3, #0]
20007370:	4a39      	ldr	r2, [pc, #228]	; (20007458 <DMA_CalcBaseAndBitshift+0x130>)
20007372:	4293      	cmp	r3, r2
20007374:	d02c      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
20007376:	687b      	ldr	r3, [r7, #4]
20007378:	681b      	ldr	r3, [r3, #0]
2000737a:	4a38      	ldr	r2, [pc, #224]	; (2000745c <DMA_CalcBaseAndBitshift+0x134>)
2000737c:	4293      	cmp	r3, r2
2000737e:	d027      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
20007380:	687b      	ldr	r3, [r7, #4]
20007382:	681b      	ldr	r3, [r3, #0]
20007384:	4a36      	ldr	r2, [pc, #216]	; (20007460 <DMA_CalcBaseAndBitshift+0x138>)
20007386:	4293      	cmp	r3, r2
20007388:	d022      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
2000738a:	687b      	ldr	r3, [r7, #4]
2000738c:	681b      	ldr	r3, [r3, #0]
2000738e:	4a35      	ldr	r2, [pc, #212]	; (20007464 <DMA_CalcBaseAndBitshift+0x13c>)
20007390:	4293      	cmp	r3, r2
20007392:	d01d      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
20007394:	687b      	ldr	r3, [r7, #4]
20007396:	681b      	ldr	r3, [r3, #0]
20007398:	4a33      	ldr	r2, [pc, #204]	; (20007468 <DMA_CalcBaseAndBitshift+0x140>)
2000739a:	4293      	cmp	r3, r2
2000739c:	d018      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
2000739e:	687b      	ldr	r3, [r7, #4]
200073a0:	681b      	ldr	r3, [r3, #0]
200073a2:	4a32      	ldr	r2, [pc, #200]	; (2000746c <DMA_CalcBaseAndBitshift+0x144>)
200073a4:	4293      	cmp	r3, r2
200073a6:	d013      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
200073a8:	687b      	ldr	r3, [r7, #4]
200073aa:	681b      	ldr	r3, [r3, #0]
200073ac:	4a30      	ldr	r2, [pc, #192]	; (20007470 <DMA_CalcBaseAndBitshift+0x148>)
200073ae:	4293      	cmp	r3, r2
200073b0:	d00e      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
200073b2:	687b      	ldr	r3, [r7, #4]
200073b4:	681b      	ldr	r3, [r3, #0]
200073b6:	4a2f      	ldr	r2, [pc, #188]	; (20007474 <DMA_CalcBaseAndBitshift+0x14c>)
200073b8:	4293      	cmp	r3, r2
200073ba:	d009      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
200073bc:	687b      	ldr	r3, [r7, #4]
200073be:	681b      	ldr	r3, [r3, #0]
200073c0:	4a2d      	ldr	r2, [pc, #180]	; (20007478 <DMA_CalcBaseAndBitshift+0x150>)
200073c2:	4293      	cmp	r3, r2
200073c4:	d004      	beq.n	200073d0 <DMA_CalcBaseAndBitshift+0xa8>
200073c6:	687b      	ldr	r3, [r7, #4]
200073c8:	681b      	ldr	r3, [r3, #0]
200073ca:	4a2c      	ldr	r2, [pc, #176]	; (2000747c <DMA_CalcBaseAndBitshift+0x154>)
200073cc:	4293      	cmp	r3, r2
200073ce:	d101      	bne.n	200073d4 <DMA_CalcBaseAndBitshift+0xac>
200073d0:	2301      	movs	r3, #1
200073d2:	e000      	b.n	200073d6 <DMA_CalcBaseAndBitshift+0xae>
200073d4:	2300      	movs	r3, #0
200073d6:	2b00      	cmp	r3, #0
200073d8:	d024      	beq.n	20007424 <DMA_CalcBaseAndBitshift+0xfc>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
200073da:	687b      	ldr	r3, [r7, #4]
200073dc:	681b      	ldr	r3, [r3, #0]
200073de:	b2db      	uxtb	r3, r3
200073e0:	3b10      	subs	r3, #16
200073e2:	4a27      	ldr	r2, [pc, #156]	; (20007480 <DMA_CalcBaseAndBitshift+0x158>)
200073e4:	fba2 2303 	umull	r2, r3, r2, r3
200073e8:	091b      	lsrs	r3, r3, #4
200073ea:	60fb      	str	r3, [r7, #12]

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
200073ec:	68fb      	ldr	r3, [r7, #12]
200073ee:	f003 0307 	and.w	r3, r3, #7
200073f2:	4a24      	ldr	r2, [pc, #144]	; (20007484 <DMA_CalcBaseAndBitshift+0x15c>)
200073f4:	5cd3      	ldrb	r3, [r2, r3]
200073f6:	461a      	mov	r2, r3
200073f8:	687b      	ldr	r3, [r7, #4]
200073fa:	65da      	str	r2, [r3, #92]	; 0x5c

    if (stream_number > 3U)
200073fc:	68fb      	ldr	r3, [r7, #12]
200073fe:	2b03      	cmp	r3, #3
20007400:	d908      	bls.n	20007414 <DMA_CalcBaseAndBitshift+0xec>
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
20007402:	687b      	ldr	r3, [r7, #4]
20007404:	681b      	ldr	r3, [r3, #0]
20007406:	461a      	mov	r2, r3
20007408:	4b1f      	ldr	r3, [pc, #124]	; (20007488 <DMA_CalcBaseAndBitshift+0x160>)
2000740a:	4013      	ands	r3, r2
2000740c:	1d1a      	adds	r2, r3, #4
2000740e:	687b      	ldr	r3, [r7, #4]
20007410:	659a      	str	r2, [r3, #88]	; 0x58
20007412:	e00d      	b.n	20007430 <DMA_CalcBaseAndBitshift+0x108>
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
20007414:	687b      	ldr	r3, [r7, #4]
20007416:	681b      	ldr	r3, [r3, #0]
20007418:	461a      	mov	r2, r3
2000741a:	4b1b      	ldr	r3, [pc, #108]	; (20007488 <DMA_CalcBaseAndBitshift+0x160>)
2000741c:	4013      	ands	r3, r2
2000741e:	687a      	ldr	r2, [r7, #4]
20007420:	6593      	str	r3, [r2, #88]	; 0x58
20007422:	e005      	b.n	20007430 <DMA_CalcBaseAndBitshift+0x108>
    }
  }
  else /* BDMA instance(s) */
  {
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
20007424:	687b      	ldr	r3, [r7, #4]
20007426:	681b      	ldr	r3, [r3, #0]
20007428:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
2000742c:	687b      	ldr	r3, [r7, #4]
2000742e:	659a      	str	r2, [r3, #88]	; 0x58
  }

  return hdma->StreamBaseAddress;
20007430:	687b      	ldr	r3, [r7, #4]
20007432:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
20007434:	4618      	mov	r0, r3
20007436:	3714      	adds	r7, #20
20007438:	46bd      	mov	sp, r7
2000743a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000743e:	4770      	bx	lr
20007440:	40020010 	.word	0x40020010
20007444:	40020028 	.word	0x40020028
20007448:	40020040 	.word	0x40020040
2000744c:	40020058 	.word	0x40020058
20007450:	40020070 	.word	0x40020070
20007454:	40020088 	.word	0x40020088
20007458:	400200a0 	.word	0x400200a0
2000745c:	400200b8 	.word	0x400200b8
20007460:	40020410 	.word	0x40020410
20007464:	40020428 	.word	0x40020428
20007468:	40020440 	.word	0x40020440
2000746c:	40020458 	.word	0x40020458
20007470:	40020470 	.word	0x40020470
20007474:	40020488 	.word	0x40020488
20007478:	400204a0 	.word	0x400204a0
2000747c:	400204b8 	.word	0x400204b8
20007480:	aaaaaaab 	.word	0xaaaaaaab
20007484:	2001c00c 	.word	0x2001c00c
20007488:	fffffc00 	.word	0xfffffc00

2000748c <DMA_CheckFifoParam>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
2000748c:	b480      	push	{r7}
2000748e:	b085      	sub	sp, #20
20007490:	af00      	add	r7, sp, #0
20007492:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20007494:	2300      	movs	r3, #0
20007496:	73fb      	strb	r3, [r7, #15]

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
20007498:	687b      	ldr	r3, [r7, #4]
2000749a:	699b      	ldr	r3, [r3, #24]
2000749c:	2b00      	cmp	r3, #0
2000749e:	d120      	bne.n	200074e2 <DMA_CheckFifoParam+0x56>
  {
    switch (hdma->Init.FIFOThreshold)
200074a0:	687b      	ldr	r3, [r7, #4]
200074a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200074a4:	2b03      	cmp	r3, #3
200074a6:	d858      	bhi.n	2000755a <DMA_CheckFifoParam+0xce>
200074a8:	a201      	add	r2, pc, #4	; (adr r2, 200074b0 <DMA_CheckFifoParam+0x24>)
200074aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200074ae:	bf00      	nop
200074b0:	200074c1 	.word	0x200074c1
200074b4:	200074d3 	.word	0x200074d3
200074b8:	200074c1 	.word	0x200074c1
200074bc:	2000755b 	.word	0x2000755b
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:

        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
200074c0:	687b      	ldr	r3, [r7, #4]
200074c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200074c4:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
200074c8:	2b00      	cmp	r3, #0
200074ca:	d048      	beq.n	2000755e <DMA_CheckFifoParam+0xd2>
        {
          status = HAL_ERROR;
200074cc:	2301      	movs	r3, #1
200074ce:	73fb      	strb	r3, [r7, #15]
        }
        break;
200074d0:	e045      	b.n	2000755e <DMA_CheckFifoParam+0xd2>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
200074d2:	687b      	ldr	r3, [r7, #4]
200074d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200074d6:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
200074da:	d142      	bne.n	20007562 <DMA_CheckFifoParam+0xd6>
        {
          status = HAL_ERROR;
200074dc:	2301      	movs	r3, #1
200074de:	73fb      	strb	r3, [r7, #15]
        }
        break;
200074e0:	e03f      	b.n	20007562 <DMA_CheckFifoParam+0xd6>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
200074e2:	687b      	ldr	r3, [r7, #4]
200074e4:	699b      	ldr	r3, [r3, #24]
200074e6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
200074ea:	d123      	bne.n	20007534 <DMA_CheckFifoParam+0xa8>
  {
    switch (hdma->Init.FIFOThreshold)
200074ec:	687b      	ldr	r3, [r7, #4]
200074ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200074f0:	2b03      	cmp	r3, #3
200074f2:	d838      	bhi.n	20007566 <DMA_CheckFifoParam+0xda>
200074f4:	a201      	add	r2, pc, #4	; (adr r2, 200074fc <DMA_CheckFifoParam+0x70>)
200074f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200074fa:	bf00      	nop
200074fc:	2000750d 	.word	0x2000750d
20007500:	20007513 	.word	0x20007513
20007504:	2000750d 	.word	0x2000750d
20007508:	20007525 	.word	0x20007525
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
2000750c:	2301      	movs	r3, #1
2000750e:	73fb      	strb	r3, [r7, #15]
        break;
20007510:	e030      	b.n	20007574 <DMA_CheckFifoParam+0xe8>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
20007512:	687b      	ldr	r3, [r7, #4]
20007514:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20007516:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2000751a:	2b00      	cmp	r3, #0
2000751c:	d025      	beq.n	2000756a <DMA_CheckFifoParam+0xde>
        {
          status = HAL_ERROR;
2000751e:	2301      	movs	r3, #1
20007520:	73fb      	strb	r3, [r7, #15]
        }
        break;
20007522:	e022      	b.n	2000756a <DMA_CheckFifoParam+0xde>

      case DMA_FIFO_THRESHOLD_FULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
20007524:	687b      	ldr	r3, [r7, #4]
20007526:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20007528:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
2000752c:	d11f      	bne.n	2000756e <DMA_CheckFifoParam+0xe2>
        {
          status = HAL_ERROR;
2000752e:	2301      	movs	r3, #1
20007530:	73fb      	strb	r3, [r7, #15]
        }
        break;
20007532:	e01c      	b.n	2000756e <DMA_CheckFifoParam+0xe2>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
20007534:	687b      	ldr	r3, [r7, #4]
20007536:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20007538:	2b02      	cmp	r3, #2
2000753a:	d902      	bls.n	20007542 <DMA_CheckFifoParam+0xb6>
2000753c:	2b03      	cmp	r3, #3
2000753e:	d003      	beq.n	20007548 <DMA_CheckFifoParam+0xbc>
          status = HAL_ERROR;
        }
    break;

      default:
        break;
20007540:	e018      	b.n	20007574 <DMA_CheckFifoParam+0xe8>
        status = HAL_ERROR;
20007542:	2301      	movs	r3, #1
20007544:	73fb      	strb	r3, [r7, #15]
        break;
20007546:	e015      	b.n	20007574 <DMA_CheckFifoParam+0xe8>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
20007548:	687b      	ldr	r3, [r7, #4]
2000754a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000754c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
20007550:	2b00      	cmp	r3, #0
20007552:	d00e      	beq.n	20007572 <DMA_CheckFifoParam+0xe6>
          status = HAL_ERROR;
20007554:	2301      	movs	r3, #1
20007556:	73fb      	strb	r3, [r7, #15]
    break;
20007558:	e00b      	b.n	20007572 <DMA_CheckFifoParam+0xe6>
        break;
2000755a:	bf00      	nop
2000755c:	e00a      	b.n	20007574 <DMA_CheckFifoParam+0xe8>
        break;
2000755e:	bf00      	nop
20007560:	e008      	b.n	20007574 <DMA_CheckFifoParam+0xe8>
        break;
20007562:	bf00      	nop
20007564:	e006      	b.n	20007574 <DMA_CheckFifoParam+0xe8>
        break;
20007566:	bf00      	nop
20007568:	e004      	b.n	20007574 <DMA_CheckFifoParam+0xe8>
        break;
2000756a:	bf00      	nop
2000756c:	e002      	b.n	20007574 <DMA_CheckFifoParam+0xe8>
        break;
2000756e:	bf00      	nop
20007570:	e000      	b.n	20007574 <DMA_CheckFifoParam+0xe8>
    break;
20007572:	bf00      	nop
    }
  }

  return status;
20007574:	7bfb      	ldrb	r3, [r7, #15]
}
20007576:	4618      	mov	r0, r3
20007578:	3714      	adds	r7, #20
2000757a:	46bd      	mov	sp, r7
2000757c:	f85d 7b04 	ldr.w	r7, [sp], #4
20007580:	4770      	bx	lr
20007582:	bf00      	nop

20007584 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
20007584:	b480      	push	{r7}
20007586:	b085      	sub	sp, #20
20007588:	af00      	add	r7, sp, #0
2000758a:	6078      	str	r0, [r7, #4]
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
2000758c:	687b      	ldr	r3, [r7, #4]
2000758e:	681b      	ldr	r3, [r3, #0]
20007590:	60bb      	str	r3, [r7, #8]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
20007592:	687b      	ldr	r3, [r7, #4]
20007594:	681b      	ldr	r3, [r3, #0]
20007596:	4a38      	ldr	r2, [pc, #224]	; (20007678 <DMA_CalcDMAMUXChannelBaseAndMask+0xf4>)
20007598:	4293      	cmp	r3, r2
2000759a:	d022      	beq.n	200075e2 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
2000759c:	687b      	ldr	r3, [r7, #4]
2000759e:	681b      	ldr	r3, [r3, #0]
200075a0:	4a36      	ldr	r2, [pc, #216]	; (2000767c <DMA_CalcDMAMUXChannelBaseAndMask+0xf8>)
200075a2:	4293      	cmp	r3, r2
200075a4:	d01d      	beq.n	200075e2 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
200075a6:	687b      	ldr	r3, [r7, #4]
200075a8:	681b      	ldr	r3, [r3, #0]
200075aa:	4a35      	ldr	r2, [pc, #212]	; (20007680 <DMA_CalcDMAMUXChannelBaseAndMask+0xfc>)
200075ac:	4293      	cmp	r3, r2
200075ae:	d018      	beq.n	200075e2 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
200075b0:	687b      	ldr	r3, [r7, #4]
200075b2:	681b      	ldr	r3, [r3, #0]
200075b4:	4a33      	ldr	r2, [pc, #204]	; (20007684 <DMA_CalcDMAMUXChannelBaseAndMask+0x100>)
200075b6:	4293      	cmp	r3, r2
200075b8:	d013      	beq.n	200075e2 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
200075ba:	687b      	ldr	r3, [r7, #4]
200075bc:	681b      	ldr	r3, [r3, #0]
200075be:	4a32      	ldr	r2, [pc, #200]	; (20007688 <DMA_CalcDMAMUXChannelBaseAndMask+0x104>)
200075c0:	4293      	cmp	r3, r2
200075c2:	d00e      	beq.n	200075e2 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
200075c4:	687b      	ldr	r3, [r7, #4]
200075c6:	681b      	ldr	r3, [r3, #0]
200075c8:	4a30      	ldr	r2, [pc, #192]	; (2000768c <DMA_CalcDMAMUXChannelBaseAndMask+0x108>)
200075ca:	4293      	cmp	r3, r2
200075cc:	d009      	beq.n	200075e2 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
200075ce:	687b      	ldr	r3, [r7, #4]
200075d0:	681b      	ldr	r3, [r3, #0]
200075d2:	4a2f      	ldr	r2, [pc, #188]	; (20007690 <DMA_CalcDMAMUXChannelBaseAndMask+0x10c>)
200075d4:	4293      	cmp	r3, r2
200075d6:	d004      	beq.n	200075e2 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
200075d8:	687b      	ldr	r3, [r7, #4]
200075da:	681b      	ldr	r3, [r3, #0]
200075dc:	4a2d      	ldr	r2, [pc, #180]	; (20007694 <DMA_CalcDMAMUXChannelBaseAndMask+0x110>)
200075de:	4293      	cmp	r3, r2
200075e0:	d101      	bne.n	200075e6 <DMA_CalcDMAMUXChannelBaseAndMask+0x62>
200075e2:	2301      	movs	r3, #1
200075e4:	e000      	b.n	200075e8 <DMA_CalcDMAMUXChannelBaseAndMask+0x64>
200075e6:	2300      	movs	r3, #0
200075e8:	2b00      	cmp	r3, #0
200075ea:	d01a      	beq.n	20007622 <DMA_CalcDMAMUXChannelBaseAndMask+0x9e>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
200075ec:	687b      	ldr	r3, [r7, #4]
200075ee:	681b      	ldr	r3, [r3, #0]
200075f0:	b2db      	uxtb	r3, r3
200075f2:	3b08      	subs	r3, #8
200075f4:	4a28      	ldr	r2, [pc, #160]	; (20007698 <DMA_CalcDMAMUXChannelBaseAndMask+0x114>)
200075f6:	fba2 2303 	umull	r2, r3, r2, r3
200075fa:	091b      	lsrs	r3, r3, #4
200075fc:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
200075fe:	68fa      	ldr	r2, [r7, #12]
20007600:	4b26      	ldr	r3, [pc, #152]	; (2000769c <DMA_CalcDMAMUXChannelBaseAndMask+0x118>)
20007602:	4413      	add	r3, r2
20007604:	009b      	lsls	r3, r3, #2
20007606:	461a      	mov	r2, r3
20007608:	687b      	ldr	r3, [r7, #4]
2000760a:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
2000760c:	687b      	ldr	r3, [r7, #4]
2000760e:	4a24      	ldr	r2, [pc, #144]	; (200076a0 <DMA_CalcDMAMUXChannelBaseAndMask+0x11c>)
20007610:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
20007612:	68fb      	ldr	r3, [r7, #12]
20007614:	f003 031f 	and.w	r3, r3, #31
20007618:	2201      	movs	r2, #1
2000761a:	409a      	lsls	r2, r3
2000761c:	687b      	ldr	r3, [r7, #4]
2000761e:	669a      	str	r2, [r3, #104]	; 0x68
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
}
20007620:	e024      	b.n	2000766c <DMA_CalcDMAMUXChannelBaseAndMask+0xe8>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
20007622:	687b      	ldr	r3, [r7, #4]
20007624:	681b      	ldr	r3, [r3, #0]
20007626:	b2db      	uxtb	r3, r3
20007628:	3b10      	subs	r3, #16
2000762a:	4a1e      	ldr	r2, [pc, #120]	; (200076a4 <DMA_CalcDMAMUXChannelBaseAndMask+0x120>)
2000762c:	fba2 2303 	umull	r2, r3, r2, r3
20007630:	091b      	lsrs	r3, r3, #4
20007632:	60fb      	str	r3, [r7, #12]
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
20007634:	68bb      	ldr	r3, [r7, #8]
20007636:	4a1c      	ldr	r2, [pc, #112]	; (200076a8 <DMA_CalcDMAMUXChannelBaseAndMask+0x124>)
20007638:	4293      	cmp	r3, r2
2000763a:	d806      	bhi.n	2000764a <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
2000763c:	68bb      	ldr	r3, [r7, #8]
2000763e:	4a1b      	ldr	r2, [pc, #108]	; (200076ac <DMA_CalcDMAMUXChannelBaseAndMask+0x128>)
20007640:	4293      	cmp	r3, r2
20007642:	d902      	bls.n	2000764a <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
      stream_number += 8U;
20007644:	68fb      	ldr	r3, [r7, #12]
20007646:	3308      	adds	r3, #8
20007648:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
2000764a:	68fa      	ldr	r2, [r7, #12]
2000764c:	4b18      	ldr	r3, [pc, #96]	; (200076b0 <DMA_CalcDMAMUXChannelBaseAndMask+0x12c>)
2000764e:	4413      	add	r3, r2
20007650:	009b      	lsls	r3, r3, #2
20007652:	461a      	mov	r2, r3
20007654:	687b      	ldr	r3, [r7, #4]
20007656:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
20007658:	687b      	ldr	r3, [r7, #4]
2000765a:	4a16      	ldr	r2, [pc, #88]	; (200076b4 <DMA_CalcDMAMUXChannelBaseAndMask+0x130>)
2000765c:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
2000765e:	68fb      	ldr	r3, [r7, #12]
20007660:	f003 031f 	and.w	r3, r3, #31
20007664:	2201      	movs	r2, #1
20007666:	409a      	lsls	r2, r3
20007668:	687b      	ldr	r3, [r7, #4]
2000766a:	669a      	str	r2, [r3, #104]	; 0x68
}
2000766c:	bf00      	nop
2000766e:	3714      	adds	r7, #20
20007670:	46bd      	mov	sp, r7
20007672:	f85d 7b04 	ldr.w	r7, [sp], #4
20007676:	4770      	bx	lr
20007678:	58025408 	.word	0x58025408
2000767c:	5802541c 	.word	0x5802541c
20007680:	58025430 	.word	0x58025430
20007684:	58025444 	.word	0x58025444
20007688:	58025458 	.word	0x58025458
2000768c:	5802546c 	.word	0x5802546c
20007690:	58025480 	.word	0x58025480
20007694:	58025494 	.word	0x58025494
20007698:	cccccccd 	.word	0xcccccccd
2000769c:	16009600 	.word	0x16009600
200076a0:	58025880 	.word	0x58025880
200076a4:	aaaaaaab 	.word	0xaaaaaaab
200076a8:	400204b8 	.word	0x400204b8
200076ac:	4002040f 	.word	0x4002040f
200076b0:	10008200 	.word	0x10008200
200076b4:	40020880 	.word	0x40020880

200076b8 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
200076b8:	b480      	push	{r7}
200076ba:	b085      	sub	sp, #20
200076bc:	af00      	add	r7, sp, #0
200076be:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
200076c0:	687b      	ldr	r3, [r7, #4]
200076c2:	685b      	ldr	r3, [r3, #4]
200076c4:	b2db      	uxtb	r3, r3
200076c6:	60fb      	str	r3, [r7, #12]

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
200076c8:	68fb      	ldr	r3, [r7, #12]
200076ca:	2b00      	cmp	r3, #0
200076cc:	d04a      	beq.n	20007764 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
200076ce:	68fb      	ldr	r3, [r7, #12]
200076d0:	2b08      	cmp	r3, #8
200076d2:	d847      	bhi.n	20007764 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
200076d4:	687b      	ldr	r3, [r7, #4]
200076d6:	681b      	ldr	r3, [r3, #0]
200076d8:	4a25      	ldr	r2, [pc, #148]	; (20007770 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xb8>)
200076da:	4293      	cmp	r3, r2
200076dc:	d022      	beq.n	20007724 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
200076de:	687b      	ldr	r3, [r7, #4]
200076e0:	681b      	ldr	r3, [r3, #0]
200076e2:	4a24      	ldr	r2, [pc, #144]	; (20007774 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xbc>)
200076e4:	4293      	cmp	r3, r2
200076e6:	d01d      	beq.n	20007724 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
200076e8:	687b      	ldr	r3, [r7, #4]
200076ea:	681b      	ldr	r3, [r3, #0]
200076ec:	4a22      	ldr	r2, [pc, #136]	; (20007778 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc0>)
200076ee:	4293      	cmp	r3, r2
200076f0:	d018      	beq.n	20007724 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
200076f2:	687b      	ldr	r3, [r7, #4]
200076f4:	681b      	ldr	r3, [r3, #0]
200076f6:	4a21      	ldr	r2, [pc, #132]	; (2000777c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc4>)
200076f8:	4293      	cmp	r3, r2
200076fa:	d013      	beq.n	20007724 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
200076fc:	687b      	ldr	r3, [r7, #4]
200076fe:	681b      	ldr	r3, [r3, #0]
20007700:	4a1f      	ldr	r2, [pc, #124]	; (20007780 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc8>)
20007702:	4293      	cmp	r3, r2
20007704:	d00e      	beq.n	20007724 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
20007706:	687b      	ldr	r3, [r7, #4]
20007708:	681b      	ldr	r3, [r3, #0]
2000770a:	4a1e      	ldr	r2, [pc, #120]	; (20007784 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xcc>)
2000770c:	4293      	cmp	r3, r2
2000770e:	d009      	beq.n	20007724 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
20007710:	687b      	ldr	r3, [r7, #4]
20007712:	681b      	ldr	r3, [r3, #0]
20007714:	4a1c      	ldr	r2, [pc, #112]	; (20007788 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd0>)
20007716:	4293      	cmp	r3, r2
20007718:	d004      	beq.n	20007724 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
2000771a:	687b      	ldr	r3, [r7, #4]
2000771c:	681b      	ldr	r3, [r3, #0]
2000771e:	4a1b      	ldr	r2, [pc, #108]	; (2000778c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd4>)
20007720:	4293      	cmp	r3, r2
20007722:	d101      	bne.n	20007728 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x70>
20007724:	2301      	movs	r3, #1
20007726:	e000      	b.n	2000772a <DMA_CalcDMAMUXRequestGenBaseAndMask+0x72>
20007728:	2300      	movs	r3, #0
2000772a:	2b00      	cmp	r3, #0
2000772c:	d00a      	beq.n	20007744 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x8c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
2000772e:	68fa      	ldr	r2, [r7, #12]
20007730:	4b17      	ldr	r3, [pc, #92]	; (20007790 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd8>)
20007732:	4413      	add	r3, r2
20007734:	009b      	lsls	r3, r3, #2
20007736:	461a      	mov	r2, r3
20007738:	687b      	ldr	r3, [r7, #4]
2000773a:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
2000773c:	687b      	ldr	r3, [r7, #4]
2000773e:	4a15      	ldr	r2, [pc, #84]	; (20007794 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xdc>)
20007740:	671a      	str	r2, [r3, #112]	; 0x70
20007742:	e009      	b.n	20007758 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xa0>
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
20007744:	68fa      	ldr	r2, [r7, #12]
20007746:	4b14      	ldr	r3, [pc, #80]	; (20007798 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe0>)
20007748:	4413      	add	r3, r2
2000774a:	009b      	lsls	r3, r3, #2
2000774c:	461a      	mov	r2, r3
2000774e:	687b      	ldr	r3, [r7, #4]
20007750:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
20007752:	687b      	ldr	r3, [r7, #4]
20007754:	4a11      	ldr	r2, [pc, #68]	; (2000779c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe4>)
20007756:	671a      	str	r2, [r3, #112]	; 0x70
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
20007758:	68fb      	ldr	r3, [r7, #12]
2000775a:	3b01      	subs	r3, #1
2000775c:	2201      	movs	r2, #1
2000775e:	409a      	lsls	r2, r3
20007760:	687b      	ldr	r3, [r7, #4]
20007762:	675a      	str	r2, [r3, #116]	; 0x74
  }
}
20007764:	bf00      	nop
20007766:	3714      	adds	r7, #20
20007768:	46bd      	mov	sp, r7
2000776a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000776e:	4770      	bx	lr
20007770:	58025408 	.word	0x58025408
20007774:	5802541c 	.word	0x5802541c
20007778:	58025430 	.word	0x58025430
2000777c:	58025444 	.word	0x58025444
20007780:	58025458 	.word	0x58025458
20007784:	5802546c 	.word	0x5802546c
20007788:	58025480 	.word	0x58025480
2000778c:	58025494 	.word	0x58025494
20007790:	1600963f 	.word	0x1600963f
20007794:	58025940 	.word	0x58025940
20007798:	1000823f 	.word	0x1000823f
2000779c:	40020940 	.word	0x40020940

200077a0 <HAL_DMAEx_MultiBufferStart>:
  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
200077a0:	b580      	push	{r7, lr}
200077a2:	b086      	sub	sp, #24
200077a4:	af00      	add	r7, sp, #0
200077a6:	60f8      	str	r0, [r7, #12]
200077a8:	60b9      	str	r1, [r7, #8]
200077aa:	607a      	str	r2, [r7, #4]
200077ac:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
200077ae:	2300      	movs	r3, #0
200077b0:	75fb      	strb	r3, [r7, #23]
  __IO uint32_t *ifcRegister_Base; /* DMA Stream Interrupt Clear register */

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
200077b2:	6a3b      	ldr	r3, [r7, #32]
200077b4:	2b00      	cmp	r3, #0
200077b6:	d003      	beq.n	200077c0 <HAL_DMAEx_MultiBufferStart+0x20>
200077b8:	6a3b      	ldr	r3, [r7, #32]
200077ba:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
200077be:	d303      	bcc.n	200077c8 <HAL_DMAEx_MultiBufferStart+0x28>
200077c0:	217f      	movs	r1, #127	; 0x7f
200077c2:	4888      	ldr	r0, [pc, #544]	; (200079e4 <HAL_DMAEx_MultiBufferStart+0x244>)
200077c4:	f7f9 f896 	bl	200008f4 <assert_failed>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
200077c8:	68fb      	ldr	r3, [r7, #12]
200077ca:	681b      	ldr	r3, [r3, #0]
200077cc:	4a86      	ldr	r2, [pc, #536]	; (200079e8 <HAL_DMAEx_MultiBufferStart+0x248>)
200077ce:	4293      	cmp	r3, r2
200077d0:	d076      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
200077d2:	68fb      	ldr	r3, [r7, #12]
200077d4:	681b      	ldr	r3, [r3, #0]
200077d6:	4a85      	ldr	r2, [pc, #532]	; (200079ec <HAL_DMAEx_MultiBufferStart+0x24c>)
200077d8:	4293      	cmp	r3, r2
200077da:	d071      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
200077dc:	68fb      	ldr	r3, [r7, #12]
200077de:	681b      	ldr	r3, [r3, #0]
200077e0:	4a83      	ldr	r2, [pc, #524]	; (200079f0 <HAL_DMAEx_MultiBufferStart+0x250>)
200077e2:	4293      	cmp	r3, r2
200077e4:	d06c      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
200077e6:	68fb      	ldr	r3, [r7, #12]
200077e8:	681b      	ldr	r3, [r3, #0]
200077ea:	4a82      	ldr	r2, [pc, #520]	; (200079f4 <HAL_DMAEx_MultiBufferStart+0x254>)
200077ec:	4293      	cmp	r3, r2
200077ee:	d067      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
200077f0:	68fb      	ldr	r3, [r7, #12]
200077f2:	681b      	ldr	r3, [r3, #0]
200077f4:	4a80      	ldr	r2, [pc, #512]	; (200079f8 <HAL_DMAEx_MultiBufferStart+0x258>)
200077f6:	4293      	cmp	r3, r2
200077f8:	d062      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
200077fa:	68fb      	ldr	r3, [r7, #12]
200077fc:	681b      	ldr	r3, [r3, #0]
200077fe:	4a7f      	ldr	r2, [pc, #508]	; (200079fc <HAL_DMAEx_MultiBufferStart+0x25c>)
20007800:	4293      	cmp	r3, r2
20007802:	d05d      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
20007804:	68fb      	ldr	r3, [r7, #12]
20007806:	681b      	ldr	r3, [r3, #0]
20007808:	4a7d      	ldr	r2, [pc, #500]	; (20007a00 <HAL_DMAEx_MultiBufferStart+0x260>)
2000780a:	4293      	cmp	r3, r2
2000780c:	d058      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
2000780e:	68fb      	ldr	r3, [r7, #12]
20007810:	681b      	ldr	r3, [r3, #0]
20007812:	4a7c      	ldr	r2, [pc, #496]	; (20007a04 <HAL_DMAEx_MultiBufferStart+0x264>)
20007814:	4293      	cmp	r3, r2
20007816:	d053      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
20007818:	68fb      	ldr	r3, [r7, #12]
2000781a:	681b      	ldr	r3, [r3, #0]
2000781c:	4a7a      	ldr	r2, [pc, #488]	; (20007a08 <HAL_DMAEx_MultiBufferStart+0x268>)
2000781e:	4293      	cmp	r3, r2
20007820:	d04e      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
20007822:	68fb      	ldr	r3, [r7, #12]
20007824:	681b      	ldr	r3, [r3, #0]
20007826:	4a79      	ldr	r2, [pc, #484]	; (20007a0c <HAL_DMAEx_MultiBufferStart+0x26c>)
20007828:	4293      	cmp	r3, r2
2000782a:	d049      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
2000782c:	68fb      	ldr	r3, [r7, #12]
2000782e:	681b      	ldr	r3, [r3, #0]
20007830:	4a77      	ldr	r2, [pc, #476]	; (20007a10 <HAL_DMAEx_MultiBufferStart+0x270>)
20007832:	4293      	cmp	r3, r2
20007834:	d044      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
20007836:	68fb      	ldr	r3, [r7, #12]
20007838:	681b      	ldr	r3, [r3, #0]
2000783a:	4a76      	ldr	r2, [pc, #472]	; (20007a14 <HAL_DMAEx_MultiBufferStart+0x274>)
2000783c:	4293      	cmp	r3, r2
2000783e:	d03f      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
20007840:	68fb      	ldr	r3, [r7, #12]
20007842:	681b      	ldr	r3, [r3, #0]
20007844:	4a74      	ldr	r2, [pc, #464]	; (20007a18 <HAL_DMAEx_MultiBufferStart+0x278>)
20007846:	4293      	cmp	r3, r2
20007848:	d03a      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
2000784a:	68fb      	ldr	r3, [r7, #12]
2000784c:	681b      	ldr	r3, [r3, #0]
2000784e:	4a73      	ldr	r2, [pc, #460]	; (20007a1c <HAL_DMAEx_MultiBufferStart+0x27c>)
20007850:	4293      	cmp	r3, r2
20007852:	d035      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
20007854:	68fb      	ldr	r3, [r7, #12]
20007856:	681b      	ldr	r3, [r3, #0]
20007858:	4a71      	ldr	r2, [pc, #452]	; (20007a20 <HAL_DMAEx_MultiBufferStart+0x280>)
2000785a:	4293      	cmp	r3, r2
2000785c:	d030      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
2000785e:	68fb      	ldr	r3, [r7, #12]
20007860:	681b      	ldr	r3, [r3, #0]
20007862:	4a70      	ldr	r2, [pc, #448]	; (20007a24 <HAL_DMAEx_MultiBufferStart+0x284>)
20007864:	4293      	cmp	r3, r2
20007866:	d02b      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
20007868:	68fb      	ldr	r3, [r7, #12]
2000786a:	681b      	ldr	r3, [r3, #0]
2000786c:	4a6e      	ldr	r2, [pc, #440]	; (20007a28 <HAL_DMAEx_MultiBufferStart+0x288>)
2000786e:	4293      	cmp	r3, r2
20007870:	d026      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
20007872:	68fb      	ldr	r3, [r7, #12]
20007874:	681b      	ldr	r3, [r3, #0]
20007876:	4a6d      	ldr	r2, [pc, #436]	; (20007a2c <HAL_DMAEx_MultiBufferStart+0x28c>)
20007878:	4293      	cmp	r3, r2
2000787a:	d021      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
2000787c:	68fb      	ldr	r3, [r7, #12]
2000787e:	681b      	ldr	r3, [r3, #0]
20007880:	4a6b      	ldr	r2, [pc, #428]	; (20007a30 <HAL_DMAEx_MultiBufferStart+0x290>)
20007882:	4293      	cmp	r3, r2
20007884:	d01c      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
20007886:	68fb      	ldr	r3, [r7, #12]
20007888:	681b      	ldr	r3, [r3, #0]
2000788a:	4a6a      	ldr	r2, [pc, #424]	; (20007a34 <HAL_DMAEx_MultiBufferStart+0x294>)
2000788c:	4293      	cmp	r3, r2
2000788e:	d017      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
20007890:	68fb      	ldr	r3, [r7, #12]
20007892:	681b      	ldr	r3, [r3, #0]
20007894:	4a68      	ldr	r2, [pc, #416]	; (20007a38 <HAL_DMAEx_MultiBufferStart+0x298>)
20007896:	4293      	cmp	r3, r2
20007898:	d012      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
2000789a:	68fb      	ldr	r3, [r7, #12]
2000789c:	681b      	ldr	r3, [r3, #0]
2000789e:	4a67      	ldr	r2, [pc, #412]	; (20007a3c <HAL_DMAEx_MultiBufferStart+0x29c>)
200078a0:	4293      	cmp	r3, r2
200078a2:	d00d      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
200078a4:	68fb      	ldr	r3, [r7, #12]
200078a6:	681b      	ldr	r3, [r3, #0]
200078a8:	4a65      	ldr	r2, [pc, #404]	; (20007a40 <HAL_DMAEx_MultiBufferStart+0x2a0>)
200078aa:	4293      	cmp	r3, r2
200078ac:	d008      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
200078ae:	68fb      	ldr	r3, [r7, #12]
200078b0:	681b      	ldr	r3, [r3, #0]
200078b2:	4a64      	ldr	r2, [pc, #400]	; (20007a44 <HAL_DMAEx_MultiBufferStart+0x2a4>)
200078b4:	4293      	cmp	r3, r2
200078b6:	d003      	beq.n	200078c0 <HAL_DMAEx_MultiBufferStart+0x120>
200078b8:	2180      	movs	r1, #128	; 0x80
200078ba:	484a      	ldr	r0, [pc, #296]	; (200079e4 <HAL_DMAEx_MultiBufferStart+0x244>)
200078bc:	f7f9 f81a 	bl	200008f4 <assert_failed>

  /* Memory-to-memory transfer not supported in double buffering mode */
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
200078c0:	68fb      	ldr	r3, [r7, #12]
200078c2:	689b      	ldr	r3, [r3, #8]
200078c4:	2b80      	cmp	r3, #128	; 0x80
200078c6:	d106      	bne.n	200078d6 <HAL_DMAEx_MultiBufferStart+0x136>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
200078c8:	68fb      	ldr	r3, [r7, #12]
200078ca:	f44f 7280 	mov.w	r2, #256	; 0x100
200078ce:	655a      	str	r2, [r3, #84]	; 0x54
    status = HAL_ERROR;
200078d0:	2301      	movs	r3, #1
200078d2:	75fb      	strb	r3, [r7, #23]
200078d4:	e1ca      	b.n	20007c6c <HAL_DMAEx_MultiBufferStart+0x4cc>
  }
  else
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
200078d6:	68fb      	ldr	r3, [r7, #12]
200078d8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
200078dc:	2b01      	cmp	r3, #1
200078de:	d101      	bne.n	200078e4 <HAL_DMAEx_MultiBufferStart+0x144>
200078e0:	2302      	movs	r3, #2
200078e2:	e1c4      	b.n	20007c6e <HAL_DMAEx_MultiBufferStart+0x4ce>
200078e4:	68fb      	ldr	r3, [r7, #12]
200078e6:	2201      	movs	r2, #1
200078e8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    if(HAL_DMA_STATE_READY == hdma->State)
200078ec:	68fb      	ldr	r3, [r7, #12]
200078ee:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
200078f2:	b2db      	uxtb	r3, r3
200078f4:	2b01      	cmp	r3, #1
200078f6:	f040 81b3 	bne.w	20007c60 <HAL_DMAEx_MultiBufferStart+0x4c0>
    {
      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_BUSY;
200078fa:	68fb      	ldr	r3, [r7, #12]
200078fc:	2202      	movs	r2, #2
200078fe:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Initialize the error code */
      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
20007902:	68fb      	ldr	r3, [r7, #12]
20007904:	2200      	movs	r2, #0
20007906:	655a      	str	r2, [r3, #84]	; 0x54

      if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20007908:	68fb      	ldr	r3, [r7, #12]
2000790a:	681b      	ldr	r3, [r3, #0]
2000790c:	4a36      	ldr	r2, [pc, #216]	; (200079e8 <HAL_DMAEx_MultiBufferStart+0x248>)
2000790e:	4293      	cmp	r3, r2
20007910:	d04a      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
20007912:	68fb      	ldr	r3, [r7, #12]
20007914:	681b      	ldr	r3, [r3, #0]
20007916:	4a35      	ldr	r2, [pc, #212]	; (200079ec <HAL_DMAEx_MultiBufferStart+0x24c>)
20007918:	4293      	cmp	r3, r2
2000791a:	d045      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
2000791c:	68fb      	ldr	r3, [r7, #12]
2000791e:	681b      	ldr	r3, [r3, #0]
20007920:	4a33      	ldr	r2, [pc, #204]	; (200079f0 <HAL_DMAEx_MultiBufferStart+0x250>)
20007922:	4293      	cmp	r3, r2
20007924:	d040      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
20007926:	68fb      	ldr	r3, [r7, #12]
20007928:	681b      	ldr	r3, [r3, #0]
2000792a:	4a32      	ldr	r2, [pc, #200]	; (200079f4 <HAL_DMAEx_MultiBufferStart+0x254>)
2000792c:	4293      	cmp	r3, r2
2000792e:	d03b      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
20007930:	68fb      	ldr	r3, [r7, #12]
20007932:	681b      	ldr	r3, [r3, #0]
20007934:	4a30      	ldr	r2, [pc, #192]	; (200079f8 <HAL_DMAEx_MultiBufferStart+0x258>)
20007936:	4293      	cmp	r3, r2
20007938:	d036      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
2000793a:	68fb      	ldr	r3, [r7, #12]
2000793c:	681b      	ldr	r3, [r3, #0]
2000793e:	4a2f      	ldr	r2, [pc, #188]	; (200079fc <HAL_DMAEx_MultiBufferStart+0x25c>)
20007940:	4293      	cmp	r3, r2
20007942:	d031      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
20007944:	68fb      	ldr	r3, [r7, #12]
20007946:	681b      	ldr	r3, [r3, #0]
20007948:	4a2d      	ldr	r2, [pc, #180]	; (20007a00 <HAL_DMAEx_MultiBufferStart+0x260>)
2000794a:	4293      	cmp	r3, r2
2000794c:	d02c      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
2000794e:	68fb      	ldr	r3, [r7, #12]
20007950:	681b      	ldr	r3, [r3, #0]
20007952:	4a2c      	ldr	r2, [pc, #176]	; (20007a04 <HAL_DMAEx_MultiBufferStart+0x264>)
20007954:	4293      	cmp	r3, r2
20007956:	d027      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
20007958:	68fb      	ldr	r3, [r7, #12]
2000795a:	681b      	ldr	r3, [r3, #0]
2000795c:	4a2a      	ldr	r2, [pc, #168]	; (20007a08 <HAL_DMAEx_MultiBufferStart+0x268>)
2000795e:	4293      	cmp	r3, r2
20007960:	d022      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
20007962:	68fb      	ldr	r3, [r7, #12]
20007964:	681b      	ldr	r3, [r3, #0]
20007966:	4a29      	ldr	r2, [pc, #164]	; (20007a0c <HAL_DMAEx_MultiBufferStart+0x26c>)
20007968:	4293      	cmp	r3, r2
2000796a:	d01d      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
2000796c:	68fb      	ldr	r3, [r7, #12]
2000796e:	681b      	ldr	r3, [r3, #0]
20007970:	4a27      	ldr	r2, [pc, #156]	; (20007a10 <HAL_DMAEx_MultiBufferStart+0x270>)
20007972:	4293      	cmp	r3, r2
20007974:	d018      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
20007976:	68fb      	ldr	r3, [r7, #12]
20007978:	681b      	ldr	r3, [r3, #0]
2000797a:	4a26      	ldr	r2, [pc, #152]	; (20007a14 <HAL_DMAEx_MultiBufferStart+0x274>)
2000797c:	4293      	cmp	r3, r2
2000797e:	d013      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
20007980:	68fb      	ldr	r3, [r7, #12]
20007982:	681b      	ldr	r3, [r3, #0]
20007984:	4a24      	ldr	r2, [pc, #144]	; (20007a18 <HAL_DMAEx_MultiBufferStart+0x278>)
20007986:	4293      	cmp	r3, r2
20007988:	d00e      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
2000798a:	68fb      	ldr	r3, [r7, #12]
2000798c:	681b      	ldr	r3, [r3, #0]
2000798e:	4a23      	ldr	r2, [pc, #140]	; (20007a1c <HAL_DMAEx_MultiBufferStart+0x27c>)
20007990:	4293      	cmp	r3, r2
20007992:	d009      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
20007994:	68fb      	ldr	r3, [r7, #12]
20007996:	681b      	ldr	r3, [r3, #0]
20007998:	4a21      	ldr	r2, [pc, #132]	; (20007a20 <HAL_DMAEx_MultiBufferStart+0x280>)
2000799a:	4293      	cmp	r3, r2
2000799c:	d004      	beq.n	200079a8 <HAL_DMAEx_MultiBufferStart+0x208>
2000799e:	68fb      	ldr	r3, [r7, #12]
200079a0:	681b      	ldr	r3, [r3, #0]
200079a2:	4a20      	ldr	r2, [pc, #128]	; (20007a24 <HAL_DMAEx_MultiBufferStart+0x284>)
200079a4:	4293      	cmp	r3, r2
200079a6:	d101      	bne.n	200079ac <HAL_DMAEx_MultiBufferStart+0x20c>
200079a8:	2301      	movs	r3, #1
200079aa:	e000      	b.n	200079ae <HAL_DMAEx_MultiBufferStart+0x20e>
200079ac:	2300      	movs	r3, #0
200079ae:	2b00      	cmp	r3, #0
200079b0:	d04a      	beq.n	20007a48 <HAL_DMAEx_MultiBufferStart+0x2a8>
      {
        /* Enable the Double buffer mode */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
200079b2:	68fb      	ldr	r3, [r7, #12]
200079b4:	681b      	ldr	r3, [r3, #0]
200079b6:	681a      	ldr	r2, [r3, #0]
200079b8:	68fb      	ldr	r3, [r7, #12]
200079ba:	681b      	ldr	r3, [r3, #0]
200079bc:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
200079c0:	601a      	str	r2, [r3, #0]

        /* Configure DMA Stream destination address */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
200079c2:	68fb      	ldr	r3, [r7, #12]
200079c4:	681b      	ldr	r3, [r3, #0]
200079c6:	683a      	ldr	r2, [r7, #0]
200079c8:	611a      	str	r2, [r3, #16]

        /* Calculate the interrupt clear flag register (IFCR) base address  */
        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));
200079ca:	68fb      	ldr	r3, [r7, #12]
200079cc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200079ce:	3308      	adds	r3, #8
200079d0:	613b      	str	r3, [r7, #16]

        /* Clear all flags */
        *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
200079d2:	68fb      	ldr	r3, [r7, #12]
200079d4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200079d6:	f003 031f 	and.w	r3, r3, #31
200079da:	223f      	movs	r2, #63	; 0x3f
200079dc:	409a      	lsls	r2, r3
200079de:	693b      	ldr	r3, [r7, #16]
200079e0:	601a      	str	r2, [r3, #0]
200079e2:	e04a      	b.n	20007a7a <HAL_DMAEx_MultiBufferStart+0x2da>
200079e4:	2001c014 	.word	0x2001c014
200079e8:	40020010 	.word	0x40020010
200079ec:	40020028 	.word	0x40020028
200079f0:	40020040 	.word	0x40020040
200079f4:	40020058 	.word	0x40020058
200079f8:	40020070 	.word	0x40020070
200079fc:	40020088 	.word	0x40020088
20007a00:	400200a0 	.word	0x400200a0
20007a04:	400200b8 	.word	0x400200b8
20007a08:	40020410 	.word	0x40020410
20007a0c:	40020428 	.word	0x40020428
20007a10:	40020440 	.word	0x40020440
20007a14:	40020458 	.word	0x40020458
20007a18:	40020470 	.word	0x40020470
20007a1c:	40020488 	.word	0x40020488
20007a20:	400204a0 	.word	0x400204a0
20007a24:	400204b8 	.word	0x400204b8
20007a28:	58025408 	.word	0x58025408
20007a2c:	5802541c 	.word	0x5802541c
20007a30:	58025430 	.word	0x58025430
20007a34:	58025444 	.word	0x58025444
20007a38:	58025458 	.word	0x58025458
20007a3c:	5802546c 	.word	0x5802546c
20007a40:	58025480 	.word	0x58025480
20007a44:	58025494 	.word	0x58025494
      }
      else /* BDMA instance(s) */
      {
        /* Enable the Double buffer mode */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
20007a48:	68fb      	ldr	r3, [r7, #12]
20007a4a:	681b      	ldr	r3, [r3, #0]
20007a4c:	6819      	ldr	r1, [r3, #0]
20007a4e:	68fb      	ldr	r3, [r7, #12]
20007a50:	681a      	ldr	r2, [r3, #0]
20007a52:	f248 0320 	movw	r3, #32800	; 0x8020
20007a56:	430b      	orrs	r3, r1
20007a58:	6013      	str	r3, [r2, #0]

        /* Configure DMA Stream destination address */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
20007a5a:	68fb      	ldr	r3, [r7, #12]
20007a5c:	681b      	ldr	r3, [r3, #0]
20007a5e:	683a      	ldr	r2, [r7, #0]
20007a60:	611a      	str	r2, [r3, #16]

        /* Calculate the interrupt clear flag register (IFCR) base address  */
        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));
20007a62:	68fb      	ldr	r3, [r7, #12]
20007a64:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20007a66:	3304      	adds	r3, #4
20007a68:	613b      	str	r3, [r7, #16]

        /* Clear all flags */
        *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
20007a6a:	68fb      	ldr	r3, [r7, #12]
20007a6c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20007a6e:	f003 031f 	and.w	r3, r3, #31
20007a72:	2201      	movs	r2, #1
20007a74:	409a      	lsls	r2, r3
20007a76:	693b      	ldr	r3, [r7, #16]
20007a78:	601a      	str	r2, [r3, #0]
      }

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
20007a7a:	68fb      	ldr	r3, [r7, #12]
20007a7c:	681b      	ldr	r3, [r3, #0]
20007a7e:	4a7e      	ldr	r2, [pc, #504]	; (20007c78 <HAL_DMAEx_MultiBufferStart+0x4d8>)
20007a80:	4293      	cmp	r3, r2
20007a82:	d072      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007a84:	68fb      	ldr	r3, [r7, #12]
20007a86:	681b      	ldr	r3, [r3, #0]
20007a88:	4a7c      	ldr	r2, [pc, #496]	; (20007c7c <HAL_DMAEx_MultiBufferStart+0x4dc>)
20007a8a:	4293      	cmp	r3, r2
20007a8c:	d06d      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007a8e:	68fb      	ldr	r3, [r7, #12]
20007a90:	681b      	ldr	r3, [r3, #0]
20007a92:	4a7b      	ldr	r2, [pc, #492]	; (20007c80 <HAL_DMAEx_MultiBufferStart+0x4e0>)
20007a94:	4293      	cmp	r3, r2
20007a96:	d068      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007a98:	68fb      	ldr	r3, [r7, #12]
20007a9a:	681b      	ldr	r3, [r3, #0]
20007a9c:	4a79      	ldr	r2, [pc, #484]	; (20007c84 <HAL_DMAEx_MultiBufferStart+0x4e4>)
20007a9e:	4293      	cmp	r3, r2
20007aa0:	d063      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007aa2:	68fb      	ldr	r3, [r7, #12]
20007aa4:	681b      	ldr	r3, [r3, #0]
20007aa6:	4a78      	ldr	r2, [pc, #480]	; (20007c88 <HAL_DMAEx_MultiBufferStart+0x4e8>)
20007aa8:	4293      	cmp	r3, r2
20007aaa:	d05e      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007aac:	68fb      	ldr	r3, [r7, #12]
20007aae:	681b      	ldr	r3, [r3, #0]
20007ab0:	4a76      	ldr	r2, [pc, #472]	; (20007c8c <HAL_DMAEx_MultiBufferStart+0x4ec>)
20007ab2:	4293      	cmp	r3, r2
20007ab4:	d059      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007ab6:	68fb      	ldr	r3, [r7, #12]
20007ab8:	681b      	ldr	r3, [r3, #0]
20007aba:	4a75      	ldr	r2, [pc, #468]	; (20007c90 <HAL_DMAEx_MultiBufferStart+0x4f0>)
20007abc:	4293      	cmp	r3, r2
20007abe:	d054      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007ac0:	68fb      	ldr	r3, [r7, #12]
20007ac2:	681b      	ldr	r3, [r3, #0]
20007ac4:	4a73      	ldr	r2, [pc, #460]	; (20007c94 <HAL_DMAEx_MultiBufferStart+0x4f4>)
20007ac6:	4293      	cmp	r3, r2
20007ac8:	d04f      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007aca:	68fb      	ldr	r3, [r7, #12]
20007acc:	681b      	ldr	r3, [r3, #0]
20007ace:	4a72      	ldr	r2, [pc, #456]	; (20007c98 <HAL_DMAEx_MultiBufferStart+0x4f8>)
20007ad0:	4293      	cmp	r3, r2
20007ad2:	d04a      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007ad4:	68fb      	ldr	r3, [r7, #12]
20007ad6:	681b      	ldr	r3, [r3, #0]
20007ad8:	4a70      	ldr	r2, [pc, #448]	; (20007c9c <HAL_DMAEx_MultiBufferStart+0x4fc>)
20007ada:	4293      	cmp	r3, r2
20007adc:	d045      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007ade:	68fb      	ldr	r3, [r7, #12]
20007ae0:	681b      	ldr	r3, [r3, #0]
20007ae2:	4a6f      	ldr	r2, [pc, #444]	; (20007ca0 <HAL_DMAEx_MultiBufferStart+0x500>)
20007ae4:	4293      	cmp	r3, r2
20007ae6:	d040      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007ae8:	68fb      	ldr	r3, [r7, #12]
20007aea:	681b      	ldr	r3, [r3, #0]
20007aec:	4a6d      	ldr	r2, [pc, #436]	; (20007ca4 <HAL_DMAEx_MultiBufferStart+0x504>)
20007aee:	4293      	cmp	r3, r2
20007af0:	d03b      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007af2:	68fb      	ldr	r3, [r7, #12]
20007af4:	681b      	ldr	r3, [r3, #0]
20007af6:	4a6c      	ldr	r2, [pc, #432]	; (20007ca8 <HAL_DMAEx_MultiBufferStart+0x508>)
20007af8:	4293      	cmp	r3, r2
20007afa:	d036      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007afc:	68fb      	ldr	r3, [r7, #12]
20007afe:	681b      	ldr	r3, [r3, #0]
20007b00:	4a6a      	ldr	r2, [pc, #424]	; (20007cac <HAL_DMAEx_MultiBufferStart+0x50c>)
20007b02:	4293      	cmp	r3, r2
20007b04:	d031      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007b06:	68fb      	ldr	r3, [r7, #12]
20007b08:	681b      	ldr	r3, [r3, #0]
20007b0a:	4a69      	ldr	r2, [pc, #420]	; (20007cb0 <HAL_DMAEx_MultiBufferStart+0x510>)
20007b0c:	4293      	cmp	r3, r2
20007b0e:	d02c      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007b10:	68fb      	ldr	r3, [r7, #12]
20007b12:	681b      	ldr	r3, [r3, #0]
20007b14:	4a67      	ldr	r2, [pc, #412]	; (20007cb4 <HAL_DMAEx_MultiBufferStart+0x514>)
20007b16:	4293      	cmp	r3, r2
20007b18:	d027      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007b1a:	68fb      	ldr	r3, [r7, #12]
20007b1c:	681b      	ldr	r3, [r3, #0]
20007b1e:	4a66      	ldr	r2, [pc, #408]	; (20007cb8 <HAL_DMAEx_MultiBufferStart+0x518>)
20007b20:	4293      	cmp	r3, r2
20007b22:	d022      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007b24:	68fb      	ldr	r3, [r7, #12]
20007b26:	681b      	ldr	r3, [r3, #0]
20007b28:	4a64      	ldr	r2, [pc, #400]	; (20007cbc <HAL_DMAEx_MultiBufferStart+0x51c>)
20007b2a:	4293      	cmp	r3, r2
20007b2c:	d01d      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007b2e:	68fb      	ldr	r3, [r7, #12]
20007b30:	681b      	ldr	r3, [r3, #0]
20007b32:	4a63      	ldr	r2, [pc, #396]	; (20007cc0 <HAL_DMAEx_MultiBufferStart+0x520>)
20007b34:	4293      	cmp	r3, r2
20007b36:	d018      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007b38:	68fb      	ldr	r3, [r7, #12]
20007b3a:	681b      	ldr	r3, [r3, #0]
20007b3c:	4a61      	ldr	r2, [pc, #388]	; (20007cc4 <HAL_DMAEx_MultiBufferStart+0x524>)
20007b3e:	4293      	cmp	r3, r2
20007b40:	d013      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007b42:	68fb      	ldr	r3, [r7, #12]
20007b44:	681b      	ldr	r3, [r3, #0]
20007b46:	4a60      	ldr	r2, [pc, #384]	; (20007cc8 <HAL_DMAEx_MultiBufferStart+0x528>)
20007b48:	4293      	cmp	r3, r2
20007b4a:	d00e      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007b4c:	68fb      	ldr	r3, [r7, #12]
20007b4e:	681b      	ldr	r3, [r3, #0]
20007b50:	4a5e      	ldr	r2, [pc, #376]	; (20007ccc <HAL_DMAEx_MultiBufferStart+0x52c>)
20007b52:	4293      	cmp	r3, r2
20007b54:	d009      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007b56:	68fb      	ldr	r3, [r7, #12]
20007b58:	681b      	ldr	r3, [r3, #0]
20007b5a:	4a5d      	ldr	r2, [pc, #372]	; (20007cd0 <HAL_DMAEx_MultiBufferStart+0x530>)
20007b5c:	4293      	cmp	r3, r2
20007b5e:	d004      	beq.n	20007b6a <HAL_DMAEx_MultiBufferStart+0x3ca>
20007b60:	68fb      	ldr	r3, [r7, #12]
20007b62:	681b      	ldr	r3, [r3, #0]
20007b64:	4a5b      	ldr	r2, [pc, #364]	; (20007cd4 <HAL_DMAEx_MultiBufferStart+0x534>)
20007b66:	4293      	cmp	r3, r2
20007b68:	d101      	bne.n	20007b6e <HAL_DMAEx_MultiBufferStart+0x3ce>
20007b6a:	2301      	movs	r3, #1
20007b6c:	e000      	b.n	20007b70 <HAL_DMAEx_MultiBufferStart+0x3d0>
20007b6e:	2300      	movs	r3, #0
20007b70:	2b00      	cmp	r3, #0
20007b72:	d013      	beq.n	20007b9c <HAL_DMAEx_MultiBufferStart+0x3fc>
      {
        /* Configure the source, destination address and the data length */
        DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
20007b74:	6a3b      	ldr	r3, [r7, #32]
20007b76:	687a      	ldr	r2, [r7, #4]
20007b78:	68b9      	ldr	r1, [r7, #8]
20007b7a:	68f8      	ldr	r0, [r7, #12]
20007b7c:	f001 fa5a 	bl	20009034 <DMA_MultiBufferSetConfig>

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
20007b80:	68fb      	ldr	r3, [r7, #12]
20007b82:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20007b84:	68fa      	ldr	r2, [r7, #12]
20007b86:	6e92      	ldr	r2, [r2, #104]	; 0x68
20007b88:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
20007b8a:	68fb      	ldr	r3, [r7, #12]
20007b8c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20007b8e:	2b00      	cmp	r3, #0
20007b90:	d004      	beq.n	20007b9c <HAL_DMAEx_MultiBufferStart+0x3fc>
        {
          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
20007b92:	68fb      	ldr	r3, [r7, #12]
20007b94:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20007b96:	68fa      	ldr	r2, [r7, #12]
20007b98:	6f52      	ldr	r2, [r2, #116]	; 0x74
20007b9a:	605a      	str	r2, [r3, #4]
        }
      }

      /* Enable the peripheral */
      __HAL_DMA_ENABLE(hdma);
20007b9c:	68fb      	ldr	r3, [r7, #12]
20007b9e:	681b      	ldr	r3, [r3, #0]
20007ba0:	4a35      	ldr	r2, [pc, #212]	; (20007c78 <HAL_DMAEx_MultiBufferStart+0x4d8>)
20007ba2:	4293      	cmp	r3, r2
20007ba4:	d04a      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007ba6:	68fb      	ldr	r3, [r7, #12]
20007ba8:	681b      	ldr	r3, [r3, #0]
20007baa:	4a34      	ldr	r2, [pc, #208]	; (20007c7c <HAL_DMAEx_MultiBufferStart+0x4dc>)
20007bac:	4293      	cmp	r3, r2
20007bae:	d045      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007bb0:	68fb      	ldr	r3, [r7, #12]
20007bb2:	681b      	ldr	r3, [r3, #0]
20007bb4:	4a32      	ldr	r2, [pc, #200]	; (20007c80 <HAL_DMAEx_MultiBufferStart+0x4e0>)
20007bb6:	4293      	cmp	r3, r2
20007bb8:	d040      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007bba:	68fb      	ldr	r3, [r7, #12]
20007bbc:	681b      	ldr	r3, [r3, #0]
20007bbe:	4a31      	ldr	r2, [pc, #196]	; (20007c84 <HAL_DMAEx_MultiBufferStart+0x4e4>)
20007bc0:	4293      	cmp	r3, r2
20007bc2:	d03b      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007bc4:	68fb      	ldr	r3, [r7, #12]
20007bc6:	681b      	ldr	r3, [r3, #0]
20007bc8:	4a2f      	ldr	r2, [pc, #188]	; (20007c88 <HAL_DMAEx_MultiBufferStart+0x4e8>)
20007bca:	4293      	cmp	r3, r2
20007bcc:	d036      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007bce:	68fb      	ldr	r3, [r7, #12]
20007bd0:	681b      	ldr	r3, [r3, #0]
20007bd2:	4a2e      	ldr	r2, [pc, #184]	; (20007c8c <HAL_DMAEx_MultiBufferStart+0x4ec>)
20007bd4:	4293      	cmp	r3, r2
20007bd6:	d031      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007bd8:	68fb      	ldr	r3, [r7, #12]
20007bda:	681b      	ldr	r3, [r3, #0]
20007bdc:	4a2c      	ldr	r2, [pc, #176]	; (20007c90 <HAL_DMAEx_MultiBufferStart+0x4f0>)
20007bde:	4293      	cmp	r3, r2
20007be0:	d02c      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007be2:	68fb      	ldr	r3, [r7, #12]
20007be4:	681b      	ldr	r3, [r3, #0]
20007be6:	4a2b      	ldr	r2, [pc, #172]	; (20007c94 <HAL_DMAEx_MultiBufferStart+0x4f4>)
20007be8:	4293      	cmp	r3, r2
20007bea:	d027      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007bec:	68fb      	ldr	r3, [r7, #12]
20007bee:	681b      	ldr	r3, [r3, #0]
20007bf0:	4a29      	ldr	r2, [pc, #164]	; (20007c98 <HAL_DMAEx_MultiBufferStart+0x4f8>)
20007bf2:	4293      	cmp	r3, r2
20007bf4:	d022      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007bf6:	68fb      	ldr	r3, [r7, #12]
20007bf8:	681b      	ldr	r3, [r3, #0]
20007bfa:	4a28      	ldr	r2, [pc, #160]	; (20007c9c <HAL_DMAEx_MultiBufferStart+0x4fc>)
20007bfc:	4293      	cmp	r3, r2
20007bfe:	d01d      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007c00:	68fb      	ldr	r3, [r7, #12]
20007c02:	681b      	ldr	r3, [r3, #0]
20007c04:	4a26      	ldr	r2, [pc, #152]	; (20007ca0 <HAL_DMAEx_MultiBufferStart+0x500>)
20007c06:	4293      	cmp	r3, r2
20007c08:	d018      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007c0a:	68fb      	ldr	r3, [r7, #12]
20007c0c:	681b      	ldr	r3, [r3, #0]
20007c0e:	4a25      	ldr	r2, [pc, #148]	; (20007ca4 <HAL_DMAEx_MultiBufferStart+0x504>)
20007c10:	4293      	cmp	r3, r2
20007c12:	d013      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007c14:	68fb      	ldr	r3, [r7, #12]
20007c16:	681b      	ldr	r3, [r3, #0]
20007c18:	4a23      	ldr	r2, [pc, #140]	; (20007ca8 <HAL_DMAEx_MultiBufferStart+0x508>)
20007c1a:	4293      	cmp	r3, r2
20007c1c:	d00e      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007c1e:	68fb      	ldr	r3, [r7, #12]
20007c20:	681b      	ldr	r3, [r3, #0]
20007c22:	4a22      	ldr	r2, [pc, #136]	; (20007cac <HAL_DMAEx_MultiBufferStart+0x50c>)
20007c24:	4293      	cmp	r3, r2
20007c26:	d009      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007c28:	68fb      	ldr	r3, [r7, #12]
20007c2a:	681b      	ldr	r3, [r3, #0]
20007c2c:	4a20      	ldr	r2, [pc, #128]	; (20007cb0 <HAL_DMAEx_MultiBufferStart+0x510>)
20007c2e:	4293      	cmp	r3, r2
20007c30:	d004      	beq.n	20007c3c <HAL_DMAEx_MultiBufferStart+0x49c>
20007c32:	68fb      	ldr	r3, [r7, #12]
20007c34:	681b      	ldr	r3, [r3, #0]
20007c36:	4a1f      	ldr	r2, [pc, #124]	; (20007cb4 <HAL_DMAEx_MultiBufferStart+0x514>)
20007c38:	4293      	cmp	r3, r2
20007c3a:	d108      	bne.n	20007c4e <HAL_DMAEx_MultiBufferStart+0x4ae>
20007c3c:	68fb      	ldr	r3, [r7, #12]
20007c3e:	681b      	ldr	r3, [r3, #0]
20007c40:	681a      	ldr	r2, [r3, #0]
20007c42:	68fb      	ldr	r3, [r7, #12]
20007c44:	681b      	ldr	r3, [r3, #0]
20007c46:	f042 0201 	orr.w	r2, r2, #1
20007c4a:	601a      	str	r2, [r3, #0]
20007c4c:	e00e      	b.n	20007c6c <HAL_DMAEx_MultiBufferStart+0x4cc>
20007c4e:	68fb      	ldr	r3, [r7, #12]
20007c50:	681b      	ldr	r3, [r3, #0]
20007c52:	681a      	ldr	r2, [r3, #0]
20007c54:	68fb      	ldr	r3, [r7, #12]
20007c56:	681b      	ldr	r3, [r3, #0]
20007c58:	f042 0201 	orr.w	r2, r2, #1
20007c5c:	601a      	str	r2, [r3, #0]
20007c5e:	e005      	b.n	20007c6c <HAL_DMAEx_MultiBufferStart+0x4cc>
    }
    else
    {
      /* Set the error code to busy */
      hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
20007c60:	68fb      	ldr	r3, [r7, #12]
20007c62:	f44f 6200 	mov.w	r2, #2048	; 0x800
20007c66:	655a      	str	r2, [r3, #84]	; 0x54

      /* Return error status */
      status = HAL_ERROR;
20007c68:	2301      	movs	r3, #1
20007c6a:	75fb      	strb	r3, [r7, #23]
    }
  }
  return status;
20007c6c:	7dfb      	ldrb	r3, [r7, #23]
}
20007c6e:	4618      	mov	r0, r3
20007c70:	3718      	adds	r7, #24
20007c72:	46bd      	mov	sp, r7
20007c74:	bd80      	pop	{r7, pc}
20007c76:	bf00      	nop
20007c78:	40020010 	.word	0x40020010
20007c7c:	40020028 	.word	0x40020028
20007c80:	40020040 	.word	0x40020040
20007c84:	40020058 	.word	0x40020058
20007c88:	40020070 	.word	0x40020070
20007c8c:	40020088 	.word	0x40020088
20007c90:	400200a0 	.word	0x400200a0
20007c94:	400200b8 	.word	0x400200b8
20007c98:	40020410 	.word	0x40020410
20007c9c:	40020428 	.word	0x40020428
20007ca0:	40020440 	.word	0x40020440
20007ca4:	40020458 	.word	0x40020458
20007ca8:	40020470 	.word	0x40020470
20007cac:	40020488 	.word	0x40020488
20007cb0:	400204a0 	.word	0x400204a0
20007cb4:	400204b8 	.word	0x400204b8
20007cb8:	58025408 	.word	0x58025408
20007cbc:	5802541c 	.word	0x5802541c
20007cc0:	58025430 	.word	0x58025430
20007cc4:	58025444 	.word	0x58025444
20007cc8:	58025458 	.word	0x58025458
20007ccc:	5802546c 	.word	0x5802546c
20007cd0:	58025480 	.word	0x58025480
20007cd4:	58025494 	.word	0x58025494

20007cd8 <HAL_DMAEx_MultiBufferStart_IT>:
  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
20007cd8:	b580      	push	{r7, lr}
20007cda:	b086      	sub	sp, #24
20007cdc:	af00      	add	r7, sp, #0
20007cde:	60f8      	str	r0, [r7, #12]
20007ce0:	60b9      	str	r1, [r7, #8]
20007ce2:	607a      	str	r2, [r7, #4]
20007ce4:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20007ce6:	2300      	movs	r3, #0
20007ce8:	75fb      	strb	r3, [r7, #23]
  __IO uint32_t *ifcRegister_Base; /* DMA Stream Interrupt Clear register */

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
20007cea:	6a3b      	ldr	r3, [r7, #32]
20007cec:	2b00      	cmp	r3, #0
20007cee:	d003      	beq.n	20007cf8 <HAL_DMAEx_MultiBufferStart_IT+0x20>
20007cf0:	6a3b      	ldr	r3, [r7, #32]
20007cf2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20007cf6:	d303      	bcc.n	20007d00 <HAL_DMAEx_MultiBufferStart_IT+0x28>
20007cf8:	21e0      	movs	r1, #224	; 0xe0
20007cfa:	4888      	ldr	r0, [pc, #544]	; (20007f1c <HAL_DMAEx_MultiBufferStart_IT+0x244>)
20007cfc:	f7f8 fdfa 	bl	200008f4 <assert_failed>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
20007d00:	68fb      	ldr	r3, [r7, #12]
20007d02:	681b      	ldr	r3, [r3, #0]
20007d04:	4a86      	ldr	r2, [pc, #536]	; (20007f20 <HAL_DMAEx_MultiBufferStart_IT+0x248>)
20007d06:	4293      	cmp	r3, r2
20007d08:	d076      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d0a:	68fb      	ldr	r3, [r7, #12]
20007d0c:	681b      	ldr	r3, [r3, #0]
20007d0e:	4a85      	ldr	r2, [pc, #532]	; (20007f24 <HAL_DMAEx_MultiBufferStart_IT+0x24c>)
20007d10:	4293      	cmp	r3, r2
20007d12:	d071      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d14:	68fb      	ldr	r3, [r7, #12]
20007d16:	681b      	ldr	r3, [r3, #0]
20007d18:	4a83      	ldr	r2, [pc, #524]	; (20007f28 <HAL_DMAEx_MultiBufferStart_IT+0x250>)
20007d1a:	4293      	cmp	r3, r2
20007d1c:	d06c      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d1e:	68fb      	ldr	r3, [r7, #12]
20007d20:	681b      	ldr	r3, [r3, #0]
20007d22:	4a82      	ldr	r2, [pc, #520]	; (20007f2c <HAL_DMAEx_MultiBufferStart_IT+0x254>)
20007d24:	4293      	cmp	r3, r2
20007d26:	d067      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d28:	68fb      	ldr	r3, [r7, #12]
20007d2a:	681b      	ldr	r3, [r3, #0]
20007d2c:	4a80      	ldr	r2, [pc, #512]	; (20007f30 <HAL_DMAEx_MultiBufferStart_IT+0x258>)
20007d2e:	4293      	cmp	r3, r2
20007d30:	d062      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d32:	68fb      	ldr	r3, [r7, #12]
20007d34:	681b      	ldr	r3, [r3, #0]
20007d36:	4a7f      	ldr	r2, [pc, #508]	; (20007f34 <HAL_DMAEx_MultiBufferStart_IT+0x25c>)
20007d38:	4293      	cmp	r3, r2
20007d3a:	d05d      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d3c:	68fb      	ldr	r3, [r7, #12]
20007d3e:	681b      	ldr	r3, [r3, #0]
20007d40:	4a7d      	ldr	r2, [pc, #500]	; (20007f38 <HAL_DMAEx_MultiBufferStart_IT+0x260>)
20007d42:	4293      	cmp	r3, r2
20007d44:	d058      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d46:	68fb      	ldr	r3, [r7, #12]
20007d48:	681b      	ldr	r3, [r3, #0]
20007d4a:	4a7c      	ldr	r2, [pc, #496]	; (20007f3c <HAL_DMAEx_MultiBufferStart_IT+0x264>)
20007d4c:	4293      	cmp	r3, r2
20007d4e:	d053      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d50:	68fb      	ldr	r3, [r7, #12]
20007d52:	681b      	ldr	r3, [r3, #0]
20007d54:	4a7a      	ldr	r2, [pc, #488]	; (20007f40 <HAL_DMAEx_MultiBufferStart_IT+0x268>)
20007d56:	4293      	cmp	r3, r2
20007d58:	d04e      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d5a:	68fb      	ldr	r3, [r7, #12]
20007d5c:	681b      	ldr	r3, [r3, #0]
20007d5e:	4a79      	ldr	r2, [pc, #484]	; (20007f44 <HAL_DMAEx_MultiBufferStart_IT+0x26c>)
20007d60:	4293      	cmp	r3, r2
20007d62:	d049      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d64:	68fb      	ldr	r3, [r7, #12]
20007d66:	681b      	ldr	r3, [r3, #0]
20007d68:	4a77      	ldr	r2, [pc, #476]	; (20007f48 <HAL_DMAEx_MultiBufferStart_IT+0x270>)
20007d6a:	4293      	cmp	r3, r2
20007d6c:	d044      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d6e:	68fb      	ldr	r3, [r7, #12]
20007d70:	681b      	ldr	r3, [r3, #0]
20007d72:	4a76      	ldr	r2, [pc, #472]	; (20007f4c <HAL_DMAEx_MultiBufferStart_IT+0x274>)
20007d74:	4293      	cmp	r3, r2
20007d76:	d03f      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d78:	68fb      	ldr	r3, [r7, #12]
20007d7a:	681b      	ldr	r3, [r3, #0]
20007d7c:	4a74      	ldr	r2, [pc, #464]	; (20007f50 <HAL_DMAEx_MultiBufferStart_IT+0x278>)
20007d7e:	4293      	cmp	r3, r2
20007d80:	d03a      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d82:	68fb      	ldr	r3, [r7, #12]
20007d84:	681b      	ldr	r3, [r3, #0]
20007d86:	4a73      	ldr	r2, [pc, #460]	; (20007f54 <HAL_DMAEx_MultiBufferStart_IT+0x27c>)
20007d88:	4293      	cmp	r3, r2
20007d8a:	d035      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d8c:	68fb      	ldr	r3, [r7, #12]
20007d8e:	681b      	ldr	r3, [r3, #0]
20007d90:	4a71      	ldr	r2, [pc, #452]	; (20007f58 <HAL_DMAEx_MultiBufferStart_IT+0x280>)
20007d92:	4293      	cmp	r3, r2
20007d94:	d030      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007d96:	68fb      	ldr	r3, [r7, #12]
20007d98:	681b      	ldr	r3, [r3, #0]
20007d9a:	4a70      	ldr	r2, [pc, #448]	; (20007f5c <HAL_DMAEx_MultiBufferStart_IT+0x284>)
20007d9c:	4293      	cmp	r3, r2
20007d9e:	d02b      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007da0:	68fb      	ldr	r3, [r7, #12]
20007da2:	681b      	ldr	r3, [r3, #0]
20007da4:	4a6e      	ldr	r2, [pc, #440]	; (20007f60 <HAL_DMAEx_MultiBufferStart_IT+0x288>)
20007da6:	4293      	cmp	r3, r2
20007da8:	d026      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007daa:	68fb      	ldr	r3, [r7, #12]
20007dac:	681b      	ldr	r3, [r3, #0]
20007dae:	4a6d      	ldr	r2, [pc, #436]	; (20007f64 <HAL_DMAEx_MultiBufferStart_IT+0x28c>)
20007db0:	4293      	cmp	r3, r2
20007db2:	d021      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007db4:	68fb      	ldr	r3, [r7, #12]
20007db6:	681b      	ldr	r3, [r3, #0]
20007db8:	4a6b      	ldr	r2, [pc, #428]	; (20007f68 <HAL_DMAEx_MultiBufferStart_IT+0x290>)
20007dba:	4293      	cmp	r3, r2
20007dbc:	d01c      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007dbe:	68fb      	ldr	r3, [r7, #12]
20007dc0:	681b      	ldr	r3, [r3, #0]
20007dc2:	4a6a      	ldr	r2, [pc, #424]	; (20007f6c <HAL_DMAEx_MultiBufferStart_IT+0x294>)
20007dc4:	4293      	cmp	r3, r2
20007dc6:	d017      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007dc8:	68fb      	ldr	r3, [r7, #12]
20007dca:	681b      	ldr	r3, [r3, #0]
20007dcc:	4a68      	ldr	r2, [pc, #416]	; (20007f70 <HAL_DMAEx_MultiBufferStart_IT+0x298>)
20007dce:	4293      	cmp	r3, r2
20007dd0:	d012      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007dd2:	68fb      	ldr	r3, [r7, #12]
20007dd4:	681b      	ldr	r3, [r3, #0]
20007dd6:	4a67      	ldr	r2, [pc, #412]	; (20007f74 <HAL_DMAEx_MultiBufferStart_IT+0x29c>)
20007dd8:	4293      	cmp	r3, r2
20007dda:	d00d      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007ddc:	68fb      	ldr	r3, [r7, #12]
20007dde:	681b      	ldr	r3, [r3, #0]
20007de0:	4a65      	ldr	r2, [pc, #404]	; (20007f78 <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
20007de2:	4293      	cmp	r3, r2
20007de4:	d008      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007de6:	68fb      	ldr	r3, [r7, #12]
20007de8:	681b      	ldr	r3, [r3, #0]
20007dea:	4a64      	ldr	r2, [pc, #400]	; (20007f7c <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
20007dec:	4293      	cmp	r3, r2
20007dee:	d003      	beq.n	20007df8 <HAL_DMAEx_MultiBufferStart_IT+0x120>
20007df0:	21e1      	movs	r1, #225	; 0xe1
20007df2:	484a      	ldr	r0, [pc, #296]	; (20007f1c <HAL_DMAEx_MultiBufferStart_IT+0x244>)
20007df4:	f7f8 fd7e 	bl	200008f4 <assert_failed>

  /* Memory-to-memory transfer not supported in double buffering mode */
  if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
20007df8:	68fb      	ldr	r3, [r7, #12]
20007dfa:	689b      	ldr	r3, [r3, #8]
20007dfc:	2b80      	cmp	r3, #128	; 0x80
20007dfe:	d105      	bne.n	20007e0c <HAL_DMAEx_MultiBufferStart_IT+0x134>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
20007e00:	68fb      	ldr	r3, [r7, #12]
20007e02:	f44f 7280 	mov.w	r2, #256	; 0x100
20007e06:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
20007e08:	2301      	movs	r3, #1
20007e0a:	e326      	b.n	2000845a <HAL_DMAEx_MultiBufferStart_IT+0x782>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
20007e0c:	68fb      	ldr	r3, [r7, #12]
20007e0e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
20007e12:	2b01      	cmp	r3, #1
20007e14:	d101      	bne.n	20007e1a <HAL_DMAEx_MultiBufferStart_IT+0x142>
20007e16:	2302      	movs	r3, #2
20007e18:	e31f      	b.n	2000845a <HAL_DMAEx_MultiBufferStart_IT+0x782>
20007e1a:	68fb      	ldr	r3, [r7, #12]
20007e1c:	2201      	movs	r2, #1
20007e1e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
20007e22:	68fb      	ldr	r3, [r7, #12]
20007e24:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20007e28:	b2db      	uxtb	r3, r3
20007e2a:	2b01      	cmp	r3, #1
20007e2c:	f040 830e 	bne.w	2000844c <HAL_DMAEx_MultiBufferStart_IT+0x774>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
20007e30:	68fb      	ldr	r3, [r7, #12]
20007e32:	2202      	movs	r2, #2
20007e34:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
20007e38:	68fb      	ldr	r3, [r7, #12]
20007e3a:	2200      	movs	r2, #0
20007e3c:	655a      	str	r2, [r3, #84]	; 0x54

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20007e3e:	68fb      	ldr	r3, [r7, #12]
20007e40:	681b      	ldr	r3, [r3, #0]
20007e42:	4a37      	ldr	r2, [pc, #220]	; (20007f20 <HAL_DMAEx_MultiBufferStart_IT+0x248>)
20007e44:	4293      	cmp	r3, r2
20007e46:	d04a      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007e48:	68fb      	ldr	r3, [r7, #12]
20007e4a:	681b      	ldr	r3, [r3, #0]
20007e4c:	4a35      	ldr	r2, [pc, #212]	; (20007f24 <HAL_DMAEx_MultiBufferStart_IT+0x24c>)
20007e4e:	4293      	cmp	r3, r2
20007e50:	d045      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007e52:	68fb      	ldr	r3, [r7, #12]
20007e54:	681b      	ldr	r3, [r3, #0]
20007e56:	4a34      	ldr	r2, [pc, #208]	; (20007f28 <HAL_DMAEx_MultiBufferStart_IT+0x250>)
20007e58:	4293      	cmp	r3, r2
20007e5a:	d040      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007e5c:	68fb      	ldr	r3, [r7, #12]
20007e5e:	681b      	ldr	r3, [r3, #0]
20007e60:	4a32      	ldr	r2, [pc, #200]	; (20007f2c <HAL_DMAEx_MultiBufferStart_IT+0x254>)
20007e62:	4293      	cmp	r3, r2
20007e64:	d03b      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007e66:	68fb      	ldr	r3, [r7, #12]
20007e68:	681b      	ldr	r3, [r3, #0]
20007e6a:	4a31      	ldr	r2, [pc, #196]	; (20007f30 <HAL_DMAEx_MultiBufferStart_IT+0x258>)
20007e6c:	4293      	cmp	r3, r2
20007e6e:	d036      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007e70:	68fb      	ldr	r3, [r7, #12]
20007e72:	681b      	ldr	r3, [r3, #0]
20007e74:	4a2f      	ldr	r2, [pc, #188]	; (20007f34 <HAL_DMAEx_MultiBufferStart_IT+0x25c>)
20007e76:	4293      	cmp	r3, r2
20007e78:	d031      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007e7a:	68fb      	ldr	r3, [r7, #12]
20007e7c:	681b      	ldr	r3, [r3, #0]
20007e7e:	4a2e      	ldr	r2, [pc, #184]	; (20007f38 <HAL_DMAEx_MultiBufferStart_IT+0x260>)
20007e80:	4293      	cmp	r3, r2
20007e82:	d02c      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007e84:	68fb      	ldr	r3, [r7, #12]
20007e86:	681b      	ldr	r3, [r3, #0]
20007e88:	4a2c      	ldr	r2, [pc, #176]	; (20007f3c <HAL_DMAEx_MultiBufferStart_IT+0x264>)
20007e8a:	4293      	cmp	r3, r2
20007e8c:	d027      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007e8e:	68fb      	ldr	r3, [r7, #12]
20007e90:	681b      	ldr	r3, [r3, #0]
20007e92:	4a2b      	ldr	r2, [pc, #172]	; (20007f40 <HAL_DMAEx_MultiBufferStart_IT+0x268>)
20007e94:	4293      	cmp	r3, r2
20007e96:	d022      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007e98:	68fb      	ldr	r3, [r7, #12]
20007e9a:	681b      	ldr	r3, [r3, #0]
20007e9c:	4a29      	ldr	r2, [pc, #164]	; (20007f44 <HAL_DMAEx_MultiBufferStart_IT+0x26c>)
20007e9e:	4293      	cmp	r3, r2
20007ea0:	d01d      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007ea2:	68fb      	ldr	r3, [r7, #12]
20007ea4:	681b      	ldr	r3, [r3, #0]
20007ea6:	4a28      	ldr	r2, [pc, #160]	; (20007f48 <HAL_DMAEx_MultiBufferStart_IT+0x270>)
20007ea8:	4293      	cmp	r3, r2
20007eaa:	d018      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007eac:	68fb      	ldr	r3, [r7, #12]
20007eae:	681b      	ldr	r3, [r3, #0]
20007eb0:	4a26      	ldr	r2, [pc, #152]	; (20007f4c <HAL_DMAEx_MultiBufferStart_IT+0x274>)
20007eb2:	4293      	cmp	r3, r2
20007eb4:	d013      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007eb6:	68fb      	ldr	r3, [r7, #12]
20007eb8:	681b      	ldr	r3, [r3, #0]
20007eba:	4a25      	ldr	r2, [pc, #148]	; (20007f50 <HAL_DMAEx_MultiBufferStart_IT+0x278>)
20007ebc:	4293      	cmp	r3, r2
20007ebe:	d00e      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007ec0:	68fb      	ldr	r3, [r7, #12]
20007ec2:	681b      	ldr	r3, [r3, #0]
20007ec4:	4a23      	ldr	r2, [pc, #140]	; (20007f54 <HAL_DMAEx_MultiBufferStart_IT+0x27c>)
20007ec6:	4293      	cmp	r3, r2
20007ec8:	d009      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007eca:	68fb      	ldr	r3, [r7, #12]
20007ecc:	681b      	ldr	r3, [r3, #0]
20007ece:	4a22      	ldr	r2, [pc, #136]	; (20007f58 <HAL_DMAEx_MultiBufferStart_IT+0x280>)
20007ed0:	4293      	cmp	r3, r2
20007ed2:	d004      	beq.n	20007ede <HAL_DMAEx_MultiBufferStart_IT+0x206>
20007ed4:	68fb      	ldr	r3, [r7, #12]
20007ed6:	681b      	ldr	r3, [r3, #0]
20007ed8:	4a20      	ldr	r2, [pc, #128]	; (20007f5c <HAL_DMAEx_MultiBufferStart_IT+0x284>)
20007eda:	4293      	cmp	r3, r2
20007edc:	d101      	bne.n	20007ee2 <HAL_DMAEx_MultiBufferStart_IT+0x20a>
20007ede:	2301      	movs	r3, #1
20007ee0:	e000      	b.n	20007ee4 <HAL_DMAEx_MultiBufferStart_IT+0x20c>
20007ee2:	2300      	movs	r3, #0
20007ee4:	2b00      	cmp	r3, #0
20007ee6:	d04b      	beq.n	20007f80 <HAL_DMAEx_MultiBufferStart_IT+0x2a8>
    {
      /* Enable the Double buffer mode */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
20007ee8:	68fb      	ldr	r3, [r7, #12]
20007eea:	681b      	ldr	r3, [r3, #0]
20007eec:	681a      	ldr	r2, [r3, #0]
20007eee:	68fb      	ldr	r3, [r7, #12]
20007ef0:	681b      	ldr	r3, [r3, #0]
20007ef2:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
20007ef6:	601a      	str	r2, [r3, #0]

      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
20007ef8:	68fb      	ldr	r3, [r7, #12]
20007efa:	681b      	ldr	r3, [r3, #0]
20007efc:	683a      	ldr	r2, [r7, #0]
20007efe:	611a      	str	r2, [r3, #16]

      /* Calculate the interrupt clear flag register (IFCR) base address  */
      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));
20007f00:	68fb      	ldr	r3, [r7, #12]
20007f02:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20007f04:	3308      	adds	r3, #8
20007f06:	613b      	str	r3, [r7, #16]

      /* Clear all flags */
      *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
20007f08:	68fb      	ldr	r3, [r7, #12]
20007f0a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20007f0c:	f003 031f 	and.w	r3, r3, #31
20007f10:	223f      	movs	r2, #63	; 0x3f
20007f12:	409a      	lsls	r2, r3
20007f14:	693b      	ldr	r3, [r7, #16]
20007f16:	601a      	str	r2, [r3, #0]
20007f18:	e04b      	b.n	20007fb2 <HAL_DMAEx_MultiBufferStart_IT+0x2da>
20007f1a:	bf00      	nop
20007f1c:	2001c014 	.word	0x2001c014
20007f20:	40020010 	.word	0x40020010
20007f24:	40020028 	.word	0x40020028
20007f28:	40020040 	.word	0x40020040
20007f2c:	40020058 	.word	0x40020058
20007f30:	40020070 	.word	0x40020070
20007f34:	40020088 	.word	0x40020088
20007f38:	400200a0 	.word	0x400200a0
20007f3c:	400200b8 	.word	0x400200b8
20007f40:	40020410 	.word	0x40020410
20007f44:	40020428 	.word	0x40020428
20007f48:	40020440 	.word	0x40020440
20007f4c:	40020458 	.word	0x40020458
20007f50:	40020470 	.word	0x40020470
20007f54:	40020488 	.word	0x40020488
20007f58:	400204a0 	.word	0x400204a0
20007f5c:	400204b8 	.word	0x400204b8
20007f60:	58025408 	.word	0x58025408
20007f64:	5802541c 	.word	0x5802541c
20007f68:	58025430 	.word	0x58025430
20007f6c:	58025444 	.word	0x58025444
20007f70:	58025458 	.word	0x58025458
20007f74:	5802546c 	.word	0x5802546c
20007f78:	58025480 	.word	0x58025480
20007f7c:	58025494 	.word	0x58025494
    }
    else /* BDMA instance(s) */
    {
      /* Enable the Double buffer mode */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
20007f80:	68fb      	ldr	r3, [r7, #12]
20007f82:	681b      	ldr	r3, [r3, #0]
20007f84:	6819      	ldr	r1, [r3, #0]
20007f86:	68fb      	ldr	r3, [r7, #12]
20007f88:	681a      	ldr	r2, [r3, #0]
20007f8a:	f248 0320 	movw	r3, #32800	; 0x8020
20007f8e:	430b      	orrs	r3, r1
20007f90:	6013      	str	r3, [r2, #0]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
20007f92:	68fb      	ldr	r3, [r7, #12]
20007f94:	681b      	ldr	r3, [r3, #0]
20007f96:	683a      	ldr	r2, [r7, #0]
20007f98:	611a      	str	r2, [r3, #16]

      /* Calculate the interrupt clear flag register (IFCR) base address  */
      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));
20007f9a:	68fb      	ldr	r3, [r7, #12]
20007f9c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20007f9e:	3304      	adds	r3, #4
20007fa0:	613b      	str	r3, [r7, #16]

      /* Clear all flags */
      *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
20007fa2:	68fb      	ldr	r3, [r7, #12]
20007fa4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20007fa6:	f003 031f 	and.w	r3, r3, #31
20007faa:	2201      	movs	r2, #1
20007fac:	409a      	lsls	r2, r3
20007fae:	693b      	ldr	r3, [r7, #16]
20007fb0:	601a      	str	r2, [r3, #0]
    }

    /* Configure the source, destination address and the data length */
    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
20007fb2:	6a3b      	ldr	r3, [r7, #32]
20007fb4:	687a      	ldr	r2, [r7, #4]
20007fb6:	68b9      	ldr	r1, [r7, #8]
20007fb8:	68f8      	ldr	r0, [r7, #12]
20007fba:	f001 f83b 	bl	20009034 <DMA_MultiBufferSetConfig>

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
20007fbe:	68fb      	ldr	r3, [r7, #12]
20007fc0:	681b      	ldr	r3, [r3, #0]
20007fc2:	4a80      	ldr	r2, [pc, #512]	; (200081c4 <HAL_DMAEx_MultiBufferStart_IT+0x4ec>)
20007fc4:	4293      	cmp	r3, r2
20007fc6:	d072      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20007fc8:	68fb      	ldr	r3, [r7, #12]
20007fca:	681b      	ldr	r3, [r3, #0]
20007fcc:	4a7e      	ldr	r2, [pc, #504]	; (200081c8 <HAL_DMAEx_MultiBufferStart_IT+0x4f0>)
20007fce:	4293      	cmp	r3, r2
20007fd0:	d06d      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20007fd2:	68fb      	ldr	r3, [r7, #12]
20007fd4:	681b      	ldr	r3, [r3, #0]
20007fd6:	4a7d      	ldr	r2, [pc, #500]	; (200081cc <HAL_DMAEx_MultiBufferStart_IT+0x4f4>)
20007fd8:	4293      	cmp	r3, r2
20007fda:	d068      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20007fdc:	68fb      	ldr	r3, [r7, #12]
20007fde:	681b      	ldr	r3, [r3, #0]
20007fe0:	4a7b      	ldr	r2, [pc, #492]	; (200081d0 <HAL_DMAEx_MultiBufferStart_IT+0x4f8>)
20007fe2:	4293      	cmp	r3, r2
20007fe4:	d063      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20007fe6:	68fb      	ldr	r3, [r7, #12]
20007fe8:	681b      	ldr	r3, [r3, #0]
20007fea:	4a7a      	ldr	r2, [pc, #488]	; (200081d4 <HAL_DMAEx_MultiBufferStart_IT+0x4fc>)
20007fec:	4293      	cmp	r3, r2
20007fee:	d05e      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20007ff0:	68fb      	ldr	r3, [r7, #12]
20007ff2:	681b      	ldr	r3, [r3, #0]
20007ff4:	4a78      	ldr	r2, [pc, #480]	; (200081d8 <HAL_DMAEx_MultiBufferStart_IT+0x500>)
20007ff6:	4293      	cmp	r3, r2
20007ff8:	d059      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20007ffa:	68fb      	ldr	r3, [r7, #12]
20007ffc:	681b      	ldr	r3, [r3, #0]
20007ffe:	4a77      	ldr	r2, [pc, #476]	; (200081dc <HAL_DMAEx_MultiBufferStart_IT+0x504>)
20008000:	4293      	cmp	r3, r2
20008002:	d054      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20008004:	68fb      	ldr	r3, [r7, #12]
20008006:	681b      	ldr	r3, [r3, #0]
20008008:	4a75      	ldr	r2, [pc, #468]	; (200081e0 <HAL_DMAEx_MultiBufferStart_IT+0x508>)
2000800a:	4293      	cmp	r3, r2
2000800c:	d04f      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
2000800e:	68fb      	ldr	r3, [r7, #12]
20008010:	681b      	ldr	r3, [r3, #0]
20008012:	4a74      	ldr	r2, [pc, #464]	; (200081e4 <HAL_DMAEx_MultiBufferStart_IT+0x50c>)
20008014:	4293      	cmp	r3, r2
20008016:	d04a      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20008018:	68fb      	ldr	r3, [r7, #12]
2000801a:	681b      	ldr	r3, [r3, #0]
2000801c:	4a72      	ldr	r2, [pc, #456]	; (200081e8 <HAL_DMAEx_MultiBufferStart_IT+0x510>)
2000801e:	4293      	cmp	r3, r2
20008020:	d045      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20008022:	68fb      	ldr	r3, [r7, #12]
20008024:	681b      	ldr	r3, [r3, #0]
20008026:	4a71      	ldr	r2, [pc, #452]	; (200081ec <HAL_DMAEx_MultiBufferStart_IT+0x514>)
20008028:	4293      	cmp	r3, r2
2000802a:	d040      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
2000802c:	68fb      	ldr	r3, [r7, #12]
2000802e:	681b      	ldr	r3, [r3, #0]
20008030:	4a6f      	ldr	r2, [pc, #444]	; (200081f0 <HAL_DMAEx_MultiBufferStart_IT+0x518>)
20008032:	4293      	cmp	r3, r2
20008034:	d03b      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20008036:	68fb      	ldr	r3, [r7, #12]
20008038:	681b      	ldr	r3, [r3, #0]
2000803a:	4a6e      	ldr	r2, [pc, #440]	; (200081f4 <HAL_DMAEx_MultiBufferStart_IT+0x51c>)
2000803c:	4293      	cmp	r3, r2
2000803e:	d036      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20008040:	68fb      	ldr	r3, [r7, #12]
20008042:	681b      	ldr	r3, [r3, #0]
20008044:	4a6c      	ldr	r2, [pc, #432]	; (200081f8 <HAL_DMAEx_MultiBufferStart_IT+0x520>)
20008046:	4293      	cmp	r3, r2
20008048:	d031      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
2000804a:	68fb      	ldr	r3, [r7, #12]
2000804c:	681b      	ldr	r3, [r3, #0]
2000804e:	4a6b      	ldr	r2, [pc, #428]	; (200081fc <HAL_DMAEx_MultiBufferStart_IT+0x524>)
20008050:	4293      	cmp	r3, r2
20008052:	d02c      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20008054:	68fb      	ldr	r3, [r7, #12]
20008056:	681b      	ldr	r3, [r3, #0]
20008058:	4a69      	ldr	r2, [pc, #420]	; (20008200 <HAL_DMAEx_MultiBufferStart_IT+0x528>)
2000805a:	4293      	cmp	r3, r2
2000805c:	d027      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
2000805e:	68fb      	ldr	r3, [r7, #12]
20008060:	681b      	ldr	r3, [r3, #0]
20008062:	4a68      	ldr	r2, [pc, #416]	; (20008204 <HAL_DMAEx_MultiBufferStart_IT+0x52c>)
20008064:	4293      	cmp	r3, r2
20008066:	d022      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20008068:	68fb      	ldr	r3, [r7, #12]
2000806a:	681b      	ldr	r3, [r3, #0]
2000806c:	4a66      	ldr	r2, [pc, #408]	; (20008208 <HAL_DMAEx_MultiBufferStart_IT+0x530>)
2000806e:	4293      	cmp	r3, r2
20008070:	d01d      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20008072:	68fb      	ldr	r3, [r7, #12]
20008074:	681b      	ldr	r3, [r3, #0]
20008076:	4a65      	ldr	r2, [pc, #404]	; (2000820c <HAL_DMAEx_MultiBufferStart_IT+0x534>)
20008078:	4293      	cmp	r3, r2
2000807a:	d018      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
2000807c:	68fb      	ldr	r3, [r7, #12]
2000807e:	681b      	ldr	r3, [r3, #0]
20008080:	4a63      	ldr	r2, [pc, #396]	; (20008210 <HAL_DMAEx_MultiBufferStart_IT+0x538>)
20008082:	4293      	cmp	r3, r2
20008084:	d013      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20008086:	68fb      	ldr	r3, [r7, #12]
20008088:	681b      	ldr	r3, [r3, #0]
2000808a:	4a62      	ldr	r2, [pc, #392]	; (20008214 <HAL_DMAEx_MultiBufferStart_IT+0x53c>)
2000808c:	4293      	cmp	r3, r2
2000808e:	d00e      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
20008090:	68fb      	ldr	r3, [r7, #12]
20008092:	681b      	ldr	r3, [r3, #0]
20008094:	4a60      	ldr	r2, [pc, #384]	; (20008218 <HAL_DMAEx_MultiBufferStart_IT+0x540>)
20008096:	4293      	cmp	r3, r2
20008098:	d009      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
2000809a:	68fb      	ldr	r3, [r7, #12]
2000809c:	681b      	ldr	r3, [r3, #0]
2000809e:	4a5f      	ldr	r2, [pc, #380]	; (2000821c <HAL_DMAEx_MultiBufferStart_IT+0x544>)
200080a0:	4293      	cmp	r3, r2
200080a2:	d004      	beq.n	200080ae <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
200080a4:	68fb      	ldr	r3, [r7, #12]
200080a6:	681b      	ldr	r3, [r3, #0]
200080a8:	4a5d      	ldr	r2, [pc, #372]	; (20008220 <HAL_DMAEx_MultiBufferStart_IT+0x548>)
200080aa:	4293      	cmp	r3, r2
200080ac:	d101      	bne.n	200080b2 <HAL_DMAEx_MultiBufferStart_IT+0x3da>
200080ae:	2301      	movs	r3, #1
200080b0:	e000      	b.n	200080b4 <HAL_DMAEx_MultiBufferStart_IT+0x3dc>
200080b2:	2300      	movs	r3, #0
200080b4:	2b00      	cmp	r3, #0
200080b6:	d00d      	beq.n	200080d4 <HAL_DMAEx_MultiBufferStart_IT+0x3fc>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
200080b8:	68fb      	ldr	r3, [r7, #12]
200080ba:	6e5b      	ldr	r3, [r3, #100]	; 0x64
200080bc:	68fa      	ldr	r2, [r7, #12]
200080be:	6e92      	ldr	r2, [r2, #104]	; 0x68
200080c0:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
200080c2:	68fb      	ldr	r3, [r7, #12]
200080c4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
200080c6:	2b00      	cmp	r3, #0
200080c8:	d004      	beq.n	200080d4 <HAL_DMAEx_MultiBufferStart_IT+0x3fc>
      {
        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
200080ca:	68fb      	ldr	r3, [r7, #12]
200080cc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
200080ce:	68fa      	ldr	r2, [r7, #12]
200080d0:	6f52      	ldr	r2, [r2, #116]	; 0x74
200080d2:	605a      	str	r2, [r3, #4]
      }
    }

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
200080d4:	68fb      	ldr	r3, [r7, #12]
200080d6:	681b      	ldr	r3, [r3, #0]
200080d8:	4a3a      	ldr	r2, [pc, #232]	; (200081c4 <HAL_DMAEx_MultiBufferStart_IT+0x4ec>)
200080da:	4293      	cmp	r3, r2
200080dc:	d04a      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
200080de:	68fb      	ldr	r3, [r7, #12]
200080e0:	681b      	ldr	r3, [r3, #0]
200080e2:	4a39      	ldr	r2, [pc, #228]	; (200081c8 <HAL_DMAEx_MultiBufferStart_IT+0x4f0>)
200080e4:	4293      	cmp	r3, r2
200080e6:	d045      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
200080e8:	68fb      	ldr	r3, [r7, #12]
200080ea:	681b      	ldr	r3, [r3, #0]
200080ec:	4a37      	ldr	r2, [pc, #220]	; (200081cc <HAL_DMAEx_MultiBufferStart_IT+0x4f4>)
200080ee:	4293      	cmp	r3, r2
200080f0:	d040      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
200080f2:	68fb      	ldr	r3, [r7, #12]
200080f4:	681b      	ldr	r3, [r3, #0]
200080f6:	4a36      	ldr	r2, [pc, #216]	; (200081d0 <HAL_DMAEx_MultiBufferStart_IT+0x4f8>)
200080f8:	4293      	cmp	r3, r2
200080fa:	d03b      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
200080fc:	68fb      	ldr	r3, [r7, #12]
200080fe:	681b      	ldr	r3, [r3, #0]
20008100:	4a34      	ldr	r2, [pc, #208]	; (200081d4 <HAL_DMAEx_MultiBufferStart_IT+0x4fc>)
20008102:	4293      	cmp	r3, r2
20008104:	d036      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
20008106:	68fb      	ldr	r3, [r7, #12]
20008108:	681b      	ldr	r3, [r3, #0]
2000810a:	4a33      	ldr	r2, [pc, #204]	; (200081d8 <HAL_DMAEx_MultiBufferStart_IT+0x500>)
2000810c:	4293      	cmp	r3, r2
2000810e:	d031      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
20008110:	68fb      	ldr	r3, [r7, #12]
20008112:	681b      	ldr	r3, [r3, #0]
20008114:	4a31      	ldr	r2, [pc, #196]	; (200081dc <HAL_DMAEx_MultiBufferStart_IT+0x504>)
20008116:	4293      	cmp	r3, r2
20008118:	d02c      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
2000811a:	68fb      	ldr	r3, [r7, #12]
2000811c:	681b      	ldr	r3, [r3, #0]
2000811e:	4a30      	ldr	r2, [pc, #192]	; (200081e0 <HAL_DMAEx_MultiBufferStart_IT+0x508>)
20008120:	4293      	cmp	r3, r2
20008122:	d027      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
20008124:	68fb      	ldr	r3, [r7, #12]
20008126:	681b      	ldr	r3, [r3, #0]
20008128:	4a2e      	ldr	r2, [pc, #184]	; (200081e4 <HAL_DMAEx_MultiBufferStart_IT+0x50c>)
2000812a:	4293      	cmp	r3, r2
2000812c:	d022      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
2000812e:	68fb      	ldr	r3, [r7, #12]
20008130:	681b      	ldr	r3, [r3, #0]
20008132:	4a2d      	ldr	r2, [pc, #180]	; (200081e8 <HAL_DMAEx_MultiBufferStart_IT+0x510>)
20008134:	4293      	cmp	r3, r2
20008136:	d01d      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
20008138:	68fb      	ldr	r3, [r7, #12]
2000813a:	681b      	ldr	r3, [r3, #0]
2000813c:	4a2b      	ldr	r2, [pc, #172]	; (200081ec <HAL_DMAEx_MultiBufferStart_IT+0x514>)
2000813e:	4293      	cmp	r3, r2
20008140:	d018      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
20008142:	68fb      	ldr	r3, [r7, #12]
20008144:	681b      	ldr	r3, [r3, #0]
20008146:	4a2a      	ldr	r2, [pc, #168]	; (200081f0 <HAL_DMAEx_MultiBufferStart_IT+0x518>)
20008148:	4293      	cmp	r3, r2
2000814a:	d013      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
2000814c:	68fb      	ldr	r3, [r7, #12]
2000814e:	681b      	ldr	r3, [r3, #0]
20008150:	4a28      	ldr	r2, [pc, #160]	; (200081f4 <HAL_DMAEx_MultiBufferStart_IT+0x51c>)
20008152:	4293      	cmp	r3, r2
20008154:	d00e      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
20008156:	68fb      	ldr	r3, [r7, #12]
20008158:	681b      	ldr	r3, [r3, #0]
2000815a:	4a27      	ldr	r2, [pc, #156]	; (200081f8 <HAL_DMAEx_MultiBufferStart_IT+0x520>)
2000815c:	4293      	cmp	r3, r2
2000815e:	d009      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
20008160:	68fb      	ldr	r3, [r7, #12]
20008162:	681b      	ldr	r3, [r3, #0]
20008164:	4a25      	ldr	r2, [pc, #148]	; (200081fc <HAL_DMAEx_MultiBufferStart_IT+0x524>)
20008166:	4293      	cmp	r3, r2
20008168:	d004      	beq.n	20008174 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
2000816a:	68fb      	ldr	r3, [r7, #12]
2000816c:	681b      	ldr	r3, [r3, #0]
2000816e:	4a24      	ldr	r2, [pc, #144]	; (20008200 <HAL_DMAEx_MultiBufferStart_IT+0x528>)
20008170:	4293      	cmp	r3, r2
20008172:	d101      	bne.n	20008178 <HAL_DMAEx_MultiBufferStart_IT+0x4a0>
20008174:	2301      	movs	r3, #1
20008176:	e000      	b.n	2000817a <HAL_DMAEx_MultiBufferStart_IT+0x4a2>
20008178:	2300      	movs	r3, #0
2000817a:	2b00      	cmp	r3, #0
2000817c:	d052      	beq.n	20008224 <HAL_DMAEx_MultiBufferStart_IT+0x54c>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
2000817e:	68fb      	ldr	r3, [r7, #12]
20008180:	681b      	ldr	r3, [r3, #0]
20008182:	681b      	ldr	r3, [r3, #0]
20008184:	f023 021e 	bic.w	r2, r3, #30
20008188:	68fb      	ldr	r3, [r7, #12]
2000818a:	681b      	ldr	r3, [r3, #0]
2000818c:	f042 0216 	orr.w	r2, r2, #22
20008190:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR |= DMA_IT_FE;
20008192:	68fb      	ldr	r3, [r7, #12]
20008194:	681b      	ldr	r3, [r3, #0]
20008196:	695a      	ldr	r2, [r3, #20]
20008198:	68fb      	ldr	r3, [r7, #12]
2000819a:	681b      	ldr	r3, [r3, #0]
2000819c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
200081a0:	615a      	str	r2, [r3, #20]

      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
200081a2:	68fb      	ldr	r3, [r7, #12]
200081a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200081a6:	2b00      	cmp	r3, #0
200081a8:	d103      	bne.n	200081b2 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
200081aa:	68fb      	ldr	r3, [r7, #12]
200081ac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200081ae:	2b00      	cmp	r3, #0
200081b0:	d052      	beq.n	20008258 <HAL_DMAEx_MultiBufferStart_IT+0x580>
      {
        /*Enable Half Transfer IT if corresponding Callback is set*/
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
200081b2:	68fb      	ldr	r3, [r7, #12]
200081b4:	681b      	ldr	r3, [r3, #0]
200081b6:	681a      	ldr	r2, [r3, #0]
200081b8:	68fb      	ldr	r3, [r7, #12]
200081ba:	681b      	ldr	r3, [r3, #0]
200081bc:	f042 0208 	orr.w	r2, r2, #8
200081c0:	601a      	str	r2, [r3, #0]
200081c2:	e049      	b.n	20008258 <HAL_DMAEx_MultiBufferStart_IT+0x580>
200081c4:	40020010 	.word	0x40020010
200081c8:	40020028 	.word	0x40020028
200081cc:	40020040 	.word	0x40020040
200081d0:	40020058 	.word	0x40020058
200081d4:	40020070 	.word	0x40020070
200081d8:	40020088 	.word	0x40020088
200081dc:	400200a0 	.word	0x400200a0
200081e0:	400200b8 	.word	0x400200b8
200081e4:	40020410 	.word	0x40020410
200081e8:	40020428 	.word	0x40020428
200081ec:	40020440 	.word	0x40020440
200081f0:	40020458 	.word	0x40020458
200081f4:	40020470 	.word	0x40020470
200081f8:	40020488 	.word	0x40020488
200081fc:	400204a0 	.word	0x400204a0
20008200:	400204b8 	.word	0x400204b8
20008204:	58025408 	.word	0x58025408
20008208:	5802541c 	.word	0x5802541c
2000820c:	58025430 	.word	0x58025430
20008210:	58025444 	.word	0x58025444
20008214:	58025458 	.word	0x58025458
20008218:	5802546c 	.word	0x5802546c
2000821c:	58025480 	.word	0x58025480
20008220:	58025494 	.word	0x58025494
      }
    }
    else /* BDMA instance(s) */
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
20008224:	68fb      	ldr	r3, [r7, #12]
20008226:	681b      	ldr	r3, [r3, #0]
20008228:	681b      	ldr	r3, [r3, #0]
2000822a:	f023 020e 	bic.w	r2, r3, #14
2000822e:	68fb      	ldr	r3, [r7, #12]
20008230:	681b      	ldr	r3, [r3, #0]
20008232:	f042 020a 	orr.w	r2, r2, #10
20008236:	601a      	str	r2, [r3, #0]

      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
20008238:	68fb      	ldr	r3, [r7, #12]
2000823a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000823c:	2b00      	cmp	r3, #0
2000823e:	d103      	bne.n	20008248 <HAL_DMAEx_MultiBufferStart_IT+0x570>
20008240:	68fb      	ldr	r3, [r7, #12]
20008242:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20008244:	2b00      	cmp	r3, #0
20008246:	d007      	beq.n	20008258 <HAL_DMAEx_MultiBufferStart_IT+0x580>
      {
        /*Enable Half Transfer IT if corresponding Callback is set*/
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
20008248:	68fb      	ldr	r3, [r7, #12]
2000824a:	681b      	ldr	r3, [r3, #0]
2000824c:	681a      	ldr	r2, [r3, #0]
2000824e:	68fb      	ldr	r3, [r7, #12]
20008250:	681b      	ldr	r3, [r3, #0]
20008252:	f042 0204 	orr.w	r2, r2, #4
20008256:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
20008258:	68fb      	ldr	r3, [r7, #12]
2000825a:	681b      	ldr	r3, [r3, #0]
2000825c:	4a81      	ldr	r2, [pc, #516]	; (20008464 <HAL_DMAEx_MultiBufferStart_IT+0x78c>)
2000825e:	4293      	cmp	r3, r2
20008260:	d072      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
20008262:	68fb      	ldr	r3, [r7, #12]
20008264:	681b      	ldr	r3, [r3, #0]
20008266:	4a80      	ldr	r2, [pc, #512]	; (20008468 <HAL_DMAEx_MultiBufferStart_IT+0x790>)
20008268:	4293      	cmp	r3, r2
2000826a:	d06d      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
2000826c:	68fb      	ldr	r3, [r7, #12]
2000826e:	681b      	ldr	r3, [r3, #0]
20008270:	4a7e      	ldr	r2, [pc, #504]	; (2000846c <HAL_DMAEx_MultiBufferStart_IT+0x794>)
20008272:	4293      	cmp	r3, r2
20008274:	d068      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
20008276:	68fb      	ldr	r3, [r7, #12]
20008278:	681b      	ldr	r3, [r3, #0]
2000827a:	4a7d      	ldr	r2, [pc, #500]	; (20008470 <HAL_DMAEx_MultiBufferStart_IT+0x798>)
2000827c:	4293      	cmp	r3, r2
2000827e:	d063      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
20008280:	68fb      	ldr	r3, [r7, #12]
20008282:	681b      	ldr	r3, [r3, #0]
20008284:	4a7b      	ldr	r2, [pc, #492]	; (20008474 <HAL_DMAEx_MultiBufferStart_IT+0x79c>)
20008286:	4293      	cmp	r3, r2
20008288:	d05e      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
2000828a:	68fb      	ldr	r3, [r7, #12]
2000828c:	681b      	ldr	r3, [r3, #0]
2000828e:	4a7a      	ldr	r2, [pc, #488]	; (20008478 <HAL_DMAEx_MultiBufferStart_IT+0x7a0>)
20008290:	4293      	cmp	r3, r2
20008292:	d059      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
20008294:	68fb      	ldr	r3, [r7, #12]
20008296:	681b      	ldr	r3, [r3, #0]
20008298:	4a78      	ldr	r2, [pc, #480]	; (2000847c <HAL_DMAEx_MultiBufferStart_IT+0x7a4>)
2000829a:	4293      	cmp	r3, r2
2000829c:	d054      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
2000829e:	68fb      	ldr	r3, [r7, #12]
200082a0:	681b      	ldr	r3, [r3, #0]
200082a2:	4a77      	ldr	r2, [pc, #476]	; (20008480 <HAL_DMAEx_MultiBufferStart_IT+0x7a8>)
200082a4:	4293      	cmp	r3, r2
200082a6:	d04f      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
200082a8:	68fb      	ldr	r3, [r7, #12]
200082aa:	681b      	ldr	r3, [r3, #0]
200082ac:	4a75      	ldr	r2, [pc, #468]	; (20008484 <HAL_DMAEx_MultiBufferStart_IT+0x7ac>)
200082ae:	4293      	cmp	r3, r2
200082b0:	d04a      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
200082b2:	68fb      	ldr	r3, [r7, #12]
200082b4:	681b      	ldr	r3, [r3, #0]
200082b6:	4a74      	ldr	r2, [pc, #464]	; (20008488 <HAL_DMAEx_MultiBufferStart_IT+0x7b0>)
200082b8:	4293      	cmp	r3, r2
200082ba:	d045      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
200082bc:	68fb      	ldr	r3, [r7, #12]
200082be:	681b      	ldr	r3, [r3, #0]
200082c0:	4a72      	ldr	r2, [pc, #456]	; (2000848c <HAL_DMAEx_MultiBufferStart_IT+0x7b4>)
200082c2:	4293      	cmp	r3, r2
200082c4:	d040      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
200082c6:	68fb      	ldr	r3, [r7, #12]
200082c8:	681b      	ldr	r3, [r3, #0]
200082ca:	4a71      	ldr	r2, [pc, #452]	; (20008490 <HAL_DMAEx_MultiBufferStart_IT+0x7b8>)
200082cc:	4293      	cmp	r3, r2
200082ce:	d03b      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
200082d0:	68fb      	ldr	r3, [r7, #12]
200082d2:	681b      	ldr	r3, [r3, #0]
200082d4:	4a6f      	ldr	r2, [pc, #444]	; (20008494 <HAL_DMAEx_MultiBufferStart_IT+0x7bc>)
200082d6:	4293      	cmp	r3, r2
200082d8:	d036      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
200082da:	68fb      	ldr	r3, [r7, #12]
200082dc:	681b      	ldr	r3, [r3, #0]
200082de:	4a6e      	ldr	r2, [pc, #440]	; (20008498 <HAL_DMAEx_MultiBufferStart_IT+0x7c0>)
200082e0:	4293      	cmp	r3, r2
200082e2:	d031      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
200082e4:	68fb      	ldr	r3, [r7, #12]
200082e6:	681b      	ldr	r3, [r3, #0]
200082e8:	4a6c      	ldr	r2, [pc, #432]	; (2000849c <HAL_DMAEx_MultiBufferStart_IT+0x7c4>)
200082ea:	4293      	cmp	r3, r2
200082ec:	d02c      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
200082ee:	68fb      	ldr	r3, [r7, #12]
200082f0:	681b      	ldr	r3, [r3, #0]
200082f2:	4a6b      	ldr	r2, [pc, #428]	; (200084a0 <HAL_DMAEx_MultiBufferStart_IT+0x7c8>)
200082f4:	4293      	cmp	r3, r2
200082f6:	d027      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
200082f8:	68fb      	ldr	r3, [r7, #12]
200082fa:	681b      	ldr	r3, [r3, #0]
200082fc:	4a69      	ldr	r2, [pc, #420]	; (200084a4 <HAL_DMAEx_MultiBufferStart_IT+0x7cc>)
200082fe:	4293      	cmp	r3, r2
20008300:	d022      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
20008302:	68fb      	ldr	r3, [r7, #12]
20008304:	681b      	ldr	r3, [r3, #0]
20008306:	4a68      	ldr	r2, [pc, #416]	; (200084a8 <HAL_DMAEx_MultiBufferStart_IT+0x7d0>)
20008308:	4293      	cmp	r3, r2
2000830a:	d01d      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
2000830c:	68fb      	ldr	r3, [r7, #12]
2000830e:	681b      	ldr	r3, [r3, #0]
20008310:	4a66      	ldr	r2, [pc, #408]	; (200084ac <HAL_DMAEx_MultiBufferStart_IT+0x7d4>)
20008312:	4293      	cmp	r3, r2
20008314:	d018      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
20008316:	68fb      	ldr	r3, [r7, #12]
20008318:	681b      	ldr	r3, [r3, #0]
2000831a:	4a65      	ldr	r2, [pc, #404]	; (200084b0 <HAL_DMAEx_MultiBufferStart_IT+0x7d8>)
2000831c:	4293      	cmp	r3, r2
2000831e:	d013      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
20008320:	68fb      	ldr	r3, [r7, #12]
20008322:	681b      	ldr	r3, [r3, #0]
20008324:	4a63      	ldr	r2, [pc, #396]	; (200084b4 <HAL_DMAEx_MultiBufferStart_IT+0x7dc>)
20008326:	4293      	cmp	r3, r2
20008328:	d00e      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
2000832a:	68fb      	ldr	r3, [r7, #12]
2000832c:	681b      	ldr	r3, [r3, #0]
2000832e:	4a62      	ldr	r2, [pc, #392]	; (200084b8 <HAL_DMAEx_MultiBufferStart_IT+0x7e0>)
20008330:	4293      	cmp	r3, r2
20008332:	d009      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
20008334:	68fb      	ldr	r3, [r7, #12]
20008336:	681b      	ldr	r3, [r3, #0]
20008338:	4a60      	ldr	r2, [pc, #384]	; (200084bc <HAL_DMAEx_MultiBufferStart_IT+0x7e4>)
2000833a:	4293      	cmp	r3, r2
2000833c:	d004      	beq.n	20008348 <HAL_DMAEx_MultiBufferStart_IT+0x670>
2000833e:	68fb      	ldr	r3, [r7, #12]
20008340:	681b      	ldr	r3, [r3, #0]
20008342:	4a5f      	ldr	r2, [pc, #380]	; (200084c0 <HAL_DMAEx_MultiBufferStart_IT+0x7e8>)
20008344:	4293      	cmp	r3, r2
20008346:	d101      	bne.n	2000834c <HAL_DMAEx_MultiBufferStart_IT+0x674>
20008348:	2301      	movs	r3, #1
2000834a:	e000      	b.n	2000834e <HAL_DMAEx_MultiBufferStart_IT+0x676>
2000834c:	2300      	movs	r3, #0
2000834e:	2b00      	cmp	r3, #0
20008350:	d01a      	beq.n	20008388 <HAL_DMAEx_MultiBufferStart_IT+0x6b0>
    {
      /* Check if DMAMUX Synchronization is enabled*/
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
20008352:	68fb      	ldr	r3, [r7, #12]
20008354:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20008356:	681b      	ldr	r3, [r3, #0]
20008358:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000835c:	2b00      	cmp	r3, #0
2000835e:	d007      	beq.n	20008370 <HAL_DMAEx_MultiBufferStart_IT+0x698>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
20008360:	68fb      	ldr	r3, [r7, #12]
20008362:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20008364:	681a      	ldr	r2, [r3, #0]
20008366:	68fb      	ldr	r3, [r7, #12]
20008368:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2000836a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
2000836e:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
20008370:	68fb      	ldr	r3, [r7, #12]
20008372:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008374:	2b00      	cmp	r3, #0
20008376:	d007      	beq.n	20008388 <HAL_DMAEx_MultiBufferStart_IT+0x6b0>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT*/
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
20008378:	68fb      	ldr	r3, [r7, #12]
2000837a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2000837c:	681a      	ldr	r2, [r3, #0]
2000837e:	68fb      	ldr	r3, [r7, #12]
20008380:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008382:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20008386:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the peripheral */
    __HAL_DMA_ENABLE(hdma);
20008388:	68fb      	ldr	r3, [r7, #12]
2000838a:	681b      	ldr	r3, [r3, #0]
2000838c:	4a35      	ldr	r2, [pc, #212]	; (20008464 <HAL_DMAEx_MultiBufferStart_IT+0x78c>)
2000838e:	4293      	cmp	r3, r2
20008390:	d04a      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
20008392:	68fb      	ldr	r3, [r7, #12]
20008394:	681b      	ldr	r3, [r3, #0]
20008396:	4a34      	ldr	r2, [pc, #208]	; (20008468 <HAL_DMAEx_MultiBufferStart_IT+0x790>)
20008398:	4293      	cmp	r3, r2
2000839a:	d045      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
2000839c:	68fb      	ldr	r3, [r7, #12]
2000839e:	681b      	ldr	r3, [r3, #0]
200083a0:	4a32      	ldr	r2, [pc, #200]	; (2000846c <HAL_DMAEx_MultiBufferStart_IT+0x794>)
200083a2:	4293      	cmp	r3, r2
200083a4:	d040      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
200083a6:	68fb      	ldr	r3, [r7, #12]
200083a8:	681b      	ldr	r3, [r3, #0]
200083aa:	4a31      	ldr	r2, [pc, #196]	; (20008470 <HAL_DMAEx_MultiBufferStart_IT+0x798>)
200083ac:	4293      	cmp	r3, r2
200083ae:	d03b      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
200083b0:	68fb      	ldr	r3, [r7, #12]
200083b2:	681b      	ldr	r3, [r3, #0]
200083b4:	4a2f      	ldr	r2, [pc, #188]	; (20008474 <HAL_DMAEx_MultiBufferStart_IT+0x79c>)
200083b6:	4293      	cmp	r3, r2
200083b8:	d036      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
200083ba:	68fb      	ldr	r3, [r7, #12]
200083bc:	681b      	ldr	r3, [r3, #0]
200083be:	4a2e      	ldr	r2, [pc, #184]	; (20008478 <HAL_DMAEx_MultiBufferStart_IT+0x7a0>)
200083c0:	4293      	cmp	r3, r2
200083c2:	d031      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
200083c4:	68fb      	ldr	r3, [r7, #12]
200083c6:	681b      	ldr	r3, [r3, #0]
200083c8:	4a2c      	ldr	r2, [pc, #176]	; (2000847c <HAL_DMAEx_MultiBufferStart_IT+0x7a4>)
200083ca:	4293      	cmp	r3, r2
200083cc:	d02c      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
200083ce:	68fb      	ldr	r3, [r7, #12]
200083d0:	681b      	ldr	r3, [r3, #0]
200083d2:	4a2b      	ldr	r2, [pc, #172]	; (20008480 <HAL_DMAEx_MultiBufferStart_IT+0x7a8>)
200083d4:	4293      	cmp	r3, r2
200083d6:	d027      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
200083d8:	68fb      	ldr	r3, [r7, #12]
200083da:	681b      	ldr	r3, [r3, #0]
200083dc:	4a29      	ldr	r2, [pc, #164]	; (20008484 <HAL_DMAEx_MultiBufferStart_IT+0x7ac>)
200083de:	4293      	cmp	r3, r2
200083e0:	d022      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
200083e2:	68fb      	ldr	r3, [r7, #12]
200083e4:	681b      	ldr	r3, [r3, #0]
200083e6:	4a28      	ldr	r2, [pc, #160]	; (20008488 <HAL_DMAEx_MultiBufferStart_IT+0x7b0>)
200083e8:	4293      	cmp	r3, r2
200083ea:	d01d      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
200083ec:	68fb      	ldr	r3, [r7, #12]
200083ee:	681b      	ldr	r3, [r3, #0]
200083f0:	4a26      	ldr	r2, [pc, #152]	; (2000848c <HAL_DMAEx_MultiBufferStart_IT+0x7b4>)
200083f2:	4293      	cmp	r3, r2
200083f4:	d018      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
200083f6:	68fb      	ldr	r3, [r7, #12]
200083f8:	681b      	ldr	r3, [r3, #0]
200083fa:	4a25      	ldr	r2, [pc, #148]	; (20008490 <HAL_DMAEx_MultiBufferStart_IT+0x7b8>)
200083fc:	4293      	cmp	r3, r2
200083fe:	d013      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
20008400:	68fb      	ldr	r3, [r7, #12]
20008402:	681b      	ldr	r3, [r3, #0]
20008404:	4a23      	ldr	r2, [pc, #140]	; (20008494 <HAL_DMAEx_MultiBufferStart_IT+0x7bc>)
20008406:	4293      	cmp	r3, r2
20008408:	d00e      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
2000840a:	68fb      	ldr	r3, [r7, #12]
2000840c:	681b      	ldr	r3, [r3, #0]
2000840e:	4a22      	ldr	r2, [pc, #136]	; (20008498 <HAL_DMAEx_MultiBufferStart_IT+0x7c0>)
20008410:	4293      	cmp	r3, r2
20008412:	d009      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
20008414:	68fb      	ldr	r3, [r7, #12]
20008416:	681b      	ldr	r3, [r3, #0]
20008418:	4a20      	ldr	r2, [pc, #128]	; (2000849c <HAL_DMAEx_MultiBufferStart_IT+0x7c4>)
2000841a:	4293      	cmp	r3, r2
2000841c:	d004      	beq.n	20008428 <HAL_DMAEx_MultiBufferStart_IT+0x750>
2000841e:	68fb      	ldr	r3, [r7, #12]
20008420:	681b      	ldr	r3, [r3, #0]
20008422:	4a1f      	ldr	r2, [pc, #124]	; (200084a0 <HAL_DMAEx_MultiBufferStart_IT+0x7c8>)
20008424:	4293      	cmp	r3, r2
20008426:	d108      	bne.n	2000843a <HAL_DMAEx_MultiBufferStart_IT+0x762>
20008428:	68fb      	ldr	r3, [r7, #12]
2000842a:	681b      	ldr	r3, [r3, #0]
2000842c:	681a      	ldr	r2, [r3, #0]
2000842e:	68fb      	ldr	r3, [r7, #12]
20008430:	681b      	ldr	r3, [r3, #0]
20008432:	f042 0201 	orr.w	r2, r2, #1
20008436:	601a      	str	r2, [r3, #0]
20008438:	e00e      	b.n	20008458 <HAL_DMAEx_MultiBufferStart_IT+0x780>
2000843a:	68fb      	ldr	r3, [r7, #12]
2000843c:	681b      	ldr	r3, [r3, #0]
2000843e:	681a      	ldr	r2, [r3, #0]
20008440:	68fb      	ldr	r3, [r7, #12]
20008442:	681b      	ldr	r3, [r3, #0]
20008444:	f042 0201 	orr.w	r2, r2, #1
20008448:	601a      	str	r2, [r3, #0]
2000844a:	e005      	b.n	20008458 <HAL_DMAEx_MultiBufferStart_IT+0x780>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
2000844c:	68fb      	ldr	r3, [r7, #12]
2000844e:	f44f 6200 	mov.w	r2, #2048	; 0x800
20008452:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
20008454:	2301      	movs	r3, #1
20008456:	75fb      	strb	r3, [r7, #23]
  }
  return status;
20008458:	7dfb      	ldrb	r3, [r7, #23]
}
2000845a:	4618      	mov	r0, r3
2000845c:	3718      	adds	r7, #24
2000845e:	46bd      	mov	sp, r7
20008460:	bd80      	pop	{r7, pc}
20008462:	bf00      	nop
20008464:	40020010 	.word	0x40020010
20008468:	40020028 	.word	0x40020028
2000846c:	40020040 	.word	0x40020040
20008470:	40020058 	.word	0x40020058
20008474:	40020070 	.word	0x40020070
20008478:	40020088 	.word	0x40020088
2000847c:	400200a0 	.word	0x400200a0
20008480:	400200b8 	.word	0x400200b8
20008484:	40020410 	.word	0x40020410
20008488:	40020428 	.word	0x40020428
2000848c:	40020440 	.word	0x40020440
20008490:	40020458 	.word	0x40020458
20008494:	40020470 	.word	0x40020470
20008498:	40020488 	.word	0x40020488
2000849c:	400204a0 	.word	0x400204a0
200084a0:	400204b8 	.word	0x400204b8
200084a4:	58025408 	.word	0x58025408
200084a8:	5802541c 	.word	0x5802541c
200084ac:	58025430 	.word	0x58025430
200084b0:	58025444 	.word	0x58025444
200084b4:	58025458 	.word	0x58025458
200084b8:	5802546c 	.word	0x5802546c
200084bc:	58025480 	.word	0x58025480
200084c0:	58025494 	.word	0x58025494

200084c4 <HAL_DMAEx_ChangeMemory>:
  *         MEMORY1 and the MEMORY1 address can be changed only when the current
  *         transfer use MEMORY0.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
{
200084c4:	b480      	push	{r7}
200084c6:	b085      	sub	sp, #20
200084c8:	af00      	add	r7, sp, #0
200084ca:	60f8      	str	r0, [r7, #12]
200084cc:	60b9      	str	r1, [r7, #8]
200084ce:	4613      	mov	r3, r2
200084d0:	71fb      	strb	r3, [r7, #7]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
200084d2:	68fb      	ldr	r3, [r7, #12]
200084d4:	681b      	ldr	r3, [r3, #0]
200084d6:	4a39      	ldr	r2, [pc, #228]	; (200085bc <HAL_DMAEx_ChangeMemory+0xf8>)
200084d8:	4293      	cmp	r3, r2
200084da:	d04a      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
200084dc:	68fb      	ldr	r3, [r7, #12]
200084de:	681b      	ldr	r3, [r3, #0]
200084e0:	4a37      	ldr	r2, [pc, #220]	; (200085c0 <HAL_DMAEx_ChangeMemory+0xfc>)
200084e2:	4293      	cmp	r3, r2
200084e4:	d045      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
200084e6:	68fb      	ldr	r3, [r7, #12]
200084e8:	681b      	ldr	r3, [r3, #0]
200084ea:	4a36      	ldr	r2, [pc, #216]	; (200085c4 <HAL_DMAEx_ChangeMemory+0x100>)
200084ec:	4293      	cmp	r3, r2
200084ee:	d040      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
200084f0:	68fb      	ldr	r3, [r7, #12]
200084f2:	681b      	ldr	r3, [r3, #0]
200084f4:	4a34      	ldr	r2, [pc, #208]	; (200085c8 <HAL_DMAEx_ChangeMemory+0x104>)
200084f6:	4293      	cmp	r3, r2
200084f8:	d03b      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
200084fa:	68fb      	ldr	r3, [r7, #12]
200084fc:	681b      	ldr	r3, [r3, #0]
200084fe:	4a33      	ldr	r2, [pc, #204]	; (200085cc <HAL_DMAEx_ChangeMemory+0x108>)
20008500:	4293      	cmp	r3, r2
20008502:	d036      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
20008504:	68fb      	ldr	r3, [r7, #12]
20008506:	681b      	ldr	r3, [r3, #0]
20008508:	4a31      	ldr	r2, [pc, #196]	; (200085d0 <HAL_DMAEx_ChangeMemory+0x10c>)
2000850a:	4293      	cmp	r3, r2
2000850c:	d031      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
2000850e:	68fb      	ldr	r3, [r7, #12]
20008510:	681b      	ldr	r3, [r3, #0]
20008512:	4a30      	ldr	r2, [pc, #192]	; (200085d4 <HAL_DMAEx_ChangeMemory+0x110>)
20008514:	4293      	cmp	r3, r2
20008516:	d02c      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
20008518:	68fb      	ldr	r3, [r7, #12]
2000851a:	681b      	ldr	r3, [r3, #0]
2000851c:	4a2e      	ldr	r2, [pc, #184]	; (200085d8 <HAL_DMAEx_ChangeMemory+0x114>)
2000851e:	4293      	cmp	r3, r2
20008520:	d027      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
20008522:	68fb      	ldr	r3, [r7, #12]
20008524:	681b      	ldr	r3, [r3, #0]
20008526:	4a2d      	ldr	r2, [pc, #180]	; (200085dc <HAL_DMAEx_ChangeMemory+0x118>)
20008528:	4293      	cmp	r3, r2
2000852a:	d022      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
2000852c:	68fb      	ldr	r3, [r7, #12]
2000852e:	681b      	ldr	r3, [r3, #0]
20008530:	4a2b      	ldr	r2, [pc, #172]	; (200085e0 <HAL_DMAEx_ChangeMemory+0x11c>)
20008532:	4293      	cmp	r3, r2
20008534:	d01d      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
20008536:	68fb      	ldr	r3, [r7, #12]
20008538:	681b      	ldr	r3, [r3, #0]
2000853a:	4a2a      	ldr	r2, [pc, #168]	; (200085e4 <HAL_DMAEx_ChangeMemory+0x120>)
2000853c:	4293      	cmp	r3, r2
2000853e:	d018      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
20008540:	68fb      	ldr	r3, [r7, #12]
20008542:	681b      	ldr	r3, [r3, #0]
20008544:	4a28      	ldr	r2, [pc, #160]	; (200085e8 <HAL_DMAEx_ChangeMemory+0x124>)
20008546:	4293      	cmp	r3, r2
20008548:	d013      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
2000854a:	68fb      	ldr	r3, [r7, #12]
2000854c:	681b      	ldr	r3, [r3, #0]
2000854e:	4a27      	ldr	r2, [pc, #156]	; (200085ec <HAL_DMAEx_ChangeMemory+0x128>)
20008550:	4293      	cmp	r3, r2
20008552:	d00e      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
20008554:	68fb      	ldr	r3, [r7, #12]
20008556:	681b      	ldr	r3, [r3, #0]
20008558:	4a25      	ldr	r2, [pc, #148]	; (200085f0 <HAL_DMAEx_ChangeMemory+0x12c>)
2000855a:	4293      	cmp	r3, r2
2000855c:	d009      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
2000855e:	68fb      	ldr	r3, [r7, #12]
20008560:	681b      	ldr	r3, [r3, #0]
20008562:	4a24      	ldr	r2, [pc, #144]	; (200085f4 <HAL_DMAEx_ChangeMemory+0x130>)
20008564:	4293      	cmp	r3, r2
20008566:	d004      	beq.n	20008572 <HAL_DMAEx_ChangeMemory+0xae>
20008568:	68fb      	ldr	r3, [r7, #12]
2000856a:	681b      	ldr	r3, [r3, #0]
2000856c:	4a22      	ldr	r2, [pc, #136]	; (200085f8 <HAL_DMAEx_ChangeMemory+0x134>)
2000856e:	4293      	cmp	r3, r2
20008570:	d101      	bne.n	20008576 <HAL_DMAEx_ChangeMemory+0xb2>
20008572:	2301      	movs	r3, #1
20008574:	e000      	b.n	20008578 <HAL_DMAEx_ChangeMemory+0xb4>
20008576:	2300      	movs	r3, #0
20008578:	2b00      	cmp	r3, #0
2000857a:	d00c      	beq.n	20008596 <HAL_DMAEx_ChangeMemory+0xd2>
  {
    if(memory == MEMORY0)
2000857c:	79fb      	ldrb	r3, [r7, #7]
2000857e:	2b00      	cmp	r3, #0
20008580:	d104      	bne.n	2000858c <HAL_DMAEx_ChangeMemory+0xc8>
    {
      /* change the memory0 address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = Address;
20008582:	68fb      	ldr	r3, [r7, #12]
20008584:	681b      	ldr	r3, [r3, #0]
20008586:	68ba      	ldr	r2, [r7, #8]
20008588:	60da      	str	r2, [r3, #12]
2000858a:	e010      	b.n	200085ae <HAL_DMAEx_ChangeMemory+0xea>
    }
    else
    {
      /* change the memory1 address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = Address;
2000858c:	68fb      	ldr	r3, [r7, #12]
2000858e:	681b      	ldr	r3, [r3, #0]
20008590:	68ba      	ldr	r2, [r7, #8]
20008592:	611a      	str	r2, [r3, #16]
20008594:	e00b      	b.n	200085ae <HAL_DMAEx_ChangeMemory+0xea>
    }
  }
  else /* BDMA instance(s) */
  {
    if(memory == MEMORY0)
20008596:	79fb      	ldrb	r3, [r7, #7]
20008598:	2b00      	cmp	r3, #0
2000859a:	d104      	bne.n	200085a6 <HAL_DMAEx_ChangeMemory+0xe2>
    {
      /* change the memory0 address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = Address;
2000859c:	68fb      	ldr	r3, [r7, #12]
2000859e:	681b      	ldr	r3, [r3, #0]
200085a0:	68ba      	ldr	r2, [r7, #8]
200085a2:	60da      	str	r2, [r3, #12]
200085a4:	e003      	b.n	200085ae <HAL_DMAEx_ChangeMemory+0xea>
    }
    else
    {
      /* change the memory1 address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = Address;
200085a6:	68fb      	ldr	r3, [r7, #12]
200085a8:	681b      	ldr	r3, [r3, #0]
200085aa:	68ba      	ldr	r2, [r7, #8]
200085ac:	611a      	str	r2, [r3, #16]
    }
  }

  return HAL_OK;
200085ae:	2300      	movs	r3, #0
}
200085b0:	4618      	mov	r0, r3
200085b2:	3714      	adds	r7, #20
200085b4:	46bd      	mov	sp, r7
200085b6:	f85d 7b04 	ldr.w	r7, [sp], #4
200085ba:	4770      	bx	lr
200085bc:	40020010 	.word	0x40020010
200085c0:	40020028 	.word	0x40020028
200085c4:	40020040 	.word	0x40020040
200085c8:	40020058 	.word	0x40020058
200085cc:	40020070 	.word	0x40020070
200085d0:	40020088 	.word	0x40020088
200085d4:	400200a0 	.word	0x400200a0
200085d8:	400200b8 	.word	0x400200b8
200085dc:	40020410 	.word	0x40020410
200085e0:	40020428 	.word	0x40020428
200085e4:	40020440 	.word	0x40020440
200085e8:	40020458 	.word	0x40020458
200085ec:	40020470 	.word	0x40020470
200085f0:	40020488 	.word	0x40020488
200085f4:	400204a0 	.word	0x400204a0
200085f8:	400204b8 	.word	0x400204b8

200085fc <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA Stream.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
200085fc:	b580      	push	{r7, lr}
200085fe:	b084      	sub	sp, #16
20008600:	af00      	add	r7, sp, #0
20008602:	6078      	str	r0, [r7, #4]
20008604:	6039      	str	r1, [r7, #0]
  uint32_t syncSignalID = 0;
20008606:	2300      	movs	r3, #0
20008608:	60fb      	str	r3, [r7, #12]
  uint32_t syncPolarity = 0;
2000860a:	2300      	movs	r3, #0
2000860c:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
2000860e:	687b      	ldr	r3, [r7, #4]
20008610:	681b      	ldr	r3, [r3, #0]
20008612:	4a8f      	ldr	r2, [pc, #572]	; (20008850 <HAL_DMAEx_ConfigMuxSync+0x254>)
20008614:	4293      	cmp	r3, r2
20008616:	d077      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
20008618:	687b      	ldr	r3, [r7, #4]
2000861a:	681b      	ldr	r3, [r3, #0]
2000861c:	4a8d      	ldr	r2, [pc, #564]	; (20008854 <HAL_DMAEx_ConfigMuxSync+0x258>)
2000861e:	4293      	cmp	r3, r2
20008620:	d072      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
20008622:	687b      	ldr	r3, [r7, #4]
20008624:	681b      	ldr	r3, [r3, #0]
20008626:	4a8c      	ldr	r2, [pc, #560]	; (20008858 <HAL_DMAEx_ConfigMuxSync+0x25c>)
20008628:	4293      	cmp	r3, r2
2000862a:	d06d      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
2000862c:	687b      	ldr	r3, [r7, #4]
2000862e:	681b      	ldr	r3, [r3, #0]
20008630:	4a8a      	ldr	r2, [pc, #552]	; (2000885c <HAL_DMAEx_ConfigMuxSync+0x260>)
20008632:	4293      	cmp	r3, r2
20008634:	d068      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
20008636:	687b      	ldr	r3, [r7, #4]
20008638:	681b      	ldr	r3, [r3, #0]
2000863a:	4a89      	ldr	r2, [pc, #548]	; (20008860 <HAL_DMAEx_ConfigMuxSync+0x264>)
2000863c:	4293      	cmp	r3, r2
2000863e:	d063      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
20008640:	687b      	ldr	r3, [r7, #4]
20008642:	681b      	ldr	r3, [r3, #0]
20008644:	4a87      	ldr	r2, [pc, #540]	; (20008864 <HAL_DMAEx_ConfigMuxSync+0x268>)
20008646:	4293      	cmp	r3, r2
20008648:	d05e      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
2000864a:	687b      	ldr	r3, [r7, #4]
2000864c:	681b      	ldr	r3, [r3, #0]
2000864e:	4a86      	ldr	r2, [pc, #536]	; (20008868 <HAL_DMAEx_ConfigMuxSync+0x26c>)
20008650:	4293      	cmp	r3, r2
20008652:	d059      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
20008654:	687b      	ldr	r3, [r7, #4]
20008656:	681b      	ldr	r3, [r3, #0]
20008658:	4a84      	ldr	r2, [pc, #528]	; (2000886c <HAL_DMAEx_ConfigMuxSync+0x270>)
2000865a:	4293      	cmp	r3, r2
2000865c:	d054      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
2000865e:	687b      	ldr	r3, [r7, #4]
20008660:	681b      	ldr	r3, [r3, #0]
20008662:	4a83      	ldr	r2, [pc, #524]	; (20008870 <HAL_DMAEx_ConfigMuxSync+0x274>)
20008664:	4293      	cmp	r3, r2
20008666:	d04f      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
20008668:	687b      	ldr	r3, [r7, #4]
2000866a:	681b      	ldr	r3, [r3, #0]
2000866c:	4a81      	ldr	r2, [pc, #516]	; (20008874 <HAL_DMAEx_ConfigMuxSync+0x278>)
2000866e:	4293      	cmp	r3, r2
20008670:	d04a      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
20008672:	687b      	ldr	r3, [r7, #4]
20008674:	681b      	ldr	r3, [r3, #0]
20008676:	4a80      	ldr	r2, [pc, #512]	; (20008878 <HAL_DMAEx_ConfigMuxSync+0x27c>)
20008678:	4293      	cmp	r3, r2
2000867a:	d045      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
2000867c:	687b      	ldr	r3, [r7, #4]
2000867e:	681b      	ldr	r3, [r3, #0]
20008680:	4a7e      	ldr	r2, [pc, #504]	; (2000887c <HAL_DMAEx_ConfigMuxSync+0x280>)
20008682:	4293      	cmp	r3, r2
20008684:	d040      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
20008686:	687b      	ldr	r3, [r7, #4]
20008688:	681b      	ldr	r3, [r3, #0]
2000868a:	4a7d      	ldr	r2, [pc, #500]	; (20008880 <HAL_DMAEx_ConfigMuxSync+0x284>)
2000868c:	4293      	cmp	r3, r2
2000868e:	d03b      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
20008690:	687b      	ldr	r3, [r7, #4]
20008692:	681b      	ldr	r3, [r3, #0]
20008694:	4a7b      	ldr	r2, [pc, #492]	; (20008884 <HAL_DMAEx_ConfigMuxSync+0x288>)
20008696:	4293      	cmp	r3, r2
20008698:	d036      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
2000869a:	687b      	ldr	r3, [r7, #4]
2000869c:	681b      	ldr	r3, [r3, #0]
2000869e:	4a7a      	ldr	r2, [pc, #488]	; (20008888 <HAL_DMAEx_ConfigMuxSync+0x28c>)
200086a0:	4293      	cmp	r3, r2
200086a2:	d031      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
200086a4:	687b      	ldr	r3, [r7, #4]
200086a6:	681b      	ldr	r3, [r3, #0]
200086a8:	4a78      	ldr	r2, [pc, #480]	; (2000888c <HAL_DMAEx_ConfigMuxSync+0x290>)
200086aa:	4293      	cmp	r3, r2
200086ac:	d02c      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
200086ae:	687b      	ldr	r3, [r7, #4]
200086b0:	681b      	ldr	r3, [r3, #0]
200086b2:	4a77      	ldr	r2, [pc, #476]	; (20008890 <HAL_DMAEx_ConfigMuxSync+0x294>)
200086b4:	4293      	cmp	r3, r2
200086b6:	d027      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
200086b8:	687b      	ldr	r3, [r7, #4]
200086ba:	681b      	ldr	r3, [r3, #0]
200086bc:	4a75      	ldr	r2, [pc, #468]	; (20008894 <HAL_DMAEx_ConfigMuxSync+0x298>)
200086be:	4293      	cmp	r3, r2
200086c0:	d022      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
200086c2:	687b      	ldr	r3, [r7, #4]
200086c4:	681b      	ldr	r3, [r3, #0]
200086c6:	4a74      	ldr	r2, [pc, #464]	; (20008898 <HAL_DMAEx_ConfigMuxSync+0x29c>)
200086c8:	4293      	cmp	r3, r2
200086ca:	d01d      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
200086cc:	687b      	ldr	r3, [r7, #4]
200086ce:	681b      	ldr	r3, [r3, #0]
200086d0:	4a72      	ldr	r2, [pc, #456]	; (2000889c <HAL_DMAEx_ConfigMuxSync+0x2a0>)
200086d2:	4293      	cmp	r3, r2
200086d4:	d018      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
200086d6:	687b      	ldr	r3, [r7, #4]
200086d8:	681b      	ldr	r3, [r3, #0]
200086da:	4a71      	ldr	r2, [pc, #452]	; (200088a0 <HAL_DMAEx_ConfigMuxSync+0x2a4>)
200086dc:	4293      	cmp	r3, r2
200086de:	d013      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
200086e0:	687b      	ldr	r3, [r7, #4]
200086e2:	681b      	ldr	r3, [r3, #0]
200086e4:	4a6f      	ldr	r2, [pc, #444]	; (200088a4 <HAL_DMAEx_ConfigMuxSync+0x2a8>)
200086e6:	4293      	cmp	r3, r2
200086e8:	d00e      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
200086ea:	687b      	ldr	r3, [r7, #4]
200086ec:	681b      	ldr	r3, [r3, #0]
200086ee:	4a6e      	ldr	r2, [pc, #440]	; (200088a8 <HAL_DMAEx_ConfigMuxSync+0x2ac>)
200086f0:	4293      	cmp	r3, r2
200086f2:	d009      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
200086f4:	687b      	ldr	r3, [r7, #4]
200086f6:	681b      	ldr	r3, [r3, #0]
200086f8:	4a6c      	ldr	r2, [pc, #432]	; (200088ac <HAL_DMAEx_ConfigMuxSync+0x2b0>)
200086fa:	4293      	cmp	r3, r2
200086fc:	d004      	beq.n	20008708 <HAL_DMAEx_ConfigMuxSync+0x10c>
200086fe:	f240 1193 	movw	r1, #403	; 0x193
20008702:	486b      	ldr	r0, [pc, #428]	; (200088b0 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
20008704:	f7f8 f8f6 	bl	200008f4 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
20008708:	683b      	ldr	r3, [r7, #0]
2000870a:	7a1b      	ldrb	r3, [r3, #8]
2000870c:	2b00      	cmp	r3, #0
2000870e:	d008      	beq.n	20008722 <HAL_DMAEx_ConfigMuxSync+0x126>
20008710:	683b      	ldr	r3, [r7, #0]
20008712:	7a1b      	ldrb	r3, [r3, #8]
20008714:	2b01      	cmp	r3, #1
20008716:	d004      	beq.n	20008722 <HAL_DMAEx_ConfigMuxSync+0x126>
20008718:	f44f 71ca 	mov.w	r1, #404	; 0x194
2000871c:	4864      	ldr	r0, [pc, #400]	; (200088b0 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
2000871e:	f7f8 f8e9 	bl	200008f4 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
20008722:	683b      	ldr	r3, [r7, #0]
20008724:	7a5b      	ldrb	r3, [r3, #9]
20008726:	2b00      	cmp	r3, #0
20008728:	d008      	beq.n	2000873c <HAL_DMAEx_ConfigMuxSync+0x140>
2000872a:	683b      	ldr	r3, [r7, #0]
2000872c:	7a5b      	ldrb	r3, [r3, #9]
2000872e:	2b01      	cmp	r3, #1
20008730:	d004      	beq.n	2000873c <HAL_DMAEx_ConfigMuxSync+0x140>
20008732:	f240 1195 	movw	r1, #405	; 0x195
20008736:	485e      	ldr	r0, [pc, #376]	; (200088b0 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
20008738:	f7f8 f8dc 	bl	200008f4 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
2000873c:	683b      	ldr	r3, [r7, #0]
2000873e:	68db      	ldr	r3, [r3, #12]
20008740:	2b00      	cmp	r3, #0
20008742:	d003      	beq.n	2000874c <HAL_DMAEx_ConfigMuxSync+0x150>
20008744:	683b      	ldr	r3, [r7, #0]
20008746:	68db      	ldr	r3, [r3, #12]
20008748:	2b20      	cmp	r3, #32
2000874a:	d904      	bls.n	20008756 <HAL_DMAEx_ConfigMuxSync+0x15a>
2000874c:	f44f 71cb 	mov.w	r1, #406	; 0x196
20008750:	4857      	ldr	r0, [pc, #348]	; (200088b0 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
20008752:	f7f8 f8cf 	bl	200008f4 <assert_failed>

  if(pSyncConfig->SyncEnable == ENABLE)
20008756:	683b      	ldr	r3, [r7, #0]
20008758:	7a1b      	ldrb	r3, [r3, #8]
2000875a:	2b01      	cmp	r3, #1
2000875c:	f040 80b9 	bne.w	200088d2 <HAL_DMAEx_ConfigMuxSync+0x2d6>
  {
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
20008760:	683b      	ldr	r3, [r7, #0]
20008762:	685b      	ldr	r3, [r3, #4]
20008764:	2b00      	cmp	r3, #0
20008766:	d013      	beq.n	20008790 <HAL_DMAEx_ConfigMuxSync+0x194>
20008768:	683b      	ldr	r3, [r7, #0]
2000876a:	685b      	ldr	r3, [r3, #4]
2000876c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20008770:	d00e      	beq.n	20008790 <HAL_DMAEx_ConfigMuxSync+0x194>
20008772:	683b      	ldr	r3, [r7, #0]
20008774:	685b      	ldr	r3, [r3, #4]
20008776:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
2000877a:	d009      	beq.n	20008790 <HAL_DMAEx_ConfigMuxSync+0x194>
2000877c:	683b      	ldr	r3, [r7, #0]
2000877e:	685b      	ldr	r3, [r3, #4]
20008780:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
20008784:	d004      	beq.n	20008790 <HAL_DMAEx_ConfigMuxSync+0x194>
20008786:	f44f 71cd 	mov.w	r1, #410	; 0x19a
2000878a:	4849      	ldr	r0, [pc, #292]	; (200088b0 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
2000878c:	f7f8 f8b2 	bl	200008f4 <assert_failed>

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20008790:	687b      	ldr	r3, [r7, #4]
20008792:	681b      	ldr	r3, [r3, #0]
20008794:	4a2e      	ldr	r2, [pc, #184]	; (20008850 <HAL_DMAEx_ConfigMuxSync+0x254>)
20008796:	4293      	cmp	r3, r2
20008798:	d04a      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
2000879a:	687b      	ldr	r3, [r7, #4]
2000879c:	681b      	ldr	r3, [r3, #0]
2000879e:	4a2d      	ldr	r2, [pc, #180]	; (20008854 <HAL_DMAEx_ConfigMuxSync+0x258>)
200087a0:	4293      	cmp	r3, r2
200087a2:	d045      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
200087a4:	687b      	ldr	r3, [r7, #4]
200087a6:	681b      	ldr	r3, [r3, #0]
200087a8:	4a2b      	ldr	r2, [pc, #172]	; (20008858 <HAL_DMAEx_ConfigMuxSync+0x25c>)
200087aa:	4293      	cmp	r3, r2
200087ac:	d040      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
200087ae:	687b      	ldr	r3, [r7, #4]
200087b0:	681b      	ldr	r3, [r3, #0]
200087b2:	4a2a      	ldr	r2, [pc, #168]	; (2000885c <HAL_DMAEx_ConfigMuxSync+0x260>)
200087b4:	4293      	cmp	r3, r2
200087b6:	d03b      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
200087b8:	687b      	ldr	r3, [r7, #4]
200087ba:	681b      	ldr	r3, [r3, #0]
200087bc:	4a28      	ldr	r2, [pc, #160]	; (20008860 <HAL_DMAEx_ConfigMuxSync+0x264>)
200087be:	4293      	cmp	r3, r2
200087c0:	d036      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
200087c2:	687b      	ldr	r3, [r7, #4]
200087c4:	681b      	ldr	r3, [r3, #0]
200087c6:	4a27      	ldr	r2, [pc, #156]	; (20008864 <HAL_DMAEx_ConfigMuxSync+0x268>)
200087c8:	4293      	cmp	r3, r2
200087ca:	d031      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
200087cc:	687b      	ldr	r3, [r7, #4]
200087ce:	681b      	ldr	r3, [r3, #0]
200087d0:	4a25      	ldr	r2, [pc, #148]	; (20008868 <HAL_DMAEx_ConfigMuxSync+0x26c>)
200087d2:	4293      	cmp	r3, r2
200087d4:	d02c      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
200087d6:	687b      	ldr	r3, [r7, #4]
200087d8:	681b      	ldr	r3, [r3, #0]
200087da:	4a24      	ldr	r2, [pc, #144]	; (2000886c <HAL_DMAEx_ConfigMuxSync+0x270>)
200087dc:	4293      	cmp	r3, r2
200087de:	d027      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
200087e0:	687b      	ldr	r3, [r7, #4]
200087e2:	681b      	ldr	r3, [r3, #0]
200087e4:	4a22      	ldr	r2, [pc, #136]	; (20008870 <HAL_DMAEx_ConfigMuxSync+0x274>)
200087e6:	4293      	cmp	r3, r2
200087e8:	d022      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
200087ea:	687b      	ldr	r3, [r7, #4]
200087ec:	681b      	ldr	r3, [r3, #0]
200087ee:	4a21      	ldr	r2, [pc, #132]	; (20008874 <HAL_DMAEx_ConfigMuxSync+0x278>)
200087f0:	4293      	cmp	r3, r2
200087f2:	d01d      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
200087f4:	687b      	ldr	r3, [r7, #4]
200087f6:	681b      	ldr	r3, [r3, #0]
200087f8:	4a1f      	ldr	r2, [pc, #124]	; (20008878 <HAL_DMAEx_ConfigMuxSync+0x27c>)
200087fa:	4293      	cmp	r3, r2
200087fc:	d018      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
200087fe:	687b      	ldr	r3, [r7, #4]
20008800:	681b      	ldr	r3, [r3, #0]
20008802:	4a1e      	ldr	r2, [pc, #120]	; (2000887c <HAL_DMAEx_ConfigMuxSync+0x280>)
20008804:	4293      	cmp	r3, r2
20008806:	d013      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
20008808:	687b      	ldr	r3, [r7, #4]
2000880a:	681b      	ldr	r3, [r3, #0]
2000880c:	4a1c      	ldr	r2, [pc, #112]	; (20008880 <HAL_DMAEx_ConfigMuxSync+0x284>)
2000880e:	4293      	cmp	r3, r2
20008810:	d00e      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
20008812:	687b      	ldr	r3, [r7, #4]
20008814:	681b      	ldr	r3, [r3, #0]
20008816:	4a1b      	ldr	r2, [pc, #108]	; (20008884 <HAL_DMAEx_ConfigMuxSync+0x288>)
20008818:	4293      	cmp	r3, r2
2000881a:	d009      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
2000881c:	687b      	ldr	r3, [r7, #4]
2000881e:	681b      	ldr	r3, [r3, #0]
20008820:	4a19      	ldr	r2, [pc, #100]	; (20008888 <HAL_DMAEx_ConfigMuxSync+0x28c>)
20008822:	4293      	cmp	r3, r2
20008824:	d004      	beq.n	20008830 <HAL_DMAEx_ConfigMuxSync+0x234>
20008826:	687b      	ldr	r3, [r7, #4]
20008828:	681b      	ldr	r3, [r3, #0]
2000882a:	4a18      	ldr	r2, [pc, #96]	; (2000888c <HAL_DMAEx_ConfigMuxSync+0x290>)
2000882c:	4293      	cmp	r3, r2
2000882e:	d101      	bne.n	20008834 <HAL_DMAEx_ConfigMuxSync+0x238>
20008830:	2301      	movs	r3, #1
20008832:	e000      	b.n	20008836 <HAL_DMAEx_ConfigMuxSync+0x23a>
20008834:	2300      	movs	r3, #0
20008836:	2b00      	cmp	r3, #0
20008838:	d03c      	beq.n	200088b4 <HAL_DMAEx_ConfigMuxSync+0x2b8>
    {
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
2000883a:	683b      	ldr	r3, [r7, #0]
2000883c:	681b      	ldr	r3, [r3, #0]
2000883e:	2b07      	cmp	r3, #7
20008840:	d941      	bls.n	200088c6 <HAL_DMAEx_ConfigMuxSync+0x2ca>
20008842:	f44f 71cf 	mov.w	r1, #414	; 0x19e
20008846:	481a      	ldr	r0, [pc, #104]	; (200088b0 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
20008848:	f7f8 f854 	bl	200008f4 <assert_failed>
2000884c:	e03b      	b.n	200088c6 <HAL_DMAEx_ConfigMuxSync+0x2ca>
2000884e:	bf00      	nop
20008850:	40020010 	.word	0x40020010
20008854:	40020028 	.word	0x40020028
20008858:	40020040 	.word	0x40020040
2000885c:	40020058 	.word	0x40020058
20008860:	40020070 	.word	0x40020070
20008864:	40020088 	.word	0x40020088
20008868:	400200a0 	.word	0x400200a0
2000886c:	400200b8 	.word	0x400200b8
20008870:	40020410 	.word	0x40020410
20008874:	40020428 	.word	0x40020428
20008878:	40020440 	.word	0x40020440
2000887c:	40020458 	.word	0x40020458
20008880:	40020470 	.word	0x40020470
20008884:	40020488 	.word	0x40020488
20008888:	400204a0 	.word	0x400204a0
2000888c:	400204b8 	.word	0x400204b8
20008890:	58025408 	.word	0x58025408
20008894:	5802541c 	.word	0x5802541c
20008898:	58025430 	.word	0x58025430
2000889c:	58025444 	.word	0x58025444
200088a0:	58025458 	.word	0x58025458
200088a4:	5802546c 	.word	0x5802546c
200088a8:	58025480 	.word	0x58025480
200088ac:	58025494 	.word	0x58025494
200088b0:	2001c014 	.word	0x2001c014
    }
    else
    {
      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
200088b4:	683b      	ldr	r3, [r7, #0]
200088b6:	681b      	ldr	r3, [r3, #0]
200088b8:	2b0f      	cmp	r3, #15
200088ba:	d904      	bls.n	200088c6 <HAL_DMAEx_ConfigMuxSync+0x2ca>
200088bc:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
200088c0:	4824      	ldr	r0, [pc, #144]	; (20008954 <HAL_DMAEx_ConfigMuxSync+0x358>)
200088c2:	f7f8 f817 	bl	200008f4 <assert_failed>
    }
    syncSignalID = pSyncConfig->SyncSignalID;
200088c6:	683b      	ldr	r3, [r7, #0]
200088c8:	681b      	ldr	r3, [r3, #0]
200088ca:	60fb      	str	r3, [r7, #12]
    syncPolarity = pSyncConfig->SyncPolarity;
200088cc:	683b      	ldr	r3, [r7, #0]
200088ce:	685b      	ldr	r3, [r3, #4]
200088d0:	60bb      	str	r3, [r7, #8]
  }

  /*Check if the DMA state is ready */
  if(hdma->State == HAL_DMA_STATE_READY)
200088d2:	687b      	ldr	r3, [r7, #4]
200088d4:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
200088d8:	b2db      	uxtb	r3, r3
200088da:	2b01      	cmp	r3, #1
200088dc:	d131      	bne.n	20008942 <HAL_DMAEx_ConfigMuxSync+0x346>
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
200088de:	687b      	ldr	r3, [r7, #4]
200088e0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
200088e4:	2b01      	cmp	r3, #1
200088e6:	d101      	bne.n	200088ec <HAL_DMAEx_ConfigMuxSync+0x2f0>
200088e8:	2302      	movs	r3, #2
200088ea:	e02f      	b.n	2000894c <HAL_DMAEx_ConfigMuxSync+0x350>
200088ec:	687b      	ldr	r3, [r7, #4]
200088ee:	2201      	movs	r2, #1
200088f0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Disable the synchronization and event generation before applying a new config */
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
200088f4:	687b      	ldr	r3, [r7, #4]
200088f6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200088f8:	681a      	ldr	r2, [r3, #0]
200088fa:	687b      	ldr	r3, [r7, #4]
200088fc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200088fe:	f422 3281 	bic.w	r2, r2, #66048	; 0x10200
20008902:	601a      	str	r2, [r3, #0]

    /* Set the new synchronization parameters (and keep the request ID filled during the Init)*/
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
20008904:	687b      	ldr	r3, [r7, #4]
20008906:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20008908:	681b      	ldr	r3, [r3, #0]
2000890a:	b2d9      	uxtb	r1, r3
2000890c:	68fb      	ldr	r3, [r7, #12]
2000890e:	061a      	lsls	r2, r3, #24
20008910:	683b      	ldr	r3, [r7, #0]
20008912:	68db      	ldr	r3, [r3, #12]
20008914:	3b01      	subs	r3, #1
20008916:	04db      	lsls	r3, r3, #19
20008918:	431a      	orrs	r2, r3
2000891a:	68bb      	ldr	r3, [r7, #8]
2000891c:	431a      	orrs	r2, r3
2000891e:	683b      	ldr	r3, [r7, #0]
20008920:	7a1b      	ldrb	r3, [r3, #8]
20008922:	041b      	lsls	r3, r3, #16
20008924:	431a      	orrs	r2, r3
20008926:	683b      	ldr	r3, [r7, #0]
20008928:	7a5b      	ldrb	r3, [r3, #9]
2000892a:	025b      	lsls	r3, r3, #9
2000892c:	431a      	orrs	r2, r3
2000892e:	687b      	ldr	r3, [r7, #4]
20008930:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20008932:	430a      	orrs	r2, r1
20008934:	601a      	str	r2, [r3, #0]
               ((pSyncConfig->RequestNumber - 1U) << DMAMUX_CxCR_NBREQ_Pos) | \
               syncPolarity | ((uint32_t)pSyncConfig->SyncEnable << DMAMUX_CxCR_SE_Pos)    | \
               ((uint32_t)pSyncConfig->EventEnable << DMAMUX_CxCR_EGE_Pos));

      /* Process Locked */
    __HAL_UNLOCK(hdma);
20008936:	687b      	ldr	r3, [r7, #4]
20008938:	2200      	movs	r2, #0
2000893a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_OK;
2000893e:	2300      	movs	r3, #0
20008940:	e004      	b.n	2000894c <HAL_DMAEx_ConfigMuxSync+0x350>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
20008942:	687b      	ldr	r3, [r7, #4]
20008944:	f44f 6200 	mov.w	r2, #2048	; 0x800
20008948:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    return HAL_ERROR;
2000894a:	2301      	movs	r3, #1
  }
}
2000894c:	4618      	mov	r0, r3
2000894e:	3710      	adds	r7, #16
20008950:	46bd      	mov	sp, r7
20008952:	bd80      	pop	{r7, pc}
20008954:	2001c014 	.word	0x2001c014

20008958 <HAL_DMAEx_ConfigMuxRequestGenerator>:
  *         contains the request generator parameters.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxRequestGenerator (DMA_HandleTypeDef *hdma, HAL_DMA_MuxRequestGeneratorConfigTypeDef *pRequestGeneratorConfig)
{
20008958:	b580      	push	{r7, lr}
2000895a:	b084      	sub	sp, #16
2000895c:	af00      	add	r7, sp, #0
2000895e:	6078      	str	r0, [r7, #4]
20008960:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  HAL_DMA_StateTypeDef temp_state = hdma->State;
20008962:	687b      	ldr	r3, [r7, #4]
20008964:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20008968:	73bb      	strb	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
2000896a:	687b      	ldr	r3, [r7, #4]
2000896c:	681b      	ldr	r3, [r3, #0]
2000896e:	4a91      	ldr	r2, [pc, #580]	; (20008bb4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x25c>)
20008970:	4293      	cmp	r3, r2
20008972:	d077      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008974:	687b      	ldr	r3, [r7, #4]
20008976:	681b      	ldr	r3, [r3, #0]
20008978:	4a8f      	ldr	r2, [pc, #572]	; (20008bb8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x260>)
2000897a:	4293      	cmp	r3, r2
2000897c:	d072      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
2000897e:	687b      	ldr	r3, [r7, #4]
20008980:	681b      	ldr	r3, [r3, #0]
20008982:	4a8e      	ldr	r2, [pc, #568]	; (20008bbc <HAL_DMAEx_ConfigMuxRequestGenerator+0x264>)
20008984:	4293      	cmp	r3, r2
20008986:	d06d      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008988:	687b      	ldr	r3, [r7, #4]
2000898a:	681b      	ldr	r3, [r3, #0]
2000898c:	4a8c      	ldr	r2, [pc, #560]	; (20008bc0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x268>)
2000898e:	4293      	cmp	r3, r2
20008990:	d068      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008992:	687b      	ldr	r3, [r7, #4]
20008994:	681b      	ldr	r3, [r3, #0]
20008996:	4a8b      	ldr	r2, [pc, #556]	; (20008bc4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x26c>)
20008998:	4293      	cmp	r3, r2
2000899a:	d063      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
2000899c:	687b      	ldr	r3, [r7, #4]
2000899e:	681b      	ldr	r3, [r3, #0]
200089a0:	4a89      	ldr	r2, [pc, #548]	; (20008bc8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x270>)
200089a2:	4293      	cmp	r3, r2
200089a4:	d05e      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
200089a6:	687b      	ldr	r3, [r7, #4]
200089a8:	681b      	ldr	r3, [r3, #0]
200089aa:	4a88      	ldr	r2, [pc, #544]	; (20008bcc <HAL_DMAEx_ConfigMuxRequestGenerator+0x274>)
200089ac:	4293      	cmp	r3, r2
200089ae:	d059      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
200089b0:	687b      	ldr	r3, [r7, #4]
200089b2:	681b      	ldr	r3, [r3, #0]
200089b4:	4a86      	ldr	r2, [pc, #536]	; (20008bd0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x278>)
200089b6:	4293      	cmp	r3, r2
200089b8:	d054      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
200089ba:	687b      	ldr	r3, [r7, #4]
200089bc:	681b      	ldr	r3, [r3, #0]
200089be:	4a85      	ldr	r2, [pc, #532]	; (20008bd4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x27c>)
200089c0:	4293      	cmp	r3, r2
200089c2:	d04f      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
200089c4:	687b      	ldr	r3, [r7, #4]
200089c6:	681b      	ldr	r3, [r3, #0]
200089c8:	4a83      	ldr	r2, [pc, #524]	; (20008bd8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x280>)
200089ca:	4293      	cmp	r3, r2
200089cc:	d04a      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
200089ce:	687b      	ldr	r3, [r7, #4]
200089d0:	681b      	ldr	r3, [r3, #0]
200089d2:	4a82      	ldr	r2, [pc, #520]	; (20008bdc <HAL_DMAEx_ConfigMuxRequestGenerator+0x284>)
200089d4:	4293      	cmp	r3, r2
200089d6:	d045      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
200089d8:	687b      	ldr	r3, [r7, #4]
200089da:	681b      	ldr	r3, [r3, #0]
200089dc:	4a80      	ldr	r2, [pc, #512]	; (20008be0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x288>)
200089de:	4293      	cmp	r3, r2
200089e0:	d040      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
200089e2:	687b      	ldr	r3, [r7, #4]
200089e4:	681b      	ldr	r3, [r3, #0]
200089e6:	4a7f      	ldr	r2, [pc, #508]	; (20008be4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x28c>)
200089e8:	4293      	cmp	r3, r2
200089ea:	d03b      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
200089ec:	687b      	ldr	r3, [r7, #4]
200089ee:	681b      	ldr	r3, [r3, #0]
200089f0:	4a7d      	ldr	r2, [pc, #500]	; (20008be8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x290>)
200089f2:	4293      	cmp	r3, r2
200089f4:	d036      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
200089f6:	687b      	ldr	r3, [r7, #4]
200089f8:	681b      	ldr	r3, [r3, #0]
200089fa:	4a7c      	ldr	r2, [pc, #496]	; (20008bec <HAL_DMAEx_ConfigMuxRequestGenerator+0x294>)
200089fc:	4293      	cmp	r3, r2
200089fe:	d031      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008a00:	687b      	ldr	r3, [r7, #4]
20008a02:	681b      	ldr	r3, [r3, #0]
20008a04:	4a7a      	ldr	r2, [pc, #488]	; (20008bf0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x298>)
20008a06:	4293      	cmp	r3, r2
20008a08:	d02c      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008a0a:	687b      	ldr	r3, [r7, #4]
20008a0c:	681b      	ldr	r3, [r3, #0]
20008a0e:	4a79      	ldr	r2, [pc, #484]	; (20008bf4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x29c>)
20008a10:	4293      	cmp	r3, r2
20008a12:	d027      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008a14:	687b      	ldr	r3, [r7, #4]
20008a16:	681b      	ldr	r3, [r3, #0]
20008a18:	4a77      	ldr	r2, [pc, #476]	; (20008bf8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2a0>)
20008a1a:	4293      	cmp	r3, r2
20008a1c:	d022      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008a1e:	687b      	ldr	r3, [r7, #4]
20008a20:	681b      	ldr	r3, [r3, #0]
20008a22:	4a76      	ldr	r2, [pc, #472]	; (20008bfc <HAL_DMAEx_ConfigMuxRequestGenerator+0x2a4>)
20008a24:	4293      	cmp	r3, r2
20008a26:	d01d      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008a28:	687b      	ldr	r3, [r7, #4]
20008a2a:	681b      	ldr	r3, [r3, #0]
20008a2c:	4a74      	ldr	r2, [pc, #464]	; (20008c00 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2a8>)
20008a2e:	4293      	cmp	r3, r2
20008a30:	d018      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008a32:	687b      	ldr	r3, [r7, #4]
20008a34:	681b      	ldr	r3, [r3, #0]
20008a36:	4a73      	ldr	r2, [pc, #460]	; (20008c04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2ac>)
20008a38:	4293      	cmp	r3, r2
20008a3a:	d013      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008a3c:	687b      	ldr	r3, [r7, #4]
20008a3e:	681b      	ldr	r3, [r3, #0]
20008a40:	4a71      	ldr	r2, [pc, #452]	; (20008c08 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2b0>)
20008a42:	4293      	cmp	r3, r2
20008a44:	d00e      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008a46:	687b      	ldr	r3, [r7, #4]
20008a48:	681b      	ldr	r3, [r3, #0]
20008a4a:	4a70      	ldr	r2, [pc, #448]	; (20008c0c <HAL_DMAEx_ConfigMuxRequestGenerator+0x2b4>)
20008a4c:	4293      	cmp	r3, r2
20008a4e:	d009      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008a50:	687b      	ldr	r3, [r7, #4]
20008a52:	681b      	ldr	r3, [r3, #0]
20008a54:	4a6e      	ldr	r2, [pc, #440]	; (20008c10 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2b8>)
20008a56:	4293      	cmp	r3, r2
20008a58:	d004      	beq.n	20008a64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10c>
20008a5a:	f240 11d7 	movw	r1, #471	; 0x1d7
20008a5e:	486d      	ldr	r0, [pc, #436]	; (20008c14 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2bc>)
20008a60:	f7f7 ff48 	bl	200008f4 <assert_failed>

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20008a64:	687b      	ldr	r3, [r7, #4]
20008a66:	681b      	ldr	r3, [r3, #0]
20008a68:	4a52      	ldr	r2, [pc, #328]	; (20008bb4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x25c>)
20008a6a:	4293      	cmp	r3, r2
20008a6c:	d04a      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008a6e:	687b      	ldr	r3, [r7, #4]
20008a70:	681b      	ldr	r3, [r3, #0]
20008a72:	4a51      	ldr	r2, [pc, #324]	; (20008bb8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x260>)
20008a74:	4293      	cmp	r3, r2
20008a76:	d045      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008a78:	687b      	ldr	r3, [r7, #4]
20008a7a:	681b      	ldr	r3, [r3, #0]
20008a7c:	4a4f      	ldr	r2, [pc, #316]	; (20008bbc <HAL_DMAEx_ConfigMuxRequestGenerator+0x264>)
20008a7e:	4293      	cmp	r3, r2
20008a80:	d040      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008a82:	687b      	ldr	r3, [r7, #4]
20008a84:	681b      	ldr	r3, [r3, #0]
20008a86:	4a4e      	ldr	r2, [pc, #312]	; (20008bc0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x268>)
20008a88:	4293      	cmp	r3, r2
20008a8a:	d03b      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008a8c:	687b      	ldr	r3, [r7, #4]
20008a8e:	681b      	ldr	r3, [r3, #0]
20008a90:	4a4c      	ldr	r2, [pc, #304]	; (20008bc4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x26c>)
20008a92:	4293      	cmp	r3, r2
20008a94:	d036      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008a96:	687b      	ldr	r3, [r7, #4]
20008a98:	681b      	ldr	r3, [r3, #0]
20008a9a:	4a4b      	ldr	r2, [pc, #300]	; (20008bc8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x270>)
20008a9c:	4293      	cmp	r3, r2
20008a9e:	d031      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008aa0:	687b      	ldr	r3, [r7, #4]
20008aa2:	681b      	ldr	r3, [r3, #0]
20008aa4:	4a49      	ldr	r2, [pc, #292]	; (20008bcc <HAL_DMAEx_ConfigMuxRequestGenerator+0x274>)
20008aa6:	4293      	cmp	r3, r2
20008aa8:	d02c      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008aaa:	687b      	ldr	r3, [r7, #4]
20008aac:	681b      	ldr	r3, [r3, #0]
20008aae:	4a48      	ldr	r2, [pc, #288]	; (20008bd0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x278>)
20008ab0:	4293      	cmp	r3, r2
20008ab2:	d027      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008ab4:	687b      	ldr	r3, [r7, #4]
20008ab6:	681b      	ldr	r3, [r3, #0]
20008ab8:	4a46      	ldr	r2, [pc, #280]	; (20008bd4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x27c>)
20008aba:	4293      	cmp	r3, r2
20008abc:	d022      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008abe:	687b      	ldr	r3, [r7, #4]
20008ac0:	681b      	ldr	r3, [r3, #0]
20008ac2:	4a45      	ldr	r2, [pc, #276]	; (20008bd8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x280>)
20008ac4:	4293      	cmp	r3, r2
20008ac6:	d01d      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008ac8:	687b      	ldr	r3, [r7, #4]
20008aca:	681b      	ldr	r3, [r3, #0]
20008acc:	4a43      	ldr	r2, [pc, #268]	; (20008bdc <HAL_DMAEx_ConfigMuxRequestGenerator+0x284>)
20008ace:	4293      	cmp	r3, r2
20008ad0:	d018      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008ad2:	687b      	ldr	r3, [r7, #4]
20008ad4:	681b      	ldr	r3, [r3, #0]
20008ad6:	4a42      	ldr	r2, [pc, #264]	; (20008be0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x288>)
20008ad8:	4293      	cmp	r3, r2
20008ada:	d013      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008adc:	687b      	ldr	r3, [r7, #4]
20008ade:	681b      	ldr	r3, [r3, #0]
20008ae0:	4a40      	ldr	r2, [pc, #256]	; (20008be4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x28c>)
20008ae2:	4293      	cmp	r3, r2
20008ae4:	d00e      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008ae6:	687b      	ldr	r3, [r7, #4]
20008ae8:	681b      	ldr	r3, [r3, #0]
20008aea:	4a3f      	ldr	r2, [pc, #252]	; (20008be8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x290>)
20008aec:	4293      	cmp	r3, r2
20008aee:	d009      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008af0:	687b      	ldr	r3, [r7, #4]
20008af2:	681b      	ldr	r3, [r3, #0]
20008af4:	4a3d      	ldr	r2, [pc, #244]	; (20008bec <HAL_DMAEx_ConfigMuxRequestGenerator+0x294>)
20008af6:	4293      	cmp	r3, r2
20008af8:	d004      	beq.n	20008b04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ac>
20008afa:	687b      	ldr	r3, [r7, #4]
20008afc:	681b      	ldr	r3, [r3, #0]
20008afe:	4a3c      	ldr	r2, [pc, #240]	; (20008bf0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x298>)
20008b00:	4293      	cmp	r3, r2
20008b02:	d101      	bne.n	20008b08 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1b0>
20008b04:	2301      	movs	r3, #1
20008b06:	e000      	b.n	20008b0a <HAL_DMAEx_ConfigMuxRequestGenerator+0x1b2>
20008b08:	2300      	movs	r3, #0
20008b0a:	2b00      	cmp	r3, #0
20008b0c:	d009      	beq.n	20008b22 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1ca>
  {
    assert_param(IS_DMA_DMAMUX_REQUEST_GEN_SIGNAL_ID(pRequestGeneratorConfig->SignalID));
20008b0e:	683b      	ldr	r3, [r7, #0]
20008b10:	681b      	ldr	r3, [r3, #0]
20008b12:	2b07      	cmp	r3, #7
20008b14:	d90e      	bls.n	20008b34 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1dc>
20008b16:	f240 11db 	movw	r1, #475	; 0x1db
20008b1a:	483e      	ldr	r0, [pc, #248]	; (20008c14 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2bc>)
20008b1c:	f7f7 feea 	bl	200008f4 <assert_failed>
20008b20:	e008      	b.n	20008b34 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1dc>
  }
  else
  {
    assert_param(IS_BDMA_DMAMUX_REQUEST_GEN_SIGNAL_ID(pRequestGeneratorConfig->SignalID));
20008b22:	683b      	ldr	r3, [r7, #0]
20008b24:	681b      	ldr	r3, [r3, #0]
20008b26:	2b1d      	cmp	r3, #29
20008b28:	d904      	bls.n	20008b34 <HAL_DMAEx_ConfigMuxRequestGenerator+0x1dc>
20008b2a:	f240 11df 	movw	r1, #479	; 0x1df
20008b2e:	4839      	ldr	r0, [pc, #228]	; (20008c14 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2bc>)
20008b30:	f7f7 fee0 	bl	200008f4 <assert_failed>
  }


  assert_param(IS_DMAMUX_REQUEST_GEN_POLARITY(pRequestGeneratorConfig->Polarity));
20008b34:	683b      	ldr	r3, [r7, #0]
20008b36:	685b      	ldr	r3, [r3, #4]
20008b38:	2b00      	cmp	r3, #0
20008b3a:	d013      	beq.n	20008b64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x20c>
20008b3c:	683b      	ldr	r3, [r7, #0]
20008b3e:	685b      	ldr	r3, [r3, #4]
20008b40:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20008b44:	d00e      	beq.n	20008b64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x20c>
20008b46:	683b      	ldr	r3, [r7, #0]
20008b48:	685b      	ldr	r3, [r3, #4]
20008b4a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
20008b4e:	d009      	beq.n	20008b64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x20c>
20008b50:	683b      	ldr	r3, [r7, #0]
20008b52:	685b      	ldr	r3, [r3, #4]
20008b54:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
20008b58:	d004      	beq.n	20008b64 <HAL_DMAEx_ConfigMuxRequestGenerator+0x20c>
20008b5a:	f240 11e3 	movw	r1, #483	; 0x1e3
20008b5e:	482d      	ldr	r0, [pc, #180]	; (20008c14 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2bc>)
20008b60:	f7f7 fec8 	bl	200008f4 <assert_failed>
  assert_param(IS_DMAMUX_REQUEST_GEN_REQUEST_NUMBER(pRequestGeneratorConfig->RequestNumber));
20008b64:	683b      	ldr	r3, [r7, #0]
20008b66:	689b      	ldr	r3, [r3, #8]
20008b68:	2b00      	cmp	r3, #0
20008b6a:	d003      	beq.n	20008b74 <HAL_DMAEx_ConfigMuxRequestGenerator+0x21c>
20008b6c:	683b      	ldr	r3, [r7, #0]
20008b6e:	689b      	ldr	r3, [r3, #8]
20008b70:	2b20      	cmp	r3, #32
20008b72:	d904      	bls.n	20008b7e <HAL_DMAEx_ConfigMuxRequestGenerator+0x226>
20008b74:	f44f 71f2 	mov.w	r1, #484	; 0x1e4
20008b78:	4826      	ldr	r0, [pc, #152]	; (20008c14 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2bc>)
20008b7a:	f7f7 febb 	bl	200008f4 <assert_failed>

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block
  */
  if(hdma->DMAmuxRequestGen == 0U)
20008b7e:	687b      	ldr	r3, [r7, #4]
20008b80:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008b82:	2b00      	cmp	r3, #0
20008b84:	d105      	bne.n	20008b92 <HAL_DMAEx_ConfigMuxRequestGenerator+0x23a>
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
20008b86:	687b      	ldr	r3, [r7, #4]
20008b88:	2240      	movs	r2, #64	; 0x40
20008b8a:	655a      	str	r2, [r3, #84]	; 0x54

    /* error status */
    status = HAL_ERROR;
20008b8c:	2301      	movs	r3, #1
20008b8e:	73fb      	strb	r3, [r7, #15]
20008b90:	e060      	b.n	20008c54 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2fc>
  }
  else if(((hdma->DMAmuxRequestGen->RGCR & DMAMUX_RGxCR_GE) == 0U) && (temp_state == HAL_DMA_STATE_READY))
20008b92:	687b      	ldr	r3, [r7, #4]
20008b94:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008b96:	681b      	ldr	r3, [r3, #0]
20008b98:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20008b9c:	2b00      	cmp	r3, #0
20008b9e:	d153      	bne.n	20008c48 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2f0>
20008ba0:	7bbb      	ldrb	r3, [r7, #14]
20008ba2:	2b01      	cmp	r3, #1
20008ba4:	d150      	bne.n	20008c48 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2f0>
  {
    /* RequestGenerator must be disable prior to the configuration i.e GE bit is 0 */

    /* Process Locked */
    __HAL_LOCK(hdma);
20008ba6:	687b      	ldr	r3, [r7, #4]
20008ba8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
20008bac:	2b01      	cmp	r3, #1
20008bae:	d133      	bne.n	20008c18 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2c0>
20008bb0:	2302      	movs	r3, #2
20008bb2:	e050      	b.n	20008c56 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2fe>
20008bb4:	40020010 	.word	0x40020010
20008bb8:	40020028 	.word	0x40020028
20008bbc:	40020040 	.word	0x40020040
20008bc0:	40020058 	.word	0x40020058
20008bc4:	40020070 	.word	0x40020070
20008bc8:	40020088 	.word	0x40020088
20008bcc:	400200a0 	.word	0x400200a0
20008bd0:	400200b8 	.word	0x400200b8
20008bd4:	40020410 	.word	0x40020410
20008bd8:	40020428 	.word	0x40020428
20008bdc:	40020440 	.word	0x40020440
20008be0:	40020458 	.word	0x40020458
20008be4:	40020470 	.word	0x40020470
20008be8:	40020488 	.word	0x40020488
20008bec:	400204a0 	.word	0x400204a0
20008bf0:	400204b8 	.word	0x400204b8
20008bf4:	58025408 	.word	0x58025408
20008bf8:	5802541c 	.word	0x5802541c
20008bfc:	58025430 	.word	0x58025430
20008c00:	58025444 	.word	0x58025444
20008c04:	58025458 	.word	0x58025458
20008c08:	5802546c 	.word	0x5802546c
20008c0c:	58025480 	.word	0x58025480
20008c10:	58025494 	.word	0x58025494
20008c14:	2001c014 	.word	0x2001c014
20008c18:	687b      	ldr	r3, [r7, #4]
20008c1a:	2201      	movs	r2, #1
20008c1c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the request generator new parameters */
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
20008c20:	683b      	ldr	r3, [r7, #0]
20008c22:	681a      	ldr	r2, [r3, #0]
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
20008c24:	683b      	ldr	r3, [r7, #0]
20008c26:	689b      	ldr	r3, [r3, #8]
20008c28:	3b01      	subs	r3, #1
20008c2a:	04db      	lsls	r3, r3, #19
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
20008c2c:	ea42 0103 	orr.w	r1, r2, r3
                                  pRequestGeneratorConfig->Polarity;
20008c30:	683b      	ldr	r3, [r7, #0]
20008c32:	685a      	ldr	r2, [r3, #4]
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
20008c34:	687b      	ldr	r3, [r7, #4]
20008c36:	6edb      	ldr	r3, [r3, #108]	; 0x6c
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
20008c38:	430a      	orrs	r2, r1
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
20008c3a:	601a      	str	r2, [r3, #0]
    /* Process Locked */
    __HAL_UNLOCK(hdma);
20008c3c:	687b      	ldr	r3, [r7, #4]
20008c3e:	2200      	movs	r2, #0
20008c40:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_OK;
20008c44:	2300      	movs	r3, #0
20008c46:	e006      	b.n	20008c56 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2fe>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
20008c48:	687b      	ldr	r3, [r7, #4]
20008c4a:	f44f 6200 	mov.w	r2, #2048	; 0x800
20008c4e:	655a      	str	r2, [r3, #84]	; 0x54

    /* error status */
    status = HAL_ERROR;
20008c50:	2301      	movs	r3, #1
20008c52:	73fb      	strb	r3, [r7, #15]
  }

  return status;
20008c54:	7bfb      	ldrb	r3, [r7, #15]
}
20008c56:	4618      	mov	r0, r3
20008c58:	3710      	adds	r7, #16
20008c5a:	46bd      	mov	sp, r7
20008c5c:	bd80      	pop	{r7, pc}
20008c5e:	bf00      	nop

20008c60 <HAL_DMAEx_EnableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_EnableMuxRequestGenerator (DMA_HandleTypeDef *hdma)
{
20008c60:	b580      	push	{r7, lr}
20008c62:	b082      	sub	sp, #8
20008c64:	af00      	add	r7, sp, #0
20008c66:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
20008c68:	687b      	ldr	r3, [r7, #4]
20008c6a:	681b      	ldr	r3, [r3, #0]
20008c6c:	4a49      	ldr	r2, [pc, #292]	; (20008d94 <HAL_DMAEx_EnableMuxRequestGenerator+0x134>)
20008c6e:	4293      	cmp	r3, r2
20008c70:	d077      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008c72:	687b      	ldr	r3, [r7, #4]
20008c74:	681b      	ldr	r3, [r3, #0]
20008c76:	4a48      	ldr	r2, [pc, #288]	; (20008d98 <HAL_DMAEx_EnableMuxRequestGenerator+0x138>)
20008c78:	4293      	cmp	r3, r2
20008c7a:	d072      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008c7c:	687b      	ldr	r3, [r7, #4]
20008c7e:	681b      	ldr	r3, [r3, #0]
20008c80:	4a46      	ldr	r2, [pc, #280]	; (20008d9c <HAL_DMAEx_EnableMuxRequestGenerator+0x13c>)
20008c82:	4293      	cmp	r3, r2
20008c84:	d06d      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008c86:	687b      	ldr	r3, [r7, #4]
20008c88:	681b      	ldr	r3, [r3, #0]
20008c8a:	4a45      	ldr	r2, [pc, #276]	; (20008da0 <HAL_DMAEx_EnableMuxRequestGenerator+0x140>)
20008c8c:	4293      	cmp	r3, r2
20008c8e:	d068      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008c90:	687b      	ldr	r3, [r7, #4]
20008c92:	681b      	ldr	r3, [r3, #0]
20008c94:	4a43      	ldr	r2, [pc, #268]	; (20008da4 <HAL_DMAEx_EnableMuxRequestGenerator+0x144>)
20008c96:	4293      	cmp	r3, r2
20008c98:	d063      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008c9a:	687b      	ldr	r3, [r7, #4]
20008c9c:	681b      	ldr	r3, [r3, #0]
20008c9e:	4a42      	ldr	r2, [pc, #264]	; (20008da8 <HAL_DMAEx_EnableMuxRequestGenerator+0x148>)
20008ca0:	4293      	cmp	r3, r2
20008ca2:	d05e      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008ca4:	687b      	ldr	r3, [r7, #4]
20008ca6:	681b      	ldr	r3, [r3, #0]
20008ca8:	4a40      	ldr	r2, [pc, #256]	; (20008dac <HAL_DMAEx_EnableMuxRequestGenerator+0x14c>)
20008caa:	4293      	cmp	r3, r2
20008cac:	d059      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008cae:	687b      	ldr	r3, [r7, #4]
20008cb0:	681b      	ldr	r3, [r3, #0]
20008cb2:	4a3f      	ldr	r2, [pc, #252]	; (20008db0 <HAL_DMAEx_EnableMuxRequestGenerator+0x150>)
20008cb4:	4293      	cmp	r3, r2
20008cb6:	d054      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008cb8:	687b      	ldr	r3, [r7, #4]
20008cba:	681b      	ldr	r3, [r3, #0]
20008cbc:	4a3d      	ldr	r2, [pc, #244]	; (20008db4 <HAL_DMAEx_EnableMuxRequestGenerator+0x154>)
20008cbe:	4293      	cmp	r3, r2
20008cc0:	d04f      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008cc2:	687b      	ldr	r3, [r7, #4]
20008cc4:	681b      	ldr	r3, [r3, #0]
20008cc6:	4a3c      	ldr	r2, [pc, #240]	; (20008db8 <HAL_DMAEx_EnableMuxRequestGenerator+0x158>)
20008cc8:	4293      	cmp	r3, r2
20008cca:	d04a      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008ccc:	687b      	ldr	r3, [r7, #4]
20008cce:	681b      	ldr	r3, [r3, #0]
20008cd0:	4a3a      	ldr	r2, [pc, #232]	; (20008dbc <HAL_DMAEx_EnableMuxRequestGenerator+0x15c>)
20008cd2:	4293      	cmp	r3, r2
20008cd4:	d045      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008cd6:	687b      	ldr	r3, [r7, #4]
20008cd8:	681b      	ldr	r3, [r3, #0]
20008cda:	4a39      	ldr	r2, [pc, #228]	; (20008dc0 <HAL_DMAEx_EnableMuxRequestGenerator+0x160>)
20008cdc:	4293      	cmp	r3, r2
20008cde:	d040      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008ce0:	687b      	ldr	r3, [r7, #4]
20008ce2:	681b      	ldr	r3, [r3, #0]
20008ce4:	4a37      	ldr	r2, [pc, #220]	; (20008dc4 <HAL_DMAEx_EnableMuxRequestGenerator+0x164>)
20008ce6:	4293      	cmp	r3, r2
20008ce8:	d03b      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008cea:	687b      	ldr	r3, [r7, #4]
20008cec:	681b      	ldr	r3, [r3, #0]
20008cee:	4a36      	ldr	r2, [pc, #216]	; (20008dc8 <HAL_DMAEx_EnableMuxRequestGenerator+0x168>)
20008cf0:	4293      	cmp	r3, r2
20008cf2:	d036      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008cf4:	687b      	ldr	r3, [r7, #4]
20008cf6:	681b      	ldr	r3, [r3, #0]
20008cf8:	4a34      	ldr	r2, [pc, #208]	; (20008dcc <HAL_DMAEx_EnableMuxRequestGenerator+0x16c>)
20008cfa:	4293      	cmp	r3, r2
20008cfc:	d031      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008cfe:	687b      	ldr	r3, [r7, #4]
20008d00:	681b      	ldr	r3, [r3, #0]
20008d02:	4a33      	ldr	r2, [pc, #204]	; (20008dd0 <HAL_DMAEx_EnableMuxRequestGenerator+0x170>)
20008d04:	4293      	cmp	r3, r2
20008d06:	d02c      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008d08:	687b      	ldr	r3, [r7, #4]
20008d0a:	681b      	ldr	r3, [r3, #0]
20008d0c:	4a31      	ldr	r2, [pc, #196]	; (20008dd4 <HAL_DMAEx_EnableMuxRequestGenerator+0x174>)
20008d0e:	4293      	cmp	r3, r2
20008d10:	d027      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008d12:	687b      	ldr	r3, [r7, #4]
20008d14:	681b      	ldr	r3, [r3, #0]
20008d16:	4a30      	ldr	r2, [pc, #192]	; (20008dd8 <HAL_DMAEx_EnableMuxRequestGenerator+0x178>)
20008d18:	4293      	cmp	r3, r2
20008d1a:	d022      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008d1c:	687b      	ldr	r3, [r7, #4]
20008d1e:	681b      	ldr	r3, [r3, #0]
20008d20:	4a2e      	ldr	r2, [pc, #184]	; (20008ddc <HAL_DMAEx_EnableMuxRequestGenerator+0x17c>)
20008d22:	4293      	cmp	r3, r2
20008d24:	d01d      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008d26:	687b      	ldr	r3, [r7, #4]
20008d28:	681b      	ldr	r3, [r3, #0]
20008d2a:	4a2d      	ldr	r2, [pc, #180]	; (20008de0 <HAL_DMAEx_EnableMuxRequestGenerator+0x180>)
20008d2c:	4293      	cmp	r3, r2
20008d2e:	d018      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008d30:	687b      	ldr	r3, [r7, #4]
20008d32:	681b      	ldr	r3, [r3, #0]
20008d34:	4a2b      	ldr	r2, [pc, #172]	; (20008de4 <HAL_DMAEx_EnableMuxRequestGenerator+0x184>)
20008d36:	4293      	cmp	r3, r2
20008d38:	d013      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008d3a:	687b      	ldr	r3, [r7, #4]
20008d3c:	681b      	ldr	r3, [r3, #0]
20008d3e:	4a2a      	ldr	r2, [pc, #168]	; (20008de8 <HAL_DMAEx_EnableMuxRequestGenerator+0x188>)
20008d40:	4293      	cmp	r3, r2
20008d42:	d00e      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008d44:	687b      	ldr	r3, [r7, #4]
20008d46:	681b      	ldr	r3, [r3, #0]
20008d48:	4a28      	ldr	r2, [pc, #160]	; (20008dec <HAL_DMAEx_EnableMuxRequestGenerator+0x18c>)
20008d4a:	4293      	cmp	r3, r2
20008d4c:	d009      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008d4e:	687b      	ldr	r3, [r7, #4]
20008d50:	681b      	ldr	r3, [r3, #0]
20008d52:	4a27      	ldr	r2, [pc, #156]	; (20008df0 <HAL_DMAEx_EnableMuxRequestGenerator+0x190>)
20008d54:	4293      	cmp	r3, r2
20008d56:	d004      	beq.n	20008d62 <HAL_DMAEx_EnableMuxRequestGenerator+0x102>
20008d58:	f240 2116 	movw	r1, #534	; 0x216
20008d5c:	4825      	ldr	r0, [pc, #148]	; (20008df4 <HAL_DMAEx_EnableMuxRequestGenerator+0x194>)
20008d5e:	f7f7 fdc9 	bl	200008f4 <assert_failed>

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
20008d62:	687b      	ldr	r3, [r7, #4]
20008d64:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20008d68:	b2db      	uxtb	r3, r3
20008d6a:	2b00      	cmp	r3, #0
20008d6c:	d00d      	beq.n	20008d8a <HAL_DMAEx_EnableMuxRequestGenerator+0x12a>
20008d6e:	687b      	ldr	r3, [r7, #4]
20008d70:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008d72:	2b00      	cmp	r3, #0
20008d74:	d009      	beq.n	20008d8a <HAL_DMAEx_EnableMuxRequestGenerator+0x12a>
  {
    /* Enable the request generator*/
    hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_GE;
20008d76:	687b      	ldr	r3, [r7, #4]
20008d78:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008d7a:	681a      	ldr	r2, [r3, #0]
20008d7c:	687b      	ldr	r3, [r7, #4]
20008d7e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008d80:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20008d84:	601a      	str	r2, [r3, #0]

   return HAL_OK;
20008d86:	2300      	movs	r3, #0
20008d88:	e000      	b.n	20008d8c <HAL_DMAEx_EnableMuxRequestGenerator+0x12c>
 }
 else
 {
   return HAL_ERROR;
20008d8a:	2301      	movs	r3, #1
 }
}
20008d8c:	4618      	mov	r0, r3
20008d8e:	3708      	adds	r7, #8
20008d90:	46bd      	mov	sp, r7
20008d92:	bd80      	pop	{r7, pc}
20008d94:	40020010 	.word	0x40020010
20008d98:	40020028 	.word	0x40020028
20008d9c:	40020040 	.word	0x40020040
20008da0:	40020058 	.word	0x40020058
20008da4:	40020070 	.word	0x40020070
20008da8:	40020088 	.word	0x40020088
20008dac:	400200a0 	.word	0x400200a0
20008db0:	400200b8 	.word	0x400200b8
20008db4:	40020410 	.word	0x40020410
20008db8:	40020428 	.word	0x40020428
20008dbc:	40020440 	.word	0x40020440
20008dc0:	40020458 	.word	0x40020458
20008dc4:	40020470 	.word	0x40020470
20008dc8:	40020488 	.word	0x40020488
20008dcc:	400204a0 	.word	0x400204a0
20008dd0:	400204b8 	.word	0x400204b8
20008dd4:	58025408 	.word	0x58025408
20008dd8:	5802541c 	.word	0x5802541c
20008ddc:	58025430 	.word	0x58025430
20008de0:	58025444 	.word	0x58025444
20008de4:	58025458 	.word	0x58025458
20008de8:	5802546c 	.word	0x5802546c
20008dec:	58025480 	.word	0x58025480
20008df0:	58025494 	.word	0x58025494
20008df4:	2001c014 	.word	0x2001c014

20008df8 <HAL_DMAEx_DisableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_DisableMuxRequestGenerator (DMA_HandleTypeDef *hdma)
{
20008df8:	b580      	push	{r7, lr}
20008dfa:	b082      	sub	sp, #8
20008dfc:	af00      	add	r7, sp, #0
20008dfe:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
20008e00:	687b      	ldr	r3, [r7, #4]
20008e02:	681b      	ldr	r3, [r3, #0]
20008e04:	4a49      	ldr	r2, [pc, #292]	; (20008f2c <HAL_DMAEx_DisableMuxRequestGenerator+0x134>)
20008e06:	4293      	cmp	r3, r2
20008e08:	d077      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e0a:	687b      	ldr	r3, [r7, #4]
20008e0c:	681b      	ldr	r3, [r3, #0]
20008e0e:	4a48      	ldr	r2, [pc, #288]	; (20008f30 <HAL_DMAEx_DisableMuxRequestGenerator+0x138>)
20008e10:	4293      	cmp	r3, r2
20008e12:	d072      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e14:	687b      	ldr	r3, [r7, #4]
20008e16:	681b      	ldr	r3, [r3, #0]
20008e18:	4a46      	ldr	r2, [pc, #280]	; (20008f34 <HAL_DMAEx_DisableMuxRequestGenerator+0x13c>)
20008e1a:	4293      	cmp	r3, r2
20008e1c:	d06d      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e1e:	687b      	ldr	r3, [r7, #4]
20008e20:	681b      	ldr	r3, [r3, #0]
20008e22:	4a45      	ldr	r2, [pc, #276]	; (20008f38 <HAL_DMAEx_DisableMuxRequestGenerator+0x140>)
20008e24:	4293      	cmp	r3, r2
20008e26:	d068      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e28:	687b      	ldr	r3, [r7, #4]
20008e2a:	681b      	ldr	r3, [r3, #0]
20008e2c:	4a43      	ldr	r2, [pc, #268]	; (20008f3c <HAL_DMAEx_DisableMuxRequestGenerator+0x144>)
20008e2e:	4293      	cmp	r3, r2
20008e30:	d063      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e32:	687b      	ldr	r3, [r7, #4]
20008e34:	681b      	ldr	r3, [r3, #0]
20008e36:	4a42      	ldr	r2, [pc, #264]	; (20008f40 <HAL_DMAEx_DisableMuxRequestGenerator+0x148>)
20008e38:	4293      	cmp	r3, r2
20008e3a:	d05e      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e3c:	687b      	ldr	r3, [r7, #4]
20008e3e:	681b      	ldr	r3, [r3, #0]
20008e40:	4a40      	ldr	r2, [pc, #256]	; (20008f44 <HAL_DMAEx_DisableMuxRequestGenerator+0x14c>)
20008e42:	4293      	cmp	r3, r2
20008e44:	d059      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e46:	687b      	ldr	r3, [r7, #4]
20008e48:	681b      	ldr	r3, [r3, #0]
20008e4a:	4a3f      	ldr	r2, [pc, #252]	; (20008f48 <HAL_DMAEx_DisableMuxRequestGenerator+0x150>)
20008e4c:	4293      	cmp	r3, r2
20008e4e:	d054      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e50:	687b      	ldr	r3, [r7, #4]
20008e52:	681b      	ldr	r3, [r3, #0]
20008e54:	4a3d      	ldr	r2, [pc, #244]	; (20008f4c <HAL_DMAEx_DisableMuxRequestGenerator+0x154>)
20008e56:	4293      	cmp	r3, r2
20008e58:	d04f      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e5a:	687b      	ldr	r3, [r7, #4]
20008e5c:	681b      	ldr	r3, [r3, #0]
20008e5e:	4a3c      	ldr	r2, [pc, #240]	; (20008f50 <HAL_DMAEx_DisableMuxRequestGenerator+0x158>)
20008e60:	4293      	cmp	r3, r2
20008e62:	d04a      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e64:	687b      	ldr	r3, [r7, #4]
20008e66:	681b      	ldr	r3, [r3, #0]
20008e68:	4a3a      	ldr	r2, [pc, #232]	; (20008f54 <HAL_DMAEx_DisableMuxRequestGenerator+0x15c>)
20008e6a:	4293      	cmp	r3, r2
20008e6c:	d045      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e6e:	687b      	ldr	r3, [r7, #4]
20008e70:	681b      	ldr	r3, [r3, #0]
20008e72:	4a39      	ldr	r2, [pc, #228]	; (20008f58 <HAL_DMAEx_DisableMuxRequestGenerator+0x160>)
20008e74:	4293      	cmp	r3, r2
20008e76:	d040      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e78:	687b      	ldr	r3, [r7, #4]
20008e7a:	681b      	ldr	r3, [r3, #0]
20008e7c:	4a37      	ldr	r2, [pc, #220]	; (20008f5c <HAL_DMAEx_DisableMuxRequestGenerator+0x164>)
20008e7e:	4293      	cmp	r3, r2
20008e80:	d03b      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e82:	687b      	ldr	r3, [r7, #4]
20008e84:	681b      	ldr	r3, [r3, #0]
20008e86:	4a36      	ldr	r2, [pc, #216]	; (20008f60 <HAL_DMAEx_DisableMuxRequestGenerator+0x168>)
20008e88:	4293      	cmp	r3, r2
20008e8a:	d036      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e8c:	687b      	ldr	r3, [r7, #4]
20008e8e:	681b      	ldr	r3, [r3, #0]
20008e90:	4a34      	ldr	r2, [pc, #208]	; (20008f64 <HAL_DMAEx_DisableMuxRequestGenerator+0x16c>)
20008e92:	4293      	cmp	r3, r2
20008e94:	d031      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008e96:	687b      	ldr	r3, [r7, #4]
20008e98:	681b      	ldr	r3, [r3, #0]
20008e9a:	4a33      	ldr	r2, [pc, #204]	; (20008f68 <HAL_DMAEx_DisableMuxRequestGenerator+0x170>)
20008e9c:	4293      	cmp	r3, r2
20008e9e:	d02c      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008ea0:	687b      	ldr	r3, [r7, #4]
20008ea2:	681b      	ldr	r3, [r3, #0]
20008ea4:	4a31      	ldr	r2, [pc, #196]	; (20008f6c <HAL_DMAEx_DisableMuxRequestGenerator+0x174>)
20008ea6:	4293      	cmp	r3, r2
20008ea8:	d027      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008eaa:	687b      	ldr	r3, [r7, #4]
20008eac:	681b      	ldr	r3, [r3, #0]
20008eae:	4a30      	ldr	r2, [pc, #192]	; (20008f70 <HAL_DMAEx_DisableMuxRequestGenerator+0x178>)
20008eb0:	4293      	cmp	r3, r2
20008eb2:	d022      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008eb4:	687b      	ldr	r3, [r7, #4]
20008eb6:	681b      	ldr	r3, [r3, #0]
20008eb8:	4a2e      	ldr	r2, [pc, #184]	; (20008f74 <HAL_DMAEx_DisableMuxRequestGenerator+0x17c>)
20008eba:	4293      	cmp	r3, r2
20008ebc:	d01d      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008ebe:	687b      	ldr	r3, [r7, #4]
20008ec0:	681b      	ldr	r3, [r3, #0]
20008ec2:	4a2d      	ldr	r2, [pc, #180]	; (20008f78 <HAL_DMAEx_DisableMuxRequestGenerator+0x180>)
20008ec4:	4293      	cmp	r3, r2
20008ec6:	d018      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008ec8:	687b      	ldr	r3, [r7, #4]
20008eca:	681b      	ldr	r3, [r3, #0]
20008ecc:	4a2b      	ldr	r2, [pc, #172]	; (20008f7c <HAL_DMAEx_DisableMuxRequestGenerator+0x184>)
20008ece:	4293      	cmp	r3, r2
20008ed0:	d013      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008ed2:	687b      	ldr	r3, [r7, #4]
20008ed4:	681b      	ldr	r3, [r3, #0]
20008ed6:	4a2a      	ldr	r2, [pc, #168]	; (20008f80 <HAL_DMAEx_DisableMuxRequestGenerator+0x188>)
20008ed8:	4293      	cmp	r3, r2
20008eda:	d00e      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008edc:	687b      	ldr	r3, [r7, #4]
20008ede:	681b      	ldr	r3, [r3, #0]
20008ee0:	4a28      	ldr	r2, [pc, #160]	; (20008f84 <HAL_DMAEx_DisableMuxRequestGenerator+0x18c>)
20008ee2:	4293      	cmp	r3, r2
20008ee4:	d009      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008ee6:	687b      	ldr	r3, [r7, #4]
20008ee8:	681b      	ldr	r3, [r3, #0]
20008eea:	4a27      	ldr	r2, [pc, #156]	; (20008f88 <HAL_DMAEx_DisableMuxRequestGenerator+0x190>)
20008eec:	4293      	cmp	r3, r2
20008eee:	d004      	beq.n	20008efa <HAL_DMAEx_DisableMuxRequestGenerator+0x102>
20008ef0:	f44f 710c 	mov.w	r1, #560	; 0x230
20008ef4:	4825      	ldr	r0, [pc, #148]	; (20008f8c <HAL_DMAEx_DisableMuxRequestGenerator+0x194>)
20008ef6:	f7f7 fcfd 	bl	200008f4 <assert_failed>

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
20008efa:	687b      	ldr	r3, [r7, #4]
20008efc:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20008f00:	b2db      	uxtb	r3, r3
20008f02:	2b00      	cmp	r3, #0
20008f04:	d00d      	beq.n	20008f22 <HAL_DMAEx_DisableMuxRequestGenerator+0x12a>
20008f06:	687b      	ldr	r3, [r7, #4]
20008f08:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008f0a:	2b00      	cmp	r3, #0
20008f0c:	d009      	beq.n	20008f22 <HAL_DMAEx_DisableMuxRequestGenerator+0x12a>
  {
    /* Disable the request generator*/
    hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_GE;
20008f0e:	687b      	ldr	r3, [r7, #4]
20008f10:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008f12:	681a      	ldr	r2, [r3, #0]
20008f14:	687b      	ldr	r3, [r7, #4]
20008f16:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008f18:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
20008f1c:	601a      	str	r2, [r3, #0]

   return HAL_OK;
20008f1e:	2300      	movs	r3, #0
20008f20:	e000      	b.n	20008f24 <HAL_DMAEx_DisableMuxRequestGenerator+0x12c>
 }
 else
 {
   return HAL_ERROR;
20008f22:	2301      	movs	r3, #1
 }
}
20008f24:	4618      	mov	r0, r3
20008f26:	3708      	adds	r7, #8
20008f28:	46bd      	mov	sp, r7
20008f2a:	bd80      	pop	{r7, pc}
20008f2c:	40020010 	.word	0x40020010
20008f30:	40020028 	.word	0x40020028
20008f34:	40020040 	.word	0x40020040
20008f38:	40020058 	.word	0x40020058
20008f3c:	40020070 	.word	0x40020070
20008f40:	40020088 	.word	0x40020088
20008f44:	400200a0 	.word	0x400200a0
20008f48:	400200b8 	.word	0x400200b8
20008f4c:	40020410 	.word	0x40020410
20008f50:	40020428 	.word	0x40020428
20008f54:	40020440 	.word	0x40020440
20008f58:	40020458 	.word	0x40020458
20008f5c:	40020470 	.word	0x40020470
20008f60:	40020488 	.word	0x40020488
20008f64:	400204a0 	.word	0x400204a0
20008f68:	400204b8 	.word	0x400204b8
20008f6c:	58025408 	.word	0x58025408
20008f70:	5802541c 	.word	0x5802541c
20008f74:	58025430 	.word	0x58025430
20008f78:	58025444 	.word	0x58025444
20008f7c:	58025458 	.word	0x58025458
20008f80:	5802546c 	.word	0x5802546c
20008f84:	58025480 	.word	0x58025480
20008f88:	58025494 	.word	0x58025494
20008f8c:	2001c014 	.word	0x2001c014

20008f90 <HAL_DMAEx_MUX_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMAEx_MUX_IRQHandler(DMA_HandleTypeDef *hdma)
{
20008f90:	b580      	push	{r7, lr}
20008f92:	b082      	sub	sp, #8
20008f94:	af00      	add	r7, sp, #0
20008f96:	6078      	str	r0, [r7, #4]
  /* Check for DMAMUX Synchronization overrun */
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
20008f98:	687b      	ldr	r3, [r7, #4]
20008f9a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20008f9c:	681a      	ldr	r2, [r3, #0]
20008f9e:	687b      	ldr	r3, [r7, #4]
20008fa0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
20008fa2:	4013      	ands	r3, r2
20008fa4:	2b00      	cmp	r3, #0
20008fa6:	d01a      	beq.n	20008fde <HAL_DMAEx_MUX_IRQHandler+0x4e>
  {
    /* Disable the synchro overrun interrupt */
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
20008fa8:	687b      	ldr	r3, [r7, #4]
20008faa:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20008fac:	681a      	ldr	r2, [r3, #0]
20008fae:	687b      	ldr	r3, [r7, #4]
20008fb0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20008fb2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20008fb6:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
20008fb8:	687b      	ldr	r3, [r7, #4]
20008fba:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20008fbc:	687a      	ldr	r2, [r7, #4]
20008fbe:	6e92      	ldr	r2, [r2, #104]	; 0x68
20008fc0:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
20008fc2:	687b      	ldr	r3, [r7, #4]
20008fc4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20008fc6:	f443 7200 	orr.w	r2, r3, #512	; 0x200
20008fca:	687b      	ldr	r3, [r7, #4]
20008fcc:	655a      	str	r2, [r3, #84]	; 0x54

    if(hdma->XferErrorCallback != NULL)
20008fce:	687b      	ldr	r3, [r7, #4]
20008fd0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20008fd2:	2b00      	cmp	r3, #0
20008fd4:	d003      	beq.n	20008fde <HAL_DMAEx_MUX_IRQHandler+0x4e>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
20008fd6:	687b      	ldr	r3, [r7, #4]
20008fd8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20008fda:	6878      	ldr	r0, [r7, #4]
20008fdc:	4798      	blx	r3
    }
  }

  if(hdma->DMAmuxRequestGen != 0)
20008fde:	687b      	ldr	r3, [r7, #4]
20008fe0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008fe2:	2b00      	cmp	r3, #0
20008fe4:	d022      	beq.n	2000902c <HAL_DMAEx_MUX_IRQHandler+0x9c>
  {
   /* if using a DMAMUX request generator block Check for DMAMUX request generator overrun */
    if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
20008fe6:	687b      	ldr	r3, [r7, #4]
20008fe8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20008fea:	681a      	ldr	r2, [r3, #0]
20008fec:	687b      	ldr	r3, [r7, #4]
20008fee:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20008ff0:	4013      	ands	r3, r2
20008ff2:	2b00      	cmp	r3, #0
20008ff4:	d01a      	beq.n	2000902c <HAL_DMAEx_MUX_IRQHandler+0x9c>
    {
      /* Disable the request gen overrun interrupt */
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
20008ff6:	687b      	ldr	r3, [r7, #4]
20008ff8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20008ffa:	681a      	ldr	r2, [r3, #0]
20008ffc:	687b      	ldr	r3, [r7, #4]
20008ffe:	6edb      	ldr	r3, [r3, #108]	; 0x6c
20009000:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20009004:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
20009006:	687b      	ldr	r3, [r7, #4]
20009008:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000900a:	687a      	ldr	r2, [r7, #4]
2000900c:	6f52      	ldr	r2, [r2, #116]	; 0x74
2000900e:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
20009010:	687b      	ldr	r3, [r7, #4]
20009012:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20009014:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
20009018:	687b      	ldr	r3, [r7, #4]
2000901a:	655a      	str	r2, [r3, #84]	; 0x54

      if(hdma->XferErrorCallback != NULL)
2000901c:	687b      	ldr	r3, [r7, #4]
2000901e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20009020:	2b00      	cmp	r3, #0
20009022:	d003      	beq.n	2000902c <HAL_DMAEx_MUX_IRQHandler+0x9c>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
20009024:	687b      	ldr	r3, [r7, #4]
20009026:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20009028:	6878      	ldr	r0, [r7, #4]
2000902a:	4798      	blx	r3
      }
    }
  }
}
2000902c:	bf00      	nop
2000902e:	3708      	adds	r7, #8
20009030:	46bd      	mov	sp, r7
20009032:	bd80      	pop	{r7, pc}

20009034 <DMA_MultiBufferSetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
20009034:	b480      	push	{r7}
20009036:	b085      	sub	sp, #20
20009038:	af00      	add	r7, sp, #0
2000903a:	60f8      	str	r0, [r7, #12]
2000903c:	60b9      	str	r1, [r7, #8]
2000903e:	607a      	str	r2, [r7, #4]
20009040:	603b      	str	r3, [r7, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
20009042:	68fb      	ldr	r3, [r7, #12]
20009044:	681b      	ldr	r3, [r3, #0]
20009046:	4a46      	ldr	r2, [pc, #280]	; (20009160 <DMA_MultiBufferSetConfig+0x12c>)
20009048:	4293      	cmp	r3, r2
2000904a:	d04a      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
2000904c:	68fb      	ldr	r3, [r7, #12]
2000904e:	681b      	ldr	r3, [r3, #0]
20009050:	4a44      	ldr	r2, [pc, #272]	; (20009164 <DMA_MultiBufferSetConfig+0x130>)
20009052:	4293      	cmp	r3, r2
20009054:	d045      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
20009056:	68fb      	ldr	r3, [r7, #12]
20009058:	681b      	ldr	r3, [r3, #0]
2000905a:	4a43      	ldr	r2, [pc, #268]	; (20009168 <DMA_MultiBufferSetConfig+0x134>)
2000905c:	4293      	cmp	r3, r2
2000905e:	d040      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
20009060:	68fb      	ldr	r3, [r7, #12]
20009062:	681b      	ldr	r3, [r3, #0]
20009064:	4a41      	ldr	r2, [pc, #260]	; (2000916c <DMA_MultiBufferSetConfig+0x138>)
20009066:	4293      	cmp	r3, r2
20009068:	d03b      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
2000906a:	68fb      	ldr	r3, [r7, #12]
2000906c:	681b      	ldr	r3, [r3, #0]
2000906e:	4a40      	ldr	r2, [pc, #256]	; (20009170 <DMA_MultiBufferSetConfig+0x13c>)
20009070:	4293      	cmp	r3, r2
20009072:	d036      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
20009074:	68fb      	ldr	r3, [r7, #12]
20009076:	681b      	ldr	r3, [r3, #0]
20009078:	4a3e      	ldr	r2, [pc, #248]	; (20009174 <DMA_MultiBufferSetConfig+0x140>)
2000907a:	4293      	cmp	r3, r2
2000907c:	d031      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
2000907e:	68fb      	ldr	r3, [r7, #12]
20009080:	681b      	ldr	r3, [r3, #0]
20009082:	4a3d      	ldr	r2, [pc, #244]	; (20009178 <DMA_MultiBufferSetConfig+0x144>)
20009084:	4293      	cmp	r3, r2
20009086:	d02c      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
20009088:	68fb      	ldr	r3, [r7, #12]
2000908a:	681b      	ldr	r3, [r3, #0]
2000908c:	4a3b      	ldr	r2, [pc, #236]	; (2000917c <DMA_MultiBufferSetConfig+0x148>)
2000908e:	4293      	cmp	r3, r2
20009090:	d027      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
20009092:	68fb      	ldr	r3, [r7, #12]
20009094:	681b      	ldr	r3, [r3, #0]
20009096:	4a3a      	ldr	r2, [pc, #232]	; (20009180 <DMA_MultiBufferSetConfig+0x14c>)
20009098:	4293      	cmp	r3, r2
2000909a:	d022      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
2000909c:	68fb      	ldr	r3, [r7, #12]
2000909e:	681b      	ldr	r3, [r3, #0]
200090a0:	4a38      	ldr	r2, [pc, #224]	; (20009184 <DMA_MultiBufferSetConfig+0x150>)
200090a2:	4293      	cmp	r3, r2
200090a4:	d01d      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
200090a6:	68fb      	ldr	r3, [r7, #12]
200090a8:	681b      	ldr	r3, [r3, #0]
200090aa:	4a37      	ldr	r2, [pc, #220]	; (20009188 <DMA_MultiBufferSetConfig+0x154>)
200090ac:	4293      	cmp	r3, r2
200090ae:	d018      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
200090b0:	68fb      	ldr	r3, [r7, #12]
200090b2:	681b      	ldr	r3, [r3, #0]
200090b4:	4a35      	ldr	r2, [pc, #212]	; (2000918c <DMA_MultiBufferSetConfig+0x158>)
200090b6:	4293      	cmp	r3, r2
200090b8:	d013      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
200090ba:	68fb      	ldr	r3, [r7, #12]
200090bc:	681b      	ldr	r3, [r3, #0]
200090be:	4a34      	ldr	r2, [pc, #208]	; (20009190 <DMA_MultiBufferSetConfig+0x15c>)
200090c0:	4293      	cmp	r3, r2
200090c2:	d00e      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
200090c4:	68fb      	ldr	r3, [r7, #12]
200090c6:	681b      	ldr	r3, [r3, #0]
200090c8:	4a32      	ldr	r2, [pc, #200]	; (20009194 <DMA_MultiBufferSetConfig+0x160>)
200090ca:	4293      	cmp	r3, r2
200090cc:	d009      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
200090ce:	68fb      	ldr	r3, [r7, #12]
200090d0:	681b      	ldr	r3, [r3, #0]
200090d2:	4a31      	ldr	r2, [pc, #196]	; (20009198 <DMA_MultiBufferSetConfig+0x164>)
200090d4:	4293      	cmp	r3, r2
200090d6:	d004      	beq.n	200090e2 <DMA_MultiBufferSetConfig+0xae>
200090d8:	68fb      	ldr	r3, [r7, #12]
200090da:	681b      	ldr	r3, [r3, #0]
200090dc:	4a2f      	ldr	r2, [pc, #188]	; (2000919c <DMA_MultiBufferSetConfig+0x168>)
200090de:	4293      	cmp	r3, r2
200090e0:	d101      	bne.n	200090e6 <DMA_MultiBufferSetConfig+0xb2>
200090e2:	2301      	movs	r3, #1
200090e4:	e000      	b.n	200090e8 <DMA_MultiBufferSetConfig+0xb4>
200090e6:	2300      	movs	r3, #0
200090e8:	2b00      	cmp	r3, #0
200090ea:	d019      	beq.n	20009120 <DMA_MultiBufferSetConfig+0xec>
  {
    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = DataLength;
200090ec:	68fb      	ldr	r3, [r7, #12]
200090ee:	681b      	ldr	r3, [r3, #0]
200090f0:	683a      	ldr	r2, [r7, #0]
200090f2:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
200090f4:	68fb      	ldr	r3, [r7, #12]
200090f6:	689b      	ldr	r3, [r3, #8]
200090f8:	2b40      	cmp	r3, #64	; 0x40
200090fa:	d108      	bne.n	2000910e <DMA_MultiBufferSetConfig+0xda>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = DstAddress;
200090fc:	68fb      	ldr	r3, [r7, #12]
200090fe:	681b      	ldr	r3, [r3, #0]
20009100:	687a      	ldr	r2, [r7, #4]
20009102:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = SrcAddress;
20009104:	68fb      	ldr	r3, [r7, #12]
20009106:	681b      	ldr	r3, [r3, #0]
20009108:	68ba      	ldr	r2, [r7, #8]
2000910a:	60da      	str	r2, [r3, #12]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
    }
  }
}
2000910c:	e021      	b.n	20009152 <DMA_MultiBufferSetConfig+0x11e>
      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = SrcAddress;
2000910e:	68fb      	ldr	r3, [r7, #12]
20009110:	681b      	ldr	r3, [r3, #0]
20009112:	68ba      	ldr	r2, [r7, #8]
20009114:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = DstAddress;
20009116:	68fb      	ldr	r3, [r7, #12]
20009118:	681b      	ldr	r3, [r3, #0]
2000911a:	687a      	ldr	r2, [r7, #4]
2000911c:	60da      	str	r2, [r3, #12]
}
2000911e:	e018      	b.n	20009152 <DMA_MultiBufferSetConfig+0x11e>
    ((BDMA_Channel_TypeDef   *)hdma->Instance)->CNDTR = DataLength;
20009120:	68fb      	ldr	r3, [r7, #12]
20009122:	681b      	ldr	r3, [r3, #0]
20009124:	683a      	ldr	r2, [r7, #0]
20009126:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
20009128:	68fb      	ldr	r3, [r7, #12]
2000912a:	689b      	ldr	r3, [r3, #8]
2000912c:	2b40      	cmp	r3, #64	; 0x40
2000912e:	d108      	bne.n	20009142 <DMA_MultiBufferSetConfig+0x10e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = DstAddress;
20009130:	68fb      	ldr	r3, [r7, #12]
20009132:	681b      	ldr	r3, [r3, #0]
20009134:	687a      	ldr	r2, [r7, #4]
20009136:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = SrcAddress;
20009138:	68fb      	ldr	r3, [r7, #12]
2000913a:	681b      	ldr	r3, [r3, #0]
2000913c:	68ba      	ldr	r2, [r7, #8]
2000913e:	60da      	str	r2, [r3, #12]
}
20009140:	e007      	b.n	20009152 <DMA_MultiBufferSetConfig+0x11e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = SrcAddress;
20009142:	68fb      	ldr	r3, [r7, #12]
20009144:	681b      	ldr	r3, [r3, #0]
20009146:	68ba      	ldr	r2, [r7, #8]
20009148:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
2000914a:	68fb      	ldr	r3, [r7, #12]
2000914c:	681b      	ldr	r3, [r3, #0]
2000914e:	687a      	ldr	r2, [r7, #4]
20009150:	60da      	str	r2, [r3, #12]
}
20009152:	bf00      	nop
20009154:	3714      	adds	r7, #20
20009156:	46bd      	mov	sp, r7
20009158:	f85d 7b04 	ldr.w	r7, [sp], #4
2000915c:	4770      	bx	lr
2000915e:	bf00      	nop
20009160:	40020010 	.word	0x40020010
20009164:	40020028 	.word	0x40020028
20009168:	40020040 	.word	0x40020040
2000916c:	40020058 	.word	0x40020058
20009170:	40020070 	.word	0x40020070
20009174:	40020088 	.word	0x40020088
20009178:	400200a0 	.word	0x400200a0
2000917c:	400200b8 	.word	0x400200b8
20009180:	40020410 	.word	0x40020410
20009184:	40020428 	.word	0x40020428
20009188:	40020440 	.word	0x40020440
2000918c:	40020458 	.word	0x40020458
20009190:	40020470 	.word	0x40020470
20009194:	40020488 	.word	0x40020488
20009198:	400204a0 	.word	0x400204a0
2000919c:	400204b8 	.word	0x400204b8

200091a0 <HAL_EXTI_SetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on EXTI configuration to be set.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
200091a0:	b580      	push	{r7, lr}
200091a2:	b088      	sub	sp, #32
200091a4:	af00      	add	r7, sp, #0
200091a6:	6078      	str	r0, [r7, #4]
200091a8:	6039      	str	r1, [r7, #0]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
200091aa:	687b      	ldr	r3, [r7, #4]
200091ac:	2b00      	cmp	r3, #0
200091ae:	d002      	beq.n	200091b6 <HAL_EXTI_SetConfigLine+0x16>
200091b0:	683b      	ldr	r3, [r7, #0]
200091b2:	2b00      	cmp	r3, #0
200091b4:	d101      	bne.n	200091ba <HAL_EXTI_SetConfigLine+0x1a>
  {
    return HAL_ERROR;
200091b6:	2301      	movs	r3, #1
200091b8:	e1c6      	b.n	20009548 <HAL_EXTI_SetConfigLine+0x3a8>
  }

  /* Check the parameters */
  assert_param(IS_EXTI_LINE(pExtiConfig->Line));
200091ba:	683b      	ldr	r3, [r7, #0]
200091bc:	681a      	ldr	r2, [r3, #0]
200091be:	4b9e      	ldr	r3, [pc, #632]	; (20009438 <HAL_EXTI_SetConfigLine+0x298>)
200091c0:	4013      	ands	r3, r2
200091c2:	2b00      	cmp	r3, #0
200091c4:	d129      	bne.n	2000921a <HAL_EXTI_SetConfigLine+0x7a>
200091c6:	683b      	ldr	r3, [r7, #0]
200091c8:	681b      	ldr	r3, [r3, #0]
200091ca:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
200091ce:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
200091d2:	d00d      	beq.n	200091f0 <HAL_EXTI_SetConfigLine+0x50>
200091d4:	683b      	ldr	r3, [r7, #0]
200091d6:	681b      	ldr	r3, [r3, #0]
200091d8:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
200091dc:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200091e0:	d006      	beq.n	200091f0 <HAL_EXTI_SetConfigLine+0x50>
200091e2:	683b      	ldr	r3, [r7, #0]
200091e4:	681b      	ldr	r3, [r3, #0]
200091e6:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
200091ea:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
200091ee:	d114      	bne.n	2000921a <HAL_EXTI_SetConfigLine+0x7a>
200091f0:	683b      	ldr	r3, [r7, #0]
200091f2:	681b      	ldr	r3, [r3, #0]
200091f4:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
200091f8:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
200091fc:	d006      	beq.n	2000920c <HAL_EXTI_SetConfigLine+0x6c>
200091fe:	683b      	ldr	r3, [r7, #0]
20009200:	681b      	ldr	r3, [r3, #0]
20009202:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009206:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
2000920a:	d106      	bne.n	2000921a <HAL_EXTI_SetConfigLine+0x7a>
2000920c:	683b      	ldr	r3, [r7, #0]
2000920e:	681a      	ldr	r2, [r3, #0]
20009210:	4b8a      	ldr	r3, [pc, #552]	; (2000943c <HAL_EXTI_SetConfigLine+0x29c>)
20009212:	4013      	ands	r3, r2
20009214:	4a8a      	ldr	r2, [pc, #552]	; (20009440 <HAL_EXTI_SetConfigLine+0x2a0>)
20009216:	4293      	cmp	r3, r2
20009218:	d903      	bls.n	20009222 <HAL_EXTI_SetConfigLine+0x82>
2000921a:	21bb      	movs	r1, #187	; 0xbb
2000921c:	4889      	ldr	r0, [pc, #548]	; (20009444 <HAL_EXTI_SetConfigLine+0x2a4>)
2000921e:	f7f7 fb69 	bl	200008f4 <assert_failed>
  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));
20009222:	683b      	ldr	r3, [r7, #0]
20009224:	685b      	ldr	r3, [r3, #4]
20009226:	f023 0303 	bic.w	r3, r3, #3
2000922a:	2b00      	cmp	r3, #0
2000922c:	d003      	beq.n	20009236 <HAL_EXTI_SetConfigLine+0x96>
2000922e:	21bc      	movs	r1, #188	; 0xbc
20009230:	4884      	ldr	r0, [pc, #528]	; (20009444 <HAL_EXTI_SetConfigLine+0x2a4>)
20009232:	f7f7 fb5f 	bl	200008f4 <assert_failed>

  /* Assign line number to handle */
  hexti->Line = pExtiConfig->Line;
20009236:	683b      	ldr	r3, [r7, #0]
20009238:	681a      	ldr	r2, [r3, #0]
2000923a:	687b      	ldr	r3, [r7, #4]
2000923c:	601a      	str	r2, [r3, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2000923e:	683b      	ldr	r3, [r7, #0]
20009240:	681b      	ldr	r3, [r3, #0]
20009242:	0c1b      	lsrs	r3, r3, #16
20009244:	f003 0303 	and.w	r3, r3, #3
20009248:	613b      	str	r3, [r7, #16]
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
2000924a:	683b      	ldr	r3, [r7, #0]
2000924c:	681b      	ldr	r3, [r3, #0]
2000924e:	f003 031f 	and.w	r3, r3, #31
20009252:	60fb      	str	r3, [r7, #12]
  maskline = (1UL << linepos);
20009254:	2201      	movs	r2, #1
20009256:	68fb      	ldr	r3, [r7, #12]
20009258:	fa02 f303 	lsl.w	r3, r2, r3
2000925c:	60bb      	str	r3, [r7, #8]

  /* Configure triggers for configurable lines */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
2000925e:	683b      	ldr	r3, [r7, #0]
20009260:	681b      	ldr	r3, [r3, #0]
20009262:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20009266:	2b00      	cmp	r3, #0
20009268:	f000 80a6 	beq.w	200093b8 <HAL_EXTI_SetConfigLine+0x218>
  {
    assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));
2000926c:	683b      	ldr	r3, [r7, #0]
2000926e:	689b      	ldr	r3, [r3, #8]
20009270:	f023 0303 	bic.w	r3, r3, #3
20009274:	2b00      	cmp	r3, #0
20009276:	d003      	beq.n	20009280 <HAL_EXTI_SetConfigLine+0xe0>
20009278:	21c9      	movs	r1, #201	; 0xc9
2000927a:	4872      	ldr	r0, [pc, #456]	; (20009444 <HAL_EXTI_SetConfigLine+0x2a4>)
2000927c:	f7f7 fb3a 	bl	200008f4 <assert_failed>

    /* Configure rising trigger */
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
20009280:	693b      	ldr	r3, [r7, #16]
20009282:	015b      	lsls	r3, r3, #5
20009284:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
20009288:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
2000928a:	69fb      	ldr	r3, [r7, #28]
2000928c:	681b      	ldr	r3, [r3, #0]
2000928e:	61bb      	str	r3, [r7, #24]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00U)
20009290:	683b      	ldr	r3, [r7, #0]
20009292:	689b      	ldr	r3, [r3, #8]
20009294:	f003 0301 	and.w	r3, r3, #1
20009298:	2b00      	cmp	r3, #0
2000929a:	d004      	beq.n	200092a6 <HAL_EXTI_SetConfigLine+0x106>
    {
      regval |= maskline;
2000929c:	69ba      	ldr	r2, [r7, #24]
2000929e:	68bb      	ldr	r3, [r7, #8]
200092a0:	4313      	orrs	r3, r2
200092a2:	61bb      	str	r3, [r7, #24]
200092a4:	e004      	b.n	200092b0 <HAL_EXTI_SetConfigLine+0x110>
    }
    else
    {
      regval &= ~maskline;
200092a6:	68bb      	ldr	r3, [r7, #8]
200092a8:	43db      	mvns	r3, r3
200092aa:	69ba      	ldr	r2, [r7, #24]
200092ac:	4013      	ands	r3, r2
200092ae:	61bb      	str	r3, [r7, #24]
    }

    /* Store rising trigger mode */
    *regaddr = regval;
200092b0:	69fb      	ldr	r3, [r7, #28]
200092b2:	69ba      	ldr	r2, [r7, #24]
200092b4:	601a      	str	r2, [r3, #0]

    /* Configure falling trigger */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
200092b6:	693b      	ldr	r3, [r7, #16]
200092b8:	015a      	lsls	r2, r3, #5
200092ba:	4b63      	ldr	r3, [pc, #396]	; (20009448 <HAL_EXTI_SetConfigLine+0x2a8>)
200092bc:	4413      	add	r3, r2
200092be:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
200092c0:	69fb      	ldr	r3, [r7, #28]
200092c2:	681b      	ldr	r3, [r3, #0]
200092c4:	61bb      	str	r3, [r7, #24]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00U)
200092c6:	683b      	ldr	r3, [r7, #0]
200092c8:	689b      	ldr	r3, [r3, #8]
200092ca:	f003 0302 	and.w	r3, r3, #2
200092ce:	2b00      	cmp	r3, #0
200092d0:	d004      	beq.n	200092dc <HAL_EXTI_SetConfigLine+0x13c>
    {
      regval |= maskline;
200092d2:	69ba      	ldr	r2, [r7, #24]
200092d4:	68bb      	ldr	r3, [r7, #8]
200092d6:	4313      	orrs	r3, r2
200092d8:	61bb      	str	r3, [r7, #24]
200092da:	e004      	b.n	200092e6 <HAL_EXTI_SetConfigLine+0x146>
    }
    else
    {
      regval &= ~maskline;
200092dc:	68bb      	ldr	r3, [r7, #8]
200092de:	43db      	mvns	r3, r3
200092e0:	69ba      	ldr	r2, [r7, #24]
200092e2:	4013      	ands	r3, r2
200092e4:	61bb      	str	r3, [r7, #24]
    }

    /* Store falling trigger mode */
    *regaddr = regval;
200092e6:	69fb      	ldr	r3, [r7, #28]
200092e8:	69ba      	ldr	r2, [r7, #24]
200092ea:	601a      	str	r2, [r3, #0]

    /* Configure gpio port selection in case of gpio exti line */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
200092ec:	683b      	ldr	r3, [r7, #0]
200092ee:	681b      	ldr	r3, [r3, #0]
200092f0:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
200092f4:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
200092f8:	d15e      	bne.n	200093b8 <HAL_EXTI_SetConfigLine+0x218>
    {
      assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));
200092fa:	683b      	ldr	r3, [r7, #0]
200092fc:	68db      	ldr	r3, [r3, #12]
200092fe:	2b00      	cmp	r3, #0
20009300:	d02b      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
20009302:	683b      	ldr	r3, [r7, #0]
20009304:	68db      	ldr	r3, [r3, #12]
20009306:	2b01      	cmp	r3, #1
20009308:	d027      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
2000930a:	683b      	ldr	r3, [r7, #0]
2000930c:	68db      	ldr	r3, [r3, #12]
2000930e:	2b02      	cmp	r3, #2
20009310:	d023      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
20009312:	683b      	ldr	r3, [r7, #0]
20009314:	68db      	ldr	r3, [r3, #12]
20009316:	2b03      	cmp	r3, #3
20009318:	d01f      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
2000931a:	683b      	ldr	r3, [r7, #0]
2000931c:	68db      	ldr	r3, [r3, #12]
2000931e:	2b04      	cmp	r3, #4
20009320:	d01b      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
20009322:	683b      	ldr	r3, [r7, #0]
20009324:	68db      	ldr	r3, [r3, #12]
20009326:	2b05      	cmp	r3, #5
20009328:	d017      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
2000932a:	683b      	ldr	r3, [r7, #0]
2000932c:	68db      	ldr	r3, [r3, #12]
2000932e:	2b06      	cmp	r3, #6
20009330:	d013      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
20009332:	683b      	ldr	r3, [r7, #0]
20009334:	68db      	ldr	r3, [r3, #12]
20009336:	2b07      	cmp	r3, #7
20009338:	d00f      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
2000933a:	683b      	ldr	r3, [r7, #0]
2000933c:	68db      	ldr	r3, [r3, #12]
2000933e:	2b08      	cmp	r3, #8
20009340:	d00b      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
20009342:	683b      	ldr	r3, [r7, #0]
20009344:	68db      	ldr	r3, [r3, #12]
20009346:	2b09      	cmp	r3, #9
20009348:	d007      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
2000934a:	683b      	ldr	r3, [r7, #0]
2000934c:	68db      	ldr	r3, [r3, #12]
2000934e:	2b0a      	cmp	r3, #10
20009350:	d003      	beq.n	2000935a <HAL_EXTI_SetConfigLine+0x1ba>
20009352:	21f0      	movs	r1, #240	; 0xf0
20009354:	483b      	ldr	r0, [pc, #236]	; (20009444 <HAL_EXTI_SetConfigLine+0x2a4>)
20009356:	f7f7 facd 	bl	200008f4 <assert_failed>
      assert_param(IS_EXTI_GPIO_PIN(linepos));
2000935a:	68fb      	ldr	r3, [r7, #12]
2000935c:	2b0f      	cmp	r3, #15
2000935e:	d903      	bls.n	20009368 <HAL_EXTI_SetConfigLine+0x1c8>
20009360:	21f1      	movs	r1, #241	; 0xf1
20009362:	4838      	ldr	r0, [pc, #224]	; (20009444 <HAL_EXTI_SetConfigLine+0x2a4>)
20009364:	f7f7 fac6 	bl	200008f4 <assert_failed>

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
20009368:	4a38      	ldr	r2, [pc, #224]	; (2000944c <HAL_EXTI_SetConfigLine+0x2ac>)
2000936a:	68fb      	ldr	r3, [r7, #12]
2000936c:	089b      	lsrs	r3, r3, #2
2000936e:	f003 0303 	and.w	r3, r3, #3
20009372:	3302      	adds	r3, #2
20009374:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20009378:	61bb      	str	r3, [r7, #24]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
2000937a:	68fb      	ldr	r3, [r7, #12]
2000937c:	f003 0303 	and.w	r3, r3, #3
20009380:	009b      	lsls	r3, r3, #2
20009382:	220f      	movs	r2, #15
20009384:	fa02 f303 	lsl.w	r3, r2, r3
20009388:	43db      	mvns	r3, r3
2000938a:	69ba      	ldr	r2, [r7, #24]
2000938c:	4013      	ands	r3, r2
2000938e:	61bb      	str	r3, [r7, #24]
      regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
20009390:	683b      	ldr	r3, [r7, #0]
20009392:	68da      	ldr	r2, [r3, #12]
20009394:	68fb      	ldr	r3, [r7, #12]
20009396:	f003 0303 	and.w	r3, r3, #3
2000939a:	009b      	lsls	r3, r3, #2
2000939c:	fa02 f303 	lsl.w	r3, r2, r3
200093a0:	69ba      	ldr	r2, [r7, #24]
200093a2:	4313      	orrs	r3, r2
200093a4:	61bb      	str	r3, [r7, #24]
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
200093a6:	4929      	ldr	r1, [pc, #164]	; (2000944c <HAL_EXTI_SetConfigLine+0x2ac>)
200093a8:	68fb      	ldr	r3, [r7, #12]
200093aa:	089b      	lsrs	r3, r3, #2
200093ac:	f003 0303 	and.w	r3, r3, #3
200093b0:	3302      	adds	r3, #2
200093b2:	69ba      	ldr	r2, [r7, #24]
200093b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* Configure interrupt mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
200093b8:	693b      	ldr	r3, [r7, #16]
200093ba:	011a      	lsls	r2, r3, #4
200093bc:	4b24      	ldr	r3, [pc, #144]	; (20009450 <HAL_EXTI_SetConfigLine+0x2b0>)
200093be:	4413      	add	r3, r2
200093c0:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
200093c2:	69fb      	ldr	r3, [r7, #28]
200093c4:	681b      	ldr	r3, [r3, #0]
200093c6:	61bb      	str	r3, [r7, #24]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00U)
200093c8:	683b      	ldr	r3, [r7, #0]
200093ca:	685b      	ldr	r3, [r3, #4]
200093cc:	f003 0301 	and.w	r3, r3, #1
200093d0:	2b00      	cmp	r3, #0
200093d2:	d004      	beq.n	200093de <HAL_EXTI_SetConfigLine+0x23e>
  {
    regval |= maskline;
200093d4:	69ba      	ldr	r2, [r7, #24]
200093d6:	68bb      	ldr	r3, [r7, #8]
200093d8:	4313      	orrs	r3, r2
200093da:	61bb      	str	r3, [r7, #24]
200093dc:	e004      	b.n	200093e8 <HAL_EXTI_SetConfigLine+0x248>
  }
  else
  {
    regval &= ~maskline;
200093de:	68bb      	ldr	r3, [r7, #8]
200093e0:	43db      	mvns	r3, r3
200093e2:	69ba      	ldr	r2, [r7, #24]
200093e4:	4013      	ands	r3, r2
200093e6:	61bb      	str	r3, [r7, #24]
  }

  /* Store interrupt mode */
  *regaddr = regval;
200093e8:	69fb      	ldr	r3, [r7, #28]
200093ea:	69ba      	ldr	r2, [r7, #24]
200093ec:	601a      	str	r2, [r3, #0]

  /* The event mode cannot be configured if the line does not support it */
  assert_param(((pExtiConfig->Line & EXTI_EVENT) == EXTI_EVENT) || ((pExtiConfig->Mode & EXTI_MODE_EVENT) != EXTI_MODE_EVENT));
200093ee:	683b      	ldr	r3, [r7, #0]
200093f0:	681b      	ldr	r3, [r3, #0]
200093f2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
200093f6:	2b00      	cmp	r3, #0
200093f8:	d10a      	bne.n	20009410 <HAL_EXTI_SetConfigLine+0x270>
200093fa:	683b      	ldr	r3, [r7, #0]
200093fc:	685b      	ldr	r3, [r3, #4]
200093fe:	f003 0302 	and.w	r3, r3, #2
20009402:	2b00      	cmp	r3, #0
20009404:	d004      	beq.n	20009410 <HAL_EXTI_SetConfigLine+0x270>
20009406:	f44f 7186 	mov.w	r1, #268	; 0x10c
2000940a:	480e      	ldr	r0, [pc, #56]	; (20009444 <HAL_EXTI_SetConfigLine+0x2a4>)
2000940c:	f7f7 fa72 	bl	200008f4 <assert_failed>

  /* Configure event mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
20009410:	693b      	ldr	r3, [r7, #16]
20009412:	011a      	lsls	r2, r3, #4
20009414:	4b0f      	ldr	r3, [pc, #60]	; (20009454 <HAL_EXTI_SetConfigLine+0x2b4>)
20009416:	4413      	add	r3, r2
20009418:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
2000941a:	69fb      	ldr	r3, [r7, #28]
2000941c:	681b      	ldr	r3, [r3, #0]
2000941e:	61bb      	str	r3, [r7, #24]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00U)
20009420:	683b      	ldr	r3, [r7, #0]
20009422:	685b      	ldr	r3, [r3, #4]
20009424:	f003 0302 	and.w	r3, r3, #2
20009428:	2b00      	cmp	r3, #0
2000942a:	d015      	beq.n	20009458 <HAL_EXTI_SetConfigLine+0x2b8>
  {
    regval |= maskline;
2000942c:	69ba      	ldr	r2, [r7, #24]
2000942e:	68bb      	ldr	r3, [r7, #8]
20009430:	4313      	orrs	r3, r2
20009432:	61bb      	str	r3, [r7, #24]
20009434:	e015      	b.n	20009462 <HAL_EXTI_SetConfigLine+0x2c2>
20009436:	bf00      	nop
20009438:	e8ccffe0 	.word	0xe8ccffe0
2000943c:	0003001f 	.word	0x0003001f
20009440:	00020017 	.word	0x00020017
20009444:	2001c050 	.word	0x2001c050
20009448:	58000004 	.word	0x58000004
2000944c:	58000400 	.word	0x58000400
20009450:	58000080 	.word	0x58000080
20009454:	58000084 	.word	0x58000084
  }
  else
  {
    regval &= ~maskline;
20009458:	68bb      	ldr	r3, [r7, #8]
2000945a:	43db      	mvns	r3, r3
2000945c:	69ba      	ldr	r2, [r7, #24]
2000945e:	4013      	ands	r3, r2
20009460:	61bb      	str	r3, [r7, #24]
  }

  /* Store event mode */
  *regaddr = regval;
20009462:	69fb      	ldr	r3, [r7, #28]
20009464:	69ba      	ldr	r2, [r7, #24]
20009466:	601a      	str	r2, [r3, #0]
  /* Store event mode */
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* Configure the D3 PendClear source in case of Wakeup target is Any */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
20009468:	683b      	ldr	r3, [r7, #0]
2000946a:	681b      	ldr	r3, [r3, #0]
2000946c:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009470:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
20009474:	d167      	bne.n	20009546 <HAL_EXTI_SetConfigLine+0x3a6>
  {
    assert_param(IS_EXTI_D3_PENDCLR_SRC(pExtiConfig->PendClearSource));
20009476:	683b      	ldr	r3, [r7, #0]
20009478:	691b      	ldr	r3, [r3, #16]
2000947a:	2b00      	cmp	r3, #0
2000947c:	d014      	beq.n	200094a8 <HAL_EXTI_SetConfigLine+0x308>
2000947e:	683b      	ldr	r3, [r7, #0]
20009480:	691b      	ldr	r3, [r3, #16]
20009482:	2b01      	cmp	r3, #1
20009484:	d010      	beq.n	200094a8 <HAL_EXTI_SetConfigLine+0x308>
20009486:	683b      	ldr	r3, [r7, #0]
20009488:	691b      	ldr	r3, [r3, #16]
2000948a:	2b02      	cmp	r3, #2
2000948c:	d00c      	beq.n	200094a8 <HAL_EXTI_SetConfigLine+0x308>
2000948e:	683b      	ldr	r3, [r7, #0]
20009490:	691b      	ldr	r3, [r3, #16]
20009492:	2b03      	cmp	r3, #3
20009494:	d008      	beq.n	200094a8 <HAL_EXTI_SetConfigLine+0x308>
20009496:	683b      	ldr	r3, [r7, #0]
20009498:	691b      	ldr	r3, [r3, #16]
2000949a:	2b04      	cmp	r3, #4
2000949c:	d004      	beq.n	200094a8 <HAL_EXTI_SetConfigLine+0x308>
2000949e:	f240 1149 	movw	r1, #329	; 0x149
200094a2:	482b      	ldr	r0, [pc, #172]	; (20009550 <HAL_EXTI_SetConfigLine+0x3b0>)
200094a4:	f7f7 fa26 	bl	200008f4 <assert_failed>

    /*Calc the PMR register address for the given line */
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
200094a8:	693b      	ldr	r3, [r7, #16]
200094aa:	015a      	lsls	r2, r3, #5
200094ac:	4b29      	ldr	r3, [pc, #164]	; (20009554 <HAL_EXTI_SetConfigLine+0x3b4>)
200094ae:	4413      	add	r3, r2
200094b0:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
200094b2:	69fb      	ldr	r3, [r7, #28]
200094b4:	681b      	ldr	r3, [r3, #0]
200094b6:	61bb      	str	r3, [r7, #24]

    if(pExtiConfig->PendClearSource == EXTI_D3_PENDCLR_SRC_NONE)
200094b8:	683b      	ldr	r3, [r7, #0]
200094ba:	691b      	ldr	r3, [r3, #16]
200094bc:	2b00      	cmp	r3, #0
200094be:	d108      	bne.n	200094d2 <HAL_EXTI_SetConfigLine+0x332>
    {
      /* Clear D3PMRx register for the given line */
      regval &= ~maskline;
200094c0:	68bb      	ldr	r3, [r7, #8]
200094c2:	43db      	mvns	r3, r3
200094c4:	69ba      	ldr	r2, [r7, #24]
200094c6:	4013      	ands	r3, r2
200094c8:	61bb      	str	r3, [r7, #24]
      /* Store D3PMRx register value */
      *regaddr = regval;
200094ca:	69fb      	ldr	r3, [r7, #28]
200094cc:	69ba      	ldr	r2, [r7, #24]
200094ce:	601a      	str	r2, [r3, #0]
200094d0:	e039      	b.n	20009546 <HAL_EXTI_SetConfigLine+0x3a6>
    }
    else
    {
      /* Set D3PMRx register to 1 for the given line */
      regval |= maskline;
200094d2:	69ba      	ldr	r2, [r7, #24]
200094d4:	68bb      	ldr	r3, [r7, #8]
200094d6:	4313      	orrs	r3, r2
200094d8:	61bb      	str	r3, [r7, #24]
      /* Store D3PMRx register value */
      *regaddr = regval;
200094da:	69fb      	ldr	r3, [r7, #28]
200094dc:	69ba      	ldr	r2, [r7, #24]
200094de:	601a      	str	r2, [r3, #0]

      if(linepos < 16UL)
200094e0:	68fb      	ldr	r3, [r7, #12]
200094e2:	2b0f      	cmp	r3, #15
200094e4:	d80a      	bhi.n	200094fc <HAL_EXTI_SetConfigLine+0x35c>
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
200094e6:	693b      	ldr	r3, [r7, #16]
200094e8:	015a      	lsls	r2, r3, #5
200094ea:	4b1b      	ldr	r3, [pc, #108]	; (20009558 <HAL_EXTI_SetConfigLine+0x3b8>)
200094ec:	4413      	add	r3, r2
200094ee:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << linepos;
200094f0:	2201      	movs	r2, #1
200094f2:	68fb      	ldr	r3, [r7, #12]
200094f4:	fa02 f303 	lsl.w	r3, r2, r3
200094f8:	617b      	str	r3, [r7, #20]
200094fa:	e00a      	b.n	20009512 <HAL_EXTI_SetConfigLine+0x372>
      }
      else
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
200094fc:	693b      	ldr	r3, [r7, #16]
200094fe:	015a      	lsls	r2, r3, #5
20009500:	4b16      	ldr	r3, [pc, #88]	; (2000955c <HAL_EXTI_SetConfigLine+0x3bc>)
20009502:	4413      	add	r3, r2
20009504:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << (linepos - 16UL);
20009506:	68fb      	ldr	r3, [r7, #12]
20009508:	3b10      	subs	r3, #16
2000950a:	2201      	movs	r2, #1
2000950c:	fa02 f303 	lsl.w	r3, r2, r3
20009510:	617b      	str	r3, [r7, #20]
      }

      regval = (*regaddr & (~(pcrlinepos * pcrlinepos * 3UL))) | (pcrlinepos * pcrlinepos * (pExtiConfig->PendClearSource - 1UL));
20009512:	69fb      	ldr	r3, [r7, #28]
20009514:	6819      	ldr	r1, [r3, #0]
20009516:	697b      	ldr	r3, [r7, #20]
20009518:	697a      	ldr	r2, [r7, #20]
2000951a:	fb02 f203 	mul.w	r2, r2, r3
2000951e:	4613      	mov	r3, r2
20009520:	005b      	lsls	r3, r3, #1
20009522:	4413      	add	r3, r2
20009524:	43db      	mvns	r3, r3
20009526:	ea01 0203 	and.w	r2, r1, r3
2000952a:	697b      	ldr	r3, [r7, #20]
2000952c:	6979      	ldr	r1, [r7, #20]
2000952e:	fb01 f303 	mul.w	r3, r1, r3
20009532:	6839      	ldr	r1, [r7, #0]
20009534:	6909      	ldr	r1, [r1, #16]
20009536:	3901      	subs	r1, #1
20009538:	fb01 f303 	mul.w	r3, r1, r3
2000953c:	4313      	orrs	r3, r2
2000953e:	61bb      	str	r3, [r7, #24]
      *regaddr = regval;
20009540:	69fb      	ldr	r3, [r7, #28]
20009542:	69ba      	ldr	r2, [r7, #24]
20009544:	601a      	str	r2, [r3, #0]
    }
  }

  return HAL_OK;
20009546:	2300      	movs	r3, #0
}
20009548:	4618      	mov	r0, r3
2000954a:	3720      	adds	r7, #32
2000954c:	46bd      	mov	sp, r7
2000954e:	bd80      	pop	{r7, pc}
20009550:	2001c050 	.word	0x2001c050
20009554:	5800000c 	.word	0x5800000c
20009558:	58000010 	.word	0x58000010
2000955c:	58000014 	.word	0x58000014

20009560 <HAL_EXTI_GetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on structure to store Exti configuration.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
20009560:	b580      	push	{r7, lr}
20009562:	b088      	sub	sp, #32
20009564:	af00      	add	r7, sp, #0
20009566:	6078      	str	r0, [r7, #4]
20009568:	6039      	str	r1, [r7, #0]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
2000956a:	687b      	ldr	r3, [r7, #4]
2000956c:	2b00      	cmp	r3, #0
2000956e:	d002      	beq.n	20009576 <HAL_EXTI_GetConfigLine+0x16>
20009570:	683b      	ldr	r3, [r7, #0]
20009572:	2b00      	cmp	r3, #0
20009574:	d101      	bne.n	2000957a <HAL_EXTI_GetConfigLine+0x1a>
  {
    return HAL_ERROR;
20009576:	2301      	movs	r3, #1
20009578:	e111      	b.n	2000979e <HAL_EXTI_GetConfigLine+0x23e>
  }

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));
2000957a:	687b      	ldr	r3, [r7, #4]
2000957c:	681a      	ldr	r2, [r3, #0]
2000957e:	4b8a      	ldr	r3, [pc, #552]	; (200097a8 <HAL_EXTI_GetConfigLine+0x248>)
20009580:	4013      	ands	r3, r2
20009582:	2b00      	cmp	r3, #0
20009584:	d129      	bne.n	200095da <HAL_EXTI_GetConfigLine+0x7a>
20009586:	687b      	ldr	r3, [r7, #4]
20009588:	681b      	ldr	r3, [r3, #0]
2000958a:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
2000958e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20009592:	d00d      	beq.n	200095b0 <HAL_EXTI_GetConfigLine+0x50>
20009594:	687b      	ldr	r3, [r7, #4]
20009596:	681b      	ldr	r3, [r3, #0]
20009598:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
2000959c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200095a0:	d006      	beq.n	200095b0 <HAL_EXTI_GetConfigLine+0x50>
200095a2:	687b      	ldr	r3, [r7, #4]
200095a4:	681b      	ldr	r3, [r3, #0]
200095a6:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
200095aa:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
200095ae:	d114      	bne.n	200095da <HAL_EXTI_GetConfigLine+0x7a>
200095b0:	687b      	ldr	r3, [r7, #4]
200095b2:	681b      	ldr	r3, [r3, #0]
200095b4:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
200095b8:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
200095bc:	d006      	beq.n	200095cc <HAL_EXTI_GetConfigLine+0x6c>
200095be:	687b      	ldr	r3, [r7, #4]
200095c0:	681b      	ldr	r3, [r3, #0]
200095c2:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
200095c6:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
200095ca:	d106      	bne.n	200095da <HAL_EXTI_GetConfigLine+0x7a>
200095cc:	687b      	ldr	r3, [r7, #4]
200095ce:	681a      	ldr	r2, [r3, #0]
200095d0:	4b76      	ldr	r3, [pc, #472]	; (200097ac <HAL_EXTI_GetConfigLine+0x24c>)
200095d2:	4013      	ands	r3, r2
200095d4:	4a76      	ldr	r2, [pc, #472]	; (200097b0 <HAL_EXTI_GetConfigLine+0x250>)
200095d6:	4293      	cmp	r3, r2
200095d8:	d904      	bls.n	200095e4 <HAL_EXTI_GetConfigLine+0x84>
200095da:	f240 1187 	movw	r1, #391	; 0x187
200095de:	4875      	ldr	r0, [pc, #468]	; (200097b4 <HAL_EXTI_GetConfigLine+0x254>)
200095e0:	f7f7 f988 	bl	200008f4 <assert_failed>

  /* Store handle line number to configuration structure */
  pExtiConfig->Line = hexti->Line;
200095e4:	687b      	ldr	r3, [r7, #4]
200095e6:	681a      	ldr	r2, [r3, #0]
200095e8:	683b      	ldr	r3, [r7, #0]
200095ea:	601a      	str	r2, [r3, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
200095ec:	683b      	ldr	r3, [r7, #0]
200095ee:	681b      	ldr	r3, [r3, #0]
200095f0:	0c1b      	lsrs	r3, r3, #16
200095f2:	f003 0303 	and.w	r3, r3, #3
200095f6:	617b      	str	r3, [r7, #20]
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
200095f8:	683b      	ldr	r3, [r7, #0]
200095fa:	681b      	ldr	r3, [r3, #0]
200095fc:	f003 031f 	and.w	r3, r3, #31
20009600:	613b      	str	r3, [r7, #16]
  maskline = (1UL << linepos);
20009602:	2201      	movs	r2, #1
20009604:	693b      	ldr	r3, [r7, #16]
20009606:	fa02 f303 	lsl.w	r3, r2, r3
2000960a:	60fb      	str	r3, [r7, #12]

  /* 1] Get core mode : interrupt */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
2000960c:	697b      	ldr	r3, [r7, #20]
2000960e:	011a      	lsls	r2, r3, #4
20009610:	4b69      	ldr	r3, [pc, #420]	; (200097b8 <HAL_EXTI_GetConfigLine+0x258>)
20009612:	4413      	add	r3, r2
20009614:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
20009616:	69fb      	ldr	r3, [r7, #28]
20009618:	681b      	ldr	r3, [r3, #0]
2000961a:	60bb      	str	r3, [r7, #8]

  pExtiConfig->Mode = EXTI_MODE_NONE;
2000961c:	683b      	ldr	r3, [r7, #0]
2000961e:	2200      	movs	r2, #0
20009620:	605a      	str	r2, [r3, #4]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
20009622:	68ba      	ldr	r2, [r7, #8]
20009624:	68fb      	ldr	r3, [r7, #12]
20009626:	4013      	ands	r3, r2
20009628:	2b00      	cmp	r3, #0
2000962a:	d002      	beq.n	20009632 <HAL_EXTI_GetConfigLine+0xd2>
  {
    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;
2000962c:	683b      	ldr	r3, [r7, #0]
2000962e:	2201      	movs	r2, #1
20009630:	605a      	str	r2, [r3, #4]
  }

  /* Get event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
20009632:	697b      	ldr	r3, [r7, #20]
20009634:	011a      	lsls	r2, r3, #4
20009636:	4b61      	ldr	r3, [pc, #388]	; (200097bc <HAL_EXTI_GetConfigLine+0x25c>)
20009638:	4413      	add	r3, r2
2000963a:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
2000963c:	69fb      	ldr	r3, [r7, #28]
2000963e:	681b      	ldr	r3, [r3, #0]
20009640:	60bb      	str	r3, [r7, #8]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
20009642:	68ba      	ldr	r2, [r7, #8]
20009644:	68fb      	ldr	r3, [r7, #12]
20009646:	4013      	ands	r3, r2
20009648:	2b00      	cmp	r3, #0
2000964a:	d005      	beq.n	20009658 <HAL_EXTI_GetConfigLine+0xf8>
  {
    pExtiConfig->Mode |= EXTI_MODE_EVENT;
2000964c:	683b      	ldr	r3, [r7, #0]
2000964e:	685b      	ldr	r3, [r3, #4]
20009650:	f043 0202 	orr.w	r2, r3, #2
20009654:	683b      	ldr	r3, [r7, #0]
20009656:	605a      	str	r2, [r3, #4]
    pExtiConfig->Mode |= EXTI_MODE_CORE2_EVENT;
  }
#endif /*DUAL_CORE*/

  /* 2] Get trigger for configurable lines : rising */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
20009658:	683b      	ldr	r3, [r7, #0]
2000965a:	681b      	ldr	r3, [r3, #0]
2000965c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20009660:	2b00      	cmp	r3, #0
20009662:	d04e      	beq.n	20009702 <HAL_EXTI_GetConfigLine+0x1a2>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
20009664:	697b      	ldr	r3, [r7, #20]
20009666:	015b      	lsls	r3, r3, #5
20009668:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
2000966c:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
2000966e:	69fb      	ldr	r3, [r7, #28]
20009670:	681b      	ldr	r3, [r3, #0]
20009672:	60bb      	str	r3, [r7, #8]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
20009674:	68ba      	ldr	r2, [r7, #8]
20009676:	68fb      	ldr	r3, [r7, #12]
20009678:	4013      	ands	r3, r2
2000967a:	2b00      	cmp	r3, #0
2000967c:	d003      	beq.n	20009686 <HAL_EXTI_GetConfigLine+0x126>
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;
2000967e:	683b      	ldr	r3, [r7, #0]
20009680:	2201      	movs	r2, #1
20009682:	609a      	str	r2, [r3, #8]
20009684:	e002      	b.n	2000968c <HAL_EXTI_GetConfigLine+0x12c>
    }
    else
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
20009686:	683b      	ldr	r3, [r7, #0]
20009688:	2200      	movs	r2, #0
2000968a:	609a      	str	r2, [r3, #8]
    }

    /* Get falling configuration */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
2000968c:	697b      	ldr	r3, [r7, #20]
2000968e:	015a      	lsls	r2, r3, #5
20009690:	4b4b      	ldr	r3, [pc, #300]	; (200097c0 <HAL_EXTI_GetConfigLine+0x260>)
20009692:	4413      	add	r3, r2
20009694:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
20009696:	69fb      	ldr	r3, [r7, #28]
20009698:	681b      	ldr	r3, [r3, #0]
2000969a:	60bb      	str	r3, [r7, #8]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
2000969c:	68ba      	ldr	r2, [r7, #8]
2000969e:	68fb      	ldr	r3, [r7, #12]
200096a0:	4013      	ands	r3, r2
200096a2:	2b00      	cmp	r3, #0
200096a4:	d005      	beq.n	200096b2 <HAL_EXTI_GetConfigLine+0x152>
    {
      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;
200096a6:	683b      	ldr	r3, [r7, #0]
200096a8:	689b      	ldr	r3, [r3, #8]
200096aa:	f043 0202 	orr.w	r2, r3, #2
200096ae:	683b      	ldr	r3, [r7, #0]
200096b0:	609a      	str	r2, [r3, #8]
    }

    /* Get Gpio port selection for gpio lines */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
200096b2:	683b      	ldr	r3, [r7, #0]
200096b4:	681b      	ldr	r3, [r3, #0]
200096b6:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
200096ba:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
200096be:	d11c      	bne.n	200096fa <HAL_EXTI_GetConfigLine+0x19a>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));
200096c0:	693b      	ldr	r3, [r7, #16]
200096c2:	2b0f      	cmp	r3, #15
200096c4:	d904      	bls.n	200096d0 <HAL_EXTI_GetConfigLine+0x170>
200096c6:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
200096ca:	483a      	ldr	r0, [pc, #232]	; (200097b4 <HAL_EXTI_GetConfigLine+0x254>)
200096cc:	f7f7 f912 	bl	200008f4 <assert_failed>

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
200096d0:	4a3c      	ldr	r2, [pc, #240]	; (200097c4 <HAL_EXTI_GetConfigLine+0x264>)
200096d2:	693b      	ldr	r3, [r7, #16]
200096d4:	089b      	lsrs	r3, r3, #2
200096d6:	f003 0303 	and.w	r3, r3, #3
200096da:	3302      	adds	r3, #2
200096dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200096e0:	60bb      	str	r3, [r7, #8]
      pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3UL - (linepos & 0x03UL)))) >> 24U);
200096e2:	693b      	ldr	r3, [r7, #16]
200096e4:	43db      	mvns	r3, r3
200096e6:	f003 0303 	and.w	r3, r3, #3
200096ea:	009b      	lsls	r3, r3, #2
200096ec:	68ba      	ldr	r2, [r7, #8]
200096ee:	fa02 f303 	lsl.w	r3, r2, r3
200096f2:	0e1a      	lsrs	r2, r3, #24
200096f4:	683b      	ldr	r3, [r7, #0]
200096f6:	60da      	str	r2, [r3, #12]
200096f8:	e009      	b.n	2000970e <HAL_EXTI_GetConfigLine+0x1ae>
    }
    else
    {
      pExtiConfig->GPIOSel = 0x00U;
200096fa:	683b      	ldr	r3, [r7, #0]
200096fc:	2200      	movs	r2, #0
200096fe:	60da      	str	r2, [r3, #12]
20009700:	e005      	b.n	2000970e <HAL_EXTI_GetConfigLine+0x1ae>
    }
  }
  else
  {
    pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
20009702:	683b      	ldr	r3, [r7, #0]
20009704:	2200      	movs	r2, #0
20009706:	609a      	str	r2, [r3, #8]
    pExtiConfig->GPIOSel = 0x00U;
20009708:	683b      	ldr	r3, [r7, #0]
2000970a:	2200      	movs	r2, #0
2000970c:	60da      	str	r2, [r3, #12]
  }

  /* 3] Get D3 Pend Clear source */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
2000970e:	683b      	ldr	r3, [r7, #0]
20009710:	681b      	ldr	r3, [r3, #0]
20009712:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009716:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
2000971a:	d13c      	bne.n	20009796 <HAL_EXTI_GetConfigLine+0x236>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
2000971c:	697b      	ldr	r3, [r7, #20]
2000971e:	015a      	lsls	r2, r3, #5
20009720:	4b29      	ldr	r3, [pc, #164]	; (200097c8 <HAL_EXTI_GetConfigLine+0x268>)
20009722:	4413      	add	r3, r2
20009724:	61fb      	str	r3, [r7, #28]
    if(((*regaddr) & linepos) == 0UL)
20009726:	69fb      	ldr	r3, [r7, #28]
20009728:	681a      	ldr	r2, [r3, #0]
2000972a:	693b      	ldr	r3, [r7, #16]
2000972c:	4013      	ands	r3, r2
2000972e:	2b00      	cmp	r3, #0
20009730:	d103      	bne.n	2000973a <HAL_EXTI_GetConfigLine+0x1da>
    {
      /* if PMR unset, then no pend clear source is used */
      pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;
20009732:	683b      	ldr	r3, [r7, #0]
20009734:	2200      	movs	r2, #0
20009736:	611a      	str	r2, [r3, #16]
20009738:	e030      	b.n	2000979c <HAL_EXTI_GetConfigLine+0x23c>
    }
    else
    {
      /* if wakeup target is any and PMR set, the read pend clear source from  D3PCRxL/H */
      if(linepos < 16UL)
2000973a:	693b      	ldr	r3, [r7, #16]
2000973c:	2b0f      	cmp	r3, #15
2000973e:	d80a      	bhi.n	20009756 <HAL_EXTI_GetConfigLine+0x1f6>
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
20009740:	697b      	ldr	r3, [r7, #20]
20009742:	015a      	lsls	r2, r3, #5
20009744:	4b21      	ldr	r3, [pc, #132]	; (200097cc <HAL_EXTI_GetConfigLine+0x26c>)
20009746:	4413      	add	r3, r2
20009748:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << linepos;
2000974a:	2201      	movs	r2, #1
2000974c:	693b      	ldr	r3, [r7, #16]
2000974e:	fa02 f303 	lsl.w	r3, r2, r3
20009752:	61bb      	str	r3, [r7, #24]
20009754:	e00a      	b.n	2000976c <HAL_EXTI_GetConfigLine+0x20c>
      }
      else
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
20009756:	697b      	ldr	r3, [r7, #20]
20009758:	015a      	lsls	r2, r3, #5
2000975a:	4b1d      	ldr	r3, [pc, #116]	; (200097d0 <HAL_EXTI_GetConfigLine+0x270>)
2000975c:	4413      	add	r3, r2
2000975e:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << (linepos - 16UL);
20009760:	693b      	ldr	r3, [r7, #16]
20009762:	3b10      	subs	r3, #16
20009764:	2201      	movs	r2, #1
20009766:	fa02 f303 	lsl.w	r3, r2, r3
2000976a:	61bb      	str	r3, [r7, #24]
      }

      pExtiConfig->PendClearSource = 1UL + ((*regaddr & (pcrlinepos * pcrlinepos * 3UL)) / (pcrlinepos * pcrlinepos));
2000976c:	69fb      	ldr	r3, [r7, #28]
2000976e:	6819      	ldr	r1, [r3, #0]
20009770:	69bb      	ldr	r3, [r7, #24]
20009772:	69ba      	ldr	r2, [r7, #24]
20009774:	fb02 f203 	mul.w	r2, r2, r3
20009778:	4613      	mov	r3, r2
2000977a:	005b      	lsls	r3, r3, #1
2000977c:	4413      	add	r3, r2
2000977e:	ea01 0203 	and.w	r2, r1, r3
20009782:	69bb      	ldr	r3, [r7, #24]
20009784:	69b9      	ldr	r1, [r7, #24]
20009786:	fb01 f303 	mul.w	r3, r1, r3
2000978a:	fbb2 f3f3 	udiv	r3, r2, r3
2000978e:	1c5a      	adds	r2, r3, #1
20009790:	683b      	ldr	r3, [r7, #0]
20009792:	611a      	str	r2, [r3, #16]
20009794:	e002      	b.n	2000979c <HAL_EXTI_GetConfigLine+0x23c>
    }
  }
  else
  {
    /* if line wakeup target is not any, then no pend clear source is used  */
    pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;
20009796:	683b      	ldr	r3, [r7, #0]
20009798:	2200      	movs	r2, #0
2000979a:	611a      	str	r2, [r3, #16]
  }

  return HAL_OK;
2000979c:	2300      	movs	r3, #0
}
2000979e:	4618      	mov	r0, r3
200097a0:	3720      	adds	r7, #32
200097a2:	46bd      	mov	sp, r7
200097a4:	bd80      	pop	{r7, pc}
200097a6:	bf00      	nop
200097a8:	e8ccffe0 	.word	0xe8ccffe0
200097ac:	0003001f 	.word	0x0003001f
200097b0:	00020017 	.word	0x00020017
200097b4:	2001c050 	.word	0x2001c050
200097b8:	58000080 	.word	0x58000080
200097bc:	58000084 	.word	0x58000084
200097c0:	58000004 	.word	0x58000004
200097c4:	58000400 	.word	0x58000400
200097c8:	5800000c 	.word	0x5800000c
200097cc:	58000010 	.word	0x58000010
200097d0:	58000014 	.word	0x58000014

200097d4 <HAL_EXTI_ClearConfigLine>:
  * @brief  Clear whole configuration of a dedicated Exti line.
  * @param  hexti Exti handle.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)
{
200097d4:	b580      	push	{r7, lr}
200097d6:	b088      	sub	sp, #32
200097d8:	af00      	add	r7, sp, #0
200097da:	6078      	str	r0, [r7, #4]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if (hexti == NULL)
200097dc:	687b      	ldr	r3, [r7, #4]
200097de:	2b00      	cmp	r3, #0
200097e0:	d101      	bne.n	200097e6 <HAL_EXTI_ClearConfigLine+0x12>
  {
    return HAL_ERROR;
200097e2:	2301      	movs	r3, #1
200097e4:	e0e9      	b.n	200099ba <HAL_EXTI_ClearConfigLine+0x1e6>
  }

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));
200097e6:	687b      	ldr	r3, [r7, #4]
200097e8:	681a      	ldr	r2, [r3, #0]
200097ea:	4b76      	ldr	r3, [pc, #472]	; (200099c4 <HAL_EXTI_ClearConfigLine+0x1f0>)
200097ec:	4013      	ands	r3, r2
200097ee:	2b00      	cmp	r3, #0
200097f0:	d129      	bne.n	20009846 <HAL_EXTI_ClearConfigLine+0x72>
200097f2:	687b      	ldr	r3, [r7, #4]
200097f4:	681b      	ldr	r3, [r3, #0]
200097f6:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
200097fa:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
200097fe:	d00d      	beq.n	2000981c <HAL_EXTI_ClearConfigLine+0x48>
20009800:	687b      	ldr	r3, [r7, #4]
20009802:	681b      	ldr	r3, [r3, #0]
20009804:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009808:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000980c:	d006      	beq.n	2000981c <HAL_EXTI_ClearConfigLine+0x48>
2000980e:	687b      	ldr	r3, [r7, #4]
20009810:	681b      	ldr	r3, [r3, #0]
20009812:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009816:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
2000981a:	d114      	bne.n	20009846 <HAL_EXTI_ClearConfigLine+0x72>
2000981c:	687b      	ldr	r3, [r7, #4]
2000981e:	681b      	ldr	r3, [r3, #0]
20009820:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009824:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
20009828:	d006      	beq.n	20009838 <HAL_EXTI_ClearConfigLine+0x64>
2000982a:	687b      	ldr	r3, [r7, #4]
2000982c:	681b      	ldr	r3, [r3, #0]
2000982e:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009832:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
20009836:	d106      	bne.n	20009846 <HAL_EXTI_ClearConfigLine+0x72>
20009838:	687b      	ldr	r3, [r7, #4]
2000983a:	681a      	ldr	r2, [r3, #0]
2000983c:	4b62      	ldr	r3, [pc, #392]	; (200099c8 <HAL_EXTI_ClearConfigLine+0x1f4>)
2000983e:	4013      	ands	r3, r2
20009840:	4a62      	ldr	r2, [pc, #392]	; (200099cc <HAL_EXTI_ClearConfigLine+0x1f8>)
20009842:	4293      	cmp	r3, r2
20009844:	d904      	bls.n	20009850 <HAL_EXTI_ClearConfigLine+0x7c>
20009846:	f240 2121 	movw	r1, #545	; 0x221
2000984a:	4861      	ldr	r0, [pc, #388]	; (200099d0 <HAL_EXTI_ClearConfigLine+0x1fc>)
2000984c:	f7f7 f852 	bl	200008f4 <assert_failed>

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
20009850:	687b      	ldr	r3, [r7, #4]
20009852:	681b      	ldr	r3, [r3, #0]
20009854:	0c1b      	lsrs	r3, r3, #16
20009856:	f003 0303 	and.w	r3, r3, #3
2000985a:	617b      	str	r3, [r7, #20]
  linepos = (hexti->Line & EXTI_PIN_MASK);
2000985c:	687b      	ldr	r3, [r7, #4]
2000985e:	681b      	ldr	r3, [r3, #0]
20009860:	f003 031f 	and.w	r3, r3, #31
20009864:	613b      	str	r3, [r7, #16]
  maskline = (1UL << linepos);
20009866:	2201      	movs	r2, #1
20009868:	693b      	ldr	r3, [r7, #16]
2000986a:	fa02 f303 	lsl.w	r3, r2, r3
2000986e:	60fb      	str	r3, [r7, #12]

  /* 1] Clear interrupt mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
20009870:	697b      	ldr	r3, [r7, #20]
20009872:	011a      	lsls	r2, r3, #4
20009874:	4b57      	ldr	r3, [pc, #348]	; (200099d4 <HAL_EXTI_ClearConfigLine+0x200>)
20009876:	4413      	add	r3, r2
20009878:	61fb      	str	r3, [r7, #28]
  regval = (*regaddr & ~maskline);
2000987a:	69fb      	ldr	r3, [r7, #28]
2000987c:	681a      	ldr	r2, [r3, #0]
2000987e:	68fb      	ldr	r3, [r7, #12]
20009880:	43db      	mvns	r3, r3
20009882:	4013      	ands	r3, r2
20009884:	60bb      	str	r3, [r7, #8]
  *regaddr = regval;
20009886:	69fb      	ldr	r3, [r7, #28]
20009888:	68ba      	ldr	r2, [r7, #8]
2000988a:	601a      	str	r2, [r3, #0]

  /* 2] Clear event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
2000988c:	697b      	ldr	r3, [r7, #20]
2000988e:	011a      	lsls	r2, r3, #4
20009890:	4b51      	ldr	r3, [pc, #324]	; (200099d8 <HAL_EXTI_ClearConfigLine+0x204>)
20009892:	4413      	add	r3, r2
20009894:	61fb      	str	r3, [r7, #28]
  regval = (*regaddr & ~maskline);
20009896:	69fb      	ldr	r3, [r7, #28]
20009898:	681a      	ldr	r2, [r3, #0]
2000989a:	68fb      	ldr	r3, [r7, #12]
2000989c:	43db      	mvns	r3, r3
2000989e:	4013      	ands	r3, r2
200098a0:	60bb      	str	r3, [r7, #8]
  *regaddr = regval;
200098a2:	69fb      	ldr	r3, [r7, #28]
200098a4:	68ba      	ldr	r2, [r7, #8]
200098a6:	601a      	str	r2, [r3, #0]
  regval = (*regaddr & ~maskline);
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* 3] Clear triggers in case of configurable lines */
  if ((hexti->Line & EXTI_CONFIG) != 0x00U)
200098a8:	687b      	ldr	r3, [r7, #4]
200098aa:	681b      	ldr	r3, [r3, #0]
200098ac:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
200098b0:	2b00      	cmp	r3, #0
200098b2:	d047      	beq.n	20009944 <HAL_EXTI_ClearConfigLine+0x170>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
200098b4:	697b      	ldr	r3, [r7, #20]
200098b6:	015b      	lsls	r3, r3, #5
200098b8:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
200098bc:	61fb      	str	r3, [r7, #28]
    regval = (*regaddr & ~maskline);
200098be:	69fb      	ldr	r3, [r7, #28]
200098c0:	681a      	ldr	r2, [r3, #0]
200098c2:	68fb      	ldr	r3, [r7, #12]
200098c4:	43db      	mvns	r3, r3
200098c6:	4013      	ands	r3, r2
200098c8:	60bb      	str	r3, [r7, #8]
    *regaddr = regval;
200098ca:	69fb      	ldr	r3, [r7, #28]
200098cc:	68ba      	ldr	r2, [r7, #8]
200098ce:	601a      	str	r2, [r3, #0]

    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
200098d0:	697b      	ldr	r3, [r7, #20]
200098d2:	015a      	lsls	r2, r3, #5
200098d4:	4b41      	ldr	r3, [pc, #260]	; (200099dc <HAL_EXTI_ClearConfigLine+0x208>)
200098d6:	4413      	add	r3, r2
200098d8:	61fb      	str	r3, [r7, #28]
    regval = (*regaddr & ~maskline);
200098da:	69fb      	ldr	r3, [r7, #28]
200098dc:	681a      	ldr	r2, [r3, #0]
200098de:	68fb      	ldr	r3, [r7, #12]
200098e0:	43db      	mvns	r3, r3
200098e2:	4013      	ands	r3, r2
200098e4:	60bb      	str	r3, [r7, #8]
    *regaddr = regval;
200098e6:	69fb      	ldr	r3, [r7, #28]
200098e8:	68ba      	ldr	r2, [r7, #8]
200098ea:	601a      	str	r2, [r3, #0]

    /* Get Gpio port selection for gpio lines */
    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)
200098ec:	687b      	ldr	r3, [r7, #4]
200098ee:	681b      	ldr	r3, [r3, #0]
200098f0:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
200098f4:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
200098f8:	d124      	bne.n	20009944 <HAL_EXTI_ClearConfigLine+0x170>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));
200098fa:	693b      	ldr	r3, [r7, #16]
200098fc:	2b0f      	cmp	r3, #15
200098fe:	d904      	bls.n	2000990a <HAL_EXTI_ClearConfigLine+0x136>
20009900:	f44f 7113 	mov.w	r1, #588	; 0x24c
20009904:	4832      	ldr	r0, [pc, #200]	; (200099d0 <HAL_EXTI_ClearConfigLine+0x1fc>)
20009906:	f7f6 fff5 	bl	200008f4 <assert_failed>

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
2000990a:	4a35      	ldr	r2, [pc, #212]	; (200099e0 <HAL_EXTI_ClearConfigLine+0x20c>)
2000990c:	693b      	ldr	r3, [r7, #16]
2000990e:	089b      	lsrs	r3, r3, #2
20009910:	f003 0303 	and.w	r3, r3, #3
20009914:	3302      	adds	r3, #2
20009916:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000991a:	60bb      	str	r3, [r7, #8]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03UL)));
2000991c:	693b      	ldr	r3, [r7, #16]
2000991e:	f003 0303 	and.w	r3, r3, #3
20009922:	009b      	lsls	r3, r3, #2
20009924:	220f      	movs	r2, #15
20009926:	fa02 f303 	lsl.w	r3, r2, r3
2000992a:	43db      	mvns	r3, r3
2000992c:	68ba      	ldr	r2, [r7, #8]
2000992e:	4013      	ands	r3, r2
20009930:	60bb      	str	r3, [r7, #8]
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
20009932:	492b      	ldr	r1, [pc, #172]	; (200099e0 <HAL_EXTI_ClearConfigLine+0x20c>)
20009934:	693b      	ldr	r3, [r7, #16]
20009936:	089b      	lsrs	r3, r3, #2
20009938:	f003 0303 	and.w	r3, r3, #3
2000993c:	3302      	adds	r3, #2
2000993e:	68ba      	ldr	r2, [r7, #8]
20009940:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* 4] Clear D3 Config lines */
  if ((hexti->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
20009944:	687b      	ldr	r3, [r7, #4]
20009946:	681b      	ldr	r3, [r3, #0]
20009948:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
2000994c:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
20009950:	d132      	bne.n	200099b8 <HAL_EXTI_ClearConfigLine+0x1e4>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
20009952:	697b      	ldr	r3, [r7, #20]
20009954:	015a      	lsls	r2, r3, #5
20009956:	4b23      	ldr	r3, [pc, #140]	; (200099e4 <HAL_EXTI_ClearConfigLine+0x210>)
20009958:	4413      	add	r3, r2
2000995a:	61fb      	str	r3, [r7, #28]
    *regaddr = (*regaddr & ~maskline);
2000995c:	69fb      	ldr	r3, [r7, #28]
2000995e:	681a      	ldr	r2, [r3, #0]
20009960:	68fb      	ldr	r3, [r7, #12]
20009962:	43db      	mvns	r3, r3
20009964:	401a      	ands	r2, r3
20009966:	69fb      	ldr	r3, [r7, #28]
20009968:	601a      	str	r2, [r3, #0]

    if(linepos < 16UL)
2000996a:	693b      	ldr	r3, [r7, #16]
2000996c:	2b0f      	cmp	r3, #15
2000996e:	d80a      	bhi.n	20009986 <HAL_EXTI_ClearConfigLine+0x1b2>
    {
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
20009970:	697b      	ldr	r3, [r7, #20]
20009972:	015a      	lsls	r2, r3, #5
20009974:	4b1c      	ldr	r3, [pc, #112]	; (200099e8 <HAL_EXTI_ClearConfigLine+0x214>)
20009976:	4413      	add	r3, r2
20009978:	61fb      	str	r3, [r7, #28]
      pcrlinepos = 1UL << linepos;
2000997a:	2201      	movs	r2, #1
2000997c:	693b      	ldr	r3, [r7, #16]
2000997e:	fa02 f303 	lsl.w	r3, r2, r3
20009982:	61bb      	str	r3, [r7, #24]
20009984:	e00a      	b.n	2000999c <HAL_EXTI_ClearConfigLine+0x1c8>
    }
    else
    {
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
20009986:	697b      	ldr	r3, [r7, #20]
20009988:	015a      	lsls	r2, r3, #5
2000998a:	4b18      	ldr	r3, [pc, #96]	; (200099ec <HAL_EXTI_ClearConfigLine+0x218>)
2000998c:	4413      	add	r3, r2
2000998e:	61fb      	str	r3, [r7, #28]
      pcrlinepos = 1UL << (linepos - 16UL);
20009990:	693b      	ldr	r3, [r7, #16]
20009992:	3b10      	subs	r3, #16
20009994:	2201      	movs	r2, #1
20009996:	fa02 f303 	lsl.w	r3, r2, r3
2000999a:	61bb      	str	r3, [r7, #24]
    }

    /*Clear D3 PendClear source */
    *regaddr &= (~(pcrlinepos * pcrlinepos * 3UL));
2000999c:	69fb      	ldr	r3, [r7, #28]
2000999e:	6819      	ldr	r1, [r3, #0]
200099a0:	69bb      	ldr	r3, [r7, #24]
200099a2:	69ba      	ldr	r2, [r7, #24]
200099a4:	fb02 f203 	mul.w	r2, r2, r3
200099a8:	4613      	mov	r3, r2
200099aa:	005b      	lsls	r3, r3, #1
200099ac:	4413      	add	r3, r2
200099ae:	43db      	mvns	r3, r3
200099b0:	ea01 0203 	and.w	r2, r1, r3
200099b4:	69fb      	ldr	r3, [r7, #28]
200099b6:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
200099b8:	2300      	movs	r3, #0
}
200099ba:	4618      	mov	r0, r3
200099bc:	3720      	adds	r7, #32
200099be:	46bd      	mov	sp, r7
200099c0:	bd80      	pop	{r7, pc}
200099c2:	bf00      	nop
200099c4:	e8ccffe0 	.word	0xe8ccffe0
200099c8:	0003001f 	.word	0x0003001f
200099cc:	00020017 	.word	0x00020017
200099d0:	2001c050 	.word	0x2001c050
200099d4:	58000080 	.word	0x58000080
200099d8:	58000084 	.word	0x58000084
200099dc:	58000004 	.word	0x58000004
200099e0:	58000400 	.word	0x58000400
200099e4:	5800000c 	.word	0x5800000c
200099e8:	58000010 	.word	0x58000010
200099ec:	58000014 	.word	0x58000014

200099f0 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
200099f0:	b480      	push	{r7}
200099f2:	b087      	sub	sp, #28
200099f4:	af00      	add	r7, sp, #0
200099f6:	60f8      	str	r0, [r7, #12]
200099f8:	460b      	mov	r3, r1
200099fa:	607a      	str	r2, [r7, #4]
200099fc:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
200099fe:	2300      	movs	r3, #0
20009a00:	75fb      	strb	r3, [r7, #23]

  /* Check null pointer */
  if (hexti == NULL)
20009a02:	68fb      	ldr	r3, [r7, #12]
20009a04:	2b00      	cmp	r3, #0
20009a06:	d101      	bne.n	20009a0c <HAL_EXTI_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
20009a08:	2301      	movs	r3, #1
20009a0a:	e00a      	b.n	20009a22 <HAL_EXTI_RegisterCallback+0x32>
  }

  switch (CallbackID)
20009a0c:	7afb      	ldrb	r3, [r7, #11]
20009a0e:	2b00      	cmp	r3, #0
20009a10:	d103      	bne.n	20009a1a <HAL_EXTI_RegisterCallback+0x2a>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
20009a12:	68fb      	ldr	r3, [r7, #12]
20009a14:	687a      	ldr	r2, [r7, #4]
20009a16:	605a      	str	r2, [r3, #4]
      break;
20009a18:	e002      	b.n	20009a20 <HAL_EXTI_RegisterCallback+0x30>

    default:
      status = HAL_ERROR;
20009a1a:	2301      	movs	r3, #1
20009a1c:	75fb      	strb	r3, [r7, #23]
      break;
20009a1e:	bf00      	nop
  }

  return status;
20009a20:	7dfb      	ldrb	r3, [r7, #23]
}
20009a22:	4618      	mov	r0, r3
20009a24:	371c      	adds	r7, #28
20009a26:	46bd      	mov	sp, r7
20009a28:	f85d 7b04 	ldr.w	r7, [sp], #4
20009a2c:	4770      	bx	lr
	...

20009a30 <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
20009a30:	b580      	push	{r7, lr}
20009a32:	b082      	sub	sp, #8
20009a34:	af00      	add	r7, sp, #0
20009a36:	6078      	str	r0, [r7, #4]
20009a38:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));
20009a3a:	683a      	ldr	r2, [r7, #0]
20009a3c:	4b1c      	ldr	r3, [pc, #112]	; (20009ab0 <HAL_EXTI_GetHandle+0x80>)
20009a3e:	4013      	ands	r3, r2
20009a40:	2b00      	cmp	r3, #0
20009a42:	d123      	bne.n	20009a8c <HAL_EXTI_GetHandle+0x5c>
20009a44:	683b      	ldr	r3, [r7, #0]
20009a46:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009a4a:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20009a4e:	d00b      	beq.n	20009a68 <HAL_EXTI_GetHandle+0x38>
20009a50:	683b      	ldr	r3, [r7, #0]
20009a52:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009a56:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20009a5a:	d005      	beq.n	20009a68 <HAL_EXTI_GetHandle+0x38>
20009a5c:	683b      	ldr	r3, [r7, #0]
20009a5e:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009a62:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
20009a66:	d111      	bne.n	20009a8c <HAL_EXTI_GetHandle+0x5c>
20009a68:	683b      	ldr	r3, [r7, #0]
20009a6a:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009a6e:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
20009a72:	d005      	beq.n	20009a80 <HAL_EXTI_GetHandle+0x50>
20009a74:	683b      	ldr	r3, [r7, #0]
20009a76:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009a7a:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
20009a7e:	d105      	bne.n	20009a8c <HAL_EXTI_GetHandle+0x5c>
20009a80:	683a      	ldr	r2, [r7, #0]
20009a82:	4b0c      	ldr	r3, [pc, #48]	; (20009ab4 <HAL_EXTI_GetHandle+0x84>)
20009a84:	4013      	ands	r3, r2
20009a86:	4a0c      	ldr	r2, [pc, #48]	; (20009ab8 <HAL_EXTI_GetHandle+0x88>)
20009a88:	4293      	cmp	r3, r2
20009a8a:	d904      	bls.n	20009a96 <HAL_EXTI_GetHandle+0x66>
20009a8c:	f44f 7126 	mov.w	r1, #664	; 0x298
20009a90:	480a      	ldr	r0, [pc, #40]	; (20009abc <HAL_EXTI_GetHandle+0x8c>)
20009a92:	f7f6 ff2f 	bl	200008f4 <assert_failed>

  /* Check null pointer */
  if (hexti == NULL)
20009a96:	687b      	ldr	r3, [r7, #4]
20009a98:	2b00      	cmp	r3, #0
20009a9a:	d101      	bne.n	20009aa0 <HAL_EXTI_GetHandle+0x70>
  {
    return HAL_ERROR;
20009a9c:	2301      	movs	r3, #1
20009a9e:	e003      	b.n	20009aa8 <HAL_EXTI_GetHandle+0x78>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
20009aa0:	687b      	ldr	r3, [r7, #4]
20009aa2:	683a      	ldr	r2, [r7, #0]
20009aa4:	601a      	str	r2, [r3, #0]

    return HAL_OK;
20009aa6:	2300      	movs	r3, #0
  }
}
20009aa8:	4618      	mov	r0, r3
20009aaa:	3708      	adds	r7, #8
20009aac:	46bd      	mov	sp, r7
20009aae:	bd80      	pop	{r7, pc}
20009ab0:	e8ccffe0 	.word	0xe8ccffe0
20009ab4:	0003001f 	.word	0x0003001f
20009ab8:	00020017 	.word	0x00020017
20009abc:	2001c050 	.word	0x2001c050

20009ac0 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
{
20009ac0:	b580      	push	{r7, lr}
20009ac2:	b086      	sub	sp, #24
20009ac4:	af00      	add	r7, sp, #0
20009ac6:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
20009ac8:	687b      	ldr	r3, [r7, #4]
20009aca:	681b      	ldr	r3, [r3, #0]
20009acc:	0c1b      	lsrs	r3, r3, #16
20009ace:	f003 0303 	and.w	r3, r3, #3
20009ad2:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
20009ad4:	687b      	ldr	r3, [r7, #4]
20009ad6:	681b      	ldr	r3, [r3, #0]
20009ad8:	f003 031f 	and.w	r3, r3, #31
20009adc:	2201      	movs	r2, #1
20009ade:	fa02 f303 	lsl.w	r3, r2, r3
20009ae2:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
20009ae4:	697b      	ldr	r3, [r7, #20]
20009ae6:	011a      	lsls	r2, r3, #4
20009ae8:	4b0c      	ldr	r3, [pc, #48]	; (20009b1c <HAL_EXTI_IRQHandler+0x5c>)
20009aea:	4413      	add	r3, r2
20009aec:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Get pending bit  */
  regval = (*regaddr & maskline);
20009aee:	68fb      	ldr	r3, [r7, #12]
20009af0:	681b      	ldr	r3, [r3, #0]
20009af2:	693a      	ldr	r2, [r7, #16]
20009af4:	4013      	ands	r3, r2
20009af6:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00U)
20009af8:	68bb      	ldr	r3, [r7, #8]
20009afa:	2b00      	cmp	r3, #0
20009afc:	d009      	beq.n	20009b12 <HAL_EXTI_IRQHandler+0x52>
  {
    /* Clear pending bit */
    *regaddr = maskline;
20009afe:	68fb      	ldr	r3, [r7, #12]
20009b00:	693a      	ldr	r2, [r7, #16]
20009b02:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
20009b04:	687b      	ldr	r3, [r7, #4]
20009b06:	685b      	ldr	r3, [r3, #4]
20009b08:	2b00      	cmp	r3, #0
20009b0a:	d002      	beq.n	20009b12 <HAL_EXTI_IRQHandler+0x52>
    {
      hexti->PendingCallback();
20009b0c:	687b      	ldr	r3, [r7, #4]
20009b0e:	685b      	ldr	r3, [r3, #4]
20009b10:	4798      	blx	r3
    }
  }
}
20009b12:	bf00      	nop
20009b14:	3718      	adds	r7, #24
20009b16:	46bd      	mov	sp, r7
20009b18:	bd80      	pop	{r7, pc}
20009b1a:	bf00      	nop
20009b1c:	58000088 	.word	0x58000088

20009b20 <HAL_EXTI_GetPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval 1 if interrupt is pending else 0.
  */
uint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
20009b20:	b580      	push	{r7, lr}
20009b22:	b088      	sub	sp, #32
20009b24:	af00      	add	r7, sp, #0
20009b26:	6078      	str	r0, [r7, #4]
20009b28:	6039      	str	r1, [r7, #0]
  uint32_t linepos;
  uint32_t maskline;
  uint32_t offset;

  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
20009b2a:	687b      	ldr	r3, [r7, #4]
20009b2c:	681a      	ldr	r2, [r3, #0]
20009b2e:	4b37      	ldr	r3, [pc, #220]	; (20009c0c <HAL_EXTI_GetPending+0xec>)
20009b30:	4013      	ands	r3, r2
20009b32:	2b00      	cmp	r3, #0
20009b34:	d129      	bne.n	20009b8a <HAL_EXTI_GetPending+0x6a>
20009b36:	687b      	ldr	r3, [r7, #4]
20009b38:	681b      	ldr	r3, [r3, #0]
20009b3a:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009b3e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20009b42:	d00d      	beq.n	20009b60 <HAL_EXTI_GetPending+0x40>
20009b44:	687b      	ldr	r3, [r7, #4]
20009b46:	681b      	ldr	r3, [r3, #0]
20009b48:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009b4c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20009b50:	d006      	beq.n	20009b60 <HAL_EXTI_GetPending+0x40>
20009b52:	687b      	ldr	r3, [r7, #4]
20009b54:	681b      	ldr	r3, [r3, #0]
20009b56:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009b5a:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
20009b5e:	d114      	bne.n	20009b8a <HAL_EXTI_GetPending+0x6a>
20009b60:	687b      	ldr	r3, [r7, #4]
20009b62:	681b      	ldr	r3, [r3, #0]
20009b64:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009b68:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
20009b6c:	d006      	beq.n	20009b7c <HAL_EXTI_GetPending+0x5c>
20009b6e:	687b      	ldr	r3, [r7, #4]
20009b70:	681b      	ldr	r3, [r3, #0]
20009b72:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009b76:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
20009b7a:	d106      	bne.n	20009b8a <HAL_EXTI_GetPending+0x6a>
20009b7c:	687b      	ldr	r3, [r7, #4]
20009b7e:	681a      	ldr	r2, [r3, #0]
20009b80:	4b23      	ldr	r3, [pc, #140]	; (20009c10 <HAL_EXTI_GetPending+0xf0>)
20009b82:	4013      	ands	r3, r2
20009b84:	4a23      	ldr	r2, [pc, #140]	; (20009c14 <HAL_EXTI_GetPending+0xf4>)
20009b86:	4293      	cmp	r3, r2
20009b88:	d904      	bls.n	20009b94 <HAL_EXTI_GetPending+0x74>
20009b8a:	f240 21fb 	movw	r1, #763	; 0x2fb
20009b8e:	4822      	ldr	r0, [pc, #136]	; (20009c18 <HAL_EXTI_GetPending+0xf8>)
20009b90:	f7f6 feb0 	bl	200008f4 <assert_failed>
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
20009b94:	687b      	ldr	r3, [r7, #4]
20009b96:	681b      	ldr	r3, [r3, #0]
20009b98:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20009b9c:	2b00      	cmp	r3, #0
20009b9e:	d104      	bne.n	20009baa <HAL_EXTI_GetPending+0x8a>
20009ba0:	f44f 713f 	mov.w	r1, #764	; 0x2fc
20009ba4:	481c      	ldr	r0, [pc, #112]	; (20009c18 <HAL_EXTI_GetPending+0xf8>)
20009ba6:	f7f6 fea5 	bl	200008f4 <assert_failed>
  assert_param(IS_EXTI_PENDING_EDGE(Edge));
20009baa:	683b      	ldr	r3, [r7, #0]
20009bac:	2b01      	cmp	r3, #1
20009bae:	d00a      	beq.n	20009bc6 <HAL_EXTI_GetPending+0xa6>
20009bb0:	683b      	ldr	r3, [r7, #0]
20009bb2:	2b02      	cmp	r3, #2
20009bb4:	d007      	beq.n	20009bc6 <HAL_EXTI_GetPending+0xa6>
20009bb6:	683b      	ldr	r3, [r7, #0]
20009bb8:	2b03      	cmp	r3, #3
20009bba:	d004      	beq.n	20009bc6 <HAL_EXTI_GetPending+0xa6>
20009bbc:	f240 21fd 	movw	r1, #765	; 0x2fd
20009bc0:	4815      	ldr	r0, [pc, #84]	; (20009c18 <HAL_EXTI_GetPending+0xf8>)
20009bc2:	f7f6 fe97 	bl	200008f4 <assert_failed>

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
20009bc6:	687b      	ldr	r3, [r7, #4]
20009bc8:	681b      	ldr	r3, [r3, #0]
20009bca:	0c1b      	lsrs	r3, r3, #16
20009bcc:	f003 0303 	and.w	r3, r3, #3
20009bd0:	61fb      	str	r3, [r7, #28]
  linepos = (hexti->Line & EXTI_PIN_MASK);
20009bd2:	687b      	ldr	r3, [r7, #4]
20009bd4:	681b      	ldr	r3, [r3, #0]
20009bd6:	f003 031f 	and.w	r3, r3, #31
20009bda:	61bb      	str	r3, [r7, #24]
  maskline = (1UL << linepos);
20009bdc:	2201      	movs	r2, #1
20009bde:	69bb      	ldr	r3, [r7, #24]
20009be0:	fa02 f303 	lsl.w	r3, r2, r3
20009be4:	617b      	str	r3, [r7, #20]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
20009be6:	69fb      	ldr	r3, [r7, #28]
20009be8:	011a      	lsls	r2, r3, #4
20009bea:	4b0c      	ldr	r3, [pc, #48]	; (20009c1c <HAL_EXTI_GetPending+0xfc>)
20009bec:	4413      	add	r3, r2
20009bee:	613b      	str	r3, [r7, #16]
#endif /* DUAL_CORE */

  /* return 1 if bit is set else 0 */
  regval = ((*regaddr & maskline) >> linepos);
20009bf0:	693b      	ldr	r3, [r7, #16]
20009bf2:	681a      	ldr	r2, [r3, #0]
20009bf4:	697b      	ldr	r3, [r7, #20]
20009bf6:	401a      	ands	r2, r3
20009bf8:	69bb      	ldr	r3, [r7, #24]
20009bfa:	fa22 f303 	lsr.w	r3, r2, r3
20009bfe:	60fb      	str	r3, [r7, #12]
  return regval;
20009c00:	68fb      	ldr	r3, [r7, #12]
}
20009c02:	4618      	mov	r0, r3
20009c04:	3720      	adds	r7, #32
20009c06:	46bd      	mov	sp, r7
20009c08:	bd80      	pop	{r7, pc}
20009c0a:	bf00      	nop
20009c0c:	e8ccffe0 	.word	0xe8ccffe0
20009c10:	0003001f 	.word	0x0003001f
20009c14:	00020017 	.word	0x00020017
20009c18:	2001c050 	.word	0x2001c050
20009c1c:	58000088 	.word	0x58000088

20009c20 <HAL_EXTI_ClearPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval None.
  */
void HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
20009c20:	b580      	push	{r7, lr}
20009c22:	b086      	sub	sp, #24
20009c24:	af00      	add	r7, sp, #0
20009c26:	6078      	str	r0, [r7, #4]
20009c28:	6039      	str	r1, [r7, #0]
  __IO uint32_t *regaddr;
  uint32_t maskline;
  uint32_t offset;

  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
20009c2a:	687b      	ldr	r3, [r7, #4]
20009c2c:	681a      	ldr	r2, [r3, #0]
20009c2e:	4b33      	ldr	r3, [pc, #204]	; (20009cfc <HAL_EXTI_ClearPending+0xdc>)
20009c30:	4013      	ands	r3, r2
20009c32:	2b00      	cmp	r3, #0
20009c34:	d129      	bne.n	20009c8a <HAL_EXTI_ClearPending+0x6a>
20009c36:	687b      	ldr	r3, [r7, #4]
20009c38:	681b      	ldr	r3, [r3, #0]
20009c3a:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009c3e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20009c42:	d00d      	beq.n	20009c60 <HAL_EXTI_ClearPending+0x40>
20009c44:	687b      	ldr	r3, [r7, #4]
20009c46:	681b      	ldr	r3, [r3, #0]
20009c48:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009c4c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20009c50:	d006      	beq.n	20009c60 <HAL_EXTI_ClearPending+0x40>
20009c52:	687b      	ldr	r3, [r7, #4]
20009c54:	681b      	ldr	r3, [r3, #0]
20009c56:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009c5a:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
20009c5e:	d114      	bne.n	20009c8a <HAL_EXTI_ClearPending+0x6a>
20009c60:	687b      	ldr	r3, [r7, #4]
20009c62:	681b      	ldr	r3, [r3, #0]
20009c64:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009c68:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
20009c6c:	d006      	beq.n	20009c7c <HAL_EXTI_ClearPending+0x5c>
20009c6e:	687b      	ldr	r3, [r7, #4]
20009c70:	681b      	ldr	r3, [r3, #0]
20009c72:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009c76:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
20009c7a:	d106      	bne.n	20009c8a <HAL_EXTI_ClearPending+0x6a>
20009c7c:	687b      	ldr	r3, [r7, #4]
20009c7e:	681a      	ldr	r2, [r3, #0]
20009c80:	4b1f      	ldr	r3, [pc, #124]	; (20009d00 <HAL_EXTI_ClearPending+0xe0>)
20009c82:	4013      	ands	r3, r2
20009c84:	4a1f      	ldr	r2, [pc, #124]	; (20009d04 <HAL_EXTI_ClearPending+0xe4>)
20009c86:	4293      	cmp	r3, r2
20009c88:	d904      	bls.n	20009c94 <HAL_EXTI_ClearPending+0x74>
20009c8a:	f240 3129 	movw	r1, #809	; 0x329
20009c8e:	481e      	ldr	r0, [pc, #120]	; (20009d08 <HAL_EXTI_ClearPending+0xe8>)
20009c90:	f7f6 fe30 	bl	200008f4 <assert_failed>
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
20009c94:	687b      	ldr	r3, [r7, #4]
20009c96:	681b      	ldr	r3, [r3, #0]
20009c98:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20009c9c:	2b00      	cmp	r3, #0
20009c9e:	d104      	bne.n	20009caa <HAL_EXTI_ClearPending+0x8a>
20009ca0:	f240 312a 	movw	r1, #810	; 0x32a
20009ca4:	4818      	ldr	r0, [pc, #96]	; (20009d08 <HAL_EXTI_ClearPending+0xe8>)
20009ca6:	f7f6 fe25 	bl	200008f4 <assert_failed>
  assert_param(IS_EXTI_PENDING_EDGE(Edge));
20009caa:	683b      	ldr	r3, [r7, #0]
20009cac:	2b01      	cmp	r3, #1
20009cae:	d00a      	beq.n	20009cc6 <HAL_EXTI_ClearPending+0xa6>
20009cb0:	683b      	ldr	r3, [r7, #0]
20009cb2:	2b02      	cmp	r3, #2
20009cb4:	d007      	beq.n	20009cc6 <HAL_EXTI_ClearPending+0xa6>
20009cb6:	683b      	ldr	r3, [r7, #0]
20009cb8:	2b03      	cmp	r3, #3
20009cba:	d004      	beq.n	20009cc6 <HAL_EXTI_ClearPending+0xa6>
20009cbc:	f240 312b 	movw	r1, #811	; 0x32b
20009cc0:	4811      	ldr	r0, [pc, #68]	; (20009d08 <HAL_EXTI_ClearPending+0xe8>)
20009cc2:	f7f6 fe17 	bl	200008f4 <assert_failed>

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
20009cc6:	687b      	ldr	r3, [r7, #4]
20009cc8:	681b      	ldr	r3, [r3, #0]
20009cca:	0c1b      	lsrs	r3, r3, #16
20009ccc:	f003 0303 	and.w	r3, r3, #3
20009cd0:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
20009cd2:	687b      	ldr	r3, [r7, #4]
20009cd4:	681b      	ldr	r3, [r3, #0]
20009cd6:	f003 031f 	and.w	r3, r3, #31
20009cda:	2201      	movs	r2, #1
20009cdc:	fa02 f303 	lsl.w	r3, r2, r3
20009ce0:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
20009ce2:	697b      	ldr	r3, [r7, #20]
20009ce4:	011a      	lsls	r2, r3, #4
20009ce6:	4b09      	ldr	r3, [pc, #36]	; (20009d0c <HAL_EXTI_ClearPending+0xec>)
20009ce8:	4413      	add	r3, r2
20009cea:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Clear Pending bit */
  *regaddr =  maskline;
20009cec:	68fb      	ldr	r3, [r7, #12]
20009cee:	693a      	ldr	r2, [r7, #16]
20009cf0:	601a      	str	r2, [r3, #0]
}
20009cf2:	bf00      	nop
20009cf4:	3718      	adds	r7, #24
20009cf6:	46bd      	mov	sp, r7
20009cf8:	bd80      	pop	{r7, pc}
20009cfa:	bf00      	nop
20009cfc:	e8ccffe0 	.word	0xe8ccffe0
20009d00:	0003001f 	.word	0x0003001f
20009d04:	00020017 	.word	0x00020017
20009d08:	2001c050 	.word	0x2001c050
20009d0c:	58000088 	.word	0x58000088

20009d10 <HAL_EXTI_GenerateSWI>:
  * @brief  Generate a software interrupt for a dedicated line.
  * @param  hexti Exti handle.
  * @retval None.
  */
void HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)
{
20009d10:	b580      	push	{r7, lr}
20009d12:	b086      	sub	sp, #24
20009d14:	af00      	add	r7, sp, #0
20009d16:	6078      	str	r0, [r7, #4]
  __IO uint32_t *regaddr;
  uint32_t maskline;
  uint32_t offset;

  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
20009d18:	687b      	ldr	r3, [r7, #4]
20009d1a:	681a      	ldr	r2, [r3, #0]
20009d1c:	4b2b      	ldr	r3, [pc, #172]	; (20009dcc <HAL_EXTI_GenerateSWI+0xbc>)
20009d1e:	4013      	ands	r3, r2
20009d20:	2b00      	cmp	r3, #0
20009d22:	d129      	bne.n	20009d78 <HAL_EXTI_GenerateSWI+0x68>
20009d24:	687b      	ldr	r3, [r7, #4]
20009d26:	681b      	ldr	r3, [r3, #0]
20009d28:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009d2c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20009d30:	d00d      	beq.n	20009d4e <HAL_EXTI_GenerateSWI+0x3e>
20009d32:	687b      	ldr	r3, [r7, #4]
20009d34:	681b      	ldr	r3, [r3, #0]
20009d36:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009d3a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20009d3e:	d006      	beq.n	20009d4e <HAL_EXTI_GenerateSWI+0x3e>
20009d40:	687b      	ldr	r3, [r7, #4]
20009d42:	681b      	ldr	r3, [r3, #0]
20009d44:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
20009d48:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
20009d4c:	d114      	bne.n	20009d78 <HAL_EXTI_GenerateSWI+0x68>
20009d4e:	687b      	ldr	r3, [r7, #4]
20009d50:	681b      	ldr	r3, [r3, #0]
20009d52:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009d56:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
20009d5a:	d006      	beq.n	20009d6a <HAL_EXTI_GenerateSWI+0x5a>
20009d5c:	687b      	ldr	r3, [r7, #4]
20009d5e:	681b      	ldr	r3, [r3, #0]
20009d60:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009d64:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
20009d68:	d106      	bne.n	20009d78 <HAL_EXTI_GenerateSWI+0x68>
20009d6a:	687b      	ldr	r3, [r7, #4]
20009d6c:	681a      	ldr	r2, [r3, #0]
20009d6e:	4b18      	ldr	r3, [pc, #96]	; (20009dd0 <HAL_EXTI_GenerateSWI+0xc0>)
20009d70:	4013      	ands	r3, r2
20009d72:	4a18      	ldr	r2, [pc, #96]	; (20009dd4 <HAL_EXTI_GenerateSWI+0xc4>)
20009d74:	4293      	cmp	r3, r2
20009d76:	d904      	bls.n	20009d82 <HAL_EXTI_GenerateSWI+0x72>
20009d78:	f44f 7154 	mov.w	r1, #848	; 0x350
20009d7c:	4816      	ldr	r0, [pc, #88]	; (20009dd8 <HAL_EXTI_GenerateSWI+0xc8>)
20009d7e:	f7f6 fdb9 	bl	200008f4 <assert_failed>
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
20009d82:	687b      	ldr	r3, [r7, #4]
20009d84:	681b      	ldr	r3, [r3, #0]
20009d86:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20009d8a:	2b00      	cmp	r3, #0
20009d8c:	d104      	bne.n	20009d98 <HAL_EXTI_GenerateSWI+0x88>
20009d8e:	f240 3151 	movw	r1, #849	; 0x351
20009d92:	4811      	ldr	r0, [pc, #68]	; (20009dd8 <HAL_EXTI_GenerateSWI+0xc8>)
20009d94:	f7f6 fdae 	bl	200008f4 <assert_failed>

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
20009d98:	687b      	ldr	r3, [r7, #4]
20009d9a:	681b      	ldr	r3, [r3, #0]
20009d9c:	0c1b      	lsrs	r3, r3, #16
20009d9e:	f003 0303 	and.w	r3, r3, #3
20009da2:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
20009da4:	687b      	ldr	r3, [r7, #4]
20009da6:	681b      	ldr	r3, [r3, #0]
20009da8:	f003 031f 	and.w	r3, r3, #31
20009dac:	2201      	movs	r2, #1
20009dae:	fa02 f303 	lsl.w	r3, r2, r3
20009db2:	613b      	str	r3, [r7, #16]

  regaddr = (__IO uint32_t *)(&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));
20009db4:	697b      	ldr	r3, [r7, #20]
20009db6:	015a      	lsls	r2, r3, #5
20009db8:	4b08      	ldr	r3, [pc, #32]	; (20009ddc <HAL_EXTI_GenerateSWI+0xcc>)
20009dba:	4413      	add	r3, r2
20009dbc:	60fb      	str	r3, [r7, #12]
  *regaddr = maskline;
20009dbe:	68fb      	ldr	r3, [r7, #12]
20009dc0:	693a      	ldr	r2, [r7, #16]
20009dc2:	601a      	str	r2, [r3, #0]
}
20009dc4:	bf00      	nop
20009dc6:	3718      	adds	r7, #24
20009dc8:	46bd      	mov	sp, r7
20009dca:	bd80      	pop	{r7, pc}
20009dcc:	e8ccffe0 	.word	0xe8ccffe0
20009dd0:	0003001f 	.word	0x0003001f
20009dd4:	00020017 	.word	0x00020017
20009dd8:	2001c050 	.word	0x2001c050
20009ddc:	58000008 	.word	0x58000008

20009de0 <HAL_FLASH_Program>:
  * @param  DataAddress specifies the address of data to be programmed
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
{
20009de0:	b580      	push	{r7, lr}
20009de2:	b08a      	sub	sp, #40	; 0x28
20009de4:	af00      	add	r7, sp, #0
20009de6:	60f8      	str	r0, [r7, #12]
20009de8:	60b9      	str	r1, [r7, #8]
20009dea:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  __IO uint32_t *dest_addr = (__IO uint32_t *)FlashAddress;
20009dec:	68bb      	ldr	r3, [r7, #8]
20009dee:	623b      	str	r3, [r7, #32]
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
20009df0:	687b      	ldr	r3, [r7, #4]
20009df2:	61fb      	str	r3, [r7, #28]
  uint32_t bank;
  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
20009df4:	2308      	movs	r3, #8
20009df6:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
20009df8:	68fb      	ldr	r3, [r7, #12]
20009dfa:	2b01      	cmp	r3, #1
20009dfc:	d003      	beq.n	20009e06 <HAL_FLASH_Program+0x26>
20009dfe:	219b      	movs	r1, #155	; 0x9b
20009e00:	4844      	ldr	r0, [pc, #272]	; (20009f14 <HAL_FLASH_Program+0x134>)
20009e02:	f7f6 fd77 	bl	200008f4 <assert_failed>
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
20009e06:	68bb      	ldr	r3, [r7, #8]
20009e08:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
20009e0c:	d303      	bcc.n	20009e16 <HAL_FLASH_Program+0x36>
20009e0e:	68bb      	ldr	r3, [r7, #8]
20009e10:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
20009e14:	d30b      	bcc.n	20009e2e <HAL_FLASH_Program+0x4e>
20009e16:	68bb      	ldr	r3, [r7, #8]
20009e18:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
20009e1c:	d303      	bcc.n	20009e26 <HAL_FLASH_Program+0x46>
20009e1e:	68bb      	ldr	r3, [r7, #8]
20009e20:	4a3d      	ldr	r2, [pc, #244]	; (20009f18 <HAL_FLASH_Program+0x138>)
20009e22:	4293      	cmp	r3, r2
20009e24:	d903      	bls.n	20009e2e <HAL_FLASH_Program+0x4e>
20009e26:	219c      	movs	r1, #156	; 0x9c
20009e28:	483a      	ldr	r0, [pc, #232]	; (20009f14 <HAL_FLASH_Program+0x134>)
20009e2a:	f7f6 fd63 	bl	200008f4 <assert_failed>

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20009e2e:	4b3b      	ldr	r3, [pc, #236]	; (20009f1c <HAL_FLASH_Program+0x13c>)
20009e30:	7d1b      	ldrb	r3, [r3, #20]
20009e32:	2b01      	cmp	r3, #1
20009e34:	d101      	bne.n	20009e3a <HAL_FLASH_Program+0x5a>
20009e36:	2302      	movs	r3, #2
20009e38:	e067      	b.n	20009f0a <HAL_FLASH_Program+0x12a>
20009e3a:	4b38      	ldr	r3, [pc, #224]	; (20009f1c <HAL_FLASH_Program+0x13c>)
20009e3c:	2201      	movs	r2, #1
20009e3e:	751a      	strb	r2, [r3, #20]

#if defined (FLASH_OPTCR_PG_OTP)
  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
#else
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
20009e40:	68bb      	ldr	r3, [r7, #8]
20009e42:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
20009e46:	d306      	bcc.n	20009e56 <HAL_FLASH_Program+0x76>
20009e48:	68bb      	ldr	r3, [r7, #8]
20009e4a:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
20009e4e:	d202      	bcs.n	20009e56 <HAL_FLASH_Program+0x76>
#endif /* FLASH_OPTCR_PG_OTP */
  {
    bank = FLASH_BANK_1;
20009e50:	2301      	movs	r3, #1
20009e52:	61bb      	str	r3, [r7, #24]
20009e54:	e001      	b.n	20009e5a <HAL_FLASH_Program+0x7a>
  }
  else
  {
    bank = FLASH_BANK_2;
20009e56:	2302      	movs	r3, #2
20009e58:	61bb      	str	r3, [r7, #24]
  }

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
20009e5a:	4b30      	ldr	r3, [pc, #192]	; (20009f1c <HAL_FLASH_Program+0x13c>)
20009e5c:	2200      	movs	r2, #0
20009e5e:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
20009e60:	69b9      	ldr	r1, [r7, #24]
20009e62:	f24c 3050 	movw	r0, #50000	; 0xc350
20009e66:	f000 fb45 	bl	2000a4f4 <FLASH_WaitForLastOperation>
20009e6a:	4603      	mov	r3, r0
20009e6c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  if(status == HAL_OK)
20009e70:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
20009e74:	2b00      	cmp	r3, #0
20009e76:	d143      	bne.n	20009f00 <HAL_FLASH_Program+0x120>
  {
    if(bank == FLASH_BANK_1)
20009e78:	69bb      	ldr	r3, [r7, #24]
20009e7a:	2b01      	cmp	r3, #1
20009e7c:	d106      	bne.n	20009e8c <HAL_FLASH_Program+0xac>
      }
      else
#endif /* FLASH_OPTCR_PG_OTP */
      {
        /* Set PG bit */
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
20009e7e:	4b28      	ldr	r3, [pc, #160]	; (20009f20 <HAL_FLASH_Program+0x140>)
20009e80:	68db      	ldr	r3, [r3, #12]
20009e82:	4a27      	ldr	r2, [pc, #156]	; (20009f20 <HAL_FLASH_Program+0x140>)
20009e84:	f043 0302 	orr.w	r3, r3, #2
20009e88:	60d3      	str	r3, [r2, #12]
20009e8a:	e007      	b.n	20009e9c <HAL_FLASH_Program+0xbc>
      }
    }
    else
    {
      /* Set PG bit */
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
20009e8c:	4b24      	ldr	r3, [pc, #144]	; (20009f20 <HAL_FLASH_Program+0x140>)
20009e8e:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
20009e92:	4a23      	ldr	r2, [pc, #140]	; (20009f20 <HAL_FLASH_Program+0x140>)
20009e94:	f043 0302 	orr.w	r3, r3, #2
20009e98:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
20009e9c:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
20009ea0:	f3bf 8f4f 	dsb	sy
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Program the flash word */
      do
      {
        *dest_addr = *src_addr;
20009ea4:	69fb      	ldr	r3, [r7, #28]
20009ea6:	681a      	ldr	r2, [r3, #0]
20009ea8:	6a3b      	ldr	r3, [r7, #32]
20009eaa:	601a      	str	r2, [r3, #0]
        dest_addr++;
20009eac:	6a3b      	ldr	r3, [r7, #32]
20009eae:	3304      	adds	r3, #4
20009eb0:	623b      	str	r3, [r7, #32]
        src_addr++;
20009eb2:	69fb      	ldr	r3, [r7, #28]
20009eb4:	3304      	adds	r3, #4
20009eb6:	61fb      	str	r3, [r7, #28]
        row_index--;
20009eb8:	7dfb      	ldrb	r3, [r7, #23]
20009eba:	3b01      	subs	r3, #1
20009ebc:	75fb      	strb	r3, [r7, #23]
     } while (row_index != 0U);
20009ebe:	7dfb      	ldrb	r3, [r7, #23]
20009ec0:	2b00      	cmp	r3, #0
20009ec2:	d1ef      	bne.n	20009ea4 <HAL_FLASH_Program+0xc4>
  __ASM volatile ("isb 0xF":::"memory");
20009ec4:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
20009ec8:	f3bf 8f4f 	dsb	sy

    __ISB();
    __DSB();

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
20009ecc:	69b9      	ldr	r1, [r7, #24]
20009ece:	f24c 3050 	movw	r0, #50000	; 0xc350
20009ed2:	f000 fb0f 	bl	2000a4f4 <FLASH_WaitForLastOperation>
20009ed6:	4603      	mov	r3, r0
20009ed8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
      CLEAR_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);
    }
    else
#endif /* FLASH_OPTCR_PG_OTP */
    {
      if(bank == FLASH_BANK_1)
20009edc:	69bb      	ldr	r3, [r7, #24]
20009ede:	2b01      	cmp	r3, #1
20009ee0:	d106      	bne.n	20009ef0 <HAL_FLASH_Program+0x110>
      {
        /* If the program operation is completed, disable the PG */
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
20009ee2:	4b0f      	ldr	r3, [pc, #60]	; (20009f20 <HAL_FLASH_Program+0x140>)
20009ee4:	68db      	ldr	r3, [r3, #12]
20009ee6:	4a0e      	ldr	r2, [pc, #56]	; (20009f20 <HAL_FLASH_Program+0x140>)
20009ee8:	f023 0302 	bic.w	r3, r3, #2
20009eec:	60d3      	str	r3, [r2, #12]
20009eee:	e007      	b.n	20009f00 <HAL_FLASH_Program+0x120>
      }
      else
      {
        /* If the program operation is completed, disable the PG */
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
20009ef0:	4b0b      	ldr	r3, [pc, #44]	; (20009f20 <HAL_FLASH_Program+0x140>)
20009ef2:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
20009ef6:	4a0a      	ldr	r2, [pc, #40]	; (20009f20 <HAL_FLASH_Program+0x140>)
20009ef8:	f023 0302 	bic.w	r3, r3, #2
20009efc:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
20009f00:	4b06      	ldr	r3, [pc, #24]	; (20009f1c <HAL_FLASH_Program+0x13c>)
20009f02:	2200      	movs	r2, #0
20009f04:	751a      	strb	r2, [r3, #20]

  return status;
20009f06:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
20009f0a:	4618      	mov	r0, r3
20009f0c:	3728      	adds	r7, #40	; 0x28
20009f0e:	46bd      	mov	sp, r7
20009f10:	bd80      	pop	{r7, pc}
20009f12:	bf00      	nop
20009f14:	2001c08c 	.word	0x2001c08c
20009f18:	0801ffff 	.word	0x0801ffff
20009f1c:	2001ca60 	.word	0x2001ca60
20009f20:	52002000 	.word	0x52002000

20009f24 <HAL_FLASH_Program_IT>:
  * @param  DataAddress specifies the address of data (256 bits) to be programmed
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
{
20009f24:	b580      	push	{r7, lr}
20009f26:	b088      	sub	sp, #32
20009f28:	af00      	add	r7, sp, #0
20009f2a:	60f8      	str	r0, [r7, #12]
20009f2c:	60b9      	str	r1, [r7, #8]
20009f2e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  __IO uint32_t *dest_addr = (__IO uint32_t*)FlashAddress;
20009f30:	68bb      	ldr	r3, [r7, #8]
20009f32:	61fb      	str	r3, [r7, #28]
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
20009f34:	687b      	ldr	r3, [r7, #4]
20009f36:	61bb      	str	r3, [r7, #24]
  uint32_t bank;
  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
20009f38:	2308      	movs	r3, #8
20009f3a:	74fb      	strb	r3, [r7, #19]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
20009f3c:	68fb      	ldr	r3, [r7, #12]
20009f3e:	2b01      	cmp	r3, #1
20009f40:	d004      	beq.n	20009f4c <HAL_FLASH_Program_IT+0x28>
20009f42:	f240 1115 	movw	r1, #277	; 0x115
20009f46:	4842      	ldr	r0, [pc, #264]	; (2000a050 <HAL_FLASH_Program_IT+0x12c>)
20009f48:	f7f6 fcd4 	bl	200008f4 <assert_failed>
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
20009f4c:	68bb      	ldr	r3, [r7, #8]
20009f4e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
20009f52:	d303      	bcc.n	20009f5c <HAL_FLASH_Program_IT+0x38>
20009f54:	68bb      	ldr	r3, [r7, #8]
20009f56:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
20009f5a:	d30c      	bcc.n	20009f76 <HAL_FLASH_Program_IT+0x52>
20009f5c:	68bb      	ldr	r3, [r7, #8]
20009f5e:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
20009f62:	d303      	bcc.n	20009f6c <HAL_FLASH_Program_IT+0x48>
20009f64:	68bb      	ldr	r3, [r7, #8]
20009f66:	4a3b      	ldr	r2, [pc, #236]	; (2000a054 <HAL_FLASH_Program_IT+0x130>)
20009f68:	4293      	cmp	r3, r2
20009f6a:	d904      	bls.n	20009f76 <HAL_FLASH_Program_IT+0x52>
20009f6c:	f44f 718b 	mov.w	r1, #278	; 0x116
20009f70:	4837      	ldr	r0, [pc, #220]	; (2000a050 <HAL_FLASH_Program_IT+0x12c>)
20009f72:	f7f6 fcbf 	bl	200008f4 <assert_failed>

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20009f76:	4b38      	ldr	r3, [pc, #224]	; (2000a058 <HAL_FLASH_Program_IT+0x134>)
20009f78:	7d1b      	ldrb	r3, [r3, #20]
20009f7a:	2b01      	cmp	r3, #1
20009f7c:	d101      	bne.n	20009f82 <HAL_FLASH_Program_IT+0x5e>
20009f7e:	2302      	movs	r3, #2
20009f80:	e062      	b.n	2000a048 <HAL_FLASH_Program_IT+0x124>
20009f82:	4b35      	ldr	r3, [pc, #212]	; (2000a058 <HAL_FLASH_Program_IT+0x134>)
20009f84:	2201      	movs	r2, #1
20009f86:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
20009f88:	4b33      	ldr	r3, [pc, #204]	; (2000a058 <HAL_FLASH_Program_IT+0x134>)
20009f8a:	2200      	movs	r2, #0
20009f8c:	619a      	str	r2, [r3, #24]

#if defined (FLASH_OPTCR_PG_OTP)
  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
#else
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
20009f8e:	68bb      	ldr	r3, [r7, #8]
20009f90:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
20009f94:	d306      	bcc.n	20009fa4 <HAL_FLASH_Program_IT+0x80>
20009f96:	68bb      	ldr	r3, [r7, #8]
20009f98:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
20009f9c:	d202      	bcs.n	20009fa4 <HAL_FLASH_Program_IT+0x80>
#endif /* FLASH_OPTCR_PG_OTP */
  {
    bank = FLASH_BANK_1;
20009f9e:	2301      	movs	r3, #1
20009fa0:	617b      	str	r3, [r7, #20]
20009fa2:	e001      	b.n	20009fa8 <HAL_FLASH_Program_IT+0x84>
  }
  else
  {
    bank = FLASH_BANK_2;
20009fa4:	2302      	movs	r3, #2
20009fa6:	617b      	str	r3, [r7, #20]
  }

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
20009fa8:	6979      	ldr	r1, [r7, #20]
20009faa:	f24c 3050 	movw	r0, #50000	; 0xc350
20009fae:	f000 faa1 	bl	2000a4f4 <FLASH_WaitForLastOperation>
20009fb2:	4603      	mov	r3, r0
20009fb4:	74bb      	strb	r3, [r7, #18]

  if (status != HAL_OK)
20009fb6:	7cbb      	ldrb	r3, [r7, #18]
20009fb8:	2b00      	cmp	r3, #0
20009fba:	d003      	beq.n	20009fc4 <HAL_FLASH_Program_IT+0xa0>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
20009fbc:	4b26      	ldr	r3, [pc, #152]	; (2000a058 <HAL_FLASH_Program_IT+0x134>)
20009fbe:	2200      	movs	r2, #0
20009fc0:	751a      	strb	r2, [r3, #20]
20009fc2:	e040      	b.n	2000a046 <HAL_FLASH_Program_IT+0x122>
  }
  else
  {
    pFlash.Address = FlashAddress;
20009fc4:	4a24      	ldr	r2, [pc, #144]	; (2000a058 <HAL_FLASH_Program_IT+0x134>)
20009fc6:	68bb      	ldr	r3, [r7, #8]
20009fc8:	6113      	str	r3, [r2, #16]

    if(bank == FLASH_BANK_1)
20009fca:	697b      	ldr	r3, [r7, #20]
20009fcc:	2b01      	cmp	r3, #1
20009fce:	d10f      	bne.n	20009ff0 <HAL_FLASH_Program_IT+0xcc>
    {
      /* Set internal variables used by the IRQ handler */
      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK1;
20009fd0:	4b21      	ldr	r3, [pc, #132]	; (2000a058 <HAL_FLASH_Program_IT+0x134>)
20009fd2:	2203      	movs	r2, #3
20009fd4:	701a      	strb	r2, [r3, #0]
      }
      else
#endif /* FLASH_OPTCR_PG_OTP */
      {
        /* Set PG bit */
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
20009fd6:	4b21      	ldr	r3, [pc, #132]	; (2000a05c <HAL_FLASH_Program_IT+0x138>)
20009fd8:	68db      	ldr	r3, [r3, #12]
20009fda:	4a20      	ldr	r2, [pc, #128]	; (2000a05c <HAL_FLASH_Program_IT+0x138>)
20009fdc:	f043 0302 	orr.w	r3, r3, #2
20009fe0:	60d3      	str	r3, [r2, #12]
      }

      /* Enable End of Operation and Error interrupts for Bank 1 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
20009fe2:	4b1e      	ldr	r3, [pc, #120]	; (2000a05c <HAL_FLASH_Program_IT+0x138>)
20009fe4:	68db      	ldr	r3, [r3, #12]
20009fe6:	4a1d      	ldr	r2, [pc, #116]	; (2000a05c <HAL_FLASH_Program_IT+0x138>)
20009fe8:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
20009fec:	60d3      	str	r3, [r2, #12]
20009fee:	e012      	b.n	2000a016 <HAL_FLASH_Program_IT+0xf2>
#endif /* FLASH_CR_OPERRIE */
    }
    else
    {
      /* Set internal variables used by the IRQ handler */
      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK2;
20009ff0:	4b19      	ldr	r3, [pc, #100]	; (2000a058 <HAL_FLASH_Program_IT+0x134>)
20009ff2:	2206      	movs	r2, #6
20009ff4:	701a      	strb	r2, [r3, #0]

      /* Set PG bit */
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
20009ff6:	4b19      	ldr	r3, [pc, #100]	; (2000a05c <HAL_FLASH_Program_IT+0x138>)
20009ff8:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
20009ffc:	4a17      	ldr	r2, [pc, #92]	; (2000a05c <HAL_FLASH_Program_IT+0x138>)
20009ffe:	f043 0302 	orr.w	r3, r3, #2
2000a002:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

      /* Enable End of Operation and Error interrupts for Bank2 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
2000a006:	4b15      	ldr	r3, [pc, #84]	; (2000a05c <HAL_FLASH_Program_IT+0x138>)
2000a008:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000a00c:	4a13      	ldr	r2, [pc, #76]	; (2000a05c <HAL_FLASH_Program_IT+0x138>)
2000a00e:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
2000a012:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
  __ASM volatile ("isb 0xF":::"memory");
2000a016:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
2000a01a:	f3bf 8f4f 	dsb	sy
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Program the flash word */
      do
      {
        *dest_addr = *src_addr;
2000a01e:	69bb      	ldr	r3, [r7, #24]
2000a020:	681a      	ldr	r2, [r3, #0]
2000a022:	69fb      	ldr	r3, [r7, #28]
2000a024:	601a      	str	r2, [r3, #0]
        dest_addr++;
2000a026:	69fb      	ldr	r3, [r7, #28]
2000a028:	3304      	adds	r3, #4
2000a02a:	61fb      	str	r3, [r7, #28]
        src_addr++;
2000a02c:	69bb      	ldr	r3, [r7, #24]
2000a02e:	3304      	adds	r3, #4
2000a030:	61bb      	str	r3, [r7, #24]
        row_index--;
2000a032:	7cfb      	ldrb	r3, [r7, #19]
2000a034:	3b01      	subs	r3, #1
2000a036:	74fb      	strb	r3, [r7, #19]
      } while (row_index != 0U);
2000a038:	7cfb      	ldrb	r3, [r7, #19]
2000a03a:	2b00      	cmp	r3, #0
2000a03c:	d1ef      	bne.n	2000a01e <HAL_FLASH_Program_IT+0xfa>
  __ASM volatile ("isb 0xF":::"memory");
2000a03e:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
2000a042:	f3bf 8f4f 	dsb	sy

    __ISB();
    __DSB();
  }

  return status;
2000a046:	7cbb      	ldrb	r3, [r7, #18]
}
2000a048:	4618      	mov	r0, r3
2000a04a:	3720      	adds	r7, #32
2000a04c:	46bd      	mov	sp, r7
2000a04e:	bd80      	pop	{r7, pc}
2000a050:	2001c08c 	.word	0x2001c08c
2000a054:	0801ffff 	.word	0x0801ffff
2000a058:	2001ca60 	.word	0x2001ca60
2000a05c:	52002000 	.word	0x52002000

2000a060 <HAL_FLASH_IRQHandler>:
/**
  * @brief This function handles FLASH interrupt request.
  * @retval None
  */
void HAL_FLASH_IRQHandler(void)
{
2000a060:	b580      	push	{r7, lr}
2000a062:	b084      	sub	sp, #16
2000a064:	af00      	add	r7, sp, #0
  uint32_t temp;
  uint32_t errorflag;
  FLASH_ProcedureTypeDef procedure;

  /* Check FLASH Bank1 End of Operation flag  */
  if(__HAL_FLASH_GET_FLAG_BANK1(FLASH_SR_EOP) != RESET)
2000a066:	4b95      	ldr	r3, [pc, #596]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a068:	691b      	ldr	r3, [r3, #16]
2000a06a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000a06e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000a072:	d15c      	bne.n	2000a12e <HAL_FLASH_IRQHandler+0xce>
  {
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK1)
2000a074:	4b92      	ldr	r3, [pc, #584]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a076:	781b      	ldrb	r3, [r3, #0]
2000a078:	b2db      	uxtb	r3, r3
2000a07a:	2b01      	cmp	r3, #1
2000a07c:	d132      	bne.n	2000a0e4 <HAL_FLASH_IRQHandler+0x84>
    {
      /* Nb of sector to erased can be decreased */
      pFlash.NbSectorsToErase--;
2000a07e:	4b90      	ldr	r3, [pc, #576]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a080:	685b      	ldr	r3, [r3, #4]
2000a082:	3b01      	subs	r3, #1
2000a084:	4a8e      	ldr	r2, [pc, #568]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a086:	6053      	str	r3, [r2, #4]

      /* Check if there are still sectors to erase */
      if(pFlash.NbSectorsToErase != 0U)
2000a088:	4b8d      	ldr	r3, [pc, #564]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a08a:	685b      	ldr	r3, [r3, #4]
2000a08c:	2b00      	cmp	r3, #0
2000a08e:	d018      	beq.n	2000a0c2 <HAL_FLASH_IRQHandler+0x62>
      {
        /* Indicate user which sector has been erased */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
2000a090:	4b8b      	ldr	r3, [pc, #556]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a092:	68db      	ldr	r3, [r3, #12]
2000a094:	4618      	mov	r0, r3
2000a096:	f000 f93d 	bl	2000a314 <HAL_FLASH_EndOfOperationCallback>

        /* Clear bank 1 End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
2000a09a:	4b88      	ldr	r3, [pc, #544]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a09c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000a0a0:	615a      	str	r2, [r3, #20]

        /* Increment sector number */
        pFlash.Sector++;
2000a0a2:	4b87      	ldr	r3, [pc, #540]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a0a4:	68db      	ldr	r3, [r3, #12]
2000a0a6:	3301      	adds	r3, #1
2000a0a8:	4a85      	ldr	r2, [pc, #532]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a0aa:	60d3      	str	r3, [r2, #12]
        temp = pFlash.Sector;
2000a0ac:	4b84      	ldr	r3, [pc, #528]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a0ae:	68db      	ldr	r3, [r3, #12]
2000a0b0:	60fb      	str	r3, [r7, #12]
        FLASH_Erase_Sector(temp, FLASH_BANK_1, pFlash.VoltageForErase);
2000a0b2:	4b83      	ldr	r3, [pc, #524]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a0b4:	689b      	ldr	r3, [r3, #8]
2000a0b6:	461a      	mov	r2, r3
2000a0b8:	2101      	movs	r1, #1
2000a0ba:	68f8      	ldr	r0, [r7, #12]
2000a0bc:	f001 f864 	bl	2000b188 <FLASH_Erase_Sector>
2000a0c0:	e035      	b.n	2000a12e <HAL_FLASH_IRQHandler+0xce>
      }
      else
      {
        /* No more sectors to Erase, user callback can be called */
        /* Reset Sector and stop Erase sectors procedure */
        pFlash.Sector = 0xFFFFFFFFU;
2000a0c2:	4b7f      	ldr	r3, [pc, #508]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a0c4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
2000a0c8:	60da      	str	r2, [r3, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2000a0ca:	4b7d      	ldr	r3, [pc, #500]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a0cc:	2200      	movs	r2, #0
2000a0ce:	701a      	strb	r2, [r3, #0]

        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
2000a0d0:	4b7b      	ldr	r3, [pc, #492]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a0d2:	68db      	ldr	r3, [r3, #12]
2000a0d4:	4618      	mov	r0, r3
2000a0d6:	f000 f91d 	bl	2000a314 <HAL_FLASH_EndOfOperationCallback>

        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
2000a0da:	4b78      	ldr	r3, [pc, #480]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a0dc:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000a0e0:	615a      	str	r2, [r3, #20]
2000a0e2:	e024      	b.n	2000a12e <HAL_FLASH_IRQHandler+0xce>
      }
    }
    else
    {
      procedure = pFlash.ProcedureOnGoing;
2000a0e4:	4b76      	ldr	r3, [pc, #472]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a0e6:	781b      	ldrb	r3, [r3, #0]
2000a0e8:	72fb      	strb	r3, [r7, #11]

      if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
2000a0ea:	7afb      	ldrb	r3, [r7, #11]
2000a0ec:	2b02      	cmp	r3, #2
2000a0ee:	d002      	beq.n	2000a0f6 <HAL_FLASH_IRQHandler+0x96>
2000a0f0:	7afb      	ldrb	r3, [r7, #11]
2000a0f2:	2b07      	cmp	r3, #7
2000a0f4:	d103      	bne.n	2000a0fe <HAL_FLASH_IRQHandler+0x9e>
      {
        /* MassErase ended. Return the selected bank */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_1);
2000a0f6:	2001      	movs	r0, #1
2000a0f8:	f000 f90c 	bl	2000a314 <HAL_FLASH_EndOfOperationCallback>
2000a0fc:	e007      	b.n	2000a10e <HAL_FLASH_IRQHandler+0xae>
      }
      else if(procedure == FLASH_PROC_PROGRAM_BANK1)
2000a0fe:	7afb      	ldrb	r3, [r7, #11]
2000a100:	2b03      	cmp	r3, #3
2000a102:	d104      	bne.n	2000a10e <HAL_FLASH_IRQHandler+0xae>
      {
        /* Program ended. Return the selected address */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
2000a104:	4b6e      	ldr	r3, [pc, #440]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a106:	691b      	ldr	r3, [r3, #16]
2000a108:	4618      	mov	r0, r3
2000a10a:	f000 f903 	bl	2000a314 <HAL_FLASH_EndOfOperationCallback>
      else
      {
        /* Nothing to do */
      }

      if((procedure != FLASH_PROC_SECTERASE_BANK2) && \
2000a10e:	7afb      	ldrb	r3, [r7, #11]
2000a110:	2b04      	cmp	r3, #4
2000a112:	d00c      	beq.n	2000a12e <HAL_FLASH_IRQHandler+0xce>
2000a114:	7afb      	ldrb	r3, [r7, #11]
2000a116:	2b05      	cmp	r3, #5
2000a118:	d009      	beq.n	2000a12e <HAL_FLASH_IRQHandler+0xce>
         (procedure != FLASH_PROC_MASSERASE_BANK2) && \
2000a11a:	7afb      	ldrb	r3, [r7, #11]
2000a11c:	2b06      	cmp	r3, #6
2000a11e:	d006      	beq.n	2000a12e <HAL_FLASH_IRQHandler+0xce>
         (procedure != FLASH_PROC_PROGRAM_BANK2))
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2000a120:	4b67      	ldr	r3, [pc, #412]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a122:	2200      	movs	r2, #0
2000a124:	701a      	strb	r2, [r3, #0]
        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
2000a126:	4b65      	ldr	r3, [pc, #404]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a128:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000a12c:	615a      	str	r2, [r3, #20]
      }
    }
  }

  /* Check FLASH Bank2 End of Operation flag  */
  if(__HAL_FLASH_GET_FLAG_BANK2(FLASH_SR_EOP) != RESET)
2000a12e:	4b63      	ldr	r3, [pc, #396]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a130:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
2000a134:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000a138:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000a13c:	d15f      	bne.n	2000a1fe <HAL_FLASH_IRQHandler+0x19e>
  {
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK2)
2000a13e:	4b60      	ldr	r3, [pc, #384]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a140:	781b      	ldrb	r3, [r3, #0]
2000a142:	b2db      	uxtb	r3, r3
2000a144:	2b04      	cmp	r3, #4
2000a146:	d134      	bne.n	2000a1b2 <HAL_FLASH_IRQHandler+0x152>
    {
      /*Nb of sector to erased can be decreased*/
      pFlash.NbSectorsToErase--;
2000a148:	4b5d      	ldr	r3, [pc, #372]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a14a:	685b      	ldr	r3, [r3, #4]
2000a14c:	3b01      	subs	r3, #1
2000a14e:	4a5c      	ldr	r2, [pc, #368]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a150:	6053      	str	r3, [r2, #4]

      /* Check if there are still sectors to erase*/
      if(pFlash.NbSectorsToErase != 0U)
2000a152:	4b5b      	ldr	r3, [pc, #364]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a154:	685b      	ldr	r3, [r3, #4]
2000a156:	2b00      	cmp	r3, #0
2000a158:	d019      	beq.n	2000a18e <HAL_FLASH_IRQHandler+0x12e>
      {
        /*Indicate user which sector has been erased*/
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
2000a15a:	4b59      	ldr	r3, [pc, #356]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a15c:	68db      	ldr	r3, [r3, #12]
2000a15e:	4618      	mov	r0, r3
2000a160:	f000 f8d8 	bl	2000a314 <HAL_FLASH_EndOfOperationCallback>

        /* Clear bank 2 End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
2000a164:	4b55      	ldr	r3, [pc, #340]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a166:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000a16a:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

        /*Increment sector number*/
        pFlash.Sector++;
2000a16e:	4b54      	ldr	r3, [pc, #336]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a170:	68db      	ldr	r3, [r3, #12]
2000a172:	3301      	adds	r3, #1
2000a174:	4a52      	ldr	r2, [pc, #328]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a176:	60d3      	str	r3, [r2, #12]
        temp = pFlash.Sector;
2000a178:	4b51      	ldr	r3, [pc, #324]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a17a:	68db      	ldr	r3, [r3, #12]
2000a17c:	60fb      	str	r3, [r7, #12]
        FLASH_Erase_Sector(temp, FLASH_BANK_2, pFlash.VoltageForErase);
2000a17e:	4b50      	ldr	r3, [pc, #320]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a180:	689b      	ldr	r3, [r3, #8]
2000a182:	461a      	mov	r2, r3
2000a184:	2102      	movs	r1, #2
2000a186:	68f8      	ldr	r0, [r7, #12]
2000a188:	f000 fffe 	bl	2000b188 <FLASH_Erase_Sector>
2000a18c:	e037      	b.n	2000a1fe <HAL_FLASH_IRQHandler+0x19e>
      }
      else
      {
        /* No more sectors to Erase, user callback can be called */
        /* Reset Sector and stop Erase sectors procedure */
        pFlash.Sector = 0xFFFFFFFFU;
2000a18e:	4b4c      	ldr	r3, [pc, #304]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a190:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
2000a194:	60da      	str	r2, [r3, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2000a196:	4b4a      	ldr	r3, [pc, #296]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a198:	2200      	movs	r2, #0
2000a19a:	701a      	strb	r2, [r3, #0]

        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
2000a19c:	4b48      	ldr	r3, [pc, #288]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a19e:	68db      	ldr	r3, [r3, #12]
2000a1a0:	4618      	mov	r0, r3
2000a1a2:	f000 f8b7 	bl	2000a314 <HAL_FLASH_EndOfOperationCallback>

        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
2000a1a6:	4b45      	ldr	r3, [pc, #276]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a1a8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000a1ac:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
2000a1b0:	e025      	b.n	2000a1fe <HAL_FLASH_IRQHandler+0x19e>
      }
    }
    else
    {
      procedure = pFlash.ProcedureOnGoing;
2000a1b2:	4b43      	ldr	r3, [pc, #268]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a1b4:	781b      	ldrb	r3, [r3, #0]
2000a1b6:	72fb      	strb	r3, [r7, #11]

      if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
2000a1b8:	7afb      	ldrb	r3, [r7, #11]
2000a1ba:	2b05      	cmp	r3, #5
2000a1bc:	d002      	beq.n	2000a1c4 <HAL_FLASH_IRQHandler+0x164>
2000a1be:	7afb      	ldrb	r3, [r7, #11]
2000a1c0:	2b07      	cmp	r3, #7
2000a1c2:	d103      	bne.n	2000a1cc <HAL_FLASH_IRQHandler+0x16c>
      {
        /*MassErase ended. Return the selected bank*/
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_2);
2000a1c4:	2002      	movs	r0, #2
2000a1c6:	f000 f8a5 	bl	2000a314 <HAL_FLASH_EndOfOperationCallback>
2000a1ca:	e007      	b.n	2000a1dc <HAL_FLASH_IRQHandler+0x17c>
      }
      else if(procedure == FLASH_PROC_PROGRAM_BANK2)
2000a1cc:	7afb      	ldrb	r3, [r7, #11]
2000a1ce:	2b06      	cmp	r3, #6
2000a1d0:	d104      	bne.n	2000a1dc <HAL_FLASH_IRQHandler+0x17c>
      {
        /* Program ended. Return the selected address */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
2000a1d2:	4b3b      	ldr	r3, [pc, #236]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a1d4:	691b      	ldr	r3, [r3, #16]
2000a1d6:	4618      	mov	r0, r3
2000a1d8:	f000 f89c 	bl	2000a314 <HAL_FLASH_EndOfOperationCallback>
      else
      {
        /* Nothing to do */
      }

      if((procedure != FLASH_PROC_SECTERASE_BANK1) && \
2000a1dc:	7afb      	ldrb	r3, [r7, #11]
2000a1de:	2b01      	cmp	r3, #1
2000a1e0:	d00d      	beq.n	2000a1fe <HAL_FLASH_IRQHandler+0x19e>
2000a1e2:	7afb      	ldrb	r3, [r7, #11]
2000a1e4:	2b02      	cmp	r3, #2
2000a1e6:	d00a      	beq.n	2000a1fe <HAL_FLASH_IRQHandler+0x19e>
         (procedure != FLASH_PROC_MASSERASE_BANK1) && \
2000a1e8:	7afb      	ldrb	r3, [r7, #11]
2000a1ea:	2b03      	cmp	r3, #3
2000a1ec:	d007      	beq.n	2000a1fe <HAL_FLASH_IRQHandler+0x19e>
         (procedure != FLASH_PROC_PROGRAM_BANK1))
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2000a1ee:	4b34      	ldr	r3, [pc, #208]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a1f0:	2200      	movs	r2, #0
2000a1f2:	701a      	strb	r2, [r3, #0]
        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
2000a1f4:	4b31      	ldr	r3, [pc, #196]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a1f6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000a1fa:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    }
  }

  /* Check FLASH Bank1 operation error flags */
#if defined (FLASH_SR_OPERR)
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
2000a1fe:	4b2f      	ldr	r3, [pc, #188]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a200:	691b      	ldr	r3, [r3, #16]
2000a202:	f403 03dc 	and.w	r3, r3, #7208960	; 0x6e0000
2000a206:	607b      	str	r3, [r7, #4]
#else
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
                            FLASH_FLAG_INCERR_BANK1);
#endif /* FLASH_SR_OPERR */

  if(errorflag != 0U)
2000a208:	687b      	ldr	r3, [r7, #4]
2000a20a:	2b00      	cmp	r3, #0
2000a20c:	d028      	beq.n	2000a260 <HAL_FLASH_IRQHandler+0x200>
  {
    /* Save the error code */
    pFlash.ErrorCode |= errorflag;
2000a20e:	4b2c      	ldr	r3, [pc, #176]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a210:	699a      	ldr	r2, [r3, #24]
2000a212:	687b      	ldr	r3, [r7, #4]
2000a214:	4313      	orrs	r3, r2
2000a216:	4a2a      	ldr	r2, [pc, #168]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a218:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG_BANK1(errorflag);
2000a21a:	4a28      	ldr	r2, [pc, #160]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a21c:	687b      	ldr	r3, [r7, #4]
2000a21e:	6153      	str	r3, [r2, #20]

    procedure = pFlash.ProcedureOnGoing;
2000a220:	4b27      	ldr	r3, [pc, #156]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a222:	781b      	ldrb	r3, [r3, #0]
2000a224:	72fb      	strb	r3, [r7, #11]

    if(procedure == FLASH_PROC_SECTERASE_BANK1)
2000a226:	7afb      	ldrb	r3, [r7, #11]
2000a228:	2b01      	cmp	r3, #1
2000a22a:	d107      	bne.n	2000a23c <HAL_FLASH_IRQHandler+0x1dc>
    {
      /* Return the faulty sector */
      temp = pFlash.Sector;
2000a22c:	4b24      	ldr	r3, [pc, #144]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a22e:	68db      	ldr	r3, [r3, #12]
2000a230:	60fb      	str	r3, [r7, #12]
      pFlash.Sector = 0xFFFFFFFFU;
2000a232:	4b23      	ldr	r3, [pc, #140]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a234:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
2000a238:	60da      	str	r2, [r3, #12]
2000a23a:	e00b      	b.n	2000a254 <HAL_FLASH_IRQHandler+0x1f4>
    }
    else if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
2000a23c:	7afb      	ldrb	r3, [r7, #11]
2000a23e:	2b02      	cmp	r3, #2
2000a240:	d002      	beq.n	2000a248 <HAL_FLASH_IRQHandler+0x1e8>
2000a242:	7afb      	ldrb	r3, [r7, #11]
2000a244:	2b07      	cmp	r3, #7
2000a246:	d102      	bne.n	2000a24e <HAL_FLASH_IRQHandler+0x1ee>
    {
      /* Return the faulty bank */
      temp = FLASH_BANK_1;
2000a248:	2301      	movs	r3, #1
2000a24a:	60fb      	str	r3, [r7, #12]
2000a24c:	e002      	b.n	2000a254 <HAL_FLASH_IRQHandler+0x1f4>
    }
    else
    {
      /* Return the faulty address */
      temp = pFlash.Address;
2000a24e:	4b1c      	ldr	r3, [pc, #112]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a250:	691b      	ldr	r3, [r3, #16]
2000a252:	60fb      	str	r3, [r7, #12]
    }

    /* Stop the procedure ongoing*/
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2000a254:	4b1a      	ldr	r3, [pc, #104]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a256:	2200      	movs	r2, #0
2000a258:	701a      	strb	r2, [r3, #0]

    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
2000a25a:	68f8      	ldr	r0, [r7, #12]
2000a25c:	f000 f864 	bl	2000a328 <HAL_FLASH_OperationErrorCallback>
  }

  /* Check FLASH Bank2 operation error flags */
#if defined (FLASH_SR_OPERR)
  errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \
2000a260:	4b16      	ldr	r3, [pc, #88]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a262:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
2000a266:	f403 03dc 	and.w	r3, r3, #7208960	; 0x6e0000
2000a26a:	607b      	str	r3, [r7, #4]
#else
  errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \
                             FLASH_FLAG_INCERR_BANK2) & 0x7FFFFFFFU);
#endif /* FLASH_SR_OPERR */

  if(errorflag != 0U)
2000a26c:	687b      	ldr	r3, [r7, #4]
2000a26e:	2b00      	cmp	r3, #0
2000a270:	d031      	beq.n	2000a2d6 <HAL_FLASH_IRQHandler+0x276>
  {
    /* Save the error code */
    pFlash.ErrorCode |= (errorflag | 0x80000000U);
2000a272:	4b13      	ldr	r3, [pc, #76]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a274:	699a      	ldr	r2, [r3, #24]
2000a276:	687b      	ldr	r3, [r7, #4]
2000a278:	4313      	orrs	r3, r2
2000a27a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
2000a27e:	4a10      	ldr	r2, [pc, #64]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a280:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG_BANK2(errorflag);
2000a282:	4a0e      	ldr	r2, [pc, #56]	; (2000a2bc <HAL_FLASH_IRQHandler+0x25c>)
2000a284:	687b      	ldr	r3, [r7, #4]
2000a286:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
2000a28a:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

    procedure = pFlash.ProcedureOnGoing;
2000a28e:	4b0c      	ldr	r3, [pc, #48]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a290:	781b      	ldrb	r3, [r3, #0]
2000a292:	72fb      	strb	r3, [r7, #11]

    if(procedure== FLASH_PROC_SECTERASE_BANK2)
2000a294:	7afb      	ldrb	r3, [r7, #11]
2000a296:	2b04      	cmp	r3, #4
2000a298:	d107      	bne.n	2000a2aa <HAL_FLASH_IRQHandler+0x24a>
    {
      /*return the faulty sector*/
      temp = pFlash.Sector;
2000a29a:	4b09      	ldr	r3, [pc, #36]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a29c:	68db      	ldr	r3, [r3, #12]
2000a29e:	60fb      	str	r3, [r7, #12]
      pFlash.Sector = 0xFFFFFFFFU;
2000a2a0:	4b07      	ldr	r3, [pc, #28]	; (2000a2c0 <HAL_FLASH_IRQHandler+0x260>)
2000a2a2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
2000a2a6:	60da      	str	r2, [r3, #12]
2000a2a8:	e00f      	b.n	2000a2ca <HAL_FLASH_IRQHandler+0x26a>
    }
    else if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
2000a2aa:	7afb      	ldrb	r3, [r7, #11]
2000a2ac:	2b05      	cmp	r3, #5
2000a2ae:	d002      	beq.n	2000a2b6 <HAL_FLASH_IRQHandler+0x256>
2000a2b0:	7afb      	ldrb	r3, [r7, #11]
2000a2b2:	2b07      	cmp	r3, #7
2000a2b4:	d106      	bne.n	2000a2c4 <HAL_FLASH_IRQHandler+0x264>
    {
      /*return the faulty bank*/
      temp = FLASH_BANK_2;
2000a2b6:	2302      	movs	r3, #2
2000a2b8:	60fb      	str	r3, [r7, #12]
2000a2ba:	e006      	b.n	2000a2ca <HAL_FLASH_IRQHandler+0x26a>
2000a2bc:	52002000 	.word	0x52002000
2000a2c0:	2001ca60 	.word	0x2001ca60
    }
    else
    {
      /*return the faulty address*/
      temp = pFlash.Address;
2000a2c4:	4b11      	ldr	r3, [pc, #68]	; (2000a30c <HAL_FLASH_IRQHandler+0x2ac>)
2000a2c6:	691b      	ldr	r3, [r3, #16]
2000a2c8:	60fb      	str	r3, [r7, #12]
    }

    /*Stop the procedure ongoing*/
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2000a2ca:	4b10      	ldr	r3, [pc, #64]	; (2000a30c <HAL_FLASH_IRQHandler+0x2ac>)
2000a2cc:	2200      	movs	r2, #0
2000a2ce:	701a      	strb	r2, [r3, #0]

    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
2000a2d0:	68f8      	ldr	r0, [r7, #12]
2000a2d2:	f000 f829 	bl	2000a328 <HAL_FLASH_OperationErrorCallback>
  }

  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
2000a2d6:	4b0d      	ldr	r3, [pc, #52]	; (2000a30c <HAL_FLASH_IRQHandler+0x2ac>)
2000a2d8:	781b      	ldrb	r3, [r3, #0]
2000a2da:	b2db      	uxtb	r3, r3
2000a2dc:	2b00      	cmp	r3, #0
2000a2de:	d110      	bne.n	2000a302 <HAL_FLASH_IRQHandler+0x2a2>
  {
#if defined (FLASH_CR_OPERRIE)
    /* Disable Bank1 Operation and Error source interrupt */
    __HAL_FLASH_DISABLE_IT_BANK1(FLASH_IT_EOP_BANK1    | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
2000a2e0:	4b0b      	ldr	r3, [pc, #44]	; (2000a310 <HAL_FLASH_IRQHandler+0x2b0>)
2000a2e2:	68db      	ldr	r3, [r3, #12]
2000a2e4:	4a0a      	ldr	r2, [pc, #40]	; (2000a310 <HAL_FLASH_IRQHandler+0x2b0>)
2000a2e6:	f423 03de 	bic.w	r3, r3, #7274496	; 0x6f0000
2000a2ea:	60d3      	str	r3, [r2, #12]
                                 FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);

    /* Disable Bank2 Operation and Error source interrupt */
    __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
2000a2ec:	4b08      	ldr	r3, [pc, #32]	; (2000a310 <HAL_FLASH_IRQHandler+0x2b0>)
2000a2ee:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000a2f2:	4a07      	ldr	r2, [pc, #28]	; (2000a310 <HAL_FLASH_IRQHandler+0x2b0>)
2000a2f4:	f423 03de 	bic.w	r3, r3, #7274496	; 0x6f0000
2000a2f8:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
    __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
                                 FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* FLASH_CR_OPERRIE */

    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
2000a2fc:	4b03      	ldr	r3, [pc, #12]	; (2000a30c <HAL_FLASH_IRQHandler+0x2ac>)
2000a2fe:	2200      	movs	r2, #0
2000a300:	751a      	strb	r2, [r3, #20]
  }
}
2000a302:	bf00      	nop
2000a304:	3710      	adds	r7, #16
2000a306:	46bd      	mov	sp, r7
2000a308:	bd80      	pop	{r7, pc}
2000a30a:	bf00      	nop
2000a30c:	2001ca60 	.word	0x2001ca60
2000a310:	52002000 	.word	0x52002000

2000a314 <HAL_FLASH_EndOfOperationCallback>:
  *                    (if 0xFFFFFFFF, it means that all the selected sectors have been erased)
  *                  Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
{
2000a314:	b480      	push	{r7}
2000a316:	b083      	sub	sp, #12
2000a318:	af00      	add	r7, sp, #0
2000a31a:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
2000a31c:	bf00      	nop
2000a31e:	370c      	adds	r7, #12
2000a320:	46bd      	mov	sp, r7
2000a322:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a326:	4770      	bx	lr

2000a328 <HAL_FLASH_OperationErrorCallback>:
  *                 Sectors Erase: Sector number which returned an error
  *                 Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
{
2000a328:	b480      	push	{r7}
2000a32a:	b083      	sub	sp, #12
2000a32c:	af00      	add	r7, sp, #0
2000a32e:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_OperationErrorCallback could be implemented in the user file
   */
}
2000a330:	bf00      	nop
2000a332:	370c      	adds	r7, #12
2000a334:	46bd      	mov	sp, r7
2000a336:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a33a:	4770      	bx	lr

2000a33c <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
2000a33c:	b480      	push	{r7}
2000a33e:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
2000a340:	4b18      	ldr	r3, [pc, #96]	; (2000a3a4 <HAL_FLASH_Unlock+0x68>)
2000a342:	68db      	ldr	r3, [r3, #12]
2000a344:	f003 0301 	and.w	r3, r3, #1
2000a348:	2b00      	cmp	r3, #0
2000a34a:	d00d      	beq.n	2000a368 <HAL_FLASH_Unlock+0x2c>
  {
    /* Authorize the FLASH Bank1 Registers access */
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
2000a34c:	4b15      	ldr	r3, [pc, #84]	; (2000a3a4 <HAL_FLASH_Unlock+0x68>)
2000a34e:	4a16      	ldr	r2, [pc, #88]	; (2000a3a8 <HAL_FLASH_Unlock+0x6c>)
2000a350:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
2000a352:	4b14      	ldr	r3, [pc, #80]	; (2000a3a4 <HAL_FLASH_Unlock+0x68>)
2000a354:	4a15      	ldr	r2, [pc, #84]	; (2000a3ac <HAL_FLASH_Unlock+0x70>)
2000a356:	605a      	str	r2, [r3, #4]

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
2000a358:	4b12      	ldr	r3, [pc, #72]	; (2000a3a4 <HAL_FLASH_Unlock+0x68>)
2000a35a:	68db      	ldr	r3, [r3, #12]
2000a35c:	f003 0301 	and.w	r3, r3, #1
2000a360:	2b00      	cmp	r3, #0
2000a362:	d001      	beq.n	2000a368 <HAL_FLASH_Unlock+0x2c>
    {
      return HAL_ERROR;
2000a364:	2301      	movs	r3, #1
2000a366:	e018      	b.n	2000a39a <HAL_FLASH_Unlock+0x5e>
    }
  }

  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
2000a368:	4b0e      	ldr	r3, [pc, #56]	; (2000a3a4 <HAL_FLASH_Unlock+0x68>)
2000a36a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000a36e:	f003 0301 	and.w	r3, r3, #1
2000a372:	2b00      	cmp	r3, #0
2000a374:	d010      	beq.n	2000a398 <HAL_FLASH_Unlock+0x5c>
  {
    /* Authorize the FLASH Bank2 Registers access */
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
2000a376:	4b0b      	ldr	r3, [pc, #44]	; (2000a3a4 <HAL_FLASH_Unlock+0x68>)
2000a378:	4a0b      	ldr	r2, [pc, #44]	; (2000a3a8 <HAL_FLASH_Unlock+0x6c>)
2000a37a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
2000a37e:	4b09      	ldr	r3, [pc, #36]	; (2000a3a4 <HAL_FLASH_Unlock+0x68>)
2000a380:	4a0a      	ldr	r2, [pc, #40]	; (2000a3ac <HAL_FLASH_Unlock+0x70>)
2000a382:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

    /* Verify Flash Bank2 is unlocked */
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
2000a386:	4b07      	ldr	r3, [pc, #28]	; (2000a3a4 <HAL_FLASH_Unlock+0x68>)
2000a388:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000a38c:	f003 0301 	and.w	r3, r3, #1
2000a390:	2b00      	cmp	r3, #0
2000a392:	d001      	beq.n	2000a398 <HAL_FLASH_Unlock+0x5c>
    {
      return HAL_ERROR;
2000a394:	2301      	movs	r3, #1
2000a396:	e000      	b.n	2000a39a <HAL_FLASH_Unlock+0x5e>
    }
  }

  return HAL_OK;
2000a398:	2300      	movs	r3, #0
}
2000a39a:	4618      	mov	r0, r3
2000a39c:	46bd      	mov	sp, r7
2000a39e:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a3a2:	4770      	bx	lr
2000a3a4:	52002000 	.word	0x52002000
2000a3a8:	45670123 	.word	0x45670123
2000a3ac:	cdef89ab 	.word	0xcdef89ab

2000a3b0 <HAL_FLASH_Lock>:
/**
  * @brief  Locks the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
2000a3b0:	b480      	push	{r7}
2000a3b2:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank1 Control Register access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
2000a3b4:	4b12      	ldr	r3, [pc, #72]	; (2000a400 <HAL_FLASH_Lock+0x50>)
2000a3b6:	68db      	ldr	r3, [r3, #12]
2000a3b8:	4a11      	ldr	r2, [pc, #68]	; (2000a400 <HAL_FLASH_Lock+0x50>)
2000a3ba:	f043 0301 	orr.w	r3, r3, #1
2000a3be:	60d3      	str	r3, [r2, #12]

  /* Verify Flash Bank1 is locked */
  if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) == 0U)
2000a3c0:	4b0f      	ldr	r3, [pc, #60]	; (2000a400 <HAL_FLASH_Lock+0x50>)
2000a3c2:	68db      	ldr	r3, [r3, #12]
2000a3c4:	f003 0301 	and.w	r3, r3, #1
2000a3c8:	2b00      	cmp	r3, #0
2000a3ca:	d101      	bne.n	2000a3d0 <HAL_FLASH_Lock+0x20>
  {
    return HAL_ERROR;
2000a3cc:	2301      	movs	r3, #1
2000a3ce:	e011      	b.n	2000a3f4 <HAL_FLASH_Lock+0x44>
  }

  /* Set the LOCK Bit to lock the FLASH Bank2 Control Register access */
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
2000a3d0:	4b0b      	ldr	r3, [pc, #44]	; (2000a400 <HAL_FLASH_Lock+0x50>)
2000a3d2:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000a3d6:	4a0a      	ldr	r2, [pc, #40]	; (2000a400 <HAL_FLASH_Lock+0x50>)
2000a3d8:	f043 0301 	orr.w	r3, r3, #1
2000a3dc:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

  /* Verify Flash Bank2 is locked */
  if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) == 0U)
2000a3e0:	4b07      	ldr	r3, [pc, #28]	; (2000a400 <HAL_FLASH_Lock+0x50>)
2000a3e2:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000a3e6:	f003 0301 	and.w	r3, r3, #1
2000a3ea:	2b00      	cmp	r3, #0
2000a3ec:	d101      	bne.n	2000a3f2 <HAL_FLASH_Lock+0x42>
  {
    return HAL_ERROR;
2000a3ee:	2301      	movs	r3, #1
2000a3f0:	e000      	b.n	2000a3f4 <HAL_FLASH_Lock+0x44>
  }

  return HAL_OK;
2000a3f2:	2300      	movs	r3, #0
}
2000a3f4:	4618      	mov	r0, r3
2000a3f6:	46bd      	mov	sp, r7
2000a3f8:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a3fc:	4770      	bx	lr
2000a3fe:	bf00      	nop
2000a400:	52002000 	.word	0x52002000

2000a404 <HAL_FLASH_OB_Unlock>:
/**
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
2000a404:	b480      	push	{r7}
2000a406:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
2000a408:	4b0c      	ldr	r3, [pc, #48]	; (2000a43c <HAL_FLASH_OB_Unlock+0x38>)
2000a40a:	699b      	ldr	r3, [r3, #24]
2000a40c:	f003 0301 	and.w	r3, r3, #1
2000a410:	2b00      	cmp	r3, #0
2000a412:	d00d      	beq.n	2000a430 <HAL_FLASH_OB_Unlock+0x2c>
  {
    /* Authorizes the Option Byte registers programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY1);
2000a414:	4b09      	ldr	r3, [pc, #36]	; (2000a43c <HAL_FLASH_OB_Unlock+0x38>)
2000a416:	4a0a      	ldr	r2, [pc, #40]	; (2000a440 <HAL_FLASH_OB_Unlock+0x3c>)
2000a418:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY2);
2000a41a:	4b08      	ldr	r3, [pc, #32]	; (2000a43c <HAL_FLASH_OB_Unlock+0x38>)
2000a41c:	4a09      	ldr	r2, [pc, #36]	; (2000a444 <HAL_FLASH_OB_Unlock+0x40>)
2000a41e:	609a      	str	r2, [r3, #8]

    /* Verify that the Option Bytes are unlocked */
    if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
2000a420:	4b06      	ldr	r3, [pc, #24]	; (2000a43c <HAL_FLASH_OB_Unlock+0x38>)
2000a422:	699b      	ldr	r3, [r3, #24]
2000a424:	f003 0301 	and.w	r3, r3, #1
2000a428:	2b00      	cmp	r3, #0
2000a42a:	d001      	beq.n	2000a430 <HAL_FLASH_OB_Unlock+0x2c>
    {
      return HAL_ERROR;
2000a42c:	2301      	movs	r3, #1
2000a42e:	e000      	b.n	2000a432 <HAL_FLASH_OB_Unlock+0x2e>
    }
  }

  return HAL_OK;
2000a430:	2300      	movs	r3, #0
}
2000a432:	4618      	mov	r0, r3
2000a434:	46bd      	mov	sp, r7
2000a436:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a43a:	4770      	bx	lr
2000a43c:	52002000 	.word	0x52002000
2000a440:	08192a3b 	.word	0x08192a3b
2000a444:	4c5d6e7f 	.word	0x4c5d6e7f

2000a448 <HAL_FLASH_OB_Lock>:
/**
  * @brief  Lock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
2000a448:	b480      	push	{r7}
2000a44a:	af00      	add	r7, sp, #0
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK);
2000a44c:	4b09      	ldr	r3, [pc, #36]	; (2000a474 <HAL_FLASH_OB_Lock+0x2c>)
2000a44e:	699b      	ldr	r3, [r3, #24]
2000a450:	4a08      	ldr	r2, [pc, #32]	; (2000a474 <HAL_FLASH_OB_Lock+0x2c>)
2000a452:	f043 0301 	orr.w	r3, r3, #1
2000a456:	6193      	str	r3, [r2, #24]

  /* Verify that the Option Bytes are locked */
  if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) == 0U)
2000a458:	4b06      	ldr	r3, [pc, #24]	; (2000a474 <HAL_FLASH_OB_Lock+0x2c>)
2000a45a:	699b      	ldr	r3, [r3, #24]
2000a45c:	f003 0301 	and.w	r3, r3, #1
2000a460:	2b00      	cmp	r3, #0
2000a462:	d101      	bne.n	2000a468 <HAL_FLASH_OB_Lock+0x20>
  {
    return HAL_ERROR;
2000a464:	2301      	movs	r3, #1
2000a466:	e000      	b.n	2000a46a <HAL_FLASH_OB_Lock+0x22>
  }

  return HAL_OK;
2000a468:	2300      	movs	r3, #0
}
2000a46a:	4618      	mov	r0, r3
2000a46c:	46bd      	mov	sp, r7
2000a46e:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a472:	4770      	bx	lr
2000a474:	52002000 	.word	0x52002000

2000a478 <HAL_FLASH_OB_Launch>:
/**
  * @brief  Launch the option bytes loading.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
{
2000a478:	b580      	push	{r7, lr}
2000a47a:	b082      	sub	sp, #8
2000a47c:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status;

  /* Wait for CRC computation to be completed */
  if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
2000a47e:	2101      	movs	r1, #1
2000a480:	f24c 3050 	movw	r0, #50000	; 0xc350
2000a484:	f000 f91a 	bl	2000a6bc <FLASH_CRC_WaitForLastOperation>
2000a488:	4603      	mov	r3, r0
2000a48a:	2b00      	cmp	r3, #0
2000a48c:	d002      	beq.n	2000a494 <HAL_FLASH_OB_Launch+0x1c>
  {
    status = HAL_ERROR;
2000a48e:	2301      	movs	r3, #1
2000a490:	71fb      	strb	r3, [r7, #7]
2000a492:	e00c      	b.n	2000a4ae <HAL_FLASH_OB_Launch+0x36>
  }
  else if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
2000a494:	2102      	movs	r1, #2
2000a496:	f24c 3050 	movw	r0, #50000	; 0xc350
2000a49a:	f000 f90f 	bl	2000a6bc <FLASH_CRC_WaitForLastOperation>
2000a49e:	4603      	mov	r3, r0
2000a4a0:	2b00      	cmp	r3, #0
2000a4a2:	d002      	beq.n	2000a4aa <HAL_FLASH_OB_Launch+0x32>
  {
    status = HAL_ERROR;
2000a4a4:	2301      	movs	r3, #1
2000a4a6:	71fb      	strb	r3, [r7, #7]
2000a4a8:	e001      	b.n	2000a4ae <HAL_FLASH_OB_Launch+0x36>
  }
  else
  {
    status = HAL_OK;
2000a4aa:	2300      	movs	r3, #0
2000a4ac:	71fb      	strb	r3, [r7, #7]
  }

  if (status == HAL_OK)
2000a4ae:	79fb      	ldrb	r3, [r7, #7]
2000a4b0:	2b00      	cmp	r3, #0
2000a4b2:	d10b      	bne.n	2000a4cc <HAL_FLASH_OB_Launch+0x54>
  {
    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
2000a4b4:	4b08      	ldr	r3, [pc, #32]	; (2000a4d8 <HAL_FLASH_OB_Launch+0x60>)
2000a4b6:	699b      	ldr	r3, [r3, #24]
2000a4b8:	4a07      	ldr	r2, [pc, #28]	; (2000a4d8 <HAL_FLASH_OB_Launch+0x60>)
2000a4ba:	f043 0302 	orr.w	r3, r3, #2
2000a4be:	6193      	str	r3, [r2, #24]

    /* Wait for OB change operation to be completed */
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
2000a4c0:	f24c 3050 	movw	r0, #50000	; 0xc350
2000a4c4:	f000 f8be 	bl	2000a644 <FLASH_OB_WaitForLastOperation>
2000a4c8:	4603      	mov	r3, r0
2000a4ca:	71fb      	strb	r3, [r7, #7]
  }

  return status;
2000a4cc:	79fb      	ldrb	r3, [r7, #7]
}
2000a4ce:	4618      	mov	r0, r3
2000a4d0:	3708      	adds	r7, #8
2000a4d2:	46bd      	mov	sp, r7
2000a4d4:	bd80      	pop	{r7, pc}
2000a4d6:	bf00      	nop
2000a4d8:	52002000 	.word	0x52002000

2000a4dc <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_DBECC_BANK2: Double Detection ECC on Bank 2
  *            @arg HAL_FLASH_ERROR_CRCRD_BANK2: CRC Read Error on Bank 2
*/

uint32_t HAL_FLASH_GetError(void)
{
2000a4dc:	b480      	push	{r7}
2000a4de:	af00      	add	r7, sp, #0
   return pFlash.ErrorCode;
2000a4e0:	4b03      	ldr	r3, [pc, #12]	; (2000a4f0 <HAL_FLASH_GetError+0x14>)
2000a4e2:	699b      	ldr	r3, [r3, #24]
}
2000a4e4:	4618      	mov	r0, r3
2000a4e6:	46bd      	mov	sp, r7
2000a4e8:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a4ec:	4770      	bx	lr
2000a4ee:	bf00      	nop
2000a4f0:	2001ca60 	.word	0x2001ca60

2000a4f4 <FLASH_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
2000a4f4:	b580      	push	{r7, lr}
2000a4f6:	b086      	sub	sp, #24
2000a4f8:	af00      	add	r7, sp, #0
2000a4fa:	6078      	str	r0, [r7, #4]
2000a4fc:	6039      	str	r1, [r7, #0]
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag, errorflag;
  uint32_t tickstart = HAL_GetTick();
2000a4fe:	f7f7 fbf5 	bl	20001cec <HAL_GetTick>
2000a502:	60f8      	str	r0, [r7, #12]

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
2000a504:	683b      	ldr	r3, [r7, #0]
2000a506:	2b01      	cmp	r3, #1
2000a508:	d007      	beq.n	2000a51a <FLASH_WaitForLastOperation+0x26>
2000a50a:	683b      	ldr	r3, [r7, #0]
2000a50c:	2b02      	cmp	r3, #2
2000a50e:	d004      	beq.n	2000a51a <FLASH_WaitForLastOperation+0x26>
2000a510:	f240 3192 	movw	r1, #914	; 0x392
2000a514:	4845      	ldr	r0, [pc, #276]	; (2000a62c <FLASH_WaitForLastOperation+0x138>)
2000a516:	f7f6 f9ed 	bl	200008f4 <assert_failed>

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
2000a51a:	683b      	ldr	r3, [r7, #0]
2000a51c:	2b01      	cmp	r3, #1
2000a51e:	d102      	bne.n	2000a526 <FLASH_WaitForLastOperation+0x32>
  {
    bsyflag = FLASH_FLAG_QW_BANK1;
2000a520:	2304      	movs	r3, #4
2000a522:	617b      	str	r3, [r7, #20]
2000a524:	e013      	b.n	2000a54e <FLASH_WaitForLastOperation+0x5a>
  }
  else
  {
    bsyflag = FLASH_FLAG_QW_BANK2;
2000a526:	4b42      	ldr	r3, [pc, #264]	; (2000a630 <FLASH_WaitForLastOperation+0x13c>)
2000a528:	617b      	str	r3, [r7, #20]
  }

  while(__HAL_FLASH_GET_FLAG(bsyflag))
2000a52a:	e010      	b.n	2000a54e <FLASH_WaitForLastOperation+0x5a>
  {
    if(Timeout != HAL_MAX_DELAY)
2000a52c:	687b      	ldr	r3, [r7, #4]
2000a52e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
2000a532:	d00c      	beq.n	2000a54e <FLASH_WaitForLastOperation+0x5a>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2000a534:	f7f7 fbda 	bl	20001cec <HAL_GetTick>
2000a538:	4602      	mov	r2, r0
2000a53a:	68fb      	ldr	r3, [r7, #12]
2000a53c:	1ad3      	subs	r3, r2, r3
2000a53e:	687a      	ldr	r2, [r7, #4]
2000a540:	429a      	cmp	r2, r3
2000a542:	d302      	bcc.n	2000a54a <FLASH_WaitForLastOperation+0x56>
2000a544:	687b      	ldr	r3, [r7, #4]
2000a546:	2b00      	cmp	r3, #0
2000a548:	d101      	bne.n	2000a54e <FLASH_WaitForLastOperation+0x5a>
      {
        return HAL_TIMEOUT;
2000a54a:	2303      	movs	r3, #3
2000a54c:	e06a      	b.n	2000a624 <FLASH_WaitForLastOperation+0x130>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
2000a54e:	697a      	ldr	r2, [r7, #20]
2000a550:	4b38      	ldr	r3, [pc, #224]	; (2000a634 <FLASH_WaitForLastOperation+0x140>)
2000a552:	4013      	ands	r3, r2
2000a554:	697a      	ldr	r2, [r7, #20]
2000a556:	429a      	cmp	r2, r3
2000a558:	d10a      	bne.n	2000a570 <FLASH_WaitForLastOperation+0x7c>
2000a55a:	4b37      	ldr	r3, [pc, #220]	; (2000a638 <FLASH_WaitForLastOperation+0x144>)
2000a55c:	691a      	ldr	r2, [r3, #16]
2000a55e:	697b      	ldr	r3, [r7, #20]
2000a560:	4013      	ands	r3, r2
2000a562:	697a      	ldr	r2, [r7, #20]
2000a564:	429a      	cmp	r2, r3
2000a566:	bf0c      	ite	eq
2000a568:	2301      	moveq	r3, #1
2000a56a:	2300      	movne	r3, #0
2000a56c:	b2db      	uxtb	r3, r3
2000a56e:	e00c      	b.n	2000a58a <FLASH_WaitForLastOperation+0x96>
2000a570:	4b31      	ldr	r3, [pc, #196]	; (2000a638 <FLASH_WaitForLastOperation+0x144>)
2000a572:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
2000a576:	43da      	mvns	r2, r3
2000a578:	697b      	ldr	r3, [r7, #20]
2000a57a:	4013      	ands	r3, r2
2000a57c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
2000a580:	2b00      	cmp	r3, #0
2000a582:	bf0c      	ite	eq
2000a584:	2301      	moveq	r3, #1
2000a586:	2300      	movne	r3, #0
2000a588:	b2db      	uxtb	r3, r3
2000a58a:	2b00      	cmp	r3, #0
2000a58c:	d1ce      	bne.n	2000a52c <FLASH_WaitForLastOperation+0x38>
      }
    }
  }

  /* Get Error Flags */
  if (Bank == FLASH_BANK_1)
2000a58e:	683b      	ldr	r3, [r7, #0]
2000a590:	2b01      	cmp	r3, #1
2000a592:	d105      	bne.n	2000a5a0 <FLASH_WaitForLastOperation+0xac>
  {
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
2000a594:	4b28      	ldr	r3, [pc, #160]	; (2000a638 <FLASH_WaitForLastOperation+0x144>)
2000a596:	691a      	ldr	r2, [r3, #16]
2000a598:	4b28      	ldr	r3, [pc, #160]	; (2000a63c <FLASH_WaitForLastOperation+0x148>)
2000a59a:	4013      	ands	r3, r2
2000a59c:	613b      	str	r3, [r7, #16]
2000a59e:	e007      	b.n	2000a5b0 <FLASH_WaitForLastOperation+0xbc>
  }
  else
  {
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
2000a5a0:	4b25      	ldr	r3, [pc, #148]	; (2000a638 <FLASH_WaitForLastOperation+0x144>)
2000a5a2:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
2000a5a6:	4b25      	ldr	r3, [pc, #148]	; (2000a63c <FLASH_WaitForLastOperation+0x148>)
2000a5a8:	4013      	ands	r3, r2
2000a5aa:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
2000a5ae:	613b      	str	r3, [r7, #16]
  }

  /* In case of error reported in Flash SR1 or SR2 registers (ECCC not managed as an error) */
  if((errorflag & 0x7DFFFFFFU) != 0U)
2000a5b0:	693b      	ldr	r3, [r7, #16]
2000a5b2:	f023 4302 	bic.w	r3, r3, #2181038080	; 0x82000000
2000a5b6:	2b00      	cmp	r3, #0
2000a5b8:	d017      	beq.n	2000a5ea <FLASH_WaitForLastOperation+0xf6>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= errorflag;
2000a5ba:	4b21      	ldr	r3, [pc, #132]	; (2000a640 <FLASH_WaitForLastOperation+0x14c>)
2000a5bc:	699a      	ldr	r2, [r3, #24]
2000a5be:	693b      	ldr	r3, [r7, #16]
2000a5c0:	4313      	orrs	r3, r2
2000a5c2:	4a1f      	ldr	r2, [pc, #124]	; (2000a640 <FLASH_WaitForLastOperation+0x14c>)
2000a5c4:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(errorflag);
2000a5c6:	693a      	ldr	r2, [r7, #16]
2000a5c8:	4b1a      	ldr	r3, [pc, #104]	; (2000a634 <FLASH_WaitForLastOperation+0x140>)
2000a5ca:	4013      	ands	r3, r2
2000a5cc:	693a      	ldr	r2, [r7, #16]
2000a5ce:	429a      	cmp	r2, r3
2000a5d0:	d103      	bne.n	2000a5da <FLASH_WaitForLastOperation+0xe6>
2000a5d2:	4a19      	ldr	r2, [pc, #100]	; (2000a638 <FLASH_WaitForLastOperation+0x144>)
2000a5d4:	693b      	ldr	r3, [r7, #16]
2000a5d6:	6153      	str	r3, [r2, #20]
2000a5d8:	e005      	b.n	2000a5e6 <FLASH_WaitForLastOperation+0xf2>
2000a5da:	4a17      	ldr	r2, [pc, #92]	; (2000a638 <FLASH_WaitForLastOperation+0x144>)
2000a5dc:	693b      	ldr	r3, [r7, #16]
2000a5de:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
2000a5e2:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

    return HAL_ERROR;
2000a5e6:	2301      	movs	r3, #1
2000a5e8:	e01c      	b.n	2000a624 <FLASH_WaitForLastOperation+0x130>
  }

  /* Check FLASH End of Operation flag  */
  if(Bank == FLASH_BANK_1)
2000a5ea:	683b      	ldr	r3, [r7, #0]
2000a5ec:	2b01      	cmp	r3, #1
2000a5ee:	d10b      	bne.n	2000a608 <FLASH_WaitForLastOperation+0x114>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
2000a5f0:	4b11      	ldr	r3, [pc, #68]	; (2000a638 <FLASH_WaitForLastOperation+0x144>)
2000a5f2:	691b      	ldr	r3, [r3, #16]
2000a5f4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000a5f8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000a5fc:	d111      	bne.n	2000a622 <FLASH_WaitForLastOperation+0x12e>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
2000a5fe:	4b0e      	ldr	r3, [pc, #56]	; (2000a638 <FLASH_WaitForLastOperation+0x144>)
2000a600:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000a604:	615a      	str	r2, [r3, #20]
2000a606:	e00c      	b.n	2000a622 <FLASH_WaitForLastOperation+0x12e>
    }
  }
  else
  {
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
2000a608:	4b0b      	ldr	r3, [pc, #44]	; (2000a638 <FLASH_WaitForLastOperation+0x144>)
2000a60a:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
2000a60e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000a612:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000a616:	d104      	bne.n	2000a622 <FLASH_WaitForLastOperation+0x12e>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
2000a618:	4b07      	ldr	r3, [pc, #28]	; (2000a638 <FLASH_WaitForLastOperation+0x144>)
2000a61a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000a61e:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    }
  }

  return HAL_OK;
2000a622:	2300      	movs	r3, #0
}
2000a624:	4618      	mov	r0, r3
2000a626:	3718      	adds	r7, #24
2000a628:	46bd      	mov	sp, r7
2000a62a:	bd80      	pop	{r7, pc}
2000a62c:	2001c08c 	.word	0x2001c08c
2000a630:	80000004 	.word	0x80000004
2000a634:	1fef000f 	.word	0x1fef000f
2000a638:	52002000 	.word	0x52002000
2000a63c:	17ee0000 	.word	0x17ee0000
2000a640:	2001ca60 	.word	0x2001ca60

2000a644 <FLASH_OB_WaitForLastOperation>:
  * @brief  Wait for a FLASH Option Bytes change operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_OB_WaitForLastOperation(uint32_t Timeout)
{
2000a644:	b580      	push	{r7, lr}
2000a646:	b084      	sub	sp, #16
2000a648:	af00      	add	r7, sp, #0
2000a64a:	6078      	str	r0, [r7, #4]
  /* Get timeout */
  uint32_t tickstart = HAL_GetTick();
2000a64c:	f7f7 fb4e 	bl	20001cec <HAL_GetTick>
2000a650:	60f8      	str	r0, [r7, #12]

  /* Wait for the FLASH Option Bytes change operation to complete by polling on OPT_BUSY flag to be reset */
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
2000a652:	e010      	b.n	2000a676 <FLASH_OB_WaitForLastOperation+0x32>
  {
    if(Timeout != HAL_MAX_DELAY)
2000a654:	687b      	ldr	r3, [r7, #4]
2000a656:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
2000a65a:	d00c      	beq.n	2000a676 <FLASH_OB_WaitForLastOperation+0x32>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2000a65c:	f7f7 fb46 	bl	20001cec <HAL_GetTick>
2000a660:	4602      	mov	r2, r0
2000a662:	68fb      	ldr	r3, [r7, #12]
2000a664:	1ad3      	subs	r3, r2, r3
2000a666:	687a      	ldr	r2, [r7, #4]
2000a668:	429a      	cmp	r2, r3
2000a66a:	d302      	bcc.n	2000a672 <FLASH_OB_WaitForLastOperation+0x2e>
2000a66c:	687b      	ldr	r3, [r7, #4]
2000a66e:	2b00      	cmp	r3, #0
2000a670:	d101      	bne.n	2000a676 <FLASH_OB_WaitForLastOperation+0x32>
      {
        return HAL_TIMEOUT;
2000a672:	2303      	movs	r3, #3
2000a674:	e01a      	b.n	2000a6ac <FLASH_OB_WaitForLastOperation+0x68>
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
2000a676:	4b0f      	ldr	r3, [pc, #60]	; (2000a6b4 <FLASH_OB_WaitForLastOperation+0x70>)
2000a678:	69db      	ldr	r3, [r3, #28]
2000a67a:	f003 0301 	and.w	r3, r3, #1
2000a67e:	2b00      	cmp	r3, #0
2000a680:	d1e8      	bne.n	2000a654 <FLASH_OB_WaitForLastOperation+0x10>
      }
    }
  }

  /* Check option byte change error */
  if(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPTCHANGEERR) != 0U)
2000a682:	4b0c      	ldr	r3, [pc, #48]	; (2000a6b4 <FLASH_OB_WaitForLastOperation+0x70>)
2000a684:	69db      	ldr	r3, [r3, #28]
2000a686:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2000a68a:	2b00      	cmp	r3, #0
2000a68c:	d00d      	beq.n	2000a6aa <FLASH_OB_WaitForLastOperation+0x66>
  {
    /* Save the error code */
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
2000a68e:	4b0a      	ldr	r3, [pc, #40]	; (2000a6b8 <FLASH_OB_WaitForLastOperation+0x74>)
2000a690:	699b      	ldr	r3, [r3, #24]
2000a692:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
2000a696:	4a08      	ldr	r2, [pc, #32]	; (2000a6b8 <FLASH_OB_WaitForLastOperation+0x74>)
2000a698:	6193      	str	r3, [r2, #24]

    /* Clear the OB error flag */
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
2000a69a:	4b06      	ldr	r3, [pc, #24]	; (2000a6b4 <FLASH_OB_WaitForLastOperation+0x70>)
2000a69c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000a69e:	4a05      	ldr	r2, [pc, #20]	; (2000a6b4 <FLASH_OB_WaitForLastOperation+0x70>)
2000a6a0:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
2000a6a4:	6253      	str	r3, [r2, #36]	; 0x24

    return HAL_ERROR;
2000a6a6:	2301      	movs	r3, #1
2000a6a8:	e000      	b.n	2000a6ac <FLASH_OB_WaitForLastOperation+0x68>
  }

  /* If there is no error flag set */
  return HAL_OK;
2000a6aa:	2300      	movs	r3, #0
}
2000a6ac:	4618      	mov	r0, r3
2000a6ae:	3710      	adds	r7, #16
2000a6b0:	46bd      	mov	sp, r7
2000a6b2:	bd80      	pop	{r7, pc}
2000a6b4:	52002000 	.word	0x52002000
2000a6b8:	2001ca60 	.word	0x2001ca60

2000a6bc <FLASH_CRC_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_CRC_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
2000a6bc:	b580      	push	{r7, lr}
2000a6be:	b084      	sub	sp, #16
2000a6c0:	af00      	add	r7, sp, #0
2000a6c2:	6078      	str	r0, [r7, #4]
2000a6c4:	6039      	str	r1, [r7, #0]
  uint32_t bsyflag;
  uint32_t tickstart = HAL_GetTick();
2000a6c6:	f7f7 fb11 	bl	20001cec <HAL_GetTick>
2000a6ca:	60b8      	str	r0, [r7, #8]

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
2000a6cc:	683b      	ldr	r3, [r7, #0]
2000a6ce:	2b01      	cmp	r3, #1
2000a6d0:	d007      	beq.n	2000a6e2 <FLASH_CRC_WaitForLastOperation+0x26>
2000a6d2:	683b      	ldr	r3, [r7, #0]
2000a6d4:	2b02      	cmp	r3, #2
2000a6d6:	d004      	beq.n	2000a6e2 <FLASH_CRC_WaitForLastOperation+0x26>
2000a6d8:	f240 4105 	movw	r1, #1029	; 0x405
2000a6dc:	4836      	ldr	r0, [pc, #216]	; (2000a7b8 <FLASH_CRC_WaitForLastOperation+0xfc>)
2000a6de:	f7f6 f909 	bl	200008f4 <assert_failed>

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
2000a6e2:	683b      	ldr	r3, [r7, #0]
2000a6e4:	2b01      	cmp	r3, #1
2000a6e6:	d102      	bne.n	2000a6ee <FLASH_CRC_WaitForLastOperation+0x32>
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK1;
2000a6e8:	2308      	movs	r3, #8
2000a6ea:	60fb      	str	r3, [r7, #12]
2000a6ec:	e013      	b.n	2000a716 <FLASH_CRC_WaitForLastOperation+0x5a>
  }
  else
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;
2000a6ee:	4b33      	ldr	r3, [pc, #204]	; (2000a7bc <FLASH_CRC_WaitForLastOperation+0x100>)
2000a6f0:	60fb      	str	r3, [r7, #12]
  }

  /* Wait for the FLASH CRC computation to complete by polling on CRC_BUSY flag to be reset */
  while(__HAL_FLASH_GET_FLAG(bsyflag))
2000a6f2:	e010      	b.n	2000a716 <FLASH_CRC_WaitForLastOperation+0x5a>
  {
    if(Timeout != HAL_MAX_DELAY)
2000a6f4:	687b      	ldr	r3, [r7, #4]
2000a6f6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
2000a6fa:	d00c      	beq.n	2000a716 <FLASH_CRC_WaitForLastOperation+0x5a>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2000a6fc:	f7f7 faf6 	bl	20001cec <HAL_GetTick>
2000a700:	4602      	mov	r2, r0
2000a702:	68bb      	ldr	r3, [r7, #8]
2000a704:	1ad3      	subs	r3, r2, r3
2000a706:	687a      	ldr	r2, [r7, #4]
2000a708:	429a      	cmp	r2, r3
2000a70a:	d302      	bcc.n	2000a712 <FLASH_CRC_WaitForLastOperation+0x56>
2000a70c:	687b      	ldr	r3, [r7, #4]
2000a70e:	2b00      	cmp	r3, #0
2000a710:	d101      	bne.n	2000a716 <FLASH_CRC_WaitForLastOperation+0x5a>
      {
        return HAL_TIMEOUT;
2000a712:	2303      	movs	r3, #3
2000a714:	e04b      	b.n	2000a7ae <FLASH_CRC_WaitForLastOperation+0xf2>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
2000a716:	68fa      	ldr	r2, [r7, #12]
2000a718:	4b29      	ldr	r3, [pc, #164]	; (2000a7c0 <FLASH_CRC_WaitForLastOperation+0x104>)
2000a71a:	4013      	ands	r3, r2
2000a71c:	68fa      	ldr	r2, [r7, #12]
2000a71e:	429a      	cmp	r2, r3
2000a720:	d10a      	bne.n	2000a738 <FLASH_CRC_WaitForLastOperation+0x7c>
2000a722:	4b28      	ldr	r3, [pc, #160]	; (2000a7c4 <FLASH_CRC_WaitForLastOperation+0x108>)
2000a724:	691a      	ldr	r2, [r3, #16]
2000a726:	68fb      	ldr	r3, [r7, #12]
2000a728:	4013      	ands	r3, r2
2000a72a:	68fa      	ldr	r2, [r7, #12]
2000a72c:	429a      	cmp	r2, r3
2000a72e:	bf0c      	ite	eq
2000a730:	2301      	moveq	r3, #1
2000a732:	2300      	movne	r3, #0
2000a734:	b2db      	uxtb	r3, r3
2000a736:	e00c      	b.n	2000a752 <FLASH_CRC_WaitForLastOperation+0x96>
2000a738:	4b22      	ldr	r3, [pc, #136]	; (2000a7c4 <FLASH_CRC_WaitForLastOperation+0x108>)
2000a73a:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
2000a73e:	43da      	mvns	r2, r3
2000a740:	68fb      	ldr	r3, [r7, #12]
2000a742:	4013      	ands	r3, r2
2000a744:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
2000a748:	2b00      	cmp	r3, #0
2000a74a:	bf0c      	ite	eq
2000a74c:	2301      	moveq	r3, #1
2000a74e:	2300      	movne	r3, #0
2000a750:	b2db      	uxtb	r3, r3
2000a752:	2b00      	cmp	r3, #0
2000a754:	d1ce      	bne.n	2000a6f4 <FLASH_CRC_WaitForLastOperation+0x38>
      }
    }
  }

  /* Check FLASH CRC read error flag  */
  if(Bank == FLASH_BANK_1)
2000a756:	683b      	ldr	r3, [r7, #0]
2000a758:	2b01      	cmp	r3, #1
2000a75a:	d112      	bne.n	2000a782 <FLASH_CRC_WaitForLastOperation+0xc6>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1))
2000a75c:	4b19      	ldr	r3, [pc, #100]	; (2000a7c4 <FLASH_CRC_WaitForLastOperation+0x108>)
2000a75e:	691b      	ldr	r3, [r3, #16]
2000a760:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000a764:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2000a768:	d120      	bne.n	2000a7ac <FLASH_CRC_WaitForLastOperation+0xf0>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK1;
2000a76a:	4b17      	ldr	r3, [pc, #92]	; (2000a7c8 <FLASH_CRC_WaitForLastOperation+0x10c>)
2000a76c:	699b      	ldr	r3, [r3, #24]
2000a76e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2000a772:	4a15      	ldr	r2, [pc, #84]	; (2000a7c8 <FLASH_CRC_WaitForLastOperation+0x10c>)
2000a774:	6193      	str	r3, [r2, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1);
2000a776:	4b13      	ldr	r3, [pc, #76]	; (2000a7c4 <FLASH_CRC_WaitForLastOperation+0x108>)
2000a778:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
2000a77c:	615a      	str	r2, [r3, #20]

      return HAL_ERROR;
2000a77e:	2301      	movs	r3, #1
2000a780:	e015      	b.n	2000a7ae <FLASH_CRC_WaitForLastOperation+0xf2>
    }
  }
  else
  {
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2))
2000a782:	4b10      	ldr	r3, [pc, #64]	; (2000a7c4 <FLASH_CRC_WaitForLastOperation+0x108>)
2000a784:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
2000a788:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000a78c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2000a790:	d10c      	bne.n	2000a7ac <FLASH_CRC_WaitForLastOperation+0xf0>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK2;
2000a792:	4b0d      	ldr	r3, [pc, #52]	; (2000a7c8 <FLASH_CRC_WaitForLastOperation+0x10c>)
2000a794:	699b      	ldr	r3, [r3, #24]
2000a796:	f043 4310 	orr.w	r3, r3, #2415919104	; 0x90000000
2000a79a:	4a0b      	ldr	r2, [pc, #44]	; (2000a7c8 <FLASH_CRC_WaitForLastOperation+0x10c>)
2000a79c:	6193      	str	r3, [r2, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2);
2000a79e:	4b09      	ldr	r3, [pc, #36]	; (2000a7c4 <FLASH_CRC_WaitForLastOperation+0x108>)
2000a7a0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
2000a7a4:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

      return HAL_ERROR;
2000a7a8:	2301      	movs	r3, #1
2000a7aa:	e000      	b.n	2000a7ae <FLASH_CRC_WaitForLastOperation+0xf2>
    }
  }

  /* If there is no error flag set */
  return HAL_OK;
2000a7ac:	2300      	movs	r3, #0
}
2000a7ae:	4618      	mov	r0, r3
2000a7b0:	3710      	adds	r7, #16
2000a7b2:	46bd      	mov	sp, r7
2000a7b4:	bd80      	pop	{r7, pc}
2000a7b6:	bf00      	nop
2000a7b8:	2001c08c 	.word	0x2001c08c
2000a7bc:	80000008 	.word	0x80000008
2000a7c0:	1fef000f 	.word	0x1fef000f
2000a7c4:	52002000 	.word	0x52002000
2000a7c8:	2001ca60 	.word	0x2001ca60

2000a7cc <HAL_FLASHEx_Erase>:
  *          the sectors have been correctly erased)
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
2000a7cc:	b580      	push	{r7, lr}
2000a7ce:	b084      	sub	sp, #16
2000a7d0:	af00      	add	r7, sp, #0
2000a7d2:	6078      	str	r0, [r7, #4]
2000a7d4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2000a7d6:	2300      	movs	r3, #0
2000a7d8:	73fb      	strb	r3, [r7, #15]
  uint32_t sector_index;

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
2000a7da:	687b      	ldr	r3, [r7, #4]
2000a7dc:	681b      	ldr	r3, [r3, #0]
2000a7de:	2b00      	cmp	r3, #0
2000a7e0:	d007      	beq.n	2000a7f2 <HAL_FLASHEx_Erase+0x26>
2000a7e2:	687b      	ldr	r3, [r7, #4]
2000a7e4:	681b      	ldr	r3, [r3, #0]
2000a7e6:	2b01      	cmp	r3, #1
2000a7e8:	d003      	beq.n	2000a7f2 <HAL_FLASHEx_Erase+0x26>
2000a7ea:	21ac      	movs	r1, #172	; 0xac
2000a7ec:	4867      	ldr	r0, [pc, #412]	; (2000a98c <HAL_FLASHEx_Erase+0x1c0>)
2000a7ee:	f7f6 f881 	bl	200008f4 <assert_failed>
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
2000a7f2:	687b      	ldr	r3, [r7, #4]
2000a7f4:	685b      	ldr	r3, [r3, #4]
2000a7f6:	2b01      	cmp	r3, #1
2000a7f8:	d00b      	beq.n	2000a812 <HAL_FLASHEx_Erase+0x46>
2000a7fa:	687b      	ldr	r3, [r7, #4]
2000a7fc:	685b      	ldr	r3, [r3, #4]
2000a7fe:	2b02      	cmp	r3, #2
2000a800:	d007      	beq.n	2000a812 <HAL_FLASHEx_Erase+0x46>
2000a802:	687b      	ldr	r3, [r7, #4]
2000a804:	685b      	ldr	r3, [r3, #4]
2000a806:	2b03      	cmp	r3, #3
2000a808:	d003      	beq.n	2000a812 <HAL_FLASHEx_Erase+0x46>
2000a80a:	21ad      	movs	r1, #173	; 0xad
2000a80c:	485f      	ldr	r0, [pc, #380]	; (2000a98c <HAL_FLASHEx_Erase+0x1c0>)
2000a80e:	f7f6 f871 	bl	200008f4 <assert_failed>

  /* Process Locked */
  __HAL_LOCK(&pFlash);
2000a812:	4b5f      	ldr	r3, [pc, #380]	; (2000a990 <HAL_FLASHEx_Erase+0x1c4>)
2000a814:	7d1b      	ldrb	r3, [r3, #20]
2000a816:	2b01      	cmp	r3, #1
2000a818:	d101      	bne.n	2000a81e <HAL_FLASHEx_Erase+0x52>
2000a81a:	2302      	movs	r3, #2
2000a81c:	e0b2      	b.n	2000a984 <HAL_FLASHEx_Erase+0x1b8>
2000a81e:	4b5c      	ldr	r3, [pc, #368]	; (2000a990 <HAL_FLASHEx_Erase+0x1c4>)
2000a820:	2201      	movs	r2, #1
2000a822:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
2000a824:	4b5a      	ldr	r3, [pc, #360]	; (2000a990 <HAL_FLASHEx_Erase+0x1c4>)
2000a826:	2200      	movs	r2, #0
2000a828:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed on Bank1 */
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000a82a:	687b      	ldr	r3, [r7, #4]
2000a82c:	685b      	ldr	r3, [r3, #4]
2000a82e:	f003 0301 	and.w	r3, r3, #1
2000a832:	2b00      	cmp	r3, #0
2000a834:	d009      	beq.n	2000a84a <HAL_FLASHEx_Erase+0x7e>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
2000a836:	2101      	movs	r1, #1
2000a838:	f24c 3050 	movw	r0, #50000	; 0xc350
2000a83c:	f7ff fe5a 	bl	2000a4f4 <FLASH_WaitForLastOperation>
2000a840:	4603      	mov	r3, r0
2000a842:	2b00      	cmp	r3, #0
2000a844:	d001      	beq.n	2000a84a <HAL_FLASHEx_Erase+0x7e>
    {
      status = HAL_ERROR;
2000a846:	2301      	movs	r3, #1
2000a848:	73fb      	strb	r3, [r7, #15]
    }
  }

  /* Wait for last operation to be completed on Bank2 */
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000a84a:	687b      	ldr	r3, [r7, #4]
2000a84c:	685b      	ldr	r3, [r3, #4]
2000a84e:	f003 0302 	and.w	r3, r3, #2
2000a852:	2b00      	cmp	r3, #0
2000a854:	d009      	beq.n	2000a86a <HAL_FLASHEx_Erase+0x9e>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
2000a856:	2102      	movs	r1, #2
2000a858:	f24c 3050 	movw	r0, #50000	; 0xc350
2000a85c:	f7ff fe4a 	bl	2000a4f4 <FLASH_WaitForLastOperation>
2000a860:	4603      	mov	r3, r0
2000a862:	2b00      	cmp	r3, #0
2000a864:	d001      	beq.n	2000a86a <HAL_FLASHEx_Erase+0x9e>
    {
      status = HAL_ERROR;
2000a866:	2301      	movs	r3, #1
2000a868:	73fb      	strb	r3, [r7, #15]
    }
  }

  if(status == HAL_OK)
2000a86a:	7bfb      	ldrb	r3, [r7, #15]
2000a86c:	2b00      	cmp	r3, #0
2000a86e:	f040 8085 	bne.w	2000a97c <HAL_FLASHEx_Erase+0x1b0>
  {
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
2000a872:	687b      	ldr	r3, [r7, #4]
2000a874:	681b      	ldr	r3, [r3, #0]
2000a876:	2b01      	cmp	r3, #1
2000a878:	d136      	bne.n	2000a8e8 <HAL_FLASHEx_Erase+0x11c>
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
2000a87a:	687b      	ldr	r3, [r7, #4]
2000a87c:	691a      	ldr	r2, [r3, #16]
2000a87e:	687b      	ldr	r3, [r7, #4]
2000a880:	685b      	ldr	r3, [r3, #4]
2000a882:	4619      	mov	r1, r3
2000a884:	4610      	mov	r0, r2
2000a886:	f000 fbf7 	bl	2000b078 <FLASH_MassErase>

      /* Wait for last operation to be completed */
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000a88a:	687b      	ldr	r3, [r7, #4]
2000a88c:	685b      	ldr	r3, [r3, #4]
2000a88e:	f003 0301 	and.w	r3, r3, #1
2000a892:	2b00      	cmp	r3, #0
2000a894:	d00f      	beq.n	2000a8b6 <HAL_FLASHEx_Erase+0xea>
      {
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
2000a896:	2101      	movs	r1, #1
2000a898:	f24c 3050 	movw	r0, #50000	; 0xc350
2000a89c:	f7ff fe2a 	bl	2000a4f4 <FLASH_WaitForLastOperation>
2000a8a0:	4603      	mov	r3, r0
2000a8a2:	2b00      	cmp	r3, #0
2000a8a4:	d001      	beq.n	2000a8aa <HAL_FLASHEx_Erase+0xde>
        {
          status = HAL_ERROR;
2000a8a6:	2301      	movs	r3, #1
2000a8a8:	73fb      	strb	r3, [r7, #15]
        }
        /* if the erase operation is completed, disable the Bank1 BER Bit */
        FLASH->CR1 &= (~FLASH_CR_BER);
2000a8aa:	4b3a      	ldr	r3, [pc, #232]	; (2000a994 <HAL_FLASHEx_Erase+0x1c8>)
2000a8ac:	68db      	ldr	r3, [r3, #12]
2000a8ae:	4a39      	ldr	r2, [pc, #228]	; (2000a994 <HAL_FLASHEx_Erase+0x1c8>)
2000a8b0:	f023 0308 	bic.w	r3, r3, #8
2000a8b4:	60d3      	str	r3, [r2, #12]
      }
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000a8b6:	687b      	ldr	r3, [r7, #4]
2000a8b8:	685b      	ldr	r3, [r3, #4]
2000a8ba:	f003 0302 	and.w	r3, r3, #2
2000a8be:	2b00      	cmp	r3, #0
2000a8c0:	d05c      	beq.n	2000a97c <HAL_FLASHEx_Erase+0x1b0>
      {
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
2000a8c2:	2102      	movs	r1, #2
2000a8c4:	f24c 3050 	movw	r0, #50000	; 0xc350
2000a8c8:	f7ff fe14 	bl	2000a4f4 <FLASH_WaitForLastOperation>
2000a8cc:	4603      	mov	r3, r0
2000a8ce:	2b00      	cmp	r3, #0
2000a8d0:	d001      	beq.n	2000a8d6 <HAL_FLASHEx_Erase+0x10a>
        {
          status = HAL_ERROR;
2000a8d2:	2301      	movs	r3, #1
2000a8d4:	73fb      	strb	r3, [r7, #15]
        }
        /* if the erase operation is completed, disable the Bank2 BER Bit */
        FLASH->CR2 &= (~FLASH_CR_BER);
2000a8d6:	4b2f      	ldr	r3, [pc, #188]	; (2000a994 <HAL_FLASHEx_Erase+0x1c8>)
2000a8d8:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000a8dc:	4a2d      	ldr	r2, [pc, #180]	; (2000a994 <HAL_FLASHEx_Erase+0x1c8>)
2000a8de:	f023 0308 	bic.w	r3, r3, #8
2000a8e2:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
2000a8e6:	e049      	b.n	2000a97c <HAL_FLASHEx_Erase+0x1b0>
      }
    }
    else
    {
      /*Initialization of SectorError variable*/
      *SectorError = 0xFFFFFFFFU;
2000a8e8:	683b      	ldr	r3, [r7, #0]
2000a8ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
2000a8ee:	601a      	str	r2, [r3, #0]

      /* Erase by sector by sector to be done*/
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
2000a8f0:	687b      	ldr	r3, [r7, #4]
2000a8f2:	689b      	ldr	r3, [r3, #8]
2000a8f4:	60bb      	str	r3, [r7, #8]
2000a8f6:	e039      	b.n	2000a96c <HAL_FLASHEx_Erase+0x1a0>
      {
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
2000a8f8:	687b      	ldr	r3, [r7, #4]
2000a8fa:	6859      	ldr	r1, [r3, #4]
2000a8fc:	687b      	ldr	r3, [r7, #4]
2000a8fe:	691b      	ldr	r3, [r3, #16]
2000a900:	461a      	mov	r2, r3
2000a902:	68b8      	ldr	r0, [r7, #8]
2000a904:	f000 fc40 	bl	2000b188 <FLASH_Erase_Sector>

        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000a908:	687b      	ldr	r3, [r7, #4]
2000a90a:	685b      	ldr	r3, [r3, #4]
2000a90c:	f003 0301 	and.w	r3, r3, #1
2000a910:	2b00      	cmp	r3, #0
2000a912:	d00c      	beq.n	2000a92e <HAL_FLASHEx_Erase+0x162>
        {
          /* Wait for last operation to be completed */
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
2000a914:	2101      	movs	r1, #1
2000a916:	f24c 3050 	movw	r0, #50000	; 0xc350
2000a91a:	f7ff fdeb 	bl	2000a4f4 <FLASH_WaitForLastOperation>
2000a91e:	4603      	mov	r3, r0
2000a920:	73fb      	strb	r3, [r7, #15]

          /* If the erase operation is completed, disable the SER Bit */
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
2000a922:	4b1c      	ldr	r3, [pc, #112]	; (2000a994 <HAL_FLASHEx_Erase+0x1c8>)
2000a924:	68da      	ldr	r2, [r3, #12]
2000a926:	491b      	ldr	r1, [pc, #108]	; (2000a994 <HAL_FLASHEx_Erase+0x1c8>)
2000a928:	4b1b      	ldr	r3, [pc, #108]	; (2000a998 <HAL_FLASHEx_Erase+0x1cc>)
2000a92a:	4013      	ands	r3, r2
2000a92c:	60cb      	str	r3, [r1, #12]
        }
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000a92e:	687b      	ldr	r3, [r7, #4]
2000a930:	685b      	ldr	r3, [r3, #4]
2000a932:	f003 0302 	and.w	r3, r3, #2
2000a936:	2b00      	cmp	r3, #0
2000a938:	d00e      	beq.n	2000a958 <HAL_FLASHEx_Erase+0x18c>
        {
          /* Wait for last operation to be completed */
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
2000a93a:	2102      	movs	r1, #2
2000a93c:	f24c 3050 	movw	r0, #50000	; 0xc350
2000a940:	f7ff fdd8 	bl	2000a4f4 <FLASH_WaitForLastOperation>
2000a944:	4603      	mov	r3, r0
2000a946:	73fb      	strb	r3, [r7, #15]

          /* If the erase operation is completed, disable the SER Bit */
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
2000a948:	4b12      	ldr	r3, [pc, #72]	; (2000a994 <HAL_FLASHEx_Erase+0x1c8>)
2000a94a:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
2000a94e:	4911      	ldr	r1, [pc, #68]	; (2000a994 <HAL_FLASHEx_Erase+0x1c8>)
2000a950:	4b11      	ldr	r3, [pc, #68]	; (2000a998 <HAL_FLASHEx_Erase+0x1cc>)
2000a952:	4013      	ands	r3, r2
2000a954:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
        }

        if(status != HAL_OK)
2000a958:	7bfb      	ldrb	r3, [r7, #15]
2000a95a:	2b00      	cmp	r3, #0
2000a95c:	d003      	beq.n	2000a966 <HAL_FLASHEx_Erase+0x19a>
        {
          /* In case of error, stop erase procedure and return the faulty sector */
          *SectorError = sector_index;
2000a95e:	683b      	ldr	r3, [r7, #0]
2000a960:	68ba      	ldr	r2, [r7, #8]
2000a962:	601a      	str	r2, [r3, #0]
          break;
2000a964:	e00a      	b.n	2000a97c <HAL_FLASHEx_Erase+0x1b0>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
2000a966:	68bb      	ldr	r3, [r7, #8]
2000a968:	3301      	adds	r3, #1
2000a96a:	60bb      	str	r3, [r7, #8]
2000a96c:	687b      	ldr	r3, [r7, #4]
2000a96e:	68da      	ldr	r2, [r3, #12]
2000a970:	687b      	ldr	r3, [r7, #4]
2000a972:	689b      	ldr	r3, [r3, #8]
2000a974:	4413      	add	r3, r2
2000a976:	68ba      	ldr	r2, [r7, #8]
2000a978:	429a      	cmp	r2, r3
2000a97a:	d3bd      	bcc.n	2000a8f8 <HAL_FLASHEx_Erase+0x12c>
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
2000a97c:	4b04      	ldr	r3, [pc, #16]	; (2000a990 <HAL_FLASHEx_Erase+0x1c4>)
2000a97e:	2200      	movs	r2, #0
2000a980:	751a      	strb	r2, [r3, #20]

  return status;
2000a982:	7bfb      	ldrb	r3, [r7, #15]
}
2000a984:	4618      	mov	r0, r3
2000a986:	3710      	adds	r7, #16
2000a988:	46bd      	mov	sp, r7
2000a98a:	bd80      	pop	{r7, pc}
2000a98c:	2001c0c8 	.word	0x2001c0c8
2000a990:	2001ca60 	.word	0x2001ca60
2000a994:	52002000 	.word	0x52002000
2000a998:	fffff8fb 	.word	0xfffff8fb

2000a99c <HAL_FLASHEx_Erase_IT>:
  *         contains the configuration information for the erasing.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
{
2000a99c:	b580      	push	{r7, lr}
2000a99e:	b084      	sub	sp, #16
2000a9a0:	af00      	add	r7, sp, #0
2000a9a2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2000a9a4:	2300      	movs	r3, #0
2000a9a6:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
2000a9a8:	687b      	ldr	r3, [r7, #4]
2000a9aa:	681b      	ldr	r3, [r3, #0]
2000a9ac:	2b00      	cmp	r3, #0
2000a9ae:	d008      	beq.n	2000a9c2 <HAL_FLASHEx_Erase_IT+0x26>
2000a9b0:	687b      	ldr	r3, [r7, #4]
2000a9b2:	681b      	ldr	r3, [r3, #0]
2000a9b4:	2b01      	cmp	r3, #1
2000a9b6:	d004      	beq.n	2000a9c2 <HAL_FLASHEx_Erase_IT+0x26>
2000a9b8:	f240 1119 	movw	r1, #281	; 0x119
2000a9bc:	4852      	ldr	r0, [pc, #328]	; (2000ab08 <HAL_FLASHEx_Erase_IT+0x16c>)
2000a9be:	f7f5 ff99 	bl	200008f4 <assert_failed>
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
2000a9c2:	687b      	ldr	r3, [r7, #4]
2000a9c4:	685b      	ldr	r3, [r3, #4]
2000a9c6:	2b01      	cmp	r3, #1
2000a9c8:	d00c      	beq.n	2000a9e4 <HAL_FLASHEx_Erase_IT+0x48>
2000a9ca:	687b      	ldr	r3, [r7, #4]
2000a9cc:	685b      	ldr	r3, [r3, #4]
2000a9ce:	2b02      	cmp	r3, #2
2000a9d0:	d008      	beq.n	2000a9e4 <HAL_FLASHEx_Erase_IT+0x48>
2000a9d2:	687b      	ldr	r3, [r7, #4]
2000a9d4:	685b      	ldr	r3, [r3, #4]
2000a9d6:	2b03      	cmp	r3, #3
2000a9d8:	d004      	beq.n	2000a9e4 <HAL_FLASHEx_Erase_IT+0x48>
2000a9da:	f44f 718d 	mov.w	r1, #282	; 0x11a
2000a9de:	484a      	ldr	r0, [pc, #296]	; (2000ab08 <HAL_FLASHEx_Erase_IT+0x16c>)
2000a9e0:	f7f5 ff88 	bl	200008f4 <assert_failed>

  /* Process Locked */
  __HAL_LOCK(&pFlash);
2000a9e4:	4b49      	ldr	r3, [pc, #292]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000a9e6:	7d1b      	ldrb	r3, [r3, #20]
2000a9e8:	2b01      	cmp	r3, #1
2000a9ea:	d101      	bne.n	2000a9f0 <HAL_FLASHEx_Erase_IT+0x54>
2000a9ec:	2302      	movs	r3, #2
2000a9ee:	e087      	b.n	2000ab00 <HAL_FLASHEx_Erase_IT+0x164>
2000a9f0:	4b46      	ldr	r3, [pc, #280]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000a9f2:	2201      	movs	r2, #1
2000a9f4:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
2000a9f6:	4b45      	ldr	r3, [pc, #276]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000a9f8:	2200      	movs	r2, #0
2000a9fa:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000a9fc:	687b      	ldr	r3, [r7, #4]
2000a9fe:	685b      	ldr	r3, [r3, #4]
2000aa00:	f003 0301 	and.w	r3, r3, #1
2000aa04:	2b00      	cmp	r3, #0
2000aa06:	d009      	beq.n	2000aa1c <HAL_FLASHEx_Erase_IT+0x80>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
2000aa08:	2101      	movs	r1, #1
2000aa0a:	f24c 3050 	movw	r0, #50000	; 0xc350
2000aa0e:	f7ff fd71 	bl	2000a4f4 <FLASH_WaitForLastOperation>
2000aa12:	4603      	mov	r3, r0
2000aa14:	2b00      	cmp	r3, #0
2000aa16:	d001      	beq.n	2000aa1c <HAL_FLASHEx_Erase_IT+0x80>
    {
      status = HAL_ERROR;
2000aa18:	2301      	movs	r3, #1
2000aa1a:	73fb      	strb	r3, [r7, #15]
    }
  }

  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000aa1c:	687b      	ldr	r3, [r7, #4]
2000aa1e:	685b      	ldr	r3, [r3, #4]
2000aa20:	f003 0302 	and.w	r3, r3, #2
2000aa24:	2b00      	cmp	r3, #0
2000aa26:	d009      	beq.n	2000aa3c <HAL_FLASHEx_Erase_IT+0xa0>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
2000aa28:	2102      	movs	r1, #2
2000aa2a:	f24c 3050 	movw	r0, #50000	; 0xc350
2000aa2e:	f7ff fd61 	bl	2000a4f4 <FLASH_WaitForLastOperation>
2000aa32:	4603      	mov	r3, r0
2000aa34:	2b00      	cmp	r3, #0
2000aa36:	d001      	beq.n	2000aa3c <HAL_FLASHEx_Erase_IT+0xa0>
    {
      status = HAL_ERROR;
2000aa38:	2301      	movs	r3, #1
2000aa3a:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (status != HAL_OK)
2000aa3c:	7bfb      	ldrb	r3, [r7, #15]
2000aa3e:	2b00      	cmp	r3, #0
2000aa40:	d003      	beq.n	2000aa4a <HAL_FLASHEx_Erase_IT+0xae>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
2000aa42:	4b32      	ldr	r3, [pc, #200]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000aa44:	2200      	movs	r2, #0
2000aa46:	751a      	strb	r2, [r3, #20]
2000aa48:	e059      	b.n	2000aafe <HAL_FLASHEx_Erase_IT+0x162>
  }
  else
  {
    if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000aa4a:	687b      	ldr	r3, [r7, #4]
2000aa4c:	685b      	ldr	r3, [r3, #4]
2000aa4e:	f003 0301 	and.w	r3, r3, #1
2000aa52:	2b00      	cmp	r3, #0
2000aa54:	d005      	beq.n	2000aa62 <HAL_FLASHEx_Erase_IT+0xc6>
    {
      /* Enable End of Operation and Error interrupts for Bank 1 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
2000aa56:	4b2e      	ldr	r3, [pc, #184]	; (2000ab10 <HAL_FLASHEx_Erase_IT+0x174>)
2000aa58:	68db      	ldr	r3, [r3, #12]
2000aa5a:	4a2d      	ldr	r2, [pc, #180]	; (2000ab10 <HAL_FLASHEx_Erase_IT+0x174>)
2000aa5c:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
2000aa60:	60d3      	str	r3, [r2, #12]
#else
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);
#endif /* FLASH_CR_OPERRIE */
    }
    if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000aa62:	687b      	ldr	r3, [r7, #4]
2000aa64:	685b      	ldr	r3, [r3, #4]
2000aa66:	f003 0302 	and.w	r3, r3, #2
2000aa6a:	2b00      	cmp	r3, #0
2000aa6c:	d007      	beq.n	2000aa7e <HAL_FLASHEx_Erase_IT+0xe2>
    {
      /* Enable End of Operation and Error interrupts for Bank 2 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
2000aa6e:	4b28      	ldr	r3, [pc, #160]	; (2000ab10 <HAL_FLASHEx_Erase_IT+0x174>)
2000aa70:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000aa74:	4a26      	ldr	r2, [pc, #152]	; (2000ab10 <HAL_FLASHEx_Erase_IT+0x174>)
2000aa76:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
2000aa7a:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* FLASH_CR_OPERRIE */
    }

    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
2000aa7e:	687b      	ldr	r3, [r7, #4]
2000aa80:	681b      	ldr	r3, [r3, #0]
2000aa82:	2b01      	cmp	r3, #1
2000aa84:	d11b      	bne.n	2000aabe <HAL_FLASHEx_Erase_IT+0x122>
    {
      /*Mass erase to be done*/
      if(pEraseInit->Banks == FLASH_BANK_1)
2000aa86:	687b      	ldr	r3, [r7, #4]
2000aa88:	685b      	ldr	r3, [r3, #4]
2000aa8a:	2b01      	cmp	r3, #1
2000aa8c:	d103      	bne.n	2000aa96 <HAL_FLASHEx_Erase_IT+0xfa>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK1;
2000aa8e:	4b1f      	ldr	r3, [pc, #124]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000aa90:	2202      	movs	r2, #2
2000aa92:	701a      	strb	r2, [r3, #0]
2000aa94:	e00a      	b.n	2000aaac <HAL_FLASHEx_Erase_IT+0x110>
      }
      else if(pEraseInit->Banks == FLASH_BANK_2)
2000aa96:	687b      	ldr	r3, [r7, #4]
2000aa98:	685b      	ldr	r3, [r3, #4]
2000aa9a:	2b02      	cmp	r3, #2
2000aa9c:	d103      	bne.n	2000aaa6 <HAL_FLASHEx_Erase_IT+0x10a>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK2;
2000aa9e:	4b1b      	ldr	r3, [pc, #108]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000aaa0:	2205      	movs	r2, #5
2000aaa2:	701a      	strb	r2, [r3, #0]
2000aaa4:	e002      	b.n	2000aaac <HAL_FLASHEx_Erase_IT+0x110>
      }
      else
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_ALLBANK_MASSERASE;
2000aaa6:	4b19      	ldr	r3, [pc, #100]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000aaa8:	2207      	movs	r2, #7
2000aaaa:	701a      	strb	r2, [r3, #0]
      }

      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
2000aaac:	687b      	ldr	r3, [r7, #4]
2000aaae:	691a      	ldr	r2, [r3, #16]
2000aab0:	687b      	ldr	r3, [r7, #4]
2000aab2:	685b      	ldr	r3, [r3, #4]
2000aab4:	4619      	mov	r1, r3
2000aab6:	4610      	mov	r0, r2
2000aab8:	f000 fade 	bl	2000b078 <FLASH_MassErase>
2000aabc:	e01f      	b.n	2000aafe <HAL_FLASHEx_Erase_IT+0x162>
    }
    else
    {
      /* Erase by sector to be done */
      if(pEraseInit->Banks == FLASH_BANK_1)
2000aabe:	687b      	ldr	r3, [r7, #4]
2000aac0:	685b      	ldr	r3, [r3, #4]
2000aac2:	2b01      	cmp	r3, #1
2000aac4:	d103      	bne.n	2000aace <HAL_FLASHEx_Erase_IT+0x132>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK1;
2000aac6:	4b11      	ldr	r3, [pc, #68]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000aac8:	2201      	movs	r2, #1
2000aaca:	701a      	strb	r2, [r3, #0]
2000aacc:	e002      	b.n	2000aad4 <HAL_FLASHEx_Erase_IT+0x138>
      }
      else
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK2;
2000aace:	4b0f      	ldr	r3, [pc, #60]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000aad0:	2204      	movs	r2, #4
2000aad2:	701a      	strb	r2, [r3, #0]
      }

      pFlash.NbSectorsToErase = pEraseInit->NbSectors;
2000aad4:	687b      	ldr	r3, [r7, #4]
2000aad6:	68db      	ldr	r3, [r3, #12]
2000aad8:	4a0c      	ldr	r2, [pc, #48]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000aada:	6053      	str	r3, [r2, #4]
      pFlash.Sector = pEraseInit->Sector;
2000aadc:	687b      	ldr	r3, [r7, #4]
2000aade:	689b      	ldr	r3, [r3, #8]
2000aae0:	4a0a      	ldr	r2, [pc, #40]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000aae2:	60d3      	str	r3, [r2, #12]
      pFlash.VoltageForErase = pEraseInit->VoltageRange;
2000aae4:	687b      	ldr	r3, [r7, #4]
2000aae6:	691b      	ldr	r3, [r3, #16]
2000aae8:	4a08      	ldr	r2, [pc, #32]	; (2000ab0c <HAL_FLASHEx_Erase_IT+0x170>)
2000aaea:	6093      	str	r3, [r2, #8]

      /* Erase first sector and wait for IT */
      FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->Banks, pEraseInit->VoltageRange);
2000aaec:	687b      	ldr	r3, [r7, #4]
2000aaee:	6898      	ldr	r0, [r3, #8]
2000aaf0:	687b      	ldr	r3, [r7, #4]
2000aaf2:	6859      	ldr	r1, [r3, #4]
2000aaf4:	687b      	ldr	r3, [r7, #4]
2000aaf6:	691b      	ldr	r3, [r3, #16]
2000aaf8:	461a      	mov	r2, r3
2000aafa:	f000 fb45 	bl	2000b188 <FLASH_Erase_Sector>
    }
  }

  return status;
2000aafe:	7bfb      	ldrb	r3, [r7, #15]
}
2000ab00:	4618      	mov	r0, r3
2000ab02:	3710      	adds	r7, #16
2000ab04:	46bd      	mov	sp, r7
2000ab06:	bd80      	pop	{r7, pc}
2000ab08:	2001c0c8 	.word	0x2001c0c8
2000ab0c:	2001ca60 	.word	0x2001ca60
2000ab10:	52002000 	.word	0x52002000

2000ab14 <HAL_FLASHEx_OBProgram>:
  *         contains the configuration information for the programming.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
2000ab14:	b580      	push	{r7, lr}
2000ab16:	b084      	sub	sp, #16
2000ab18:	af00      	add	r7, sp, #0
2000ab1a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;

  /* Check the parameters */
  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
2000ab1c:	687b      	ldr	r3, [r7, #4]
2000ab1e:	681b      	ldr	r3, [r3, #0]
2000ab20:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2000ab24:	d203      	bcs.n	2000ab2e <HAL_FLASHEx_OBProgram+0x1a>
2000ab26:	687b      	ldr	r3, [r7, #4]
2000ab28:	681b      	ldr	r3, [r3, #0]
2000ab2a:	2b00      	cmp	r3, #0
2000ab2c:	d104      	bne.n	2000ab38 <HAL_FLASHEx_OBProgram+0x24>
2000ab2e:	f240 1187 	movw	r1, #391	; 0x187
2000ab32:	485f      	ldr	r0, [pc, #380]	; (2000acb0 <HAL_FLASHEx_OBProgram+0x19c>)
2000ab34:	f7f5 fede 	bl	200008f4 <assert_failed>

  /* Process Locked */
  __HAL_LOCK(&pFlash);
2000ab38:	4b5e      	ldr	r3, [pc, #376]	; (2000acb4 <HAL_FLASHEx_OBProgram+0x1a0>)
2000ab3a:	7d1b      	ldrb	r3, [r3, #20]
2000ab3c:	2b01      	cmp	r3, #1
2000ab3e:	d101      	bne.n	2000ab44 <HAL_FLASHEx_OBProgram+0x30>
2000ab40:	2302      	movs	r3, #2
2000ab42:	e0b1      	b.n	2000aca8 <HAL_FLASHEx_OBProgram+0x194>
2000ab44:	4b5b      	ldr	r3, [pc, #364]	; (2000acb4 <HAL_FLASHEx_OBProgram+0x1a0>)
2000ab46:	2201      	movs	r2, #1
2000ab48:	751a      	strb	r2, [r3, #20]

  /* Reset Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
2000ab4a:	4b5a      	ldr	r3, [pc, #360]	; (2000acb4 <HAL_FLASHEx_OBProgram+0x1a0>)
2000ab4c:	2200      	movs	r2, #0
2000ab4e:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
2000ab50:	2101      	movs	r1, #1
2000ab52:	f24c 3050 	movw	r0, #50000	; 0xc350
2000ab56:	f7ff fccd 	bl	2000a4f4 <FLASH_WaitForLastOperation>
2000ab5a:	4603      	mov	r3, r0
2000ab5c:	2b00      	cmp	r3, #0
2000ab5e:	d002      	beq.n	2000ab66 <HAL_FLASHEx_OBProgram+0x52>
  {
    status = HAL_ERROR;
2000ab60:	2301      	movs	r3, #1
2000ab62:	73fb      	strb	r3, [r7, #15]
2000ab64:	e00c      	b.n	2000ab80 <HAL_FLASHEx_OBProgram+0x6c>
  }
  else if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
2000ab66:	2102      	movs	r1, #2
2000ab68:	f24c 3050 	movw	r0, #50000	; 0xc350
2000ab6c:	f7ff fcc2 	bl	2000a4f4 <FLASH_WaitForLastOperation>
2000ab70:	4603      	mov	r3, r0
2000ab72:	2b00      	cmp	r3, #0
2000ab74:	d002      	beq.n	2000ab7c <HAL_FLASHEx_OBProgram+0x68>
  {
    status = HAL_ERROR;
2000ab76:	2301      	movs	r3, #1
2000ab78:	73fb      	strb	r3, [r7, #15]
2000ab7a:	e001      	b.n	2000ab80 <HAL_FLASHEx_OBProgram+0x6c>
  }
  else
  {
    status = HAL_OK;
2000ab7c:	2300      	movs	r3, #0
2000ab7e:	73fb      	strb	r3, [r7, #15]
  }

  if(status == HAL_OK)
2000ab80:	7bfb      	ldrb	r3, [r7, #15]
2000ab82:	2b00      	cmp	r3, #0
2000ab84:	f040 808c 	bne.w	2000aca0 <HAL_FLASHEx_OBProgram+0x18c>
  {
    /*Write protection configuration*/
    if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
2000ab88:	687b      	ldr	r3, [r7, #4]
2000ab8a:	681b      	ldr	r3, [r3, #0]
2000ab8c:	f003 0301 	and.w	r3, r3, #1
2000ab90:	2b00      	cmp	r3, #0
2000ab92:	d021      	beq.n	2000abd8 <HAL_FLASHEx_OBProgram+0xc4>
    {
      assert_param(IS_WRPSTATE(pOBInit->WRPState));
2000ab94:	687b      	ldr	r3, [r7, #4]
2000ab96:	685b      	ldr	r3, [r3, #4]
2000ab98:	2b00      	cmp	r3, #0
2000ab9a:	d008      	beq.n	2000abae <HAL_FLASHEx_OBProgram+0x9a>
2000ab9c:	687b      	ldr	r3, [r7, #4]
2000ab9e:	685b      	ldr	r3, [r3, #4]
2000aba0:	2b01      	cmp	r3, #1
2000aba2:	d004      	beq.n	2000abae <HAL_FLASHEx_OBProgram+0x9a>
2000aba4:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
2000aba8:	4841      	ldr	r0, [pc, #260]	; (2000acb0 <HAL_FLASHEx_OBProgram+0x19c>)
2000abaa:	f7f5 fea3 	bl	200008f4 <assert_failed>

      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
2000abae:	687b      	ldr	r3, [r7, #4]
2000abb0:	685b      	ldr	r3, [r3, #4]
2000abb2:	2b01      	cmp	r3, #1
2000abb4:	d108      	bne.n	2000abc8 <HAL_FLASHEx_OBProgram+0xb4>
      {
        /*Enable of Write protection on the selected Sector*/
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
2000abb6:	687b      	ldr	r3, [r7, #4]
2000abb8:	689a      	ldr	r2, [r3, #8]
2000abba:	687b      	ldr	r3, [r7, #4]
2000abbc:	69db      	ldr	r3, [r3, #28]
2000abbe:	4619      	mov	r1, r3
2000abc0:	4610      	mov	r0, r2
2000abc2:	f000 fb43 	bl	2000b24c <FLASH_OB_EnableWRP>
2000abc6:	e007      	b.n	2000abd8 <HAL_FLASHEx_OBProgram+0xc4>
      }
      else
      {
        /*Disable of Write protection on the selected Sector*/
        FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);
2000abc8:	687b      	ldr	r3, [r7, #4]
2000abca:	689a      	ldr	r2, [r3, #8]
2000abcc:	687b      	ldr	r3, [r7, #4]
2000abce:	69db      	ldr	r3, [r3, #28]
2000abd0:	4619      	mov	r1, r3
2000abd2:	4610      	mov	r0, r2
2000abd4:	f000 fb7a 	bl	2000b2cc <FLASH_OB_DisableWRP>
      }
    }

    /* Read protection configuration */
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
2000abd8:	687b      	ldr	r3, [r7, #4]
2000abda:	681b      	ldr	r3, [r3, #0]
2000abdc:	f003 0302 	and.w	r3, r3, #2
2000abe0:	2b00      	cmp	r3, #0
2000abe2:	d004      	beq.n	2000abee <HAL_FLASHEx_OBProgram+0xda>
    {
      /* Configure the Read protection level */
      FLASH_OB_RDPConfig(pOBInit->RDPLevel);
2000abe4:	687b      	ldr	r3, [r7, #4]
2000abe6:	68db      	ldr	r3, [r3, #12]
2000abe8:	4618      	mov	r0, r3
2000abea:	f000 fbdf 	bl	2000b3ac <FLASH_OB_RDPConfig>
    }

    /* User Configuration */
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
2000abee:	687b      	ldr	r3, [r7, #4]
2000abf0:	681b      	ldr	r3, [r3, #0]
2000abf2:	f003 0304 	and.w	r3, r3, #4
2000abf6:	2b00      	cmp	r3, #0
2000abf8:	d007      	beq.n	2000ac0a <HAL_FLASHEx_OBProgram+0xf6>
    {
      /* Configure the user option bytes */
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
2000abfa:	687b      	ldr	r3, [r7, #4]
2000abfc:	695a      	ldr	r2, [r3, #20]
2000abfe:	687b      	ldr	r3, [r7, #4]
2000ac00:	699b      	ldr	r3, [r3, #24]
2000ac02:	4619      	mov	r1, r3
2000ac04:	4610      	mov	r0, r2
2000ac06:	f000 fc13 	bl	2000b430 <FLASH_OB_UserConfig>
    }

    /* PCROP Configuration */
    if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
2000ac0a:	687b      	ldr	r3, [r7, #4]
2000ac0c:	681b      	ldr	r3, [r3, #0]
2000ac0e:	f003 0308 	and.w	r3, r3, #8
2000ac12:	2b00      	cmp	r3, #0
2000ac14:	d01a      	beq.n	2000ac4c <HAL_FLASHEx_OBProgram+0x138>
    {
      assert_param(IS_FLASH_BANK(pOBInit->Banks));
2000ac16:	687b      	ldr	r3, [r7, #4]
2000ac18:	69db      	ldr	r3, [r3, #28]
2000ac1a:	2b01      	cmp	r3, #1
2000ac1c:	d00c      	beq.n	2000ac38 <HAL_FLASHEx_OBProgram+0x124>
2000ac1e:	687b      	ldr	r3, [r7, #4]
2000ac20:	69db      	ldr	r3, [r3, #28]
2000ac22:	2b02      	cmp	r3, #2
2000ac24:	d008      	beq.n	2000ac38 <HAL_FLASHEx_OBProgram+0x124>
2000ac26:	687b      	ldr	r3, [r7, #4]
2000ac28:	69db      	ldr	r3, [r3, #28]
2000ac2a:	2b03      	cmp	r3, #3
2000ac2c:	d004      	beq.n	2000ac38 <HAL_FLASHEx_OBProgram+0x124>
2000ac2e:	f240 11c1 	movw	r1, #449	; 0x1c1
2000ac32:	481f      	ldr	r0, [pc, #124]	; (2000acb0 <HAL_FLASHEx_OBProgram+0x19c>)
2000ac34:	f7f5 fe5e 	bl	200008f4 <assert_failed>

      /*Configure the Proprietary code readout protection */
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
2000ac38:	687b      	ldr	r3, [r7, #4]
2000ac3a:	6a18      	ldr	r0, [r3, #32]
2000ac3c:	687b      	ldr	r3, [r7, #4]
2000ac3e:	6a59      	ldr	r1, [r3, #36]	; 0x24
2000ac40:	687b      	ldr	r3, [r7, #4]
2000ac42:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2000ac44:	687b      	ldr	r3, [r7, #4]
2000ac46:	69db      	ldr	r3, [r3, #28]
2000ac48:	f000 fd46 	bl	2000b6d8 <FLASH_OB_PCROPConfig>
    }

    /* BOR Level configuration */
    if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
2000ac4c:	687b      	ldr	r3, [r7, #4]
2000ac4e:	681b      	ldr	r3, [r3, #0]
2000ac50:	f003 0310 	and.w	r3, r3, #16
2000ac54:	2b00      	cmp	r3, #0
2000ac56:	d004      	beq.n	2000ac62 <HAL_FLASHEx_OBProgram+0x14e>
    {
      FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
2000ac58:	687b      	ldr	r3, [r7, #4]
2000ac5a:	691b      	ldr	r3, [r3, #16]
2000ac5c:	4618      	mov	r0, r3
2000ac5e:	f000 fe07 	bl	2000b870 <FLASH_OB_BOR_LevelConfig>
    {
      FLASH_OB_CM4BootAddConfig(pOBInit->CM4BootConfig, pOBInit->CM4BootAddr0, pOBInit->CM4BootAddr1);
    }
#else /* Single Core*/
    /* Boot Address  configuration */
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADD) == OPTIONBYTE_BOOTADD)
2000ac62:	687b      	ldr	r3, [r7, #4]
2000ac64:	681b      	ldr	r3, [r3, #0]
2000ac66:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000ac6a:	2b00      	cmp	r3, #0
2000ac6c:	d008      	beq.n	2000ac80 <HAL_FLASHEx_OBProgram+0x16c>
    {
      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);
2000ac6e:	687b      	ldr	r3, [r7, #4]
2000ac70:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
2000ac72:	687b      	ldr	r3, [r7, #4]
2000ac74:	6b19      	ldr	r1, [r3, #48]	; 0x30
2000ac76:	687b      	ldr	r3, [r7, #4]
2000ac78:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000ac7a:	461a      	mov	r2, r3
2000ac7c:	f000 fe2c 	bl	2000b8d8 <FLASH_OB_BootAddConfig>
    }
#endif /*DUAL_CORE*/

    /* Secure area configuration */
    if((pOBInit->OptionType & OPTIONBYTE_SECURE_AREA) == OPTIONBYTE_SECURE_AREA)
2000ac80:	687b      	ldr	r3, [r7, #4]
2000ac82:	681b      	ldr	r3, [r3, #0]
2000ac84:	f003 0320 	and.w	r3, r3, #32
2000ac88:	2b00      	cmp	r3, #0
2000ac8a:	d009      	beq.n	2000aca0 <HAL_FLASHEx_OBProgram+0x18c>
    {
      FLASH_OB_SecureAreaConfig(pOBInit->SecureAreaConfig, pOBInit->SecureAreaStartAddr, pOBInit->SecureAreaEndAddr,pOBInit->Banks);
2000ac8c:	687b      	ldr	r3, [r7, #4]
2000ac8e:	6b98      	ldr	r0, [r3, #56]	; 0x38
2000ac90:	687b      	ldr	r3, [r7, #4]
2000ac92:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
2000ac94:	687b      	ldr	r3, [r7, #4]
2000ac96:	6c1a      	ldr	r2, [r3, #64]	; 0x40
2000ac98:	687b      	ldr	r3, [r7, #4]
2000ac9a:	69db      	ldr	r3, [r3, #28]
2000ac9c:	f000 fe84 	bl	2000b9a8 <FLASH_OB_SecureAreaConfig>
    }
#endif /* FLASH_OTPBL_LOCKBL */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
2000aca0:	4b04      	ldr	r3, [pc, #16]	; (2000acb4 <HAL_FLASHEx_OBProgram+0x1a0>)
2000aca2:	2200      	movs	r2, #0
2000aca4:	751a      	strb	r2, [r3, #20]

  return status;
2000aca6:	7bfb      	ldrb	r3, [r7, #15]
}
2000aca8:	4618      	mov	r0, r3
2000acaa:	3710      	adds	r7, #16
2000acac:	46bd      	mov	sp, r7
2000acae:	bd80      	pop	{r7, pc}
2000acb0:	2001c0c8 	.word	0x2001c0c8
2000acb4:	2001ca60 	.word	0x2001ca60

2000acb8 <HAL_FLASHEx_OBGetConfig>:
  *         as this parameter is use to get the given Bank WRP, PCROP and secured area configuration.
  *
  * @retval None
  */
void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
{
2000acb8:	b580      	push	{r7, lr}
2000acba:	b082      	sub	sp, #8
2000acbc:	af00      	add	r7, sp, #0
2000acbe:	6078      	str	r0, [r7, #4]
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
2000acc0:	687b      	ldr	r3, [r7, #4]
2000acc2:	2216      	movs	r2, #22
2000acc4:	601a      	str	r2, [r3, #0]

  /* Get Read protection level */
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
2000acc6:	f000 fb97 	bl	2000b3f8 <FLASH_OB_GetRDP>
2000acca:	4602      	mov	r2, r0
2000accc:	687b      	ldr	r3, [r7, #4]
2000acce:	60da      	str	r2, [r3, #12]

  /* Get the user option bytes */
  pOBInit->USERConfig = FLASH_OB_GetUser();
2000acd0:	f000 fcec 	bl	2000b6ac <FLASH_OB_GetUser>
2000acd4:	4602      	mov	r2, r0
2000acd6:	687b      	ldr	r3, [r7, #4]
2000acd8:	619a      	str	r2, [r3, #24]

  /*Get BOR Level*/
  pOBInit->BORLevel = FLASH_OB_GetBOR();
2000acda:	f000 fdef 	bl	2000b8bc <FLASH_OB_GetBOR>
2000acde:	4602      	mov	r2, r0
2000ace0:	687b      	ldr	r3, [r7, #4]
2000ace2:	611a      	str	r2, [r3, #16]

  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
2000ace4:	687b      	ldr	r3, [r7, #4]
2000ace6:	69db      	ldr	r3, [r3, #28]
2000ace8:	2b01      	cmp	r3, #1
2000acea:	d003      	beq.n	2000acf4 <HAL_FLASHEx_OBGetConfig+0x3c>
2000acec:	687b      	ldr	r3, [r7, #4]
2000acee:	69db      	ldr	r3, [r3, #28]
2000acf0:	2b02      	cmp	r3, #2
2000acf2:	d129      	bne.n	2000ad48 <HAL_FLASHEx_OBGetConfig+0x90>
  {
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
2000acf4:	687b      	ldr	r3, [r7, #4]
2000acf6:	681b      	ldr	r3, [r3, #0]
2000acf8:	f043 0229 	orr.w	r2, r3, #41	; 0x29
2000acfc:	687b      	ldr	r3, [r7, #4]
2000acfe:	601a      	str	r2, [r3, #0]

    /* Get write protection on the selected area */
    FLASH_OB_GetWRP(&(pOBInit->WRPState), &(pOBInit->WRPSector), pOBInit->Banks);
2000ad00:	687b      	ldr	r3, [r7, #4]
2000ad02:	1d18      	adds	r0, r3, #4
2000ad04:	687b      	ldr	r3, [r7, #4]
2000ad06:	f103 0108 	add.w	r1, r3, #8
2000ad0a:	687b      	ldr	r3, [r7, #4]
2000ad0c:	69db      	ldr	r3, [r3, #28]
2000ad0e:	461a      	mov	r2, r3
2000ad10:	f000 fb1a 	bl	2000b348 <FLASH_OB_GetWRP>

    /* Get the Proprietary code readout protection */
    FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROPStartAddr), &(pOBInit->PCROPEndAddr), pOBInit->Banks);
2000ad14:	687b      	ldr	r3, [r7, #4]
2000ad16:	f103 0020 	add.w	r0, r3, #32
2000ad1a:	687b      	ldr	r3, [r7, #4]
2000ad1c:	f103 0124 	add.w	r1, r3, #36	; 0x24
2000ad20:	687b      	ldr	r3, [r7, #4]
2000ad22:	f103 0228 	add.w	r2, r3, #40	; 0x28
2000ad26:	687b      	ldr	r3, [r7, #4]
2000ad28:	69db      	ldr	r3, [r3, #28]
2000ad2a:	f000 fd5b 	bl	2000b7e4 <FLASH_OB_GetPCROP>

    /*Get Bank Secure area*/
    FLASH_OB_GetSecureArea(&(pOBInit->SecureAreaConfig), &(pOBInit->SecureAreaStartAddr), &(pOBInit->SecureAreaEndAddr), pOBInit->Banks);
2000ad2e:	687b      	ldr	r3, [r7, #4]
2000ad30:	f103 0038 	add.w	r0, r3, #56	; 0x38
2000ad34:	687b      	ldr	r3, [r7, #4]
2000ad36:	f103 013c 	add.w	r1, r3, #60	; 0x3c
2000ad3a:	687b      	ldr	r3, [r7, #4]
2000ad3c:	f103 0240 	add.w	r2, r3, #64	; 0x40
2000ad40:	687b      	ldr	r3, [r7, #4]
2000ad42:	69db      	ldr	r3, [r3, #28]
2000ad44:	f000 feba 	bl	2000babc <FLASH_OB_GetSecureArea>
  }

  /*Get Boot Address*/
  FLASH_OB_GetBootAdd(&(pOBInit->BootAddr0), &(pOBInit->BootAddr1));
2000ad48:	687b      	ldr	r3, [r7, #4]
2000ad4a:	f103 0230 	add.w	r2, r3, #48	; 0x30
2000ad4e:	687b      	ldr	r3, [r7, #4]
2000ad50:	3334      	adds	r3, #52	; 0x34
2000ad52:	4619      	mov	r1, r3
2000ad54:	4610      	mov	r0, r2
2000ad56:	f000 fe0b 	bl	2000b970 <FLASH_OB_GetBootAdd>
  pOBInit->OptionType |= OPTIONBYTE_CM7_BOOTADD | OPTIONBYTE_CM4_BOOTADD;

  /*Get CM4 Boot Address*/
  FLASH_OB_GetCM4BootAdd(&(pOBInit->CM4BootAddr0), &(pOBInit->CM4BootAddr1));
#else
  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;
2000ad5a:	687b      	ldr	r3, [r7, #4]
2000ad5c:	681b      	ldr	r3, [r3, #0]
2000ad5e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
2000ad62:	687b      	ldr	r3, [r7, #4]
2000ad64:	601a      	str	r2, [r3, #0]
  pOBInit->OptionType |= OPTIONBYTE_OTP_LOCK;

  /* Get OTP Block Lock */
  pOBInit->OTPBlockLock = FLASH_OB_OTP_GetLock();
#endif /* FLASH_OTPBL_LOCKBL */
}
2000ad66:	bf00      	nop
2000ad68:	3708      	adds	r7, #8
2000ad6a:	46bd      	mov	sp, r7
2000ad6c:	bd80      	pop	{r7, pc}
	...

2000ad70 <HAL_FLASHEx_Unlock_Bank1>:
/**
  * @brief  Unlock the FLASH Bank1 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank1(void)
{
2000ad70:	b480      	push	{r7}
2000ad72:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
2000ad74:	4b0c      	ldr	r3, [pc, #48]	; (2000ada8 <HAL_FLASHEx_Unlock_Bank1+0x38>)
2000ad76:	68db      	ldr	r3, [r3, #12]
2000ad78:	f003 0301 	and.w	r3, r3, #1
2000ad7c:	2b00      	cmp	r3, #0
2000ad7e:	d00d      	beq.n	2000ad9c <HAL_FLASHEx_Unlock_Bank1+0x2c>
  {
    /* Authorize the FLASH Bank1 Registers access */
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
2000ad80:	4b09      	ldr	r3, [pc, #36]	; (2000ada8 <HAL_FLASHEx_Unlock_Bank1+0x38>)
2000ad82:	4a0a      	ldr	r2, [pc, #40]	; (2000adac <HAL_FLASHEx_Unlock_Bank1+0x3c>)
2000ad84:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
2000ad86:	4b08      	ldr	r3, [pc, #32]	; (2000ada8 <HAL_FLASHEx_Unlock_Bank1+0x38>)
2000ad88:	4a09      	ldr	r2, [pc, #36]	; (2000adb0 <HAL_FLASHEx_Unlock_Bank1+0x40>)
2000ad8a:	605a      	str	r2, [r3, #4]

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
2000ad8c:	4b06      	ldr	r3, [pc, #24]	; (2000ada8 <HAL_FLASHEx_Unlock_Bank1+0x38>)
2000ad8e:	68db      	ldr	r3, [r3, #12]
2000ad90:	f003 0301 	and.w	r3, r3, #1
2000ad94:	2b00      	cmp	r3, #0
2000ad96:	d001      	beq.n	2000ad9c <HAL_FLASHEx_Unlock_Bank1+0x2c>
    {
      return HAL_ERROR;
2000ad98:	2301      	movs	r3, #1
2000ad9a:	e000      	b.n	2000ad9e <HAL_FLASHEx_Unlock_Bank1+0x2e>
    }
  }

  return HAL_OK;
2000ad9c:	2300      	movs	r3, #0
}
2000ad9e:	4618      	mov	r0, r3
2000ada0:	46bd      	mov	sp, r7
2000ada2:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ada6:	4770      	bx	lr
2000ada8:	52002000 	.word	0x52002000
2000adac:	45670123 	.word	0x45670123
2000adb0:	cdef89ab 	.word	0xcdef89ab

2000adb4 <HAL_FLASHEx_Lock_Bank1>:
/**
  * @brief  Locks the FLASH Bank1 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Lock_Bank1(void)
{
2000adb4:	b480      	push	{r7}
2000adb6:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank1 Registers access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
2000adb8:	4b05      	ldr	r3, [pc, #20]	; (2000add0 <HAL_FLASHEx_Lock_Bank1+0x1c>)
2000adba:	68db      	ldr	r3, [r3, #12]
2000adbc:	4a04      	ldr	r2, [pc, #16]	; (2000add0 <HAL_FLASHEx_Lock_Bank1+0x1c>)
2000adbe:	f043 0301 	orr.w	r3, r3, #1
2000adc2:	60d3      	str	r3, [r2, #12]
  return HAL_OK;
2000adc4:	2300      	movs	r3, #0
}
2000adc6:	4618      	mov	r0, r3
2000adc8:	46bd      	mov	sp, r7
2000adca:	f85d 7b04 	ldr.w	r7, [sp], #4
2000adce:	4770      	bx	lr
2000add0:	52002000 	.word	0x52002000

2000add4 <HAL_FLASHEx_Unlock_Bank2>:
/**
  * @brief  Unlock the FLASH Bank2 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank2(void)
{
2000add4:	b480      	push	{r7}
2000add6:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
2000add8:	4b0e      	ldr	r3, [pc, #56]	; (2000ae14 <HAL_FLASHEx_Unlock_Bank2+0x40>)
2000adda:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000adde:	f003 0301 	and.w	r3, r3, #1
2000ade2:	2b00      	cmp	r3, #0
2000ade4:	d010      	beq.n	2000ae08 <HAL_FLASHEx_Unlock_Bank2+0x34>
  {
    /* Authorize the FLASH Bank2 Registers access */
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
2000ade6:	4b0b      	ldr	r3, [pc, #44]	; (2000ae14 <HAL_FLASHEx_Unlock_Bank2+0x40>)
2000ade8:	4a0b      	ldr	r2, [pc, #44]	; (2000ae18 <HAL_FLASHEx_Unlock_Bank2+0x44>)
2000adea:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
2000adee:	4b09      	ldr	r3, [pc, #36]	; (2000ae14 <HAL_FLASHEx_Unlock_Bank2+0x40>)
2000adf0:	4a0a      	ldr	r2, [pc, #40]	; (2000ae1c <HAL_FLASHEx_Unlock_Bank2+0x48>)
2000adf2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
2000adf6:	4b07      	ldr	r3, [pc, #28]	; (2000ae14 <HAL_FLASHEx_Unlock_Bank2+0x40>)
2000adf8:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000adfc:	f003 0301 	and.w	r3, r3, #1
2000ae00:	2b00      	cmp	r3, #0
2000ae02:	d001      	beq.n	2000ae08 <HAL_FLASHEx_Unlock_Bank2+0x34>
    {
      return HAL_ERROR;
2000ae04:	2301      	movs	r3, #1
2000ae06:	e000      	b.n	2000ae0a <HAL_FLASHEx_Unlock_Bank2+0x36>
    }
  }

  return HAL_OK;
2000ae08:	2300      	movs	r3, #0
}
2000ae0a:	4618      	mov	r0, r3
2000ae0c:	46bd      	mov	sp, r7
2000ae0e:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ae12:	4770      	bx	lr
2000ae14:	52002000 	.word	0x52002000
2000ae18:	45670123 	.word	0x45670123
2000ae1c:	cdef89ab 	.word	0xcdef89ab

2000ae20 <HAL_FLASHEx_Lock_Bank2>:
/**
  * @brief  Locks the FLASH Bank2 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Lock_Bank2(void)
{
2000ae20:	b480      	push	{r7}
2000ae22:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank2 Registers access */
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
2000ae24:	4b06      	ldr	r3, [pc, #24]	; (2000ae40 <HAL_FLASHEx_Lock_Bank2+0x20>)
2000ae26:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000ae2a:	4a05      	ldr	r2, [pc, #20]	; (2000ae40 <HAL_FLASHEx_Lock_Bank2+0x20>)
2000ae2c:	f043 0301 	orr.w	r3, r3, #1
2000ae30:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
  return HAL_OK;
2000ae34:	2300      	movs	r3, #0
}
2000ae36:	4618      	mov	r0, r3
2000ae38:	46bd      	mov	sp, r7
2000ae3a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ae3e:	4770      	bx	lr
2000ae40:	52002000 	.word	0x52002000

2000ae44 <HAL_FLASHEx_ComputeCRC>:
  *         A special error flag (CRC read error: CRCRDERR) can be used to
  *         detect such a case.
  * @retval HAL Status
*/
HAL_StatusTypeDef HAL_FLASHEx_ComputeCRC(FLASH_CRCInitTypeDef *pCRCInit, uint32_t *CRC_Result)
{
2000ae44:	b580      	push	{r7, lr}
2000ae46:	b084      	sub	sp, #16
2000ae48:	af00      	add	r7, sp, #0
2000ae4a:	6078      	str	r0, [r7, #4]
2000ae4c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t sector_index;

  /* Check the parameters */
  assert_param(IS_FLASH_BANK_EXCLUSIVE(pCRCInit->Bank));
2000ae4e:	687b      	ldr	r3, [r7, #4]
2000ae50:	689b      	ldr	r3, [r3, #8]
2000ae52:	2b01      	cmp	r3, #1
2000ae54:	d008      	beq.n	2000ae68 <HAL_FLASHEx_ComputeCRC+0x24>
2000ae56:	687b      	ldr	r3, [r7, #4]
2000ae58:	689b      	ldr	r3, [r3, #8]
2000ae5a:	2b02      	cmp	r3, #2
2000ae5c:	d004      	beq.n	2000ae68 <HAL_FLASHEx_ComputeCRC+0x24>
2000ae5e:	f44f 7120 	mov.w	r1, #640	; 0x280
2000ae62:	4882      	ldr	r0, [pc, #520]	; (2000b06c <HAL_FLASHEx_ComputeCRC+0x228>)
2000ae64:	f7f5 fd46 	bl	200008f4 <assert_failed>
  assert_param(IS_FLASH_TYPECRC(pCRCInit->TypeCRC));
2000ae68:	687b      	ldr	r3, [r7, #4]
2000ae6a:	681b      	ldr	r3, [r3, #0]
2000ae6c:	2b00      	cmp	r3, #0
2000ae6e:	d00e      	beq.n	2000ae8e <HAL_FLASHEx_ComputeCRC+0x4a>
2000ae70:	687b      	ldr	r3, [r7, #4]
2000ae72:	681b      	ldr	r3, [r3, #0]
2000ae74:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2000ae78:	d009      	beq.n	2000ae8e <HAL_FLASHEx_ComputeCRC+0x4a>
2000ae7a:	687b      	ldr	r3, [r7, #4]
2000ae7c:	681b      	ldr	r3, [r3, #0]
2000ae7e:	4a7c      	ldr	r2, [pc, #496]	; (2000b070 <HAL_FLASHEx_ComputeCRC+0x22c>)
2000ae80:	4293      	cmp	r3, r2
2000ae82:	d004      	beq.n	2000ae8e <HAL_FLASHEx_ComputeCRC+0x4a>
2000ae84:	f240 2181 	movw	r1, #641	; 0x281
2000ae88:	4878      	ldr	r0, [pc, #480]	; (2000b06c <HAL_FLASHEx_ComputeCRC+0x228>)
2000ae8a:	f7f5 fd33 	bl	200008f4 <assert_failed>

  /* Wait for OB change operation to be completed */
  status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
2000ae8e:	f24c 3050 	movw	r0, #50000	; 0xc350
2000ae92:	f7ff fbd7 	bl	2000a644 <FLASH_OB_WaitForLastOperation>
2000ae96:	4603      	mov	r3, r0
2000ae98:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
2000ae9a:	7bfb      	ldrb	r3, [r7, #15]
2000ae9c:	2b00      	cmp	r3, #0
2000ae9e:	f040 80e0 	bne.w	2000b062 <HAL_FLASHEx_ComputeCRC+0x21e>
  {
    if (pCRCInit->Bank == FLASH_BANK_1)
2000aea2:	687b      	ldr	r3, [r7, #4]
2000aea4:	689b      	ldr	r3, [r3, #8]
2000aea6:	2b01      	cmp	r3, #1
2000aea8:	d166      	bne.n	2000af78 <HAL_FLASHEx_ComputeCRC+0x134>
    {
      /* Enable CRC feature */
      FLASH->CR1 |= FLASH_CR_CRC_EN;
2000aeaa:	4b72      	ldr	r3, [pc, #456]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000aeac:	68db      	ldr	r3, [r3, #12]
2000aeae:	4a71      	ldr	r2, [pc, #452]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000aeb0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
2000aeb4:	60d3      	str	r3, [r2, #12]

      /* Clear CRC flags in Status Register: CRC end of calculation and CRC read error */
      FLASH->CCR1 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);
2000aeb6:	4b6f      	ldr	r3, [pc, #444]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000aeb8:	695b      	ldr	r3, [r3, #20]
2000aeba:	4a6e      	ldr	r2, [pc, #440]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000aebc:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
2000aec0:	6153      	str	r3, [r2, #20]

      /* Clear current CRC result, program burst size and define memory area on which CRC has to be computed */
      FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
2000aec2:	4b6c      	ldr	r3, [pc, #432]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000aec4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
2000aec6:	687b      	ldr	r3, [r7, #4]
2000aec8:	6859      	ldr	r1, [r3, #4]
2000aeca:	687b      	ldr	r3, [r7, #4]
2000aecc:	681b      	ldr	r3, [r3, #0]
2000aece:	430b      	orrs	r3, r1
2000aed0:	4313      	orrs	r3, r2
2000aed2:	4a68      	ldr	r2, [pc, #416]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000aed4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2000aed8:	6513      	str	r3, [r2, #80]	; 0x50

      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
2000aeda:	687b      	ldr	r3, [r7, #4]
2000aedc:	681b      	ldr	r3, [r3, #0]
2000aede:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2000aee2:	d119      	bne.n	2000af18 <HAL_FLASHEx_ComputeCRC+0xd4>
      {
        /* Clear sectors list */
        FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_SECT;
2000aee4:	4b63      	ldr	r3, [pc, #396]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000aee6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000aee8:	4a62      	ldr	r2, [pc, #392]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000aeea:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
2000aeee:	6513      	str	r3, [r2, #80]	; 0x50

        /* Select CRC sectors */
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
2000aef0:	687b      	ldr	r3, [r7, #4]
2000aef2:	68db      	ldr	r3, [r3, #12]
2000aef4:	60bb      	str	r3, [r7, #8]
2000aef6:	e006      	b.n	2000af06 <HAL_FLASHEx_ComputeCRC+0xc2>
        {
          FLASH_CRC_AddSector(sector_index, FLASH_BANK_1);
2000aef8:	2101      	movs	r1, #1
2000aefa:	68b8      	ldr	r0, [r7, #8]
2000aefc:	f000 fe24 	bl	2000bb48 <FLASH_CRC_AddSector>
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
2000af00:	68bb      	ldr	r3, [r7, #8]
2000af02:	3301      	adds	r3, #1
2000af04:	60bb      	str	r3, [r7, #8]
2000af06:	687b      	ldr	r3, [r7, #4]
2000af08:	691a      	ldr	r2, [r3, #16]
2000af0a:	687b      	ldr	r3, [r7, #4]
2000af0c:	68db      	ldr	r3, [r3, #12]
2000af0e:	4413      	add	r3, r2
2000af10:	68ba      	ldr	r2, [r7, #8]
2000af12:	429a      	cmp	r2, r3
2000af14:	d3f0      	bcc.n	2000aef8 <HAL_FLASHEx_ComputeCRC+0xb4>
2000af16:	e013      	b.n	2000af40 <HAL_FLASHEx_ComputeCRC+0xfc>
        }
      }
      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)
2000af18:	687b      	ldr	r3, [r7, #4]
2000af1a:	681b      	ldr	r3, [r3, #0]
2000af1c:	4a54      	ldr	r2, [pc, #336]	; (2000b070 <HAL_FLASHEx_ComputeCRC+0x22c>)
2000af1e:	4293      	cmp	r3, r2
2000af20:	d106      	bne.n	2000af30 <HAL_FLASHEx_ComputeCRC+0xec>
      {
        /* Enable Bank 1 CRC select bit */
        FLASH->CRCCR1 |= FLASH_CRCCR_ALL_BANK;
2000af22:	4b54      	ldr	r3, [pc, #336]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af24:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000af26:	4a53      	ldr	r2, [pc, #332]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af28:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
2000af2c:	6513      	str	r3, [r2, #80]	; 0x50
2000af2e:	e007      	b.n	2000af40 <HAL_FLASHEx_ComputeCRC+0xfc>
      }
      else
      {
        /* Select CRC start and end addresses */
        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_1);
2000af30:	687b      	ldr	r3, [r7, #4]
2000af32:	6958      	ldr	r0, [r3, #20]
2000af34:	687b      	ldr	r3, [r7, #4]
2000af36:	699b      	ldr	r3, [r3, #24]
2000af38:	2201      	movs	r2, #1
2000af3a:	4619      	mov	r1, r3
2000af3c:	f000 fe3e 	bl	2000bbbc <FLASH_CRC_SelectAddress>
      }

      /* Start the CRC calculation */
      FLASH->CRCCR1 |= FLASH_CRCCR_START_CRC;
2000af40:	4b4c      	ldr	r3, [pc, #304]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af42:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000af44:	4a4b      	ldr	r2, [pc, #300]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af46:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000af4a:	6513      	str	r3, [r2, #80]	; 0x50

      /* Wait on CRC busy flag */
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
2000af4c:	2101      	movs	r1, #1
2000af4e:	f24c 3050 	movw	r0, #50000	; 0xc350
2000af52:	f7ff fbb3 	bl	2000a6bc <FLASH_CRC_WaitForLastOperation>
2000af56:	4603      	mov	r3, r0
2000af58:	73fb      	strb	r3, [r7, #15]

      /* Return CRC result */
      (*CRC_Result) = FLASH->CRCDATA;
2000af5a:	4b46      	ldr	r3, [pc, #280]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af5c:	6dda      	ldr	r2, [r3, #92]	; 0x5c
2000af5e:	683b      	ldr	r3, [r7, #0]
2000af60:	601a      	str	r2, [r3, #0]

      /* Disable CRC feature */
      FLASH->CR1 &= (~FLASH_CR_CRC_EN);
2000af62:	4b44      	ldr	r3, [pc, #272]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af64:	68db      	ldr	r3, [r3, #12]
2000af66:	4a43      	ldr	r2, [pc, #268]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af68:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
2000af6c:	60d3      	str	r3, [r2, #12]

      /* Clear CRC flags */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCEND_BANK1 | FLASH_FLAG_CRCRDERR_BANK1);
2000af6e:	4b41      	ldr	r3, [pc, #260]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af70:	f04f 52c0 	mov.w	r2, #402653184	; 0x18000000
2000af74:	615a      	str	r2, [r3, #20]
2000af76:	e074      	b.n	2000b062 <HAL_FLASHEx_ComputeCRC+0x21e>
    }
    else
    {
      /* Enable CRC feature */
      FLASH->CR2 |= FLASH_CR_CRC_EN;
2000af78:	4b3e      	ldr	r3, [pc, #248]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af7a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000af7e:	4a3d      	ldr	r2, [pc, #244]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af80:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
2000af84:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

      /* Clear CRC flags in Status Register: CRC end of calculation and CRC read error */
      FLASH->CCR2 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);
2000af88:	4b3a      	ldr	r3, [pc, #232]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af8a:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
2000af8e:	4a39      	ldr	r2, [pc, #228]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af90:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
2000af94:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

      /* Clear current CRC result, program burst size and define memory area on which CRC has to be computed */
      FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
2000af98:	4b36      	ldr	r3, [pc, #216]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000af9a:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
2000af9e:	687b      	ldr	r3, [r7, #4]
2000afa0:	6859      	ldr	r1, [r3, #4]
2000afa2:	687b      	ldr	r3, [r7, #4]
2000afa4:	681b      	ldr	r3, [r3, #0]
2000afa6:	430b      	orrs	r3, r1
2000afa8:	4313      	orrs	r3, r2
2000afaa:	4a32      	ldr	r2, [pc, #200]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000afac:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2000afb0:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150

      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
2000afb4:	687b      	ldr	r3, [r7, #4]
2000afb6:	681b      	ldr	r3, [r3, #0]
2000afb8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2000afbc:	d11b      	bne.n	2000aff6 <HAL_FLASHEx_ComputeCRC+0x1b2>
      {
        /* Clear sectors list */
        FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_SECT;
2000afbe:	4b2d      	ldr	r3, [pc, #180]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000afc0:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
2000afc4:	4a2b      	ldr	r2, [pc, #172]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000afc6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
2000afca:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150

        /* Add CRC sectors */
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
2000afce:	687b      	ldr	r3, [r7, #4]
2000afd0:	68db      	ldr	r3, [r3, #12]
2000afd2:	60bb      	str	r3, [r7, #8]
2000afd4:	e006      	b.n	2000afe4 <HAL_FLASHEx_ComputeCRC+0x1a0>
        {
          FLASH_CRC_AddSector(sector_index, FLASH_BANK_2);
2000afd6:	2102      	movs	r1, #2
2000afd8:	68b8      	ldr	r0, [r7, #8]
2000afda:	f000 fdb5 	bl	2000bb48 <FLASH_CRC_AddSector>
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
2000afde:	68bb      	ldr	r3, [r7, #8]
2000afe0:	3301      	adds	r3, #1
2000afe2:	60bb      	str	r3, [r7, #8]
2000afe4:	687b      	ldr	r3, [r7, #4]
2000afe6:	691a      	ldr	r2, [r3, #16]
2000afe8:	687b      	ldr	r3, [r7, #4]
2000afea:	68db      	ldr	r3, [r3, #12]
2000afec:	4413      	add	r3, r2
2000afee:	68ba      	ldr	r2, [r7, #8]
2000aff0:	429a      	cmp	r2, r3
2000aff2:	d3f0      	bcc.n	2000afd6 <HAL_FLASHEx_ComputeCRC+0x192>
2000aff4:	e015      	b.n	2000b022 <HAL_FLASHEx_ComputeCRC+0x1de>
        }
      }
      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)
2000aff6:	687b      	ldr	r3, [r7, #4]
2000aff8:	681b      	ldr	r3, [r3, #0]
2000affa:	4a1d      	ldr	r2, [pc, #116]	; (2000b070 <HAL_FLASHEx_ComputeCRC+0x22c>)
2000affc:	4293      	cmp	r3, r2
2000affe:	d108      	bne.n	2000b012 <HAL_FLASHEx_ComputeCRC+0x1ce>
      {
        /* Enable Bank 2 CRC select bit */
        FLASH->CRCCR2 |= FLASH_CRCCR_ALL_BANK;
2000b000:	4b1c      	ldr	r3, [pc, #112]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000b002:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
2000b006:	4a1b      	ldr	r2, [pc, #108]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000b008:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
2000b00c:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150
2000b010:	e007      	b.n	2000b022 <HAL_FLASHEx_ComputeCRC+0x1de>
      }
      else
      {
        /* Select CRC start and end addresses */
        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_2);
2000b012:	687b      	ldr	r3, [r7, #4]
2000b014:	6958      	ldr	r0, [r3, #20]
2000b016:	687b      	ldr	r3, [r7, #4]
2000b018:	699b      	ldr	r3, [r3, #24]
2000b01a:	2202      	movs	r2, #2
2000b01c:	4619      	mov	r1, r3
2000b01e:	f000 fdcd 	bl	2000bbbc <FLASH_CRC_SelectAddress>
      }

      /* Start the CRC calculation */
      FLASH->CRCCR2 |= FLASH_CRCCR_START_CRC;
2000b022:	4b14      	ldr	r3, [pc, #80]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000b024:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
2000b028:	4a12      	ldr	r2, [pc, #72]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000b02a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000b02e:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150

      /* Wait on CRC busy flag */
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
2000b032:	2102      	movs	r1, #2
2000b034:	f24c 3050 	movw	r0, #50000	; 0xc350
2000b038:	f7ff fb40 	bl	2000a6bc <FLASH_CRC_WaitForLastOperation>
2000b03c:	4603      	mov	r3, r0
2000b03e:	73fb      	strb	r3, [r7, #15]

      /* Return CRC result */
      (*CRC_Result) = FLASH->CRCDATA;
2000b040:	4b0c      	ldr	r3, [pc, #48]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000b042:	6dda      	ldr	r2, [r3, #92]	; 0x5c
2000b044:	683b      	ldr	r3, [r7, #0]
2000b046:	601a      	str	r2, [r3, #0]

      /* Disable CRC feature */
      FLASH->CR2 &= (~FLASH_CR_CRC_EN);
2000b048:	4b0a      	ldr	r3, [pc, #40]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000b04a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000b04e:	4a09      	ldr	r2, [pc, #36]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000b050:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
2000b054:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

      /* Clear CRC flags */
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCEND_BANK2 | FLASH_FLAG_CRCRDERR_BANK2);
2000b058:	4b06      	ldr	r3, [pc, #24]	; (2000b074 <HAL_FLASHEx_ComputeCRC+0x230>)
2000b05a:	f04f 52c0 	mov.w	r2, #402653184	; 0x18000000
2000b05e:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    }
  }

  return status;
2000b062:	7bfb      	ldrb	r3, [r7, #15]
}
2000b064:	4618      	mov	r0, r3
2000b066:	3710      	adds	r7, #16
2000b068:	46bd      	mov	sp, r7
2000b06a:	bd80      	pop	{r7, pc}
2000b06c:	2001c0c8 	.word	0x2001c0c8
2000b070:	00400100 	.word	0x00400100
2000b074:	52002000 	.word	0x52002000

2000b078 <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)
{
2000b078:	b580      	push	{r7, lr}
2000b07a:	b082      	sub	sp, #8
2000b07c:	af00      	add	r7, sp, #0
2000b07e:	6078      	str	r0, [r7, #4]
2000b080:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
#if defined (FLASH_CR_PSIZE)
  assert_param(IS_VOLTAGERANGE(VoltageRange));
2000b082:	687b      	ldr	r3, [r7, #4]
2000b084:	2b00      	cmp	r3, #0
2000b086:	d00d      	beq.n	2000b0a4 <FLASH_MassErase+0x2c>
2000b088:	687b      	ldr	r3, [r7, #4]
2000b08a:	2b10      	cmp	r3, #16
2000b08c:	d00a      	beq.n	2000b0a4 <FLASH_MassErase+0x2c>
2000b08e:	687b      	ldr	r3, [r7, #4]
2000b090:	2b20      	cmp	r3, #32
2000b092:	d007      	beq.n	2000b0a4 <FLASH_MassErase+0x2c>
2000b094:	687b      	ldr	r3, [r7, #4]
2000b096:	2b30      	cmp	r3, #48	; 0x30
2000b098:	d004      	beq.n	2000b0a4 <FLASH_MassErase+0x2c>
2000b09a:	f44f 7144 	mov.w	r1, #784	; 0x310
2000b09e:	4838      	ldr	r0, [pc, #224]	; (2000b180 <FLASH_MassErase+0x108>)
2000b0a0:	f7f5 fc28 	bl	200008f4 <assert_failed>
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));
2000b0a4:	683b      	ldr	r3, [r7, #0]
2000b0a6:	2b01      	cmp	r3, #1
2000b0a8:	d00a      	beq.n	2000b0c0 <FLASH_MassErase+0x48>
2000b0aa:	683b      	ldr	r3, [r7, #0]
2000b0ac:	2b02      	cmp	r3, #2
2000b0ae:	d007      	beq.n	2000b0c0 <FLASH_MassErase+0x48>
2000b0b0:	683b      	ldr	r3, [r7, #0]
2000b0b2:	2b03      	cmp	r3, #3
2000b0b4:	d004      	beq.n	2000b0c0 <FLASH_MassErase+0x48>
2000b0b6:	f44f 7145 	mov.w	r1, #788	; 0x314
2000b0ba:	4831      	ldr	r0, [pc, #196]	; (2000b180 <FLASH_MassErase+0x108>)
2000b0bc:	f7f5 fc1a 	bl	200008f4 <assert_failed>

  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
2000b0c0:	683b      	ldr	r3, [r7, #0]
2000b0c2:	f003 0303 	and.w	r3, r3, #3
2000b0c6:	2b03      	cmp	r3, #3
2000b0c8:	d122      	bne.n	2000b110 <FLASH_MassErase+0x98>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange for Bank1 and Bank2 */
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
2000b0ca:	4b2e      	ldr	r3, [pc, #184]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b0cc:	68db      	ldr	r3, [r3, #12]
2000b0ce:	4a2d      	ldr	r2, [pc, #180]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b0d0:	f023 0330 	bic.w	r3, r3, #48	; 0x30
2000b0d4:	60d3      	str	r3, [r2, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
2000b0d6:	4b2b      	ldr	r3, [pc, #172]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b0d8:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000b0dc:	4a29      	ldr	r2, [pc, #164]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b0de:	f023 0330 	bic.w	r3, r3, #48	; 0x30
2000b0e2:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

    /* Set voltage range */
    FLASH->CR1 |= VoltageRange;
2000b0e6:	4b27      	ldr	r3, [pc, #156]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b0e8:	68da      	ldr	r2, [r3, #12]
2000b0ea:	4926      	ldr	r1, [pc, #152]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b0ec:	687b      	ldr	r3, [r7, #4]
2000b0ee:	4313      	orrs	r3, r2
2000b0f0:	60cb      	str	r3, [r1, #12]
    FLASH->CR2 |= VoltageRange;
2000b0f2:	4b24      	ldr	r3, [pc, #144]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b0f4:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
2000b0f8:	4922      	ldr	r1, [pc, #136]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b0fa:	687b      	ldr	r3, [r7, #4]
2000b0fc:	4313      	orrs	r3, r2
2000b0fe:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
#endif /* FLASH_CR_PSIZE */

    /* Set Mass Erase Bit */
    FLASH->OPTCR |= FLASH_OPTCR_MER;
2000b102:	4b20      	ldr	r3, [pc, #128]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b104:	699b      	ldr	r3, [r3, #24]
2000b106:	4a1f      	ldr	r2, [pc, #124]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b108:	f043 0310 	orr.w	r3, r3, #16
2000b10c:	6193      	str	r3, [r2, #24]

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
    }
  }
}
2000b10e:	e033      	b.n	2000b178 <FLASH_MassErase+0x100>
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000b110:	683b      	ldr	r3, [r7, #0]
2000b112:	f003 0301 	and.w	r3, r3, #1
2000b116:	2b00      	cmp	r3, #0
2000b118:	d011      	beq.n	2000b13e <FLASH_MassErase+0xc6>
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
2000b11a:	4b1a      	ldr	r3, [pc, #104]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b11c:	68db      	ldr	r3, [r3, #12]
2000b11e:	4a19      	ldr	r2, [pc, #100]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b120:	f023 0330 	bic.w	r3, r3, #48	; 0x30
2000b124:	60d3      	str	r3, [r2, #12]
      FLASH->CR1 |=  VoltageRange;
2000b126:	4b17      	ldr	r3, [pc, #92]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b128:	68da      	ldr	r2, [r3, #12]
2000b12a:	4916      	ldr	r1, [pc, #88]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b12c:	687b      	ldr	r3, [r7, #4]
2000b12e:	4313      	orrs	r3, r2
2000b130:	60cb      	str	r3, [r1, #12]
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
2000b132:	4b14      	ldr	r3, [pc, #80]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b134:	68db      	ldr	r3, [r3, #12]
2000b136:	4a13      	ldr	r2, [pc, #76]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b138:	f043 0388 	orr.w	r3, r3, #136	; 0x88
2000b13c:	60d3      	str	r3, [r2, #12]
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000b13e:	683b      	ldr	r3, [r7, #0]
2000b140:	f003 0302 	and.w	r3, r3, #2
2000b144:	2b00      	cmp	r3, #0
2000b146:	d017      	beq.n	2000b178 <FLASH_MassErase+0x100>
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
2000b148:	4b0e      	ldr	r3, [pc, #56]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b14a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000b14e:	4a0d      	ldr	r2, [pc, #52]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b150:	f023 0330 	bic.w	r3, r3, #48	; 0x30
2000b154:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
      FLASH->CR2 |= VoltageRange;
2000b158:	4b0a      	ldr	r3, [pc, #40]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b15a:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
2000b15e:	4909      	ldr	r1, [pc, #36]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b160:	687b      	ldr	r3, [r7, #4]
2000b162:	4313      	orrs	r3, r2
2000b164:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
2000b168:	4b06      	ldr	r3, [pc, #24]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b16a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000b16e:	4a05      	ldr	r2, [pc, #20]	; (2000b184 <FLASH_MassErase+0x10c>)
2000b170:	f043 0388 	orr.w	r3, r3, #136	; 0x88
2000b174:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
}
2000b178:	bf00      	nop
2000b17a:	3708      	adds	r7, #8
2000b17c:	46bd      	mov	sp, r7
2000b17e:	bd80      	pop	{r7, pc}
2000b180:	2001c0c8 	.word	0x2001c0c8
2000b184:	52002000 	.word	0x52002000

2000b188 <FLASH_Erase_Sector>:
  *            @arg FLASH_VOLTAGE_RANGE_4 : Flash program/erase by 64 bits
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)
{
2000b188:	b580      	push	{r7, lr}
2000b18a:	b084      	sub	sp, #16
2000b18c:	af00      	add	r7, sp, #0
2000b18e:	60f8      	str	r0, [r7, #12]
2000b190:	60b9      	str	r1, [r7, #8]
2000b192:	607a      	str	r2, [r7, #4]
  assert_param(IS_FLASH_SECTOR(Sector));
2000b194:	68fb      	ldr	r3, [r7, #12]
2000b196:	2b00      	cmp	r3, #0
2000b198:	d004      	beq.n	2000b1a4 <FLASH_Erase_Sector+0x1c>
2000b19a:	f240 3156 	movw	r1, #854	; 0x356
2000b19e:	4829      	ldr	r0, [pc, #164]	; (2000b244 <FLASH_Erase_Sector+0xbc>)
2000b1a0:	f7f5 fba8 	bl	200008f4 <assert_failed>
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));
2000b1a4:	68bb      	ldr	r3, [r7, #8]
2000b1a6:	2b01      	cmp	r3, #1
2000b1a8:	d007      	beq.n	2000b1ba <FLASH_Erase_Sector+0x32>
2000b1aa:	68bb      	ldr	r3, [r7, #8]
2000b1ac:	2b02      	cmp	r3, #2
2000b1ae:	d004      	beq.n	2000b1ba <FLASH_Erase_Sector+0x32>
2000b1b0:	f240 3157 	movw	r1, #855	; 0x357
2000b1b4:	4823      	ldr	r0, [pc, #140]	; (2000b244 <FLASH_Erase_Sector+0xbc>)
2000b1b6:	f7f5 fb9d 	bl	200008f4 <assert_failed>
#if defined (FLASH_CR_PSIZE)
  assert_param(IS_VOLTAGERANGE(VoltageRange));
2000b1ba:	687b      	ldr	r3, [r7, #4]
2000b1bc:	2b00      	cmp	r3, #0
2000b1be:	d00d      	beq.n	2000b1dc <FLASH_Erase_Sector+0x54>
2000b1c0:	687b      	ldr	r3, [r7, #4]
2000b1c2:	2b10      	cmp	r3, #16
2000b1c4:	d00a      	beq.n	2000b1dc <FLASH_Erase_Sector+0x54>
2000b1c6:	687b      	ldr	r3, [r7, #4]
2000b1c8:	2b20      	cmp	r3, #32
2000b1ca:	d007      	beq.n	2000b1dc <FLASH_Erase_Sector+0x54>
2000b1cc:	687b      	ldr	r3, [r7, #4]
2000b1ce:	2b30      	cmp	r3, #48	; 0x30
2000b1d0:	d004      	beq.n	2000b1dc <FLASH_Erase_Sector+0x54>
2000b1d2:	f240 3159 	movw	r1, #857	; 0x359
2000b1d6:	481b      	ldr	r0, [pc, #108]	; (2000b244 <FLASH_Erase_Sector+0xbc>)
2000b1d8:	f7f5 fb8c 	bl	200008f4 <assert_failed>
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000b1dc:	68bb      	ldr	r3, [r7, #8]
2000b1de:	f003 0301 	and.w	r3, r3, #1
2000b1e2:	2b00      	cmp	r3, #0
2000b1e4:	d010      	beq.n	2000b208 <FLASH_Erase_Sector+0x80>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
2000b1e6:	4b18      	ldr	r3, [pc, #96]	; (2000b248 <FLASH_Erase_Sector+0xc0>)
2000b1e8:	68db      	ldr	r3, [r3, #12]
2000b1ea:	4a17      	ldr	r2, [pc, #92]	; (2000b248 <FLASH_Erase_Sector+0xc0>)
2000b1ec:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
2000b1f0:	60d3      	str	r3, [r2, #12]

    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
2000b1f2:	4b15      	ldr	r3, [pc, #84]	; (2000b248 <FLASH_Erase_Sector+0xc0>)
2000b1f4:	68da      	ldr	r2, [r3, #12]
2000b1f6:	68fb      	ldr	r3, [r7, #12]
2000b1f8:	0219      	lsls	r1, r3, #8
2000b1fa:	687b      	ldr	r3, [r7, #4]
2000b1fc:	430b      	orrs	r3, r1
2000b1fe:	4313      	orrs	r3, r2
2000b200:	4a11      	ldr	r2, [pc, #68]	; (2000b248 <FLASH_Erase_Sector+0xc0>)
2000b202:	f043 0384 	orr.w	r3, r3, #132	; 0x84
2000b206:	60d3      	str	r3, [r2, #12]

    FLASH->CR1 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000b208:	68bb      	ldr	r3, [r7, #8]
2000b20a:	f003 0302 	and.w	r3, r3, #2
2000b20e:	2b00      	cmp	r3, #0
2000b210:	d014      	beq.n	2000b23c <FLASH_Erase_Sector+0xb4>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank2 */
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
2000b212:	4b0d      	ldr	r3, [pc, #52]	; (2000b248 <FLASH_Erase_Sector+0xc0>)
2000b214:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2000b218:	4a0b      	ldr	r2, [pc, #44]	; (2000b248 <FLASH_Erase_Sector+0xc0>)
2000b21a:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
2000b21e:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
2000b222:	4b09      	ldr	r3, [pc, #36]	; (2000b248 <FLASH_Erase_Sector+0xc0>)
2000b224:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
2000b228:	68fb      	ldr	r3, [r7, #12]
2000b22a:	0219      	lsls	r1, r3, #8
2000b22c:	687b      	ldr	r3, [r7, #4]
2000b22e:	430b      	orrs	r3, r1
2000b230:	4313      	orrs	r3, r2
2000b232:	4a05      	ldr	r2, [pc, #20]	; (2000b248 <FLASH_Erase_Sector+0xc0>)
2000b234:	f043 0384 	orr.w	r3, r3, #132	; 0x84
2000b238:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
    FLASH->CR2 &= ~(FLASH_CR_SNB);

    FLASH->CR2 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }
}
2000b23c:	bf00      	nop
2000b23e:	3710      	adds	r7, #16
2000b240:	46bd      	mov	sp, r7
2000b242:	bd80      	pop	{r7, pc}
2000b244:	2001c0c8 	.word	0x2001c0c8
2000b248:	52002000 	.word	0x52002000

2000b24c <FLASH_OB_EnableWRP>:
  *            @arg FLASH_BANK_BOTH: enable WRP on both bank1 and bank2 specified sectors
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)
{
2000b24c:	b580      	push	{r7, lr}
2000b24e:	b082      	sub	sp, #8
2000b250:	af00      	add	r7, sp, #0
2000b252:	6078      	str	r0, [r7, #4]
2000b254:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
2000b256:	687b      	ldr	r3, [r7, #4]
2000b258:	2b00      	cmp	r3, #0
2000b25a:	d104      	bne.n	2000b266 <FLASH_OB_EnableWRP+0x1a>
2000b25c:	f240 318e 	movw	r1, #910	; 0x38e
2000b260:	4818      	ldr	r0, [pc, #96]	; (2000b2c4 <FLASH_OB_EnableWRP+0x78>)
2000b262:	f7f5 fb47 	bl	200008f4 <assert_failed>
  assert_param(IS_FLASH_BANK(Banks));
2000b266:	683b      	ldr	r3, [r7, #0]
2000b268:	2b01      	cmp	r3, #1
2000b26a:	d00a      	beq.n	2000b282 <FLASH_OB_EnableWRP+0x36>
2000b26c:	683b      	ldr	r3, [r7, #0]
2000b26e:	2b02      	cmp	r3, #2
2000b270:	d007      	beq.n	2000b282 <FLASH_OB_EnableWRP+0x36>
2000b272:	683b      	ldr	r3, [r7, #0]
2000b274:	2b03      	cmp	r3, #3
2000b276:	d004      	beq.n	2000b282 <FLASH_OB_EnableWRP+0x36>
2000b278:	f240 318f 	movw	r1, #911	; 0x38f
2000b27c:	4811      	ldr	r0, [pc, #68]	; (2000b2c4 <FLASH_OB_EnableWRP+0x78>)
2000b27e:	f7f5 fb39 	bl	200008f4 <assert_failed>

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000b282:	683b      	ldr	r3, [r7, #0]
2000b284:	f003 0301 	and.w	r3, r3, #1
2000b288:	2b00      	cmp	r3, #0
2000b28a:	d007      	beq.n	2000b29c <FLASH_OB_EnableWRP+0x50>
  {
    /* Enable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 &= (~(WRPSector & FLASH_WPSN_WRPSN));
2000b28c:	4b0e      	ldr	r3, [pc, #56]	; (2000b2c8 <FLASH_OB_EnableWRP+0x7c>)
2000b28e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
2000b290:	687b      	ldr	r3, [r7, #4]
2000b292:	b2db      	uxtb	r3, r3
2000b294:	43db      	mvns	r3, r3
2000b296:	490c      	ldr	r1, [pc, #48]	; (2000b2c8 <FLASH_OB_EnableWRP+0x7c>)
2000b298:	4013      	ands	r3, r2
2000b29a:	63cb      	str	r3, [r1, #60]	; 0x3c
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000b29c:	683b      	ldr	r3, [r7, #0]
2000b29e:	f003 0302 	and.w	r3, r3, #2
2000b2a2:	2b00      	cmp	r3, #0
2000b2a4:	d009      	beq.n	2000b2ba <FLASH_OB_EnableWRP+0x6e>
  {
    /* Enable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 &= (~(WRPSector & FLASH_WPSN_WRPSN));
2000b2a6:	4b08      	ldr	r3, [pc, #32]	; (2000b2c8 <FLASH_OB_EnableWRP+0x7c>)
2000b2a8:	f8d3 213c 	ldr.w	r2, [r3, #316]	; 0x13c
2000b2ac:	687b      	ldr	r3, [r7, #4]
2000b2ae:	b2db      	uxtb	r3, r3
2000b2b0:	43db      	mvns	r3, r3
2000b2b2:	4905      	ldr	r1, [pc, #20]	; (2000b2c8 <FLASH_OB_EnableWRP+0x7c>)
2000b2b4:	4013      	ands	r3, r2
2000b2b6:	f8c1 313c 	str.w	r3, [r1, #316]	; 0x13c
  }
}
2000b2ba:	bf00      	nop
2000b2bc:	3708      	adds	r7, #8
2000b2be:	46bd      	mov	sp, r7
2000b2c0:	bd80      	pop	{r7, pc}
2000b2c2:	bf00      	nop
2000b2c4:	2001c0c8 	.word	0x2001c0c8
2000b2c8:	52002000 	.word	0x52002000

2000b2cc <FLASH_OB_DisableWRP>:
  *            @arg FLASH_BANK_BOTH: disable WRP on both bank1 and bank2 specified sectors
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)
{
2000b2cc:	b580      	push	{r7, lr}
2000b2ce:	b082      	sub	sp, #8
2000b2d0:	af00      	add	r7, sp, #0
2000b2d2:	6078      	str	r0, [r7, #4]
2000b2d4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
2000b2d6:	687b      	ldr	r3, [r7, #4]
2000b2d8:	2b00      	cmp	r3, #0
2000b2da:	d104      	bne.n	2000b2e6 <FLASH_OB_DisableWRP+0x1a>
2000b2dc:	f240 31af 	movw	r1, #943	; 0x3af
2000b2e0:	4817      	ldr	r0, [pc, #92]	; (2000b340 <FLASH_OB_DisableWRP+0x74>)
2000b2e2:	f7f5 fb07 	bl	200008f4 <assert_failed>
  assert_param(IS_FLASH_BANK(Banks));
2000b2e6:	683b      	ldr	r3, [r7, #0]
2000b2e8:	2b01      	cmp	r3, #1
2000b2ea:	d00a      	beq.n	2000b302 <FLASH_OB_DisableWRP+0x36>
2000b2ec:	683b      	ldr	r3, [r7, #0]
2000b2ee:	2b02      	cmp	r3, #2
2000b2f0:	d007      	beq.n	2000b302 <FLASH_OB_DisableWRP+0x36>
2000b2f2:	683b      	ldr	r3, [r7, #0]
2000b2f4:	2b03      	cmp	r3, #3
2000b2f6:	d004      	beq.n	2000b302 <FLASH_OB_DisableWRP+0x36>
2000b2f8:	f44f 716c 	mov.w	r1, #944	; 0x3b0
2000b2fc:	4810      	ldr	r0, [pc, #64]	; (2000b340 <FLASH_OB_DisableWRP+0x74>)
2000b2fe:	f7f5 faf9 	bl	200008f4 <assert_failed>

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000b302:	683b      	ldr	r3, [r7, #0]
2000b304:	f003 0301 	and.w	r3, r3, #1
2000b308:	2b00      	cmp	r3, #0
2000b30a:	d006      	beq.n	2000b31a <FLASH_OB_DisableWRP+0x4e>
  {
    /* Disable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 |= (WRPSector & FLASH_WPSN_WRPSN);
2000b30c:	4b0d      	ldr	r3, [pc, #52]	; (2000b344 <FLASH_OB_DisableWRP+0x78>)
2000b30e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
2000b310:	687b      	ldr	r3, [r7, #4]
2000b312:	b2db      	uxtb	r3, r3
2000b314:	490b      	ldr	r1, [pc, #44]	; (2000b344 <FLASH_OB_DisableWRP+0x78>)
2000b316:	4313      	orrs	r3, r2
2000b318:	63cb      	str	r3, [r1, #60]	; 0x3c
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000b31a:	683b      	ldr	r3, [r7, #0]
2000b31c:	f003 0302 	and.w	r3, r3, #2
2000b320:	2b00      	cmp	r3, #0
2000b322:	d008      	beq.n	2000b336 <FLASH_OB_DisableWRP+0x6a>
  {
    /* Disable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 |= (WRPSector & FLASH_WPSN_WRPSN);
2000b324:	4b07      	ldr	r3, [pc, #28]	; (2000b344 <FLASH_OB_DisableWRP+0x78>)
2000b326:	f8d3 213c 	ldr.w	r2, [r3, #316]	; 0x13c
2000b32a:	687b      	ldr	r3, [r7, #4]
2000b32c:	b2db      	uxtb	r3, r3
2000b32e:	4905      	ldr	r1, [pc, #20]	; (2000b344 <FLASH_OB_DisableWRP+0x78>)
2000b330:	4313      	orrs	r3, r2
2000b332:	f8c1 313c 	str.w	r3, [r1, #316]	; 0x13c
  }
}
2000b336:	bf00      	nop
2000b338:	3708      	adds	r7, #8
2000b33a:	46bd      	mov	sp, r7
2000b33c:	bd80      	pop	{r7, pc}
2000b33e:	bf00      	nop
2000b340:	2001c0c8 	.word	0x2001c0c8
2000b344:	52002000 	.word	0x52002000

2000b348 <FLASH_OB_GetWRP>:
  *            @arg FLASH_BANK_BOTH: note allowed in this functions
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_GetWRP(uint32_t *WRPState, uint32_t *WRPSector, uint32_t Bank)
{
2000b348:	b480      	push	{r7}
2000b34a:	b087      	sub	sp, #28
2000b34c:	af00      	add	r7, sp, #0
2000b34e:	60f8      	str	r0, [r7, #12]
2000b350:	60b9      	str	r1, [r7, #8]
2000b352:	607a      	str	r2, [r7, #4]
  uint32_t regvalue = 0U;
2000b354:	2300      	movs	r3, #0
2000b356:	617b      	str	r3, [r7, #20]

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
2000b358:	687b      	ldr	r3, [r7, #4]
2000b35a:	f003 0303 	and.w	r3, r3, #3
2000b35e:	2b01      	cmp	r3, #1
2000b360:	d102      	bne.n	2000b368 <FLASH_OB_GetWRP+0x20>
  {
    regvalue = FLASH->WPSN_CUR1;
2000b362:	4b11      	ldr	r3, [pc, #68]	; (2000b3a8 <FLASH_OB_GetWRP+0x60>)
2000b364:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000b366:	617b      	str	r3, [r7, #20]
  }

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_2)
2000b368:	687b      	ldr	r3, [r7, #4]
2000b36a:	f003 0303 	and.w	r3, r3, #3
2000b36e:	2b02      	cmp	r3, #2
2000b370:	d103      	bne.n	2000b37a <FLASH_OB_GetWRP+0x32>
  {
    regvalue = FLASH->WPSN_CUR2;
2000b372:	4b0d      	ldr	r3, [pc, #52]	; (2000b3a8 <FLASH_OB_GetWRP+0x60>)
2000b374:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
2000b378:	617b      	str	r3, [r7, #20]
  }

  (*WRPSector) = (~regvalue) & FLASH_WPSN_WRPSN;
2000b37a:	697b      	ldr	r3, [r7, #20]
2000b37c:	43db      	mvns	r3, r3
2000b37e:	b2da      	uxtb	r2, r3
2000b380:	68bb      	ldr	r3, [r7, #8]
2000b382:	601a      	str	r2, [r3, #0]

  if(*WRPSector == 0U)
2000b384:	68bb      	ldr	r3, [r7, #8]
2000b386:	681b      	ldr	r3, [r3, #0]
2000b388:	2b00      	cmp	r3, #0
2000b38a:	d103      	bne.n	2000b394 <FLASH_OB_GetWRP+0x4c>
  {
    (*WRPState) = OB_WRPSTATE_DISABLE;
2000b38c:	68fb      	ldr	r3, [r7, #12]
2000b38e:	2200      	movs	r2, #0
2000b390:	601a      	str	r2, [r3, #0]
  }
  else
  {
    (*WRPState) = OB_WRPSTATE_ENABLE;
  }
}
2000b392:	e002      	b.n	2000b39a <FLASH_OB_GetWRP+0x52>
    (*WRPState) = OB_WRPSTATE_ENABLE;
2000b394:	68fb      	ldr	r3, [r7, #12]
2000b396:	2201      	movs	r2, #1
2000b398:	601a      	str	r2, [r3, #0]
}
2000b39a:	bf00      	nop
2000b39c:	371c      	adds	r7, #28
2000b39e:	46bd      	mov	sp, r7
2000b3a0:	f85d 7b04 	ldr.w	r7, [sp], #4
2000b3a4:	4770      	bx	lr
2000b3a6:	bf00      	nop
2000b3a8:	52002000 	.word	0x52002000

2000b3ac <FLASH_OB_RDPConfig>:
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  *
  * @retval HAL status
  */
static void FLASH_OB_RDPConfig(uint32_t RDPLevel)
{
2000b3ac:	b580      	push	{r7, lr}
2000b3ae:	b082      	sub	sp, #8
2000b3b0:	af00      	add	r7, sp, #0
2000b3b2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));
2000b3b4:	687b      	ldr	r3, [r7, #4]
2000b3b6:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000b3ba:	d00c      	beq.n	2000b3d6 <FLASH_OB_RDPConfig+0x2a>
2000b3bc:	687b      	ldr	r3, [r7, #4]
2000b3be:	f5b3 4faa 	cmp.w	r3, #21760	; 0x5500
2000b3c2:	d008      	beq.n	2000b3d6 <FLASH_OB_RDPConfig+0x2a>
2000b3c4:	687b      	ldr	r3, [r7, #4]
2000b3c6:	f5b3 4f4c 	cmp.w	r3, #52224	; 0xcc00
2000b3ca:	d004      	beq.n	2000b3d6 <FLASH_OB_RDPConfig+0x2a>
2000b3cc:	f44f 6180 	mov.w	r1, #1024	; 0x400
2000b3d0:	4807      	ldr	r0, [pc, #28]	; (2000b3f0 <FLASH_OB_RDPConfig+0x44>)
2000b3d2:	f7f5 fa8f 	bl	200008f4 <assert_failed>

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_RDP, RDPLevel);
2000b3d6:	4b07      	ldr	r3, [pc, #28]	; (2000b3f4 <FLASH_OB_RDPConfig+0x48>)
2000b3d8:	6a1b      	ldr	r3, [r3, #32]
2000b3da:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
2000b3de:	4905      	ldr	r1, [pc, #20]	; (2000b3f4 <FLASH_OB_RDPConfig+0x48>)
2000b3e0:	687b      	ldr	r3, [r7, #4]
2000b3e2:	4313      	orrs	r3, r2
2000b3e4:	620b      	str	r3, [r1, #32]
}
2000b3e6:	bf00      	nop
2000b3e8:	3708      	adds	r7, #8
2000b3ea:	46bd      	mov	sp, r7
2000b3ec:	bd80      	pop	{r7, pc}
2000b3ee:	bf00      	nop
2000b3f0:	2001c0c8 	.word	0x2001c0c8
2000b3f4:	52002000 	.word	0x52002000

2000b3f8 <FLASH_OB_GetRDP>:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
2000b3f8:	b480      	push	{r7}
2000b3fa:	b083      	sub	sp, #12
2000b3fc:	af00      	add	r7, sp, #0
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
2000b3fe:	4b0b      	ldr	r3, [pc, #44]	; (2000b42c <FLASH_OB_GetRDP+0x34>)
2000b400:	69db      	ldr	r3, [r3, #28]
2000b402:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
2000b406:	607b      	str	r3, [r7, #4]
  
  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))
2000b408:	687b      	ldr	r3, [r7, #4]
2000b40a:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000b40e:	d006      	beq.n	2000b41e <FLASH_OB_GetRDP+0x26>
2000b410:	687b      	ldr	r3, [r7, #4]
2000b412:	f5b3 4f4c 	cmp.w	r3, #52224	; 0xcc00
2000b416:	d002      	beq.n	2000b41e <FLASH_OB_GetRDP+0x26>
  {
    return (OB_RDP_LEVEL_1);
2000b418:	f44f 43aa 	mov.w	r3, #21760	; 0x5500
2000b41c:	e000      	b.n	2000b420 <FLASH_OB_GetRDP+0x28>
  }
  else
  {
    return rdp_level;
2000b41e:	687b      	ldr	r3, [r7, #4]
  }
}
2000b420:	4618      	mov	r0, r3
2000b422:	370c      	adds	r7, #12
2000b424:	46bd      	mov	sp, r7
2000b426:	f85d 7b04 	ldr.w	r7, [sp], #4
2000b42a:	4770      	bx	lr
2000b42c:	52002000 	.word	0x52002000

2000b430 <FLASH_OB_UserConfig>:
  *
  * @retval HAL status
  */
#endif /*DUAL_CORE*/
static void FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig)
{
2000b430:	b580      	push	{r7, lr}
2000b432:	b084      	sub	sp, #16
2000b434:	af00      	add	r7, sp, #0
2000b436:	6078      	str	r0, [r7, #4]
2000b438:	6039      	str	r1, [r7, #0]
  uint32_t optr_reg_val = 0;
2000b43a:	2300      	movs	r3, #0
2000b43c:	60fb      	str	r3, [r7, #12]
  uint32_t optr_reg_mask = 0;
2000b43e:	2300      	movs	r3, #0
2000b440:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));
2000b442:	687b      	ldr	r3, [r7, #4]
2000b444:	f5b3 6fe8 	cmp.w	r3, #1856	; 0x740
2000b448:	d202      	bcs.n	2000b450 <FLASH_OB_UserConfig+0x20>
2000b44a:	687b      	ldr	r3, [r7, #4]
2000b44c:	2b00      	cmp	r3, #0
2000b44e:	d104      	bne.n	2000b45a <FLASH_OB_UserConfig+0x2a>
2000b450:	f240 414c 	movw	r1, #1100	; 0x44c
2000b454:	4893      	ldr	r0, [pc, #588]	; (2000b6a4 <FLASH_OB_UserConfig+0x274>)
2000b456:	f7f5 fa4d 	bl	200008f4 <assert_failed>

  if((UserType & OB_USER_IWDG1_SW) != 0U)
2000b45a:	687b      	ldr	r3, [r7, #4]
2000b45c:	f003 0301 	and.w	r3, r3, #1
2000b460:	2b00      	cmp	r3, #0
2000b462:	d018      	beq.n	2000b496 <FLASH_OB_UserConfig+0x66>
  {
    /* IWDG_HW option byte should be modified */
    assert_param(IS_OB_IWDG1_SOURCE(UserConfig & FLASH_OPTSR_IWDG1_SW));
2000b464:	683b      	ldr	r3, [r7, #0]
2000b466:	f003 0310 	and.w	r3, r3, #16
2000b46a:	2b00      	cmp	r3, #0
2000b46c:	d109      	bne.n	2000b482 <FLASH_OB_UserConfig+0x52>
2000b46e:	683b      	ldr	r3, [r7, #0]
2000b470:	f003 0310 	and.w	r3, r3, #16
2000b474:	2b00      	cmp	r3, #0
2000b476:	d004      	beq.n	2000b482 <FLASH_OB_UserConfig+0x52>
2000b478:	f240 4151 	movw	r1, #1105	; 0x451
2000b47c:	4889      	ldr	r0, [pc, #548]	; (2000b6a4 <FLASH_OB_UserConfig+0x274>)
2000b47e:	f7f5 fa39 	bl	200008f4 <assert_failed>

    /* Set value and mask for IWDG_HW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG1_SW);
2000b482:	683b      	ldr	r3, [r7, #0]
2000b484:	f003 0310 	and.w	r3, r3, #16
2000b488:	68fa      	ldr	r2, [r7, #12]
2000b48a:	4313      	orrs	r3, r2
2000b48c:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_IWDG1_SW;
2000b48e:	68bb      	ldr	r3, [r7, #8]
2000b490:	f043 0310 	orr.w	r3, r3, #16
2000b494:	60bb      	str	r3, [r7, #8]
    /* Set value and mask for IWDG2_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG2_SW);
    optr_reg_mask |= FLASH_OPTSR_IWDG2_SW;
  }
#endif /*DUAL_CORE*/
  if((UserType & OB_USER_NRST_STOP_D1) != 0U)
2000b496:	687b      	ldr	r3, [r7, #4]
2000b498:	f003 0302 	and.w	r3, r3, #2
2000b49c:	2b00      	cmp	r3, #0
2000b49e:	d018      	beq.n	2000b4d2 <FLASH_OB_UserConfig+0xa2>
  {
    /* NRST_STOP option byte should be modified */
    assert_param(IS_OB_STOP_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D1));
2000b4a0:	683b      	ldr	r3, [r7, #0]
2000b4a2:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000b4a6:	2b00      	cmp	r3, #0
2000b4a8:	d109      	bne.n	2000b4be <FLASH_OB_UserConfig+0x8e>
2000b4aa:	683b      	ldr	r3, [r7, #0]
2000b4ac:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000b4b0:	2b00      	cmp	r3, #0
2000b4b2:	d004      	beq.n	2000b4be <FLASH_OB_UserConfig+0x8e>
2000b4b4:	f240 4165 	movw	r1, #1125	; 0x465
2000b4b8:	487a      	ldr	r0, [pc, #488]	; (2000b6a4 <FLASH_OB_UserConfig+0x274>)
2000b4ba:	f7f5 fa1b 	bl	200008f4 <assert_failed>

    /* Set value and mask for NRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
2000b4be:	683b      	ldr	r3, [r7, #0]
2000b4c0:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000b4c4:	68fa      	ldr	r2, [r7, #12]
2000b4c6:	4313      	orrs	r3, r2
2000b4c8:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D1;
2000b4ca:	68bb      	ldr	r3, [r7, #8]
2000b4cc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2000b4d0:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_NRST_STDBY_D1) != 0U)
2000b4d2:	687b      	ldr	r3, [r7, #4]
2000b4d4:	f003 0304 	and.w	r3, r3, #4
2000b4d8:	2b00      	cmp	r3, #0
2000b4da:	d018      	beq.n	2000b50e <FLASH_OB_UserConfig+0xde>
  {
    /* NRST_STDBY option byte should be modified */
    assert_param(IS_OB_STDBY_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D1));
2000b4dc:	683b      	ldr	r3, [r7, #0]
2000b4de:	f003 0380 	and.w	r3, r3, #128	; 0x80
2000b4e2:	2b00      	cmp	r3, #0
2000b4e4:	d109      	bne.n	2000b4fa <FLASH_OB_UserConfig+0xca>
2000b4e6:	683b      	ldr	r3, [r7, #0]
2000b4e8:	f003 0380 	and.w	r3, r3, #128	; 0x80
2000b4ec:	2b00      	cmp	r3, #0
2000b4ee:	d004      	beq.n	2000b4fa <FLASH_OB_UserConfig+0xca>
2000b4f0:	f240 416f 	movw	r1, #1135	; 0x46f
2000b4f4:	486b      	ldr	r0, [pc, #428]	; (2000b6a4 <FLASH_OB_UserConfig+0x274>)
2000b4f6:	f7f5 f9fd 	bl	200008f4 <assert_failed>

    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
2000b4fa:	683b      	ldr	r3, [r7, #0]
2000b4fc:	f003 0380 	and.w	r3, r3, #128	; 0x80
2000b500:	68fa      	ldr	r2, [r7, #12]
2000b502:	4313      	orrs	r3, r2
2000b504:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D1;
2000b506:	68bb      	ldr	r3, [r7, #8]
2000b508:	f043 0380 	orr.w	r3, r3, #128	; 0x80
2000b50c:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
2000b50e:	687b      	ldr	r3, [r7, #4]
2000b510:	f003 0308 	and.w	r3, r3, #8
2000b514:	2b00      	cmp	r3, #0
2000b516:	d018      	beq.n	2000b54a <FLASH_OB_UserConfig+0x11a>
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTSR_FZ_IWDG_STOP));
2000b518:	683b      	ldr	r3, [r7, #0]
2000b51a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000b51e:	2b00      	cmp	r3, #0
2000b520:	d009      	beq.n	2000b536 <FLASH_OB_UserConfig+0x106>
2000b522:	683b      	ldr	r3, [r7, #0]
2000b524:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000b528:	2b00      	cmp	r3, #0
2000b52a:	d104      	bne.n	2000b536 <FLASH_OB_UserConfig+0x106>
2000b52c:	f240 4179 	movw	r1, #1145	; 0x479
2000b530:	485c      	ldr	r0, [pc, #368]	; (2000b6a4 <FLASH_OB_UserConfig+0x274>)
2000b532:	f7f5 f9df 	bl	200008f4 <assert_failed>

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
2000b536:	683b      	ldr	r3, [r7, #0]
2000b538:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000b53c:	68fa      	ldr	r2, [r7, #12]
2000b53e:	4313      	orrs	r3, r2
2000b540:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_STOP;
2000b542:	68bb      	ldr	r3, [r7, #8]
2000b544:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2000b548:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
2000b54a:	687b      	ldr	r3, [r7, #4]
2000b54c:	f003 0310 	and.w	r3, r3, #16
2000b550:	2b00      	cmp	r3, #0
2000b552:	d018      	beq.n	2000b586 <FLASH_OB_UserConfig+0x156>
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY));
2000b554:	683b      	ldr	r3, [r7, #0]
2000b556:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2000b55a:	2b00      	cmp	r3, #0
2000b55c:	d009      	beq.n	2000b572 <FLASH_OB_UserConfig+0x142>
2000b55e:	683b      	ldr	r3, [r7, #0]
2000b560:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2000b564:	2b00      	cmp	r3, #0
2000b566:	d104      	bne.n	2000b572 <FLASH_OB_UserConfig+0x142>
2000b568:	f240 4183 	movw	r1, #1155	; 0x483
2000b56c:	484d      	ldr	r0, [pc, #308]	; (2000b6a4 <FLASH_OB_UserConfig+0x274>)
2000b56e:	f7f5 f9c1 	bl	200008f4 <assert_failed>

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
2000b572:	683b      	ldr	r3, [r7, #0]
2000b574:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2000b578:	68fa      	ldr	r2, [r7, #12]
2000b57a:	4313      	orrs	r3, r2
2000b57c:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_SDBY;
2000b57e:	68bb      	ldr	r3, [r7, #8]
2000b580:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
2000b584:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_ST_RAM_SIZE) != 0U)
2000b586:	687b      	ldr	r3, [r7, #4]
2000b588:	f003 0320 	and.w	r3, r3, #32
2000b58c:	2b00      	cmp	r3, #0
2000b58e:	d025      	beq.n	2000b5dc <FLASH_OB_UserConfig+0x1ac>
  {
    /* ST_RAM_SIZE option byte should be modified */
    assert_param(IS_OB_USER_ST_RAM_SIZE(UserConfig & FLASH_OPTSR_ST_RAM_SIZE));
2000b590:	683b      	ldr	r3, [r7, #0]
2000b592:	f403 13c0 	and.w	r3, r3, #1572864	; 0x180000
2000b596:	2b00      	cmp	r3, #0
2000b598:	d016      	beq.n	2000b5c8 <FLASH_OB_UserConfig+0x198>
2000b59a:	683b      	ldr	r3, [r7, #0]
2000b59c:	f403 13c0 	and.w	r3, r3, #1572864	; 0x180000
2000b5a0:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
2000b5a4:	d010      	beq.n	2000b5c8 <FLASH_OB_UserConfig+0x198>
2000b5a6:	683b      	ldr	r3, [r7, #0]
2000b5a8:	f403 13c0 	and.w	r3, r3, #1572864	; 0x180000
2000b5ac:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2000b5b0:	d00a      	beq.n	2000b5c8 <FLASH_OB_UserConfig+0x198>
2000b5b2:	683b      	ldr	r3, [r7, #0]
2000b5b4:	f403 13c0 	and.w	r3, r3, #1572864	; 0x180000
2000b5b8:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
2000b5bc:	d004      	beq.n	2000b5c8 <FLASH_OB_UserConfig+0x198>
2000b5be:	f240 418d 	movw	r1, #1165	; 0x48d
2000b5c2:	4838      	ldr	r0, [pc, #224]	; (2000b6a4 <FLASH_OB_UserConfig+0x274>)
2000b5c4:	f7f5 f996 	bl	200008f4 <assert_failed>

    /* Set value and mask for ST_RAM_SIZE option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
2000b5c8:	683b      	ldr	r3, [r7, #0]
2000b5ca:	f403 13c0 	and.w	r3, r3, #1572864	; 0x180000
2000b5ce:	68fa      	ldr	r2, [r7, #12]
2000b5d0:	4313      	orrs	r3, r2
2000b5d2:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_ST_RAM_SIZE;
2000b5d4:	68bb      	ldr	r3, [r7, #8]
2000b5d6:	f443 13c0 	orr.w	r3, r3, #1572864	; 0x180000
2000b5da:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_SECURITY) != 0U)
2000b5dc:	687b      	ldr	r3, [r7, #4]
2000b5de:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000b5e2:	2b00      	cmp	r3, #0
2000b5e4:	d018      	beq.n	2000b618 <FLASH_OB_UserConfig+0x1e8>
  {
    /* SECURITY option byte should be modified */
    assert_param(IS_OB_USER_SECURITY(UserConfig & FLASH_OPTSR_SECURITY));
2000b5e6:	683b      	ldr	r3, [r7, #0]
2000b5e8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
2000b5ec:	2b00      	cmp	r3, #0
2000b5ee:	d109      	bne.n	2000b604 <FLASH_OB_UserConfig+0x1d4>
2000b5f0:	683b      	ldr	r3, [r7, #0]
2000b5f2:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
2000b5f6:	2b00      	cmp	r3, #0
2000b5f8:	d004      	beq.n	2000b604 <FLASH_OB_UserConfig+0x1d4>
2000b5fa:	f240 4197 	movw	r1, #1175	; 0x497
2000b5fe:	4829      	ldr	r0, [pc, #164]	; (2000b6a4 <FLASH_OB_UserConfig+0x274>)
2000b600:	f7f5 f978 	bl	200008f4 <assert_failed>

    /* Set value and mask for SECURITY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
2000b604:	683b      	ldr	r3, [r7, #0]
2000b606:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
2000b60a:	68fa      	ldr	r2, [r7, #12]
2000b60c:	4313      	orrs	r3, r2
2000b60e:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_SECURITY;
2000b610:	68bb      	ldr	r3, [r7, #8]
2000b612:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
2000b616:	60bb      	str	r3, [r7, #8]
    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D2);
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D2;
  }
#endif /* DUAL_CORE */
  if((UserType & OB_USER_SWAP_BANK) != 0U)
2000b618:	687b      	ldr	r3, [r7, #4]
2000b61a:	f403 7380 	and.w	r3, r3, #256	; 0x100
2000b61e:	2b00      	cmp	r3, #0
2000b620:	d014      	beq.n	2000b64c <FLASH_OB_UserConfig+0x21c>
  {
    /* SWAP_BANK_OPT option byte should be modified */
    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTSR_SWAP_BANK_OPT));
2000b622:	683b      	ldr	r3, [r7, #0]
2000b624:	2b00      	cmp	r3, #0
2000b626:	da07      	bge.n	2000b638 <FLASH_OB_UserConfig+0x208>
2000b628:	683b      	ldr	r3, [r7, #0]
2000b62a:	2b00      	cmp	r3, #0
2000b62c:	db04      	blt.n	2000b638 <FLASH_OB_UserConfig+0x208>
2000b62e:	f240 41ca 	movw	r1, #1226	; 0x4ca
2000b632:	481c      	ldr	r0, [pc, #112]	; (2000b6a4 <FLASH_OB_UserConfig+0x274>)
2000b634:	f7f5 f95e 	bl	200008f4 <assert_failed>

    /* Set value and mask for SWAP_BANK_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
2000b638:	683b      	ldr	r3, [r7, #0]
2000b63a:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
2000b63e:	68fa      	ldr	r2, [r7, #12]
2000b640:	4313      	orrs	r3, r2
2000b642:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_SWAP_BANK_OPT;
2000b644:	68bb      	ldr	r3, [r7, #8]
2000b646:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
2000b64a:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IOHSLV) != 0U)
2000b64c:	687b      	ldr	r3, [r7, #4]
2000b64e:	f003 0380 	and.w	r3, r3, #128	; 0x80
2000b652:	2b00      	cmp	r3, #0
2000b654:	d018      	beq.n	2000b688 <FLASH_OB_UserConfig+0x258>
  {
    /* IOHSLV_OPT option byte should be modified */
    assert_param(IS_OB_USER_IOHSLV(UserConfig & FLASH_OPTSR_IO_HSLV));
2000b656:	683b      	ldr	r3, [r7, #0]
2000b658:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2000b65c:	2b00      	cmp	r3, #0
2000b65e:	d009      	beq.n	2000b674 <FLASH_OB_UserConfig+0x244>
2000b660:	683b      	ldr	r3, [r7, #0]
2000b662:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2000b666:	2b00      	cmp	r3, #0
2000b668:	d104      	bne.n	2000b674 <FLASH_OB_UserConfig+0x244>
2000b66a:	f240 41d4 	movw	r1, #1236	; 0x4d4
2000b66e:	480d      	ldr	r0, [pc, #52]	; (2000b6a4 <FLASH_OB_UserConfig+0x274>)
2000b670:	f7f5 f940 	bl	200008f4 <assert_failed>

    /* Set value and mask for IOHSLV_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
2000b674:	683b      	ldr	r3, [r7, #0]
2000b676:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2000b67a:	68fa      	ldr	r2, [r7, #12]
2000b67c:	4313      	orrs	r3, r2
2000b67e:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_IO_HSLV;
2000b680:	68bb      	ldr	r3, [r7, #8]
2000b682:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
2000b686:	60bb      	str	r3, [r7, #8]
    optr_reg_mask |= FLASH_OPTSR_VDDMMC_HSLV;
  }
#endif /* FLASH_OPTSR_VDDMMC_HSLV */

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
2000b688:	4b07      	ldr	r3, [pc, #28]	; (2000b6a8 <FLASH_OB_UserConfig+0x278>)
2000b68a:	6a1a      	ldr	r2, [r3, #32]
2000b68c:	68bb      	ldr	r3, [r7, #8]
2000b68e:	43db      	mvns	r3, r3
2000b690:	401a      	ands	r2, r3
2000b692:	4905      	ldr	r1, [pc, #20]	; (2000b6a8 <FLASH_OB_UserConfig+0x278>)
2000b694:	68fb      	ldr	r3, [r7, #12]
2000b696:	4313      	orrs	r3, r2
2000b698:	620b      	str	r3, [r1, #32]
}
2000b69a:	bf00      	nop
2000b69c:	3710      	adds	r7, #16
2000b69e:	46bd      	mov	sp, r7
2000b6a0:	bd80      	pop	{r7, pc}
2000b6a2:	bf00      	nop
2000b6a4:	2001c0c8 	.word	0x2001c0c8
2000b6a8:	52002000 	.word	0x52002000

2000b6ac <FLASH_OB_GetUser>:
  *         FZ_IWDG_STOP(Bit 17), FZ_IWDG_SDBY(Bit 18), ST_RAM_SIZE(Bit[19:20]),
  *         SECURITY(Bit 21), IO_HSLV (Bit 29) and SWAP_BANK_OPT(Bit 31).
  */
#endif /*DUAL_CORE*/
static uint32_t FLASH_OB_GetUser(void)
{
2000b6ac:	b480      	push	{r7}
2000b6ae:	b083      	sub	sp, #12
2000b6b0:	af00      	add	r7, sp, #0
  uint32_t userConfig = READ_REG(FLASH->OPTSR_CUR);
2000b6b2:	4b07      	ldr	r3, [pc, #28]	; (2000b6d0 <FLASH_OB_GetUser+0x24>)
2000b6b4:	69db      	ldr	r3, [r3, #28]
2000b6b6:	607b      	str	r3, [r7, #4]
  userConfig &= (~(FLASH_OPTSR_BOR_LEV | FLASH_OPTSR_RDP));
2000b6b8:	687a      	ldr	r2, [r7, #4]
2000b6ba:	4b06      	ldr	r3, [pc, #24]	; (2000b6d4 <FLASH_OB_GetUser+0x28>)
2000b6bc:	4013      	ands	r3, r2
2000b6be:	607b      	str	r3, [r7, #4]

  return userConfig;
2000b6c0:	687b      	ldr	r3, [r7, #4]
}
2000b6c2:	4618      	mov	r0, r3
2000b6c4:	370c      	adds	r7, #12
2000b6c6:	46bd      	mov	sp, r7
2000b6c8:	f85d 7b04 	ldr.w	r7, [sp], #4
2000b6cc:	4770      	bx	lr
2000b6ce:	bf00      	nop
2000b6d0:	52002000 	.word	0x52002000
2000b6d4:	ffff00f3 	.word	0xffff00f3

2000b6d8 <FLASH_OB_PCROPConfig>:
  *            @arg FLASH_BANK_BOTH: PCROP on specified bank1 and bank2 area (same config will be applied on both banks)
  *
  * @retval None
  */
static void FLASH_OB_PCROPConfig(uint32_t PCROPConfig, uint32_t PCROPStartAddr, uint32_t PCROPEndAddr, uint32_t Banks)
{
2000b6d8:	b580      	push	{r7, lr}
2000b6da:	b084      	sub	sp, #16
2000b6dc:	af00      	add	r7, sp, #0
2000b6de:	60f8      	str	r0, [r7, #12]
2000b6e0:	60b9      	str	r1, [r7, #8]
2000b6e2:	607a      	str	r2, [r7, #4]
2000b6e4:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
2000b6e6:	683b      	ldr	r3, [r7, #0]
2000b6e8:	2b01      	cmp	r3, #1
2000b6ea:	d00a      	beq.n	2000b702 <FLASH_OB_PCROPConfig+0x2a>
2000b6ec:	683b      	ldr	r3, [r7, #0]
2000b6ee:	2b02      	cmp	r3, #2
2000b6f0:	d007      	beq.n	2000b702 <FLASH_OB_PCROPConfig+0x2a>
2000b6f2:	683b      	ldr	r3, [r7, #0]
2000b6f4:	2b03      	cmp	r3, #3
2000b6f6:	d004      	beq.n	2000b702 <FLASH_OB_PCROPConfig+0x2a>
2000b6f8:	f240 5122 	movw	r1, #1314	; 0x522
2000b6fc:	4836      	ldr	r0, [pc, #216]	; (2000b7d8 <FLASH_OB_PCROPConfig+0x100>)
2000b6fe:	f7f5 f8f9 	bl	200008f4 <assert_failed>
  assert_param(IS_OB_PCROP_RDP(PCROPConfig));
2000b702:	68fb      	ldr	r3, [r7, #12]
2000b704:	2b00      	cmp	r3, #0
2000b706:	d008      	beq.n	2000b71a <FLASH_OB_PCROPConfig+0x42>
2000b708:	68fb      	ldr	r3, [r7, #12]
2000b70a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
2000b70e:	d004      	beq.n	2000b71a <FLASH_OB_PCROPConfig+0x42>
2000b710:	f240 5123 	movw	r1, #1315	; 0x523
2000b714:	4830      	ldr	r0, [pc, #192]	; (2000b7d8 <FLASH_OB_PCROPConfig+0x100>)
2000b716:	f7f5 f8ed 	bl	200008f4 <assert_failed>

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000b71a:	683b      	ldr	r3, [r7, #0]
2000b71c:	f003 0301 	and.w	r3, r3, #1
2000b720:	2b00      	cmp	r3, #0
2000b722:	d027      	beq.n	2000b774 <FLASH_OB_PCROPConfig+0x9c>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPStartAddr));
2000b724:	68bb      	ldr	r3, [r7, #8]
2000b726:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2000b72a:	d303      	bcc.n	2000b734 <FLASH_OB_PCROPConfig+0x5c>
2000b72c:	68bb      	ldr	r3, [r7, #8]
2000b72e:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000b732:	d304      	bcc.n	2000b73e <FLASH_OB_PCROPConfig+0x66>
2000b734:	f240 5127 	movw	r1, #1319	; 0x527
2000b738:	4827      	ldr	r0, [pc, #156]	; (2000b7d8 <FLASH_OB_PCROPConfig+0x100>)
2000b73a:	f7f5 f8db 	bl	200008f4 <assert_failed>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPEndAddr));
2000b73e:	687b      	ldr	r3, [r7, #4]
2000b740:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2000b744:	d303      	bcc.n	2000b74e <FLASH_OB_PCROPConfig+0x76>
2000b746:	687b      	ldr	r3, [r7, #4]
2000b748:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000b74c:	d304      	bcc.n	2000b758 <FLASH_OB_PCROPConfig+0x80>
2000b74e:	f44f 61a5 	mov.w	r1, #1320	; 0x528
2000b752:	4821      	ldr	r0, [pc, #132]	; (2000b7d8 <FLASH_OB_PCROPConfig+0x100>)
2000b754:	f7f5 f8ce 	bl	200008f4 <assert_failed>

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
2000b758:	68bb      	ldr	r3, [r7, #8]
2000b75a:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2000b75e:	0a1a      	lsrs	r2, r3, #8
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
2000b760:	687b      	ldr	r3, [r7, #4]
2000b762:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2000b766:	0a1b      	lsrs	r3, r3, #8
2000b768:	041b      	lsls	r3, r3, #16
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
2000b76a:	431a      	orrs	r2, r3
2000b76c:	491b      	ldr	r1, [pc, #108]	; (2000b7dc <FLASH_OB_PCROPConfig+0x104>)
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
2000b76e:	68fb      	ldr	r3, [r7, #12]
2000b770:	4313      	orrs	r3, r2
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
2000b772:	62cb      	str	r3, [r1, #44]	; 0x2c
                       PCROPConfig;
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000b774:	683b      	ldr	r3, [r7, #0]
2000b776:	f003 0302 	and.w	r3, r3, #2
2000b77a:	2b00      	cmp	r3, #0
2000b77c:	d028      	beq.n	2000b7d0 <FLASH_OB_PCROPConfig+0xf8>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPStartAddr));
2000b77e:	68bb      	ldr	r3, [r7, #8]
2000b780:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000b784:	d303      	bcc.n	2000b78e <FLASH_OB_PCROPConfig+0xb6>
2000b786:	68bb      	ldr	r3, [r7, #8]
2000b788:	4a15      	ldr	r2, [pc, #84]	; (2000b7e0 <FLASH_OB_PCROPConfig+0x108>)
2000b78a:	4293      	cmp	r3, r2
2000b78c:	d904      	bls.n	2000b798 <FLASH_OB_PCROPConfig+0xc0>
2000b78e:	f240 5132 	movw	r1, #1330	; 0x532
2000b792:	4811      	ldr	r0, [pc, #68]	; (2000b7d8 <FLASH_OB_PCROPConfig+0x100>)
2000b794:	f7f5 f8ae 	bl	200008f4 <assert_failed>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPEndAddr));
2000b798:	687b      	ldr	r3, [r7, #4]
2000b79a:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000b79e:	d303      	bcc.n	2000b7a8 <FLASH_OB_PCROPConfig+0xd0>
2000b7a0:	687b      	ldr	r3, [r7, #4]
2000b7a2:	4a0f      	ldr	r2, [pc, #60]	; (2000b7e0 <FLASH_OB_PCROPConfig+0x108>)
2000b7a4:	4293      	cmp	r3, r2
2000b7a6:	d904      	bls.n	2000b7b2 <FLASH_OB_PCROPConfig+0xda>
2000b7a8:	f240 5133 	movw	r1, #1331	; 0x533
2000b7ac:	480a      	ldr	r0, [pc, #40]	; (2000b7d8 <FLASH_OB_PCROPConfig+0x100>)
2000b7ae:	f7f5 f8a1 	bl	200008f4 <assert_failed>

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
2000b7b2:	68bb      	ldr	r3, [r7, #8]
2000b7b4:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
2000b7b8:	0a1a      	lsrs	r2, r3, #8
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
2000b7ba:	687b      	ldr	r3, [r7, #4]
2000b7bc:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
2000b7c0:	0a1b      	lsrs	r3, r3, #8
2000b7c2:	041b      	lsls	r3, r3, #16
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
2000b7c4:	431a      	orrs	r2, r3
2000b7c6:	4905      	ldr	r1, [pc, #20]	; (2000b7dc <FLASH_OB_PCROPConfig+0x104>)
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
2000b7c8:	68fb      	ldr	r3, [r7, #12]
2000b7ca:	4313      	orrs	r3, r2
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
2000b7cc:	f8c1 312c 	str.w	r3, [r1, #300]	; 0x12c
                       PCROPConfig;
  }
}
2000b7d0:	bf00      	nop
2000b7d2:	3710      	adds	r7, #16
2000b7d4:	46bd      	mov	sp, r7
2000b7d6:	bd80      	pop	{r7, pc}
2000b7d8:	2001c0c8 	.word	0x2001c0c8
2000b7dc:	52002000 	.word	0x52002000
2000b7e0:	0801ffff 	.word	0x0801ffff

2000b7e4 <FLASH_OB_GetPCROP>:
  *            @arg FLASH_BANK_BOTH: is  not allowed here
  *
  * @retval None
  */
static void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROPStartAddr, uint32_t *PCROPEndAddr, uint32_t Bank)
{
2000b7e4:	b480      	push	{r7}
2000b7e6:	b087      	sub	sp, #28
2000b7e8:	af00      	add	r7, sp, #0
2000b7ea:	60f8      	str	r0, [r7, #12]
2000b7ec:	60b9      	str	r1, [r7, #8]
2000b7ee:	607a      	str	r2, [r7, #4]
2000b7f0:	603b      	str	r3, [r7, #0]
  uint32_t regvalue = 0;
2000b7f2:	2300      	movs	r3, #0
2000b7f4:	617b      	str	r3, [r7, #20]
  uint32_t bankBase = 0;
2000b7f6:	2300      	movs	r3, #0
2000b7f8:	613b      	str	r3, [r7, #16]

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
2000b7fa:	683b      	ldr	r3, [r7, #0]
2000b7fc:	f003 0303 	and.w	r3, r3, #3
2000b800:	2b01      	cmp	r3, #1
2000b802:	d105      	bne.n	2000b810 <FLASH_OB_GetPCROP+0x2c>
  {
    regvalue = FLASH->PRAR_CUR1;
2000b804:	4b18      	ldr	r3, [pc, #96]	; (2000b868 <FLASH_OB_GetPCROP+0x84>)
2000b806:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2000b808:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK1_BASE;
2000b80a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
2000b80e:	613b      	str	r3, [r7, #16]
  }

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_2)
2000b810:	683b      	ldr	r3, [r7, #0]
2000b812:	f003 0303 	and.w	r3, r3, #3
2000b816:	2b02      	cmp	r3, #2
2000b818:	d106      	bne.n	2000b828 <FLASH_OB_GetPCROP+0x44>
  {
    regvalue = FLASH->PRAR_CUR2;
2000b81a:	4b13      	ldr	r3, [pc, #76]	; (2000b868 <FLASH_OB_GetPCROP+0x84>)
2000b81c:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
2000b820:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK2_BASE;
2000b822:	f04f 6301 	mov.w	r3, #135266304	; 0x8100000
2000b826:	613b      	str	r3, [r7, #16]
  }

  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
2000b828:	697b      	ldr	r3, [r7, #20]
2000b82a:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
2000b82e:	68fb      	ldr	r3, [r7, #12]
2000b830:	601a      	str	r2, [r3, #0]

  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
2000b832:	697b      	ldr	r3, [r7, #20]
2000b834:	021a      	lsls	r2, r3, #8
2000b836:	4b0d      	ldr	r3, [pc, #52]	; (2000b86c <FLASH_OB_GetPCROP+0x88>)
2000b838:	4013      	ands	r3, r2
2000b83a:	693a      	ldr	r2, [r7, #16]
2000b83c:	441a      	add	r2, r3
2000b83e:	68bb      	ldr	r3, [r7, #8]
2000b840:	601a      	str	r2, [r3, #0]
  (*PCROPEndAddr) = (regvalue & FLASH_PRAR_PROT_AREA_END) >> FLASH_PRAR_PROT_AREA_END_Pos;
2000b842:	697b      	ldr	r3, [r7, #20]
2000b844:	0c1b      	lsrs	r3, r3, #16
2000b846:	f3c3 020b 	ubfx	r2, r3, #0, #12
2000b84a:	687b      	ldr	r3, [r7, #4]
2000b84c:	601a      	str	r2, [r3, #0]
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
2000b84e:	687b      	ldr	r3, [r7, #4]
2000b850:	681b      	ldr	r3, [r3, #0]
2000b852:	021a      	lsls	r2, r3, #8
2000b854:	693b      	ldr	r3, [r7, #16]
2000b856:	441a      	add	r2, r3
2000b858:	687b      	ldr	r3, [r7, #4]
2000b85a:	601a      	str	r2, [r3, #0]
}
2000b85c:	bf00      	nop
2000b85e:	371c      	adds	r7, #28
2000b860:	46bd      	mov	sp, r7
2000b862:	f85d 7b04 	ldr.w	r7, [sp], #4
2000b866:	4770      	bx	lr
2000b868:	52002000 	.word	0x52002000
2000b86c:	000fff00 	.word	0x000fff00

2000b870 <FLASH_OB_BOR_LevelConfig>:
  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V
  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V
  * @retval None
  */
static void FLASH_OB_BOR_LevelConfig(uint32_t Level)
{
2000b870:	b580      	push	{r7, lr}
2000b872:	b082      	sub	sp, #8
2000b874:	af00      	add	r7, sp, #0
2000b876:	6078      	str	r0, [r7, #4]
  assert_param(IS_OB_BOR_LEVEL(Level));
2000b878:	687b      	ldr	r3, [r7, #4]
2000b87a:	2b00      	cmp	r3, #0
2000b87c:	d00d      	beq.n	2000b89a <FLASH_OB_BOR_LevelConfig+0x2a>
2000b87e:	687b      	ldr	r3, [r7, #4]
2000b880:	2b04      	cmp	r3, #4
2000b882:	d00a      	beq.n	2000b89a <FLASH_OB_BOR_LevelConfig+0x2a>
2000b884:	687b      	ldr	r3, [r7, #4]
2000b886:	2b08      	cmp	r3, #8
2000b888:	d007      	beq.n	2000b89a <FLASH_OB_BOR_LevelConfig+0x2a>
2000b88a:	687b      	ldr	r3, [r7, #4]
2000b88c:	2b0c      	cmp	r3, #12
2000b88e:	d004      	beq.n	2000b89a <FLASH_OB_BOR_LevelConfig+0x2a>
2000b890:	f240 5172 	movw	r1, #1394	; 0x572
2000b894:	4807      	ldr	r0, [pc, #28]	; (2000b8b4 <FLASH_OB_BOR_LevelConfig+0x44>)
2000b896:	f7f5 f82d 	bl	200008f4 <assert_failed>

  /* Configure BOR_LEV option byte */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_BOR_LEV, Level);
2000b89a:	4b07      	ldr	r3, [pc, #28]	; (2000b8b8 <FLASH_OB_BOR_LevelConfig+0x48>)
2000b89c:	6a1b      	ldr	r3, [r3, #32]
2000b89e:	f023 020c 	bic.w	r2, r3, #12
2000b8a2:	4905      	ldr	r1, [pc, #20]	; (2000b8b8 <FLASH_OB_BOR_LevelConfig+0x48>)
2000b8a4:	687b      	ldr	r3, [r7, #4]
2000b8a6:	4313      	orrs	r3, r2
2000b8a8:	620b      	str	r3, [r1, #32]
}
2000b8aa:	bf00      	nop
2000b8ac:	3708      	adds	r7, #8
2000b8ae:	46bd      	mov	sp, r7
2000b8b0:	bd80      	pop	{r7, pc}
2000b8b2:	bf00      	nop
2000b8b4:	2001c0c8 	.word	0x2001c0c8
2000b8b8:	52002000 	.word	0x52002000

2000b8bc <FLASH_OB_GetBOR>:
  *            @arg OB_BOR_LEVEL1: Reset level threshold is set to 2.1V
  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V
  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V
  */
static uint32_t FLASH_OB_GetBOR(void)
{
2000b8bc:	b480      	push	{r7}
2000b8be:	af00      	add	r7, sp, #0
  return (FLASH->OPTSR_CUR & FLASH_OPTSR_BOR_LEV);
2000b8c0:	4b04      	ldr	r3, [pc, #16]	; (2000b8d4 <FLASH_OB_GetBOR+0x18>)
2000b8c2:	69db      	ldr	r3, [r3, #28]
2000b8c4:	f003 030c 	and.w	r3, r3, #12
}
2000b8c8:	4618      	mov	r0, r3
2000b8ca:	46bd      	mov	sp, r7
2000b8cc:	f85d 7b04 	ldr.w	r7, [sp], #4
2000b8d0:	4770      	bx	lr
2000b8d2:	bf00      	nop
2000b8d4:	52002000 	.word	0x52002000

2000b8d8 <FLASH_OB_BootAddConfig>:
  * @param  BootAddress0 Specifies the Boot Address 0
  * @param  BootAddress1 Specifies the Boot Address 1
  * @retval HAL Status
  */
static void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)
{
2000b8d8:	b580      	push	{r7, lr}
2000b8da:	b084      	sub	sp, #16
2000b8dc:	af00      	add	r7, sp, #0
2000b8de:	60f8      	str	r0, [r7, #12]
2000b8e0:	60b9      	str	r1, [r7, #8]
2000b8e2:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));
2000b8e4:	68fb      	ldr	r3, [r7, #12]
2000b8e6:	2b01      	cmp	r3, #1
2000b8e8:	d00a      	beq.n	2000b900 <FLASH_OB_BootAddConfig+0x28>
2000b8ea:	68fb      	ldr	r3, [r7, #12]
2000b8ec:	2b02      	cmp	r3, #2
2000b8ee:	d007      	beq.n	2000b900 <FLASH_OB_BootAddConfig+0x28>
2000b8f0:	68fb      	ldr	r3, [r7, #12]
2000b8f2:	2b03      	cmp	r3, #3
2000b8f4:	d004      	beq.n	2000b900 <FLASH_OB_BootAddConfig+0x28>
2000b8f6:	f240 5193 	movw	r1, #1427	; 0x593
2000b8fa:	4819      	ldr	r0, [pc, #100]	; (2000b960 <FLASH_OB_BootAddConfig+0x88>)
2000b8fc:	f7f4 fffa 	bl	200008f4 <assert_failed>

  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)
2000b900:	68fb      	ldr	r3, [r7, #12]
2000b902:	f003 0301 	and.w	r3, r3, #1
2000b906:	2b00      	cmp	r3, #0
2000b908:	d011      	beq.n	2000b92e <FLASH_OB_BootAddConfig+0x56>
  {
    /* Check the parameters */
    assert_param(IS_BOOT_ADDRESS(BootAddress0));
2000b90a:	68bb      	ldr	r3, [r7, #8]
2000b90c:	4a15      	ldr	r2, [pc, #84]	; (2000b964 <FLASH_OB_BootAddConfig+0x8c>)
2000b90e:	4293      	cmp	r3, r2
2000b910:	d904      	bls.n	2000b91c <FLASH_OB_BootAddConfig+0x44>
2000b912:	f44f 61b3 	mov.w	r1, #1432	; 0x598
2000b916:	4812      	ldr	r0, [pc, #72]	; (2000b960 <FLASH_OB_BootAddConfig+0x88>)
2000b918:	f7f4 ffec 	bl	200008f4 <assert_failed>

    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD0, (BootAddress0 >> 16));
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD0, (BootAddress0 >> 16));
2000b91c:	4b12      	ldr	r3, [pc, #72]	; (2000b968 <FLASH_OB_BootAddConfig+0x90>)
2000b91e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2000b920:	4b12      	ldr	r3, [pc, #72]	; (2000b96c <FLASH_OB_BootAddConfig+0x94>)
2000b922:	4013      	ands	r3, r2
2000b924:	68ba      	ldr	r2, [r7, #8]
2000b926:	0c12      	lsrs	r2, r2, #16
2000b928:	490f      	ldr	r1, [pc, #60]	; (2000b968 <FLASH_OB_BootAddConfig+0x90>)
2000b92a:	4313      	orrs	r3, r2
2000b92c:	644b      	str	r3, [r1, #68]	; 0x44
#endif /* DUAL_CORE */
  }

  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)
2000b92e:	68fb      	ldr	r3, [r7, #12]
2000b930:	f003 0302 	and.w	r3, r3, #2
2000b934:	2b00      	cmp	r3, #0
2000b936:	d00f      	beq.n	2000b958 <FLASH_OB_BootAddConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_BOOT_ADDRESS(BootAddress1));
2000b938:	687b      	ldr	r3, [r7, #4]
2000b93a:	4a0a      	ldr	r2, [pc, #40]	; (2000b964 <FLASH_OB_BootAddConfig+0x8c>)
2000b93c:	4293      	cmp	r3, r2
2000b93e:	d904      	bls.n	2000b94a <FLASH_OB_BootAddConfig+0x72>
2000b940:	f240 51a5 	movw	r1, #1445	; 0x5a5
2000b944:	4806      	ldr	r0, [pc, #24]	; (2000b960 <FLASH_OB_BootAddConfig+0x88>)
2000b946:	f7f4 ffd5 	bl	200008f4 <assert_failed>

    /* Configure CM7 BOOT ADD1 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD1, BootAddress1);
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD1, BootAddress1);
2000b94a:	4b07      	ldr	r3, [pc, #28]	; (2000b968 <FLASH_OB_BootAddConfig+0x90>)
2000b94c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000b94e:	b29a      	uxth	r2, r3
2000b950:	4905      	ldr	r1, [pc, #20]	; (2000b968 <FLASH_OB_BootAddConfig+0x90>)
2000b952:	687b      	ldr	r3, [r7, #4]
2000b954:	4313      	orrs	r3, r2
2000b956:	644b      	str	r3, [r1, #68]	; 0x44
#endif /* DUAL_CORE */
  }
}
2000b958:	bf00      	nop
2000b95a:	3710      	adds	r7, #16
2000b95c:	46bd      	mov	sp, r7
2000b95e:	bd80      	pop	{r7, pc}
2000b960:	2001c0c8 	.word	0x2001c0c8
2000b964:	3fff0000 	.word	0x3fff0000
2000b968:	52002000 	.word	0x52002000
2000b96c:	ffff0000 	.word	0xffff0000

2000b970 <FLASH_OB_GetBootAdd>:
  * @param  BootAddress0 Specifies the Boot Address 0.
  * @param  BootAddress1 Specifies the Boot Address 1.
  * @retval HAL Status
  */
static void FLASH_OB_GetBootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1)
{
2000b970:	b480      	push	{r7}
2000b972:	b085      	sub	sp, #20
2000b974:	af00      	add	r7, sp, #0
2000b976:	6078      	str	r0, [r7, #4]
2000b978:	6039      	str	r1, [r7, #0]
  regvalue = FLASH->BOOT7_CUR;

  (*BootAddress0) = (regvalue & FLASH_BOOT7_BCM7_ADD0) << 16;
  (*BootAddress1) = (regvalue & FLASH_BOOT7_BCM7_ADD1);
#else /* Single Core */
  regvalue = FLASH->BOOT_CUR;
2000b97a:	4b09      	ldr	r3, [pc, #36]	; (2000b9a0 <FLASH_OB_GetBootAdd+0x30>)
2000b97c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000b97e:	60fb      	str	r3, [r7, #12]

  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
2000b980:	68fb      	ldr	r3, [r7, #12]
2000b982:	041a      	lsls	r2, r3, #16
2000b984:	687b      	ldr	r3, [r7, #4]
2000b986:	601a      	str	r2, [r3, #0]
  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);
2000b988:	68fa      	ldr	r2, [r7, #12]
2000b98a:	4b06      	ldr	r3, [pc, #24]	; (2000b9a4 <FLASH_OB_GetBootAdd+0x34>)
2000b98c:	4013      	ands	r3, r2
2000b98e:	683a      	ldr	r2, [r7, #0]
2000b990:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE */
}
2000b992:	bf00      	nop
2000b994:	3714      	adds	r7, #20
2000b996:	46bd      	mov	sp, r7
2000b998:	f85d 7b04 	ldr.w	r7, [sp], #4
2000b99c:	4770      	bx	lr
2000b99e:	bf00      	nop
2000b9a0:	52002000 	.word	0x52002000
2000b9a4:	ffff0000 	.word	0xffff0000

2000b9a8 <FLASH_OB_SecureAreaConfig>:
  *            @arg FLASH_BANK_2: Secure area on specified bank2 area
  *            @arg FLASH_BANK_BOTH: Secure area on specified bank1 and bank2 area (same config will be applied on both banks)
  * @retval None
  */
static void FLASH_OB_SecureAreaConfig(uint32_t SecureAreaConfig, uint32_t SecureAreaStartAddr, uint32_t SecureAreaEndAddr, uint32_t Banks)
{
2000b9a8:	b580      	push	{r7, lr}
2000b9aa:	b084      	sub	sp, #16
2000b9ac:	af00      	add	r7, sp, #0
2000b9ae:	60f8      	str	r0, [r7, #12]
2000b9b0:	60b9      	str	r1, [r7, #8]
2000b9b2:	607a      	str	r2, [r7, #4]
2000b9b4:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
2000b9b6:	683b      	ldr	r3, [r7, #0]
2000b9b8:	2b01      	cmp	r3, #1
2000b9ba:	d00a      	beq.n	2000b9d2 <FLASH_OB_SecureAreaConfig+0x2a>
2000b9bc:	683b      	ldr	r3, [r7, #0]
2000b9be:	2b02      	cmp	r3, #2
2000b9c0:	d007      	beq.n	2000b9d2 <FLASH_OB_SecureAreaConfig+0x2a>
2000b9c2:	683b      	ldr	r3, [r7, #0]
2000b9c4:	2b03      	cmp	r3, #3
2000b9c6:	d004      	beq.n	2000b9d2 <FLASH_OB_SecureAreaConfig+0x2a>
2000b9c8:	f240 610d 	movw	r1, #1549	; 0x60d
2000b9cc:	4838      	ldr	r0, [pc, #224]	; (2000bab0 <FLASH_OB_SecureAreaConfig+0x108>)
2000b9ce:	f7f4 ff91 	bl	200008f4 <assert_failed>
  assert_param(IS_OB_SECURE_RDP(SecureAreaConfig));
2000b9d2:	68fb      	ldr	r3, [r7, #12]
2000b9d4:	2b00      	cmp	r3, #0
2000b9d6:	d008      	beq.n	2000b9ea <FLASH_OB_SecureAreaConfig+0x42>
2000b9d8:	68fb      	ldr	r3, [r7, #12]
2000b9da:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
2000b9de:	d004      	beq.n	2000b9ea <FLASH_OB_SecureAreaConfig+0x42>
2000b9e0:	f240 610e 	movw	r1, #1550	; 0x60e
2000b9e4:	4832      	ldr	r0, [pc, #200]	; (2000bab0 <FLASH_OB_SecureAreaConfig+0x108>)
2000b9e6:	f7f4 ff85 	bl	200008f4 <assert_failed>

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2000b9ea:	683b      	ldr	r3, [r7, #0]
2000b9ec:	f003 0301 	and.w	r3, r3, #1
2000b9f0:	2b00      	cmp	r3, #0
2000b9f2:	d029      	beq.n	2000ba48 <FLASH_OB_SecureAreaConfig+0xa0>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaStartAddr));
2000b9f4:	68bb      	ldr	r3, [r7, #8]
2000b9f6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2000b9fa:	d303      	bcc.n	2000ba04 <FLASH_OB_SecureAreaConfig+0x5c>
2000b9fc:	68bb      	ldr	r3, [r7, #8]
2000b9fe:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000ba02:	d304      	bcc.n	2000ba0e <FLASH_OB_SecureAreaConfig+0x66>
2000ba04:	f240 6113 	movw	r1, #1555	; 0x613
2000ba08:	4829      	ldr	r0, [pc, #164]	; (2000bab0 <FLASH_OB_SecureAreaConfig+0x108>)
2000ba0a:	f7f4 ff73 	bl	200008f4 <assert_failed>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaEndAddr));
2000ba0e:	687b      	ldr	r3, [r7, #4]
2000ba10:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2000ba14:	d303      	bcc.n	2000ba1e <FLASH_OB_SecureAreaConfig+0x76>
2000ba16:	687b      	ldr	r3, [r7, #4]
2000ba18:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000ba1c:	d304      	bcc.n	2000ba28 <FLASH_OB_SecureAreaConfig+0x80>
2000ba1e:	f240 6114 	movw	r1, #1556	; 0x614
2000ba22:	4823      	ldr	r0, [pc, #140]	; (2000bab0 <FLASH_OB_SecureAreaConfig+0x108>)
2000ba24:	f7f4 ff66 	bl	200008f4 <assert_failed>

    /* Configure the secure area */
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2000ba28:	68bb      	ldr	r3, [r7, #8]
2000ba2a:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2000ba2e:	0a1a      	lsrs	r2, r3, #8
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
2000ba30:	687b      	ldr	r3, [r7, #4]
2000ba32:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2000ba36:	0a1b      	lsrs	r3, r3, #8
2000ba38:	041b      	lsls	r3, r3, #16
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2000ba3a:	431a      	orrs	r2, r3
                       (SecureAreaConfig & FLASH_SCAR_DMES);
2000ba3c:	68fb      	ldr	r3, [r7, #12]
2000ba3e:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2000ba42:	491c      	ldr	r1, [pc, #112]	; (2000bab4 <FLASH_OB_SecureAreaConfig+0x10c>)
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
2000ba44:	4313      	orrs	r3, r2
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2000ba46:	634b      	str	r3, [r1, #52]	; 0x34
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
2000ba48:	683b      	ldr	r3, [r7, #0]
2000ba4a:	f003 0302 	and.w	r3, r3, #2
2000ba4e:	2b00      	cmp	r3, #0
2000ba50:	d02a      	beq.n	2000baa8 <FLASH_OB_SecureAreaConfig+0x100>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaStartAddr));
2000ba52:	68bb      	ldr	r3, [r7, #8]
2000ba54:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000ba58:	d303      	bcc.n	2000ba62 <FLASH_OB_SecureAreaConfig+0xba>
2000ba5a:	68bb      	ldr	r3, [r7, #8]
2000ba5c:	4a16      	ldr	r2, [pc, #88]	; (2000bab8 <FLASH_OB_SecureAreaConfig+0x110>)
2000ba5e:	4293      	cmp	r3, r2
2000ba60:	d904      	bls.n	2000ba6c <FLASH_OB_SecureAreaConfig+0xc4>
2000ba62:	f240 611f 	movw	r1, #1567	; 0x61f
2000ba66:	4812      	ldr	r0, [pc, #72]	; (2000bab0 <FLASH_OB_SecureAreaConfig+0x108>)
2000ba68:	f7f4 ff44 	bl	200008f4 <assert_failed>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaEndAddr));
2000ba6c:	687b      	ldr	r3, [r7, #4]
2000ba6e:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000ba72:	d303      	bcc.n	2000ba7c <FLASH_OB_SecureAreaConfig+0xd4>
2000ba74:	687b      	ldr	r3, [r7, #4]
2000ba76:	4a10      	ldr	r2, [pc, #64]	; (2000bab8 <FLASH_OB_SecureAreaConfig+0x110>)
2000ba78:	4293      	cmp	r3, r2
2000ba7a:	d904      	bls.n	2000ba86 <FLASH_OB_SecureAreaConfig+0xde>
2000ba7c:	f44f 61c4 	mov.w	r1, #1568	; 0x620
2000ba80:	480b      	ldr	r0, [pc, #44]	; (2000bab0 <FLASH_OB_SecureAreaConfig+0x108>)
2000ba82:	f7f4 ff37 	bl	200008f4 <assert_failed>

    /* Configure the secure area */
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
2000ba86:	68bb      	ldr	r3, [r7, #8]
2000ba88:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
2000ba8c:	0a1a      	lsrs	r2, r3, #8
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
2000ba8e:	687b      	ldr	r3, [r7, #4]
2000ba90:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
2000ba94:	0a1b      	lsrs	r3, r3, #8
2000ba96:	041b      	lsls	r3, r3, #16
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
2000ba98:	431a      	orrs	r2, r3
                       (SecureAreaConfig & FLASH_SCAR_DMES);
2000ba9a:	68fb      	ldr	r3, [r7, #12]
2000ba9c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
2000baa0:	4904      	ldr	r1, [pc, #16]	; (2000bab4 <FLASH_OB_SecureAreaConfig+0x10c>)
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
2000baa2:	4313      	orrs	r3, r2
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
2000baa4:	f8c1 3134 	str.w	r3, [r1, #308]	; 0x134
  }
}
2000baa8:	bf00      	nop
2000baaa:	3710      	adds	r7, #16
2000baac:	46bd      	mov	sp, r7
2000baae:	bd80      	pop	{r7, pc}
2000bab0:	2001c0c8 	.word	0x2001c0c8
2000bab4:	52002000 	.word	0x52002000
2000bab8:	0801ffff 	.word	0x0801ffff

2000babc <FLASH_OB_GetSecureArea>:
  * @param  SecureAreaEndAddr gives the secure area end address
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_OB_GetSecureArea(uint32_t *SecureAreaConfig, uint32_t *SecureAreaStartAddr, uint32_t *SecureAreaEndAddr, uint32_t Bank)
{
2000babc:	b480      	push	{r7}
2000babe:	b087      	sub	sp, #28
2000bac0:	af00      	add	r7, sp, #0
2000bac2:	60f8      	str	r0, [r7, #12]
2000bac4:	60b9      	str	r1, [r7, #8]
2000bac6:	607a      	str	r2, [r7, #4]
2000bac8:	603b      	str	r3, [r7, #0]
  uint32_t regvalue = 0;
2000baca:	2300      	movs	r3, #0
2000bacc:	617b      	str	r3, [r7, #20]
  uint32_t bankBase = 0;
2000bace:	2300      	movs	r3, #0
2000bad0:	613b      	str	r3, [r7, #16]

  /* Check Bank parameter value */
  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
2000bad2:	683b      	ldr	r3, [r7, #0]
2000bad4:	f003 0303 	and.w	r3, r3, #3
2000bad8:	2b01      	cmp	r3, #1
2000bada:	d105      	bne.n	2000bae8 <FLASH_OB_GetSecureArea+0x2c>
  {
    regvalue = FLASH->SCAR_CUR1;
2000badc:	4b18      	ldr	r3, [pc, #96]	; (2000bb40 <FLASH_OB_GetSecureArea+0x84>)
2000bade:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000bae0:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK1_BASE;
2000bae2:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
2000bae6:	613b      	str	r3, [r7, #16]
  }

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_2)
2000bae8:	683b      	ldr	r3, [r7, #0]
2000baea:	f003 0303 	and.w	r3, r3, #3
2000baee:	2b02      	cmp	r3, #2
2000baf0:	d106      	bne.n	2000bb00 <FLASH_OB_GetSecureArea+0x44>
  {
    regvalue = FLASH->SCAR_CUR2;
2000baf2:	4b13      	ldr	r3, [pc, #76]	; (2000bb40 <FLASH_OB_GetSecureArea+0x84>)
2000baf4:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
2000baf8:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK2_BASE;
2000bafa:	f04f 6301 	mov.w	r3, #135266304	; 0x8100000
2000bafe:	613b      	str	r3, [r7, #16]
  }

  /* Get the secure area settings */
  (*SecureAreaConfig) = (regvalue & FLASH_SCAR_DMES);
2000bb00:	697b      	ldr	r3, [r7, #20]
2000bb02:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
2000bb06:	68fb      	ldr	r3, [r7, #12]
2000bb08:	601a      	str	r2, [r3, #0]
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
2000bb0a:	697b      	ldr	r3, [r7, #20]
2000bb0c:	021a      	lsls	r2, r3, #8
2000bb0e:	4b0d      	ldr	r3, [pc, #52]	; (2000bb44 <FLASH_OB_GetSecureArea+0x88>)
2000bb10:	4013      	ands	r3, r2
2000bb12:	693a      	ldr	r2, [r7, #16]
2000bb14:	441a      	add	r2, r3
2000bb16:	68bb      	ldr	r3, [r7, #8]
2000bb18:	601a      	str	r2, [r3, #0]
  (*SecureAreaEndAddr) = (regvalue & FLASH_SCAR_SEC_AREA_END) >> FLASH_SCAR_SEC_AREA_END_Pos;
2000bb1a:	697b      	ldr	r3, [r7, #20]
2000bb1c:	0c1b      	lsrs	r3, r3, #16
2000bb1e:	f3c3 020b 	ubfx	r2, r3, #0, #12
2000bb22:	687b      	ldr	r3, [r7, #4]
2000bb24:	601a      	str	r2, [r3, #0]
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
2000bb26:	687b      	ldr	r3, [r7, #4]
2000bb28:	681b      	ldr	r3, [r3, #0]
2000bb2a:	021a      	lsls	r2, r3, #8
2000bb2c:	693b      	ldr	r3, [r7, #16]
2000bb2e:	441a      	add	r2, r3
2000bb30:	687b      	ldr	r3, [r7, #4]
2000bb32:	601a      	str	r2, [r3, #0]
}
2000bb34:	bf00      	nop
2000bb36:	371c      	adds	r7, #28
2000bb38:	46bd      	mov	sp, r7
2000bb3a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000bb3e:	4770      	bx	lr
2000bb40:	52002000 	.word	0x52002000
2000bb44:	000fff00 	.word	0x000fff00

2000bb48 <FLASH_CRC_AddSector>:
  * @param  Sector Specifies the CRC sector number
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_CRC_AddSector(uint32_t Sector, uint32_t Bank)
{
2000bb48:	b580      	push	{r7, lr}
2000bb4a:	b082      	sub	sp, #8
2000bb4c:	af00      	add	r7, sp, #0
2000bb4e:	6078      	str	r0, [r7, #4]
2000bb50:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));
2000bb52:	687b      	ldr	r3, [r7, #4]
2000bb54:	2b00      	cmp	r3, #0
2000bb56:	d004      	beq.n	2000bb62 <FLASH_CRC_AddSector+0x1a>
2000bb58:	f240 6154 	movw	r1, #1620	; 0x654
2000bb5c:	4815      	ldr	r0, [pc, #84]	; (2000bbb4 <FLASH_CRC_AddSector+0x6c>)
2000bb5e:	f7f4 fec9 	bl	200008f4 <assert_failed>

  if (Bank == FLASH_BANK_1)
2000bb62:	683b      	ldr	r3, [r7, #0]
2000bb64:	2b01      	cmp	r3, #1
2000bb66:	d10e      	bne.n	2000bb86 <FLASH_CRC_AddSector+0x3e>
  {
    /* Clear CRC sector */
    FLASH->CRCCR1 &= (~FLASH_CRCCR_CRC_SECT);
2000bb68:	4b13      	ldr	r3, [pc, #76]	; (2000bbb8 <FLASH_CRC_AddSector+0x70>)
2000bb6a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000bb6c:	4a12      	ldr	r2, [pc, #72]	; (2000bbb8 <FLASH_CRC_AddSector+0x70>)
2000bb6e:	f023 0307 	bic.w	r3, r3, #7
2000bb72:	6513      	str	r3, [r2, #80]	; 0x50

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR1 |= Sector | FLASH_CRCCR_ADD_SECT;
2000bb74:	4b10      	ldr	r3, [pc, #64]	; (2000bbb8 <FLASH_CRC_AddSector+0x70>)
2000bb76:	6d1a      	ldr	r2, [r3, #80]	; 0x50
2000bb78:	687b      	ldr	r3, [r7, #4]
2000bb7a:	4313      	orrs	r3, r2
2000bb7c:	4a0e      	ldr	r2, [pc, #56]	; (2000bbb8 <FLASH_CRC_AddSector+0x70>)
2000bb7e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2000bb82:	6513      	str	r3, [r2, #80]	; 0x50
    FLASH->CRCCR2 &= (~FLASH_CRCCR_CRC_SECT);

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;
  }
}
2000bb84:	e011      	b.n	2000bbaa <FLASH_CRC_AddSector+0x62>
    FLASH->CRCCR2 &= (~FLASH_CRCCR_CRC_SECT);
2000bb86:	4b0c      	ldr	r3, [pc, #48]	; (2000bbb8 <FLASH_CRC_AddSector+0x70>)
2000bb88:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
2000bb8c:	4a0a      	ldr	r2, [pc, #40]	; (2000bbb8 <FLASH_CRC_AddSector+0x70>)
2000bb8e:	f023 0307 	bic.w	r3, r3, #7
2000bb92:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150
    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;
2000bb96:	4b08      	ldr	r3, [pc, #32]	; (2000bbb8 <FLASH_CRC_AddSector+0x70>)
2000bb98:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
2000bb9c:	687b      	ldr	r3, [r7, #4]
2000bb9e:	4313      	orrs	r3, r2
2000bba0:	4a05      	ldr	r2, [pc, #20]	; (2000bbb8 <FLASH_CRC_AddSector+0x70>)
2000bba2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2000bba6:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150
}
2000bbaa:	bf00      	nop
2000bbac:	3708      	adds	r7, #8
2000bbae:	46bd      	mov	sp, r7
2000bbb0:	bd80      	pop	{r7, pc}
2000bbb2:	bf00      	nop
2000bbb4:	2001c0c8 	.word	0x2001c0c8
2000bbb8:	52002000 	.word	0x52002000

2000bbbc <FLASH_CRC_SelectAddress>:
  * @param  CRCEndAddr Specifies the CRC end address
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_CRC_SelectAddress(uint32_t CRCStartAddr, uint32_t CRCEndAddr, uint32_t Bank)
{
2000bbbc:	b580      	push	{r7, lr}
2000bbbe:	b084      	sub	sp, #16
2000bbc0:	af00      	add	r7, sp, #0
2000bbc2:	60f8      	str	r0, [r7, #12]
2000bbc4:	60b9      	str	r1, [r7, #8]
2000bbc6:	607a      	str	r2, [r7, #4]
  if (Bank == FLASH_BANK_1)
2000bbc8:	687b      	ldr	r3, [r7, #4]
2000bbca:	2b01      	cmp	r3, #1
2000bbcc:	d120      	bne.n	2000bc10 <FLASH_CRC_SelectAddress+0x54>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCStartAddr));
2000bbce:	68fb      	ldr	r3, [r7, #12]
2000bbd0:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2000bbd4:	d303      	bcc.n	2000bbde <FLASH_CRC_SelectAddress+0x22>
2000bbd6:	68fb      	ldr	r3, [r7, #12]
2000bbd8:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000bbdc:	d304      	bcc.n	2000bbe8 <FLASH_CRC_SelectAddress+0x2c>
2000bbde:	f240 6173 	movw	r1, #1651	; 0x673
2000bbe2:	481e      	ldr	r0, [pc, #120]	; (2000bc5c <FLASH_CRC_SelectAddress+0xa0>)
2000bbe4:	f7f4 fe86 	bl	200008f4 <assert_failed>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCEndAddr));
2000bbe8:	68bb      	ldr	r3, [r7, #8]
2000bbea:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2000bbee:	d303      	bcc.n	2000bbf8 <FLASH_CRC_SelectAddress+0x3c>
2000bbf0:	68bb      	ldr	r3, [r7, #8]
2000bbf2:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000bbf6:	d304      	bcc.n	2000bc02 <FLASH_CRC_SelectAddress+0x46>
2000bbf8:	f240 6174 	movw	r1, #1652	; 0x674
2000bbfc:	4817      	ldr	r0, [pc, #92]	; (2000bc5c <FLASH_CRC_SelectAddress+0xa0>)
2000bbfe:	f7f4 fe79 	bl	200008f4 <assert_failed>

    /* Write CRC Start and End addresses */
    FLASH->CRCSADD1 = CRCStartAddr;
2000bc02:	4a17      	ldr	r2, [pc, #92]	; (2000bc60 <FLASH_CRC_SelectAddress+0xa4>)
2000bc04:	68fb      	ldr	r3, [r7, #12]
2000bc06:	6553      	str	r3, [r2, #84]	; 0x54
    FLASH->CRCEADD1 = CRCEndAddr;
2000bc08:	4a15      	ldr	r2, [pc, #84]	; (2000bc60 <FLASH_CRC_SelectAddress+0xa4>)
2000bc0a:	68bb      	ldr	r3, [r7, #8]
2000bc0c:	6593      	str	r3, [r2, #88]	; 0x58

    /* Write CRC Start and End addresses */
    FLASH->CRCSADD2 = CRCStartAddr;
    FLASH->CRCEADD2 = CRCEndAddr;
  }
}
2000bc0e:	e021      	b.n	2000bc54 <FLASH_CRC_SelectAddress+0x98>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(CRCStartAddr));
2000bc10:	68fb      	ldr	r3, [r7, #12]
2000bc12:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000bc16:	d303      	bcc.n	2000bc20 <FLASH_CRC_SelectAddress+0x64>
2000bc18:	68fb      	ldr	r3, [r7, #12]
2000bc1a:	4a12      	ldr	r2, [pc, #72]	; (2000bc64 <FLASH_CRC_SelectAddress+0xa8>)
2000bc1c:	4293      	cmp	r3, r2
2000bc1e:	d904      	bls.n	2000bc2a <FLASH_CRC_SelectAddress+0x6e>
2000bc20:	f240 617c 	movw	r1, #1660	; 0x67c
2000bc24:	480d      	ldr	r0, [pc, #52]	; (2000bc5c <FLASH_CRC_SelectAddress+0xa0>)
2000bc26:	f7f4 fe65 	bl	200008f4 <assert_failed>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(CRCEndAddr));
2000bc2a:	68bb      	ldr	r3, [r7, #8]
2000bc2c:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
2000bc30:	d303      	bcc.n	2000bc3a <FLASH_CRC_SelectAddress+0x7e>
2000bc32:	68bb      	ldr	r3, [r7, #8]
2000bc34:	4a0b      	ldr	r2, [pc, #44]	; (2000bc64 <FLASH_CRC_SelectAddress+0xa8>)
2000bc36:	4293      	cmp	r3, r2
2000bc38:	d904      	bls.n	2000bc44 <FLASH_CRC_SelectAddress+0x88>
2000bc3a:	f240 617d 	movw	r1, #1661	; 0x67d
2000bc3e:	4807      	ldr	r0, [pc, #28]	; (2000bc5c <FLASH_CRC_SelectAddress+0xa0>)
2000bc40:	f7f4 fe58 	bl	200008f4 <assert_failed>
    FLASH->CRCSADD2 = CRCStartAddr;
2000bc44:	4a06      	ldr	r2, [pc, #24]	; (2000bc60 <FLASH_CRC_SelectAddress+0xa4>)
2000bc46:	68fb      	ldr	r3, [r7, #12]
2000bc48:	f8c2 3154 	str.w	r3, [r2, #340]	; 0x154
    FLASH->CRCEADD2 = CRCEndAddr;
2000bc4c:	4a04      	ldr	r2, [pc, #16]	; (2000bc60 <FLASH_CRC_SelectAddress+0xa4>)
2000bc4e:	68bb      	ldr	r3, [r7, #8]
2000bc50:	f8c2 3158 	str.w	r3, [r2, #344]	; 0x158
}
2000bc54:	bf00      	nop
2000bc56:	3710      	adds	r7, #16
2000bc58:	46bd      	mov	sp, r7
2000bc5a:	bd80      	pop	{r7, pc}
2000bc5c:	2001c0c8 	.word	0x2001c0c8
2000bc60:	52002000 	.word	0x52002000
2000bc64:	0801ffff 	.word	0x0801ffff

2000bc68 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
2000bc68:	b580      	push	{r7, lr}
2000bc6a:	b088      	sub	sp, #32
2000bc6c:	af00      	add	r7, sp, #0
2000bc6e:	6078      	str	r0, [r7, #4]
2000bc70:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
2000bc72:	2300      	movs	r3, #0
2000bc74:	61fb      	str	r3, [r7, #28]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
2000bc76:	4b47      	ldr	r3, [pc, #284]	; (2000bd94 <HAL_GPIO_Init+0x12c>)
2000bc78:	617b      	str	r3, [r7, #20]
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
2000bc7a:	687b      	ldr	r3, [r7, #4]
2000bc7c:	4a46      	ldr	r2, [pc, #280]	; (2000bd98 <HAL_GPIO_Init+0x130>)
2000bc7e:	4293      	cmp	r3, r2
2000bc80:	d02b      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bc82:	687b      	ldr	r3, [r7, #4]
2000bc84:	4a45      	ldr	r2, [pc, #276]	; (2000bd9c <HAL_GPIO_Init+0x134>)
2000bc86:	4293      	cmp	r3, r2
2000bc88:	d027      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bc8a:	687b      	ldr	r3, [r7, #4]
2000bc8c:	4a44      	ldr	r2, [pc, #272]	; (2000bda0 <HAL_GPIO_Init+0x138>)
2000bc8e:	4293      	cmp	r3, r2
2000bc90:	d023      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bc92:	687b      	ldr	r3, [r7, #4]
2000bc94:	4a43      	ldr	r2, [pc, #268]	; (2000bda4 <HAL_GPIO_Init+0x13c>)
2000bc96:	4293      	cmp	r3, r2
2000bc98:	d01f      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bc9a:	687b      	ldr	r3, [r7, #4]
2000bc9c:	4a42      	ldr	r2, [pc, #264]	; (2000bda8 <HAL_GPIO_Init+0x140>)
2000bc9e:	4293      	cmp	r3, r2
2000bca0:	d01b      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bca2:	687b      	ldr	r3, [r7, #4]
2000bca4:	4a41      	ldr	r2, [pc, #260]	; (2000bdac <HAL_GPIO_Init+0x144>)
2000bca6:	4293      	cmp	r3, r2
2000bca8:	d017      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bcaa:	687b      	ldr	r3, [r7, #4]
2000bcac:	4a40      	ldr	r2, [pc, #256]	; (2000bdb0 <HAL_GPIO_Init+0x148>)
2000bcae:	4293      	cmp	r3, r2
2000bcb0:	d013      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bcb2:	687b      	ldr	r3, [r7, #4]
2000bcb4:	4a3f      	ldr	r2, [pc, #252]	; (2000bdb4 <HAL_GPIO_Init+0x14c>)
2000bcb6:	4293      	cmp	r3, r2
2000bcb8:	d00f      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bcba:	687b      	ldr	r3, [r7, #4]
2000bcbc:	4a3e      	ldr	r2, [pc, #248]	; (2000bdb8 <HAL_GPIO_Init+0x150>)
2000bcbe:	4293      	cmp	r3, r2
2000bcc0:	d00b      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bcc2:	687b      	ldr	r3, [r7, #4]
2000bcc4:	4a3d      	ldr	r2, [pc, #244]	; (2000bdbc <HAL_GPIO_Init+0x154>)
2000bcc6:	4293      	cmp	r3, r2
2000bcc8:	d007      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bcca:	687b      	ldr	r3, [r7, #4]
2000bccc:	4a3c      	ldr	r2, [pc, #240]	; (2000bdc0 <HAL_GPIO_Init+0x158>)
2000bcce:	4293      	cmp	r3, r2
2000bcd0:	d003      	beq.n	2000bcda <HAL_GPIO_Init+0x72>
2000bcd2:	21bb      	movs	r1, #187	; 0xbb
2000bcd4:	483b      	ldr	r0, [pc, #236]	; (2000bdc4 <HAL_GPIO_Init+0x15c>)
2000bcd6:	f7f4 fe0d 	bl	200008f4 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
2000bcda:	683b      	ldr	r3, [r7, #0]
2000bcdc:	681b      	ldr	r3, [r3, #0]
2000bcde:	b29b      	uxth	r3, r3
2000bce0:	2b00      	cmp	r3, #0
2000bce2:	d005      	beq.n	2000bcf0 <HAL_GPIO_Init+0x88>
2000bce4:	683b      	ldr	r3, [r7, #0]
2000bce6:	681a      	ldr	r2, [r3, #0]
2000bce8:	4b37      	ldr	r3, [pc, #220]	; (2000bdc8 <HAL_GPIO_Init+0x160>)
2000bcea:	4013      	ands	r3, r2
2000bcec:	2b00      	cmp	r3, #0
2000bcee:	d003      	beq.n	2000bcf8 <HAL_GPIO_Init+0x90>
2000bcf0:	21bc      	movs	r1, #188	; 0xbc
2000bcf2:	4834      	ldr	r0, [pc, #208]	; (2000bdc4 <HAL_GPIO_Init+0x15c>)
2000bcf4:	f7f4 fdfe 	bl	200008f4 <assert_failed>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
2000bcf8:	683b      	ldr	r3, [r7, #0]
2000bcfa:	685b      	ldr	r3, [r3, #4]
2000bcfc:	2b00      	cmp	r3, #0
2000bcfe:	d035      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd00:	683b      	ldr	r3, [r7, #0]
2000bd02:	685b      	ldr	r3, [r3, #4]
2000bd04:	2b01      	cmp	r3, #1
2000bd06:	d031      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd08:	683b      	ldr	r3, [r7, #0]
2000bd0a:	685b      	ldr	r3, [r3, #4]
2000bd0c:	2b11      	cmp	r3, #17
2000bd0e:	d02d      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd10:	683b      	ldr	r3, [r7, #0]
2000bd12:	685b      	ldr	r3, [r3, #4]
2000bd14:	2b02      	cmp	r3, #2
2000bd16:	d029      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd18:	683b      	ldr	r3, [r7, #0]
2000bd1a:	685b      	ldr	r3, [r3, #4]
2000bd1c:	2b12      	cmp	r3, #18
2000bd1e:	d025      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd20:	683b      	ldr	r3, [r7, #0]
2000bd22:	685b      	ldr	r3, [r3, #4]
2000bd24:	4a29      	ldr	r2, [pc, #164]	; (2000bdcc <HAL_GPIO_Init+0x164>)
2000bd26:	4293      	cmp	r3, r2
2000bd28:	d020      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd2a:	683b      	ldr	r3, [r7, #0]
2000bd2c:	685b      	ldr	r3, [r3, #4]
2000bd2e:	4a28      	ldr	r2, [pc, #160]	; (2000bdd0 <HAL_GPIO_Init+0x168>)
2000bd30:	4293      	cmp	r3, r2
2000bd32:	d01b      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd34:	683b      	ldr	r3, [r7, #0]
2000bd36:	685b      	ldr	r3, [r3, #4]
2000bd38:	4a26      	ldr	r2, [pc, #152]	; (2000bdd4 <HAL_GPIO_Init+0x16c>)
2000bd3a:	4293      	cmp	r3, r2
2000bd3c:	d016      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd3e:	683b      	ldr	r3, [r7, #0]
2000bd40:	685b      	ldr	r3, [r3, #4]
2000bd42:	4a25      	ldr	r2, [pc, #148]	; (2000bdd8 <HAL_GPIO_Init+0x170>)
2000bd44:	4293      	cmp	r3, r2
2000bd46:	d011      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd48:	683b      	ldr	r3, [r7, #0]
2000bd4a:	685b      	ldr	r3, [r3, #4]
2000bd4c:	4a23      	ldr	r2, [pc, #140]	; (2000bddc <HAL_GPIO_Init+0x174>)
2000bd4e:	4293      	cmp	r3, r2
2000bd50:	d00c      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd52:	683b      	ldr	r3, [r7, #0]
2000bd54:	685b      	ldr	r3, [r3, #4]
2000bd56:	4a22      	ldr	r2, [pc, #136]	; (2000bde0 <HAL_GPIO_Init+0x178>)
2000bd58:	4293      	cmp	r3, r2
2000bd5a:	d007      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd5c:	683b      	ldr	r3, [r7, #0]
2000bd5e:	685b      	ldr	r3, [r3, #4]
2000bd60:	2b03      	cmp	r3, #3
2000bd62:	d003      	beq.n	2000bd6c <HAL_GPIO_Init+0x104>
2000bd64:	21bd      	movs	r1, #189	; 0xbd
2000bd66:	4817      	ldr	r0, [pc, #92]	; (2000bdc4 <HAL_GPIO_Init+0x15c>)
2000bd68:	f7f4 fdc4 	bl	200008f4 <assert_failed>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
2000bd6c:	683b      	ldr	r3, [r7, #0]
2000bd6e:	689b      	ldr	r3, [r3, #8]
2000bd70:	2b00      	cmp	r3, #0
2000bd72:	f000 821a 	beq.w	2000c1aa <HAL_GPIO_Init+0x542>
2000bd76:	683b      	ldr	r3, [r7, #0]
2000bd78:	689b      	ldr	r3, [r3, #8]
2000bd7a:	2b01      	cmp	r3, #1
2000bd7c:	f000 8215 	beq.w	2000c1aa <HAL_GPIO_Init+0x542>
2000bd80:	683b      	ldr	r3, [r7, #0]
2000bd82:	689b      	ldr	r3, [r3, #8]
2000bd84:	2b02      	cmp	r3, #2
2000bd86:	f000 8210 	beq.w	2000c1aa <HAL_GPIO_Init+0x542>
2000bd8a:	21be      	movs	r1, #190	; 0xbe
2000bd8c:	480d      	ldr	r0, [pc, #52]	; (2000bdc4 <HAL_GPIO_Init+0x15c>)
2000bd8e:	f7f4 fdb1 	bl	200008f4 <assert_failed>

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
2000bd92:	e20a      	b.n	2000c1aa <HAL_GPIO_Init+0x542>
2000bd94:	58000080 	.word	0x58000080
2000bd98:	58020000 	.word	0x58020000
2000bd9c:	58020400 	.word	0x58020400
2000bda0:	58020800 	.word	0x58020800
2000bda4:	58020c00 	.word	0x58020c00
2000bda8:	58021000 	.word	0x58021000
2000bdac:	58021400 	.word	0x58021400
2000bdb0:	58021800 	.word	0x58021800
2000bdb4:	58021c00 	.word	0x58021c00
2000bdb8:	58022000 	.word	0x58022000
2000bdbc:	58022400 	.word	0x58022400
2000bdc0:	58022800 	.word	0x58022800
2000bdc4:	2001c108 	.word	0x2001c108
2000bdc8:	ffff0000 	.word	0xffff0000
2000bdcc:	11110000 	.word	0x11110000
2000bdd0:	11210000 	.word	0x11210000
2000bdd4:	11310000 	.word	0x11310000
2000bdd8:	11120000 	.word	0x11120000
2000bddc:	11220000 	.word	0x11220000
2000bde0:	11320000 	.word	0x11320000
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
2000bde4:	683b      	ldr	r3, [r7, #0]
2000bde6:	681a      	ldr	r2, [r3, #0]
2000bde8:	2101      	movs	r1, #1
2000bdea:	69fb      	ldr	r3, [r7, #28]
2000bdec:	fa01 f303 	lsl.w	r3, r1, r3
2000bdf0:	4013      	ands	r3, r2
2000bdf2:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
2000bdf4:	693b      	ldr	r3, [r7, #16]
2000bdf6:	2b00      	cmp	r3, #0
2000bdf8:	f000 81d4 	beq.w	2000c1a4 <HAL_GPIO_Init+0x53c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
2000bdfc:	683b      	ldr	r3, [r7, #0]
2000bdfe:	685b      	ldr	r3, [r3, #4]
2000be00:	2b01      	cmp	r3, #1
2000be02:	d00b      	beq.n	2000be1c <HAL_GPIO_Init+0x1b4>
2000be04:	683b      	ldr	r3, [r7, #0]
2000be06:	685b      	ldr	r3, [r3, #4]
2000be08:	2b02      	cmp	r3, #2
2000be0a:	d007      	beq.n	2000be1c <HAL_GPIO_Init+0x1b4>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
2000be0c:	683b      	ldr	r3, [r7, #0]
2000be0e:	685b      	ldr	r3, [r3, #4]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
2000be10:	2b11      	cmp	r3, #17
2000be12:	d003      	beq.n	2000be1c <HAL_GPIO_Init+0x1b4>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
2000be14:	683b      	ldr	r3, [r7, #0]
2000be16:	685b      	ldr	r3, [r3, #4]
2000be18:	2b12      	cmp	r3, #18
2000be1a:	d144      	bne.n	2000bea6 <HAL_GPIO_Init+0x23e>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
2000be1c:	683b      	ldr	r3, [r7, #0]
2000be1e:	68db      	ldr	r3, [r3, #12]
2000be20:	2b00      	cmp	r3, #0
2000be22:	d00f      	beq.n	2000be44 <HAL_GPIO_Init+0x1dc>
2000be24:	683b      	ldr	r3, [r7, #0]
2000be26:	68db      	ldr	r3, [r3, #12]
2000be28:	2b01      	cmp	r3, #1
2000be2a:	d00b      	beq.n	2000be44 <HAL_GPIO_Init+0x1dc>
2000be2c:	683b      	ldr	r3, [r7, #0]
2000be2e:	68db      	ldr	r3, [r3, #12]
2000be30:	2b02      	cmp	r3, #2
2000be32:	d007      	beq.n	2000be44 <HAL_GPIO_Init+0x1dc>
2000be34:	683b      	ldr	r3, [r7, #0]
2000be36:	68db      	ldr	r3, [r3, #12]
2000be38:	2b03      	cmp	r3, #3
2000be3a:	d003      	beq.n	2000be44 <HAL_GPIO_Init+0x1dc>
2000be3c:	21ce      	movs	r1, #206	; 0xce
2000be3e:	4897      	ldr	r0, [pc, #604]	; (2000c09c <HAL_GPIO_Init+0x434>)
2000be40:	f7f4 fd58 	bl	200008f4 <assert_failed>
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
2000be44:	687b      	ldr	r3, [r7, #4]
2000be46:	689b      	ldr	r3, [r3, #8]
2000be48:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
2000be4a:	69fb      	ldr	r3, [r7, #28]
2000be4c:	005b      	lsls	r3, r3, #1
2000be4e:	2203      	movs	r2, #3
2000be50:	fa02 f303 	lsl.w	r3, r2, r3
2000be54:	43db      	mvns	r3, r3
2000be56:	69ba      	ldr	r2, [r7, #24]
2000be58:	4013      	ands	r3, r2
2000be5a:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
2000be5c:	683b      	ldr	r3, [r7, #0]
2000be5e:	68da      	ldr	r2, [r3, #12]
2000be60:	69fb      	ldr	r3, [r7, #28]
2000be62:	005b      	lsls	r3, r3, #1
2000be64:	fa02 f303 	lsl.w	r3, r2, r3
2000be68:	69ba      	ldr	r2, [r7, #24]
2000be6a:	4313      	orrs	r3, r2
2000be6c:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
2000be6e:	687b      	ldr	r3, [r7, #4]
2000be70:	69ba      	ldr	r2, [r7, #24]
2000be72:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
2000be74:	687b      	ldr	r3, [r7, #4]
2000be76:	685b      	ldr	r3, [r3, #4]
2000be78:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
2000be7a:	2201      	movs	r2, #1
2000be7c:	69fb      	ldr	r3, [r7, #28]
2000be7e:	fa02 f303 	lsl.w	r3, r2, r3
2000be82:	43db      	mvns	r3, r3
2000be84:	69ba      	ldr	r2, [r7, #24]
2000be86:	4013      	ands	r3, r2
2000be88:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
2000be8a:	683b      	ldr	r3, [r7, #0]
2000be8c:	685b      	ldr	r3, [r3, #4]
2000be8e:	091b      	lsrs	r3, r3, #4
2000be90:	f003 0201 	and.w	r2, r3, #1
2000be94:	69fb      	ldr	r3, [r7, #28]
2000be96:	fa02 f303 	lsl.w	r3, r2, r3
2000be9a:	69ba      	ldr	r2, [r7, #24]
2000be9c:	4313      	orrs	r3, r2
2000be9e:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
2000bea0:	687b      	ldr	r3, [r7, #4]
2000bea2:	69ba      	ldr	r2, [r7, #24]
2000bea4:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
2000bea6:	687b      	ldr	r3, [r7, #4]
2000bea8:	68db      	ldr	r3, [r3, #12]
2000beaa:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
2000beac:	69fb      	ldr	r3, [r7, #28]
2000beae:	005b      	lsls	r3, r3, #1
2000beb0:	2203      	movs	r2, #3
2000beb2:	fa02 f303 	lsl.w	r3, r2, r3
2000beb6:	43db      	mvns	r3, r3
2000beb8:	69ba      	ldr	r2, [r7, #24]
2000beba:	4013      	ands	r3, r2
2000bebc:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
2000bebe:	683b      	ldr	r3, [r7, #0]
2000bec0:	689a      	ldr	r2, [r3, #8]
2000bec2:	69fb      	ldr	r3, [r7, #28]
2000bec4:	005b      	lsls	r3, r3, #1
2000bec6:	fa02 f303 	lsl.w	r3, r2, r3
2000beca:	69ba      	ldr	r2, [r7, #24]
2000becc:	4313      	orrs	r3, r2
2000bece:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
2000bed0:	687b      	ldr	r3, [r7, #4]
2000bed2:	69ba      	ldr	r2, [r7, #24]
2000bed4:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
2000bed6:	683b      	ldr	r3, [r7, #0]
2000bed8:	685b      	ldr	r3, [r3, #4]
2000beda:	2b02      	cmp	r3, #2
2000bedc:	d003      	beq.n	2000bee6 <HAL_GPIO_Init+0x27e>
2000bede:	683b      	ldr	r3, [r7, #0]
2000bee0:	685b      	ldr	r3, [r3, #4]
2000bee2:	2b12      	cmp	r3, #18
2000bee4:	d15b      	bne.n	2000bf9e <HAL_GPIO_Init+0x336>
      {
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
2000bee6:	687b      	ldr	r3, [r7, #4]
2000bee8:	4a6d      	ldr	r2, [pc, #436]	; (2000c0a0 <HAL_GPIO_Init+0x438>)
2000beea:	4293      	cmp	r3, r2
2000beec:	d02b      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000beee:	687b      	ldr	r3, [r7, #4]
2000bef0:	4a6c      	ldr	r2, [pc, #432]	; (2000c0a4 <HAL_GPIO_Init+0x43c>)
2000bef2:	4293      	cmp	r3, r2
2000bef4:	d027      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000bef6:	687b      	ldr	r3, [r7, #4]
2000bef8:	4a6b      	ldr	r2, [pc, #428]	; (2000c0a8 <HAL_GPIO_Init+0x440>)
2000befa:	4293      	cmp	r3, r2
2000befc:	d023      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000befe:	687b      	ldr	r3, [r7, #4]
2000bf00:	4a6a      	ldr	r2, [pc, #424]	; (2000c0ac <HAL_GPIO_Init+0x444>)
2000bf02:	4293      	cmp	r3, r2
2000bf04:	d01f      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000bf06:	687b      	ldr	r3, [r7, #4]
2000bf08:	4a69      	ldr	r2, [pc, #420]	; (2000c0b0 <HAL_GPIO_Init+0x448>)
2000bf0a:	4293      	cmp	r3, r2
2000bf0c:	d01b      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000bf0e:	687b      	ldr	r3, [r7, #4]
2000bf10:	4a68      	ldr	r2, [pc, #416]	; (2000c0b4 <HAL_GPIO_Init+0x44c>)
2000bf12:	4293      	cmp	r3, r2
2000bf14:	d017      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000bf16:	687b      	ldr	r3, [r7, #4]
2000bf18:	4a67      	ldr	r2, [pc, #412]	; (2000c0b8 <HAL_GPIO_Init+0x450>)
2000bf1a:	4293      	cmp	r3, r2
2000bf1c:	d013      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000bf1e:	687b      	ldr	r3, [r7, #4]
2000bf20:	4a66      	ldr	r2, [pc, #408]	; (2000c0bc <HAL_GPIO_Init+0x454>)
2000bf22:	4293      	cmp	r3, r2
2000bf24:	d00f      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000bf26:	687b      	ldr	r3, [r7, #4]
2000bf28:	4a65      	ldr	r2, [pc, #404]	; (2000c0c0 <HAL_GPIO_Init+0x458>)
2000bf2a:	4293      	cmp	r3, r2
2000bf2c:	d00b      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000bf2e:	687b      	ldr	r3, [r7, #4]
2000bf30:	4a64      	ldr	r2, [pc, #400]	; (2000c0c4 <HAL_GPIO_Init+0x45c>)
2000bf32:	4293      	cmp	r3, r2
2000bf34:	d007      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000bf36:	687b      	ldr	r3, [r7, #4]
2000bf38:	4a63      	ldr	r2, [pc, #396]	; (2000c0c8 <HAL_GPIO_Init+0x460>)
2000bf3a:	4293      	cmp	r3, r2
2000bf3c:	d003      	beq.n	2000bf46 <HAL_GPIO_Init+0x2de>
2000bf3e:	21e6      	movs	r1, #230	; 0xe6
2000bf40:	4856      	ldr	r0, [pc, #344]	; (2000c09c <HAL_GPIO_Init+0x434>)
2000bf42:	f7f4 fcd7 	bl	200008f4 <assert_failed>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
2000bf46:	683b      	ldr	r3, [r7, #0]
2000bf48:	691b      	ldr	r3, [r3, #16]
2000bf4a:	2b0f      	cmp	r3, #15
2000bf4c:	d903      	bls.n	2000bf56 <HAL_GPIO_Init+0x2ee>
2000bf4e:	21e7      	movs	r1, #231	; 0xe7
2000bf50:	4852      	ldr	r0, [pc, #328]	; (2000c09c <HAL_GPIO_Init+0x434>)
2000bf52:	f7f4 fccf 	bl	200008f4 <assert_failed>

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
2000bf56:	69fb      	ldr	r3, [r7, #28]
2000bf58:	08da      	lsrs	r2, r3, #3
2000bf5a:	687b      	ldr	r3, [r7, #4]
2000bf5c:	3208      	adds	r2, #8
2000bf5e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
2000bf62:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
2000bf64:	69fb      	ldr	r3, [r7, #28]
2000bf66:	f003 0307 	and.w	r3, r3, #7
2000bf6a:	009b      	lsls	r3, r3, #2
2000bf6c:	220f      	movs	r2, #15
2000bf6e:	fa02 f303 	lsl.w	r3, r2, r3
2000bf72:	43db      	mvns	r3, r3
2000bf74:	69ba      	ldr	r2, [r7, #24]
2000bf76:	4013      	ands	r3, r2
2000bf78:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
2000bf7a:	683b      	ldr	r3, [r7, #0]
2000bf7c:	691a      	ldr	r2, [r3, #16]
2000bf7e:	69fb      	ldr	r3, [r7, #28]
2000bf80:	f003 0307 	and.w	r3, r3, #7
2000bf84:	009b      	lsls	r3, r3, #2
2000bf86:	fa02 f303 	lsl.w	r3, r2, r3
2000bf8a:	69ba      	ldr	r2, [r7, #24]
2000bf8c:	4313      	orrs	r3, r2
2000bf8e:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
2000bf90:	69fb      	ldr	r3, [r7, #28]
2000bf92:	08da      	lsrs	r2, r3, #3
2000bf94:	687b      	ldr	r3, [r7, #4]
2000bf96:	3208      	adds	r2, #8
2000bf98:	69b9      	ldr	r1, [r7, #24]
2000bf9a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
2000bf9e:	687b      	ldr	r3, [r7, #4]
2000bfa0:	681b      	ldr	r3, [r3, #0]
2000bfa2:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
2000bfa4:	69fb      	ldr	r3, [r7, #28]
2000bfa6:	005b      	lsls	r3, r3, #1
2000bfa8:	2203      	movs	r2, #3
2000bfaa:	fa02 f303 	lsl.w	r3, r2, r3
2000bfae:	43db      	mvns	r3, r3
2000bfb0:	69ba      	ldr	r2, [r7, #24]
2000bfb2:	4013      	ands	r3, r2
2000bfb4:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
2000bfb6:	683b      	ldr	r3, [r7, #0]
2000bfb8:	685b      	ldr	r3, [r3, #4]
2000bfba:	f003 0203 	and.w	r2, r3, #3
2000bfbe:	69fb      	ldr	r3, [r7, #28]
2000bfc0:	005b      	lsls	r3, r3, #1
2000bfc2:	fa02 f303 	lsl.w	r3, r2, r3
2000bfc6:	69ba      	ldr	r2, [r7, #24]
2000bfc8:	4313      	orrs	r3, r2
2000bfca:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
2000bfcc:	687b      	ldr	r3, [r7, #4]
2000bfce:	69ba      	ldr	r2, [r7, #24]
2000bfd0:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
2000bfd2:	683b      	ldr	r3, [r7, #0]
2000bfd4:	685b      	ldr	r3, [r3, #4]
2000bfd6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000bfda:	2b00      	cmp	r3, #0
2000bfdc:	f000 80e2 	beq.w	2000c1a4 <HAL_GPIO_Init+0x53c>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
2000bfe0:	4b3a      	ldr	r3, [pc, #232]	; (2000c0cc <HAL_GPIO_Init+0x464>)
2000bfe2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2000bfe6:	4a39      	ldr	r2, [pc, #228]	; (2000c0cc <HAL_GPIO_Init+0x464>)
2000bfe8:	f043 0302 	orr.w	r3, r3, #2
2000bfec:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
2000bff0:	4b36      	ldr	r3, [pc, #216]	; (2000c0cc <HAL_GPIO_Init+0x464>)
2000bff2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2000bff6:	f003 0302 	and.w	r3, r3, #2
2000bffa:	60fb      	str	r3, [r7, #12]
2000bffc:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
2000bffe:	4a34      	ldr	r2, [pc, #208]	; (2000c0d0 <HAL_GPIO_Init+0x468>)
2000c000:	69fb      	ldr	r3, [r7, #28]
2000c002:	089b      	lsrs	r3, r3, #2
2000c004:	3302      	adds	r3, #2
2000c006:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000c00a:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
2000c00c:	69fb      	ldr	r3, [r7, #28]
2000c00e:	f003 0303 	and.w	r3, r3, #3
2000c012:	009b      	lsls	r3, r3, #2
2000c014:	220f      	movs	r2, #15
2000c016:	fa02 f303 	lsl.w	r3, r2, r3
2000c01a:	43db      	mvns	r3, r3
2000c01c:	69ba      	ldr	r2, [r7, #24]
2000c01e:	4013      	ands	r3, r2
2000c020:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
2000c022:	687b      	ldr	r3, [r7, #4]
2000c024:	4a1e      	ldr	r2, [pc, #120]	; (2000c0a0 <HAL_GPIO_Init+0x438>)
2000c026:	4293      	cmp	r3, r2
2000c028:	d054      	beq.n	2000c0d4 <HAL_GPIO_Init+0x46c>
2000c02a:	687b      	ldr	r3, [r7, #4]
2000c02c:	4a1d      	ldr	r2, [pc, #116]	; (2000c0a4 <HAL_GPIO_Init+0x43c>)
2000c02e:	4293      	cmp	r3, r2
2000c030:	d031      	beq.n	2000c096 <HAL_GPIO_Init+0x42e>
2000c032:	687b      	ldr	r3, [r7, #4]
2000c034:	4a1c      	ldr	r2, [pc, #112]	; (2000c0a8 <HAL_GPIO_Init+0x440>)
2000c036:	4293      	cmp	r3, r2
2000c038:	d02b      	beq.n	2000c092 <HAL_GPIO_Init+0x42a>
2000c03a:	687b      	ldr	r3, [r7, #4]
2000c03c:	4a1b      	ldr	r2, [pc, #108]	; (2000c0ac <HAL_GPIO_Init+0x444>)
2000c03e:	4293      	cmp	r3, r2
2000c040:	d025      	beq.n	2000c08e <HAL_GPIO_Init+0x426>
2000c042:	687b      	ldr	r3, [r7, #4]
2000c044:	4a1a      	ldr	r2, [pc, #104]	; (2000c0b0 <HAL_GPIO_Init+0x448>)
2000c046:	4293      	cmp	r3, r2
2000c048:	d01f      	beq.n	2000c08a <HAL_GPIO_Init+0x422>
2000c04a:	687b      	ldr	r3, [r7, #4]
2000c04c:	4a19      	ldr	r2, [pc, #100]	; (2000c0b4 <HAL_GPIO_Init+0x44c>)
2000c04e:	4293      	cmp	r3, r2
2000c050:	d019      	beq.n	2000c086 <HAL_GPIO_Init+0x41e>
2000c052:	687b      	ldr	r3, [r7, #4]
2000c054:	4a18      	ldr	r2, [pc, #96]	; (2000c0b8 <HAL_GPIO_Init+0x450>)
2000c056:	4293      	cmp	r3, r2
2000c058:	d013      	beq.n	2000c082 <HAL_GPIO_Init+0x41a>
2000c05a:	687b      	ldr	r3, [r7, #4]
2000c05c:	4a17      	ldr	r2, [pc, #92]	; (2000c0bc <HAL_GPIO_Init+0x454>)
2000c05e:	4293      	cmp	r3, r2
2000c060:	d00d      	beq.n	2000c07e <HAL_GPIO_Init+0x416>
2000c062:	687b      	ldr	r3, [r7, #4]
2000c064:	4a16      	ldr	r2, [pc, #88]	; (2000c0c0 <HAL_GPIO_Init+0x458>)
2000c066:	4293      	cmp	r3, r2
2000c068:	d007      	beq.n	2000c07a <HAL_GPIO_Init+0x412>
2000c06a:	687b      	ldr	r3, [r7, #4]
2000c06c:	4a15      	ldr	r2, [pc, #84]	; (2000c0c4 <HAL_GPIO_Init+0x45c>)
2000c06e:	4293      	cmp	r3, r2
2000c070:	d101      	bne.n	2000c076 <HAL_GPIO_Init+0x40e>
2000c072:	2309      	movs	r3, #9
2000c074:	e02f      	b.n	2000c0d6 <HAL_GPIO_Init+0x46e>
2000c076:	230a      	movs	r3, #10
2000c078:	e02d      	b.n	2000c0d6 <HAL_GPIO_Init+0x46e>
2000c07a:	2308      	movs	r3, #8
2000c07c:	e02b      	b.n	2000c0d6 <HAL_GPIO_Init+0x46e>
2000c07e:	2307      	movs	r3, #7
2000c080:	e029      	b.n	2000c0d6 <HAL_GPIO_Init+0x46e>
2000c082:	2306      	movs	r3, #6
2000c084:	e027      	b.n	2000c0d6 <HAL_GPIO_Init+0x46e>
2000c086:	2305      	movs	r3, #5
2000c088:	e025      	b.n	2000c0d6 <HAL_GPIO_Init+0x46e>
2000c08a:	2304      	movs	r3, #4
2000c08c:	e023      	b.n	2000c0d6 <HAL_GPIO_Init+0x46e>
2000c08e:	2303      	movs	r3, #3
2000c090:	e021      	b.n	2000c0d6 <HAL_GPIO_Init+0x46e>
2000c092:	2302      	movs	r3, #2
2000c094:	e01f      	b.n	2000c0d6 <HAL_GPIO_Init+0x46e>
2000c096:	2301      	movs	r3, #1
2000c098:	e01d      	b.n	2000c0d6 <HAL_GPIO_Init+0x46e>
2000c09a:	bf00      	nop
2000c09c:	2001c108 	.word	0x2001c108
2000c0a0:	58020000 	.word	0x58020000
2000c0a4:	58020400 	.word	0x58020400
2000c0a8:	58020800 	.word	0x58020800
2000c0ac:	58020c00 	.word	0x58020c00
2000c0b0:	58021000 	.word	0x58021000
2000c0b4:	58021400 	.word	0x58021400
2000c0b8:	58021800 	.word	0x58021800
2000c0bc:	58021c00 	.word	0x58021c00
2000c0c0:	58022000 	.word	0x58022000
2000c0c4:	58022400 	.word	0x58022400
2000c0c8:	58022800 	.word	0x58022800
2000c0cc:	58024400 	.word	0x58024400
2000c0d0:	58000400 	.word	0x58000400
2000c0d4:	2300      	movs	r3, #0
2000c0d6:	69fa      	ldr	r2, [r7, #28]
2000c0d8:	f002 0203 	and.w	r2, r2, #3
2000c0dc:	0092      	lsls	r2, r2, #2
2000c0de:	4093      	lsls	r3, r2
2000c0e0:	69ba      	ldr	r2, [r7, #24]
2000c0e2:	4313      	orrs	r3, r2
2000c0e4:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
2000c0e6:	4937      	ldr	r1, [pc, #220]	; (2000c1c4 <HAL_GPIO_Init+0x55c>)
2000c0e8:	69fb      	ldr	r3, [r7, #28]
2000c0ea:	089b      	lsrs	r3, r3, #2
2000c0ec:	3302      	adds	r3, #2
2000c0ee:	69ba      	ldr	r2, [r7, #24]
2000c0f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
2000c0f4:	697b      	ldr	r3, [r7, #20]
2000c0f6:	681b      	ldr	r3, [r3, #0]
2000c0f8:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
2000c0fa:	693b      	ldr	r3, [r7, #16]
2000c0fc:	43db      	mvns	r3, r3
2000c0fe:	69ba      	ldr	r2, [r7, #24]
2000c100:	4013      	ands	r3, r2
2000c102:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
2000c104:	683b      	ldr	r3, [r7, #0]
2000c106:	685b      	ldr	r3, [r3, #4]
2000c108:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000c10c:	2b00      	cmp	r3, #0
2000c10e:	d003      	beq.n	2000c118 <HAL_GPIO_Init+0x4b0>
        {
          temp |= iocurrent;
2000c110:	69ba      	ldr	r2, [r7, #24]
2000c112:	693b      	ldr	r3, [r7, #16]
2000c114:	4313      	orrs	r3, r2
2000c116:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
2000c118:	697b      	ldr	r3, [r7, #20]
2000c11a:	69ba      	ldr	r2, [r7, #24]
2000c11c:	601a      	str	r2, [r3, #0]

        temp = EXTI_CurrentCPU->EMR1;
2000c11e:	697b      	ldr	r3, [r7, #20]
2000c120:	685b      	ldr	r3, [r3, #4]
2000c122:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
2000c124:	693b      	ldr	r3, [r7, #16]
2000c126:	43db      	mvns	r3, r3
2000c128:	69ba      	ldr	r2, [r7, #24]
2000c12a:	4013      	ands	r3, r2
2000c12c:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
2000c12e:	683b      	ldr	r3, [r7, #0]
2000c130:	685b      	ldr	r3, [r3, #4]
2000c132:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000c136:	2b00      	cmp	r3, #0
2000c138:	d003      	beq.n	2000c142 <HAL_GPIO_Init+0x4da>
        {
          temp |= iocurrent;
2000c13a:	69ba      	ldr	r2, [r7, #24]
2000c13c:	693b      	ldr	r3, [r7, #16]
2000c13e:	4313      	orrs	r3, r2
2000c140:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
2000c142:	697b      	ldr	r3, [r7, #20]
2000c144:	69ba      	ldr	r2, [r7, #24]
2000c146:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
2000c148:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2000c14c:	681b      	ldr	r3, [r3, #0]
2000c14e:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
2000c150:	693b      	ldr	r3, [r7, #16]
2000c152:	43db      	mvns	r3, r3
2000c154:	69ba      	ldr	r2, [r7, #24]
2000c156:	4013      	ands	r3, r2
2000c158:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
2000c15a:	683b      	ldr	r3, [r7, #0]
2000c15c:	685b      	ldr	r3, [r3, #4]
2000c15e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
2000c162:	2b00      	cmp	r3, #0
2000c164:	d003      	beq.n	2000c16e <HAL_GPIO_Init+0x506>
        {
          temp |= iocurrent;
2000c166:	69ba      	ldr	r2, [r7, #24]
2000c168:	693b      	ldr	r3, [r7, #16]
2000c16a:	4313      	orrs	r3, r2
2000c16c:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
2000c16e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2000c172:	69bb      	ldr	r3, [r7, #24]
2000c174:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
2000c176:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2000c17a:	685b      	ldr	r3, [r3, #4]
2000c17c:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
2000c17e:	693b      	ldr	r3, [r7, #16]
2000c180:	43db      	mvns	r3, r3
2000c182:	69ba      	ldr	r2, [r7, #24]
2000c184:	4013      	ands	r3, r2
2000c186:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
2000c188:	683b      	ldr	r3, [r7, #0]
2000c18a:	685b      	ldr	r3, [r3, #4]
2000c18c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
2000c190:	2b00      	cmp	r3, #0
2000c192:	d003      	beq.n	2000c19c <HAL_GPIO_Init+0x534>
        {
          temp |= iocurrent;
2000c194:	69ba      	ldr	r2, [r7, #24]
2000c196:	693b      	ldr	r3, [r7, #16]
2000c198:	4313      	orrs	r3, r2
2000c19a:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
2000c19c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2000c1a0:	69bb      	ldr	r3, [r7, #24]
2000c1a2:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
2000c1a4:	69fb      	ldr	r3, [r7, #28]
2000c1a6:	3301      	adds	r3, #1
2000c1a8:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
2000c1aa:	683b      	ldr	r3, [r7, #0]
2000c1ac:	681a      	ldr	r2, [r3, #0]
2000c1ae:	69fb      	ldr	r3, [r7, #28]
2000c1b0:	fa22 f303 	lsr.w	r3, r2, r3
2000c1b4:	2b00      	cmp	r3, #0
2000c1b6:	f47f ae15 	bne.w	2000bde4 <HAL_GPIO_Init+0x17c>
  }
}
2000c1ba:	bf00      	nop
2000c1bc:	3720      	adds	r7, #32
2000c1be:	46bd      	mov	sp, r7
2000c1c0:	bd80      	pop	{r7, pc}
2000c1c2:	bf00      	nop
2000c1c4:	58000400 	.word	0x58000400

2000c1c8 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
2000c1c8:	b580      	push	{r7, lr}
2000c1ca:	b086      	sub	sp, #24
2000c1cc:	af00      	add	r7, sp, #0
2000c1ce:	6078      	str	r0, [r7, #4]
2000c1d0:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
2000c1d2:	2300      	movs	r3, #0
2000c1d4:	617b      	str	r3, [r7, #20]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
2000c1d6:	4b94      	ldr	r3, [pc, #592]	; (2000c428 <HAL_GPIO_DeInit+0x260>)
2000c1d8:	613b      	str	r3, [r7, #16]
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
2000c1da:	687b      	ldr	r3, [r7, #4]
2000c1dc:	4a93      	ldr	r2, [pc, #588]	; (2000c42c <HAL_GPIO_DeInit+0x264>)
2000c1de:	4293      	cmp	r3, r2
2000c1e0:	d02c      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c1e2:	687b      	ldr	r3, [r7, #4]
2000c1e4:	4a92      	ldr	r2, [pc, #584]	; (2000c430 <HAL_GPIO_DeInit+0x268>)
2000c1e6:	4293      	cmp	r3, r2
2000c1e8:	d028      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c1ea:	687b      	ldr	r3, [r7, #4]
2000c1ec:	4a91      	ldr	r2, [pc, #580]	; (2000c434 <HAL_GPIO_DeInit+0x26c>)
2000c1ee:	4293      	cmp	r3, r2
2000c1f0:	d024      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c1f2:	687b      	ldr	r3, [r7, #4]
2000c1f4:	4a90      	ldr	r2, [pc, #576]	; (2000c438 <HAL_GPIO_DeInit+0x270>)
2000c1f6:	4293      	cmp	r3, r2
2000c1f8:	d020      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c1fa:	687b      	ldr	r3, [r7, #4]
2000c1fc:	4a8f      	ldr	r2, [pc, #572]	; (2000c43c <HAL_GPIO_DeInit+0x274>)
2000c1fe:	4293      	cmp	r3, r2
2000c200:	d01c      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c202:	687b      	ldr	r3, [r7, #4]
2000c204:	4a8e      	ldr	r2, [pc, #568]	; (2000c440 <HAL_GPIO_DeInit+0x278>)
2000c206:	4293      	cmp	r3, r2
2000c208:	d018      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c20a:	687b      	ldr	r3, [r7, #4]
2000c20c:	4a8d      	ldr	r2, [pc, #564]	; (2000c444 <HAL_GPIO_DeInit+0x27c>)
2000c20e:	4293      	cmp	r3, r2
2000c210:	d014      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c212:	687b      	ldr	r3, [r7, #4]
2000c214:	4a8c      	ldr	r2, [pc, #560]	; (2000c448 <HAL_GPIO_DeInit+0x280>)
2000c216:	4293      	cmp	r3, r2
2000c218:	d010      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c21a:	687b      	ldr	r3, [r7, #4]
2000c21c:	4a8b      	ldr	r2, [pc, #556]	; (2000c44c <HAL_GPIO_DeInit+0x284>)
2000c21e:	4293      	cmp	r3, r2
2000c220:	d00c      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c222:	687b      	ldr	r3, [r7, #4]
2000c224:	4a8a      	ldr	r2, [pc, #552]	; (2000c450 <HAL_GPIO_DeInit+0x288>)
2000c226:	4293      	cmp	r3, r2
2000c228:	d008      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c22a:	687b      	ldr	r3, [r7, #4]
2000c22c:	4a89      	ldr	r2, [pc, #548]	; (2000c454 <HAL_GPIO_DeInit+0x28c>)
2000c22e:	4293      	cmp	r3, r2
2000c230:	d004      	beq.n	2000c23c <HAL_GPIO_DeInit+0x74>
2000c232:	f240 113f 	movw	r1, #319	; 0x13f
2000c236:	4888      	ldr	r0, [pc, #544]	; (2000c458 <HAL_GPIO_DeInit+0x290>)
2000c238:	f7f4 fb5c 	bl	200008f4 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
2000c23c:	683b      	ldr	r3, [r7, #0]
2000c23e:	b29b      	uxth	r3, r3
2000c240:	2b00      	cmp	r3, #0
2000c242:	d005      	beq.n	2000c250 <HAL_GPIO_DeInit+0x88>
2000c244:	683a      	ldr	r2, [r7, #0]
2000c246:	4b85      	ldr	r3, [pc, #532]	; (2000c45c <HAL_GPIO_DeInit+0x294>)
2000c248:	4013      	ands	r3, r2
2000c24a:	2b00      	cmp	r3, #0
2000c24c:	f000 80e0 	beq.w	2000c410 <HAL_GPIO_DeInit+0x248>
2000c250:	f44f 71a0 	mov.w	r1, #320	; 0x140
2000c254:	4880      	ldr	r0, [pc, #512]	; (2000c458 <HAL_GPIO_DeInit+0x290>)
2000c256:	f7f4 fb4d 	bl	200008f4 <assert_failed>

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00U)
2000c25a:	e0d9      	b.n	2000c410 <HAL_GPIO_DeInit+0x248>
  {
    /* Get current io position */
    iocurrent = GPIO_Pin & (1UL << position) ;
2000c25c:	2201      	movs	r2, #1
2000c25e:	697b      	ldr	r3, [r7, #20]
2000c260:	fa02 f303 	lsl.w	r3, r2, r3
2000c264:	683a      	ldr	r2, [r7, #0]
2000c266:	4013      	ands	r3, r2
2000c268:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00U)
2000c26a:	68fb      	ldr	r3, [r7, #12]
2000c26c:	2b00      	cmp	r3, #0
2000c26e:	f000 80cc 	beq.w	2000c40a <HAL_GPIO_DeInit+0x242>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
2000c272:	4a7b      	ldr	r2, [pc, #492]	; (2000c460 <HAL_GPIO_DeInit+0x298>)
2000c274:	697b      	ldr	r3, [r7, #20]
2000c276:	089b      	lsrs	r3, r3, #2
2000c278:	3302      	adds	r3, #2
2000c27a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000c27e:	60bb      	str	r3, [r7, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
2000c280:	697b      	ldr	r3, [r7, #20]
2000c282:	f003 0303 	and.w	r3, r3, #3
2000c286:	009b      	lsls	r3, r3, #2
2000c288:	220f      	movs	r2, #15
2000c28a:	fa02 f303 	lsl.w	r3, r2, r3
2000c28e:	68ba      	ldr	r2, [r7, #8]
2000c290:	4013      	ands	r3, r2
2000c292:	60bb      	str	r3, [r7, #8]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
2000c294:	687b      	ldr	r3, [r7, #4]
2000c296:	4a65      	ldr	r2, [pc, #404]	; (2000c42c <HAL_GPIO_DeInit+0x264>)
2000c298:	4293      	cmp	r3, r2
2000c29a:	d037      	beq.n	2000c30c <HAL_GPIO_DeInit+0x144>
2000c29c:	687b      	ldr	r3, [r7, #4]
2000c29e:	4a64      	ldr	r2, [pc, #400]	; (2000c430 <HAL_GPIO_DeInit+0x268>)
2000c2a0:	4293      	cmp	r3, r2
2000c2a2:	d031      	beq.n	2000c308 <HAL_GPIO_DeInit+0x140>
2000c2a4:	687b      	ldr	r3, [r7, #4]
2000c2a6:	4a63      	ldr	r2, [pc, #396]	; (2000c434 <HAL_GPIO_DeInit+0x26c>)
2000c2a8:	4293      	cmp	r3, r2
2000c2aa:	d02b      	beq.n	2000c304 <HAL_GPIO_DeInit+0x13c>
2000c2ac:	687b      	ldr	r3, [r7, #4]
2000c2ae:	4a62      	ldr	r2, [pc, #392]	; (2000c438 <HAL_GPIO_DeInit+0x270>)
2000c2b0:	4293      	cmp	r3, r2
2000c2b2:	d025      	beq.n	2000c300 <HAL_GPIO_DeInit+0x138>
2000c2b4:	687b      	ldr	r3, [r7, #4]
2000c2b6:	4a61      	ldr	r2, [pc, #388]	; (2000c43c <HAL_GPIO_DeInit+0x274>)
2000c2b8:	4293      	cmp	r3, r2
2000c2ba:	d01f      	beq.n	2000c2fc <HAL_GPIO_DeInit+0x134>
2000c2bc:	687b      	ldr	r3, [r7, #4]
2000c2be:	4a60      	ldr	r2, [pc, #384]	; (2000c440 <HAL_GPIO_DeInit+0x278>)
2000c2c0:	4293      	cmp	r3, r2
2000c2c2:	d019      	beq.n	2000c2f8 <HAL_GPIO_DeInit+0x130>
2000c2c4:	687b      	ldr	r3, [r7, #4]
2000c2c6:	4a5f      	ldr	r2, [pc, #380]	; (2000c444 <HAL_GPIO_DeInit+0x27c>)
2000c2c8:	4293      	cmp	r3, r2
2000c2ca:	d013      	beq.n	2000c2f4 <HAL_GPIO_DeInit+0x12c>
2000c2cc:	687b      	ldr	r3, [r7, #4]
2000c2ce:	4a5e      	ldr	r2, [pc, #376]	; (2000c448 <HAL_GPIO_DeInit+0x280>)
2000c2d0:	4293      	cmp	r3, r2
2000c2d2:	d00d      	beq.n	2000c2f0 <HAL_GPIO_DeInit+0x128>
2000c2d4:	687b      	ldr	r3, [r7, #4]
2000c2d6:	4a5d      	ldr	r2, [pc, #372]	; (2000c44c <HAL_GPIO_DeInit+0x284>)
2000c2d8:	4293      	cmp	r3, r2
2000c2da:	d007      	beq.n	2000c2ec <HAL_GPIO_DeInit+0x124>
2000c2dc:	687b      	ldr	r3, [r7, #4]
2000c2de:	4a5c      	ldr	r2, [pc, #368]	; (2000c450 <HAL_GPIO_DeInit+0x288>)
2000c2e0:	4293      	cmp	r3, r2
2000c2e2:	d101      	bne.n	2000c2e8 <HAL_GPIO_DeInit+0x120>
2000c2e4:	2309      	movs	r3, #9
2000c2e6:	e012      	b.n	2000c30e <HAL_GPIO_DeInit+0x146>
2000c2e8:	230a      	movs	r3, #10
2000c2ea:	e010      	b.n	2000c30e <HAL_GPIO_DeInit+0x146>
2000c2ec:	2308      	movs	r3, #8
2000c2ee:	e00e      	b.n	2000c30e <HAL_GPIO_DeInit+0x146>
2000c2f0:	2307      	movs	r3, #7
2000c2f2:	e00c      	b.n	2000c30e <HAL_GPIO_DeInit+0x146>
2000c2f4:	2306      	movs	r3, #6
2000c2f6:	e00a      	b.n	2000c30e <HAL_GPIO_DeInit+0x146>
2000c2f8:	2305      	movs	r3, #5
2000c2fa:	e008      	b.n	2000c30e <HAL_GPIO_DeInit+0x146>
2000c2fc:	2304      	movs	r3, #4
2000c2fe:	e006      	b.n	2000c30e <HAL_GPIO_DeInit+0x146>
2000c300:	2303      	movs	r3, #3
2000c302:	e004      	b.n	2000c30e <HAL_GPIO_DeInit+0x146>
2000c304:	2302      	movs	r3, #2
2000c306:	e002      	b.n	2000c30e <HAL_GPIO_DeInit+0x146>
2000c308:	2301      	movs	r3, #1
2000c30a:	e000      	b.n	2000c30e <HAL_GPIO_DeInit+0x146>
2000c30c:	2300      	movs	r3, #0
2000c30e:	697a      	ldr	r2, [r7, #20]
2000c310:	f002 0203 	and.w	r2, r2, #3
2000c314:	0092      	lsls	r2, r2, #2
2000c316:	4093      	lsls	r3, r2
2000c318:	68ba      	ldr	r2, [r7, #8]
2000c31a:	429a      	cmp	r2, r3
2000c31c:	d136      	bne.n	2000c38c <HAL_GPIO_DeInit+0x1c4>
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
2000c31e:	693b      	ldr	r3, [r7, #16]
2000c320:	681a      	ldr	r2, [r3, #0]
2000c322:	68fb      	ldr	r3, [r7, #12]
2000c324:	43db      	mvns	r3, r3
2000c326:	401a      	ands	r2, r3
2000c328:	693b      	ldr	r3, [r7, #16]
2000c32a:	601a      	str	r2, [r3, #0]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
2000c32c:	693b      	ldr	r3, [r7, #16]
2000c32e:	685a      	ldr	r2, [r3, #4]
2000c330:	68fb      	ldr	r3, [r7, #12]
2000c332:	43db      	mvns	r3, r3
2000c334:	401a      	ands	r2, r3
2000c336:	693b      	ldr	r3, [r7, #16]
2000c338:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~(iocurrent);
2000c33a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2000c33e:	681a      	ldr	r2, [r3, #0]
2000c340:	68fb      	ldr	r3, [r7, #12]
2000c342:	43db      	mvns	r3, r3
2000c344:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
2000c348:	4013      	ands	r3, r2
2000c34a:	600b      	str	r3, [r1, #0]
        EXTI->FTSR1 &= ~(iocurrent);
2000c34c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2000c350:	685a      	ldr	r2, [r3, #4]
2000c352:	68fb      	ldr	r3, [r7, #12]
2000c354:	43db      	mvns	r3, r3
2000c356:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
2000c35a:	4013      	ands	r3, r2
2000c35c:	604b      	str	r3, [r1, #4]

        tmp = 0x0FUL << (4U * (position & 0x03U));
2000c35e:	697b      	ldr	r3, [r7, #20]
2000c360:	f003 0303 	and.w	r3, r3, #3
2000c364:	009b      	lsls	r3, r3, #2
2000c366:	220f      	movs	r2, #15
2000c368:	fa02 f303 	lsl.w	r3, r2, r3
2000c36c:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
2000c36e:	4a3c      	ldr	r2, [pc, #240]	; (2000c460 <HAL_GPIO_DeInit+0x298>)
2000c370:	697b      	ldr	r3, [r7, #20]
2000c372:	089b      	lsrs	r3, r3, #2
2000c374:	3302      	adds	r3, #2
2000c376:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
2000c37a:	68bb      	ldr	r3, [r7, #8]
2000c37c:	43da      	mvns	r2, r3
2000c37e:	4838      	ldr	r0, [pc, #224]	; (2000c460 <HAL_GPIO_DeInit+0x298>)
2000c380:	697b      	ldr	r3, [r7, #20]
2000c382:	089b      	lsrs	r3, r3, #2
2000c384:	400a      	ands	r2, r1
2000c386:	3302      	adds	r3, #2
2000c388:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
2000c38c:	687b      	ldr	r3, [r7, #4]
2000c38e:	681a      	ldr	r2, [r3, #0]
2000c390:	697b      	ldr	r3, [r7, #20]
2000c392:	005b      	lsls	r3, r3, #1
2000c394:	2103      	movs	r1, #3
2000c396:	fa01 f303 	lsl.w	r3, r1, r3
2000c39a:	431a      	orrs	r2, r3
2000c39c:	687b      	ldr	r3, [r7, #4]
2000c39e:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
2000c3a0:	697b      	ldr	r3, [r7, #20]
2000c3a2:	08da      	lsrs	r2, r3, #3
2000c3a4:	687b      	ldr	r3, [r7, #4]
2000c3a6:	3208      	adds	r2, #8
2000c3a8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
2000c3ac:	697b      	ldr	r3, [r7, #20]
2000c3ae:	f003 0307 	and.w	r3, r3, #7
2000c3b2:	009b      	lsls	r3, r3, #2
2000c3b4:	220f      	movs	r2, #15
2000c3b6:	fa02 f303 	lsl.w	r3, r2, r3
2000c3ba:	43db      	mvns	r3, r3
2000c3bc:	697a      	ldr	r2, [r7, #20]
2000c3be:	08d2      	lsrs	r2, r2, #3
2000c3c0:	4019      	ands	r1, r3
2000c3c2:	687b      	ldr	r3, [r7, #4]
2000c3c4:	3208      	adds	r2, #8
2000c3c6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
2000c3ca:	687b      	ldr	r3, [r7, #4]
2000c3cc:	68da      	ldr	r2, [r3, #12]
2000c3ce:	697b      	ldr	r3, [r7, #20]
2000c3d0:	005b      	lsls	r3, r3, #1
2000c3d2:	2103      	movs	r1, #3
2000c3d4:	fa01 f303 	lsl.w	r3, r1, r3
2000c3d8:	43db      	mvns	r3, r3
2000c3da:	401a      	ands	r2, r3
2000c3dc:	687b      	ldr	r3, [r7, #4]
2000c3de:	60da      	str	r2, [r3, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
2000c3e0:	687b      	ldr	r3, [r7, #4]
2000c3e2:	685a      	ldr	r2, [r3, #4]
2000c3e4:	2101      	movs	r1, #1
2000c3e6:	697b      	ldr	r3, [r7, #20]
2000c3e8:	fa01 f303 	lsl.w	r3, r1, r3
2000c3ec:	43db      	mvns	r3, r3
2000c3ee:	401a      	ands	r2, r3
2000c3f0:	687b      	ldr	r3, [r7, #4]
2000c3f2:	605a      	str	r2, [r3, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
2000c3f4:	687b      	ldr	r3, [r7, #4]
2000c3f6:	689a      	ldr	r2, [r3, #8]
2000c3f8:	697b      	ldr	r3, [r7, #20]
2000c3fa:	005b      	lsls	r3, r3, #1
2000c3fc:	2103      	movs	r1, #3
2000c3fe:	fa01 f303 	lsl.w	r3, r1, r3
2000c402:	43db      	mvns	r3, r3
2000c404:	401a      	ands	r2, r3
2000c406:	687b      	ldr	r3, [r7, #4]
2000c408:	609a      	str	r2, [r3, #8]
    }

    position++;
2000c40a:	697b      	ldr	r3, [r7, #20]
2000c40c:	3301      	adds	r3, #1
2000c40e:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00U)
2000c410:	683a      	ldr	r2, [r7, #0]
2000c412:	697b      	ldr	r3, [r7, #20]
2000c414:	fa22 f303 	lsr.w	r3, r2, r3
2000c418:	2b00      	cmp	r3, #0
2000c41a:	f47f af1f 	bne.w	2000c25c <HAL_GPIO_DeInit+0x94>
  }
}
2000c41e:	bf00      	nop
2000c420:	3718      	adds	r7, #24
2000c422:	46bd      	mov	sp, r7
2000c424:	bd80      	pop	{r7, pc}
2000c426:	bf00      	nop
2000c428:	58000080 	.word	0x58000080
2000c42c:	58020000 	.word	0x58020000
2000c430:	58020400 	.word	0x58020400
2000c434:	58020800 	.word	0x58020800
2000c438:	58020c00 	.word	0x58020c00
2000c43c:	58021000 	.word	0x58021000
2000c440:	58021400 	.word	0x58021400
2000c444:	58021800 	.word	0x58021800
2000c448:	58021c00 	.word	0x58021c00
2000c44c:	58022000 	.word	0x58022000
2000c450:	58022400 	.word	0x58022400
2000c454:	58022800 	.word	0x58022800
2000c458:	2001c108 	.word	0x2001c108
2000c45c:	ffff0000 	.word	0xffff0000
2000c460:	58000400 	.word	0x58000400

2000c464 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
2000c464:	b580      	push	{r7, lr}
2000c466:	b084      	sub	sp, #16
2000c468:	af00      	add	r7, sp, #0
2000c46a:	6078      	str	r0, [r7, #4]
2000c46c:	460b      	mov	r3, r1
2000c46e:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
2000c470:	887b      	ldrh	r3, [r7, #2]
2000c472:	2b00      	cmp	r3, #0
2000c474:	d004      	beq.n	2000c480 <HAL_GPIO_ReadPin+0x1c>
2000c476:	887a      	ldrh	r2, [r7, #2]
2000c478:	4b0c      	ldr	r3, [pc, #48]	; (2000c4ac <HAL_GPIO_ReadPin+0x48>)
2000c47a:	4013      	ands	r3, r2
2000c47c:	2b00      	cmp	r3, #0
2000c47e:	d004      	beq.n	2000c48a <HAL_GPIO_ReadPin+0x26>
2000c480:	f240 118d 	movw	r1, #397	; 0x18d
2000c484:	480a      	ldr	r0, [pc, #40]	; (2000c4b0 <HAL_GPIO_ReadPin+0x4c>)
2000c486:	f7f4 fa35 	bl	200008f4 <assert_failed>

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
2000c48a:	687b      	ldr	r3, [r7, #4]
2000c48c:	691a      	ldr	r2, [r3, #16]
2000c48e:	887b      	ldrh	r3, [r7, #2]
2000c490:	4013      	ands	r3, r2
2000c492:	2b00      	cmp	r3, #0
2000c494:	d002      	beq.n	2000c49c <HAL_GPIO_ReadPin+0x38>
  {
    bitstatus = GPIO_PIN_SET;
2000c496:	2301      	movs	r3, #1
2000c498:	73fb      	strb	r3, [r7, #15]
2000c49a:	e001      	b.n	2000c4a0 <HAL_GPIO_ReadPin+0x3c>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
2000c49c:	2300      	movs	r3, #0
2000c49e:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
2000c4a0:	7bfb      	ldrb	r3, [r7, #15]
}
2000c4a2:	4618      	mov	r0, r3
2000c4a4:	3710      	adds	r7, #16
2000c4a6:	46bd      	mov	sp, r7
2000c4a8:	bd80      	pop	{r7, pc}
2000c4aa:	bf00      	nop
2000c4ac:	ffff0000 	.word	0xffff0000
2000c4b0:	2001c108 	.word	0x2001c108

2000c4b4 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
2000c4b4:	b580      	push	{r7, lr}
2000c4b6:	b082      	sub	sp, #8
2000c4b8:	af00      	add	r7, sp, #0
2000c4ba:	6078      	str	r0, [r7, #4]
2000c4bc:	460b      	mov	r3, r1
2000c4be:	807b      	strh	r3, [r7, #2]
2000c4c0:	4613      	mov	r3, r2
2000c4c2:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
2000c4c4:	887b      	ldrh	r3, [r7, #2]
2000c4c6:	2b00      	cmp	r3, #0
2000c4c8:	d004      	beq.n	2000c4d4 <HAL_GPIO_WritePin+0x20>
2000c4ca:	887a      	ldrh	r2, [r7, #2]
2000c4cc:	4b11      	ldr	r3, [pc, #68]	; (2000c514 <HAL_GPIO_WritePin+0x60>)
2000c4ce:	4013      	ands	r3, r2
2000c4d0:	2b00      	cmp	r3, #0
2000c4d2:	d004      	beq.n	2000c4de <HAL_GPIO_WritePin+0x2a>
2000c4d4:	f240 11ad 	movw	r1, #429	; 0x1ad
2000c4d8:	480f      	ldr	r0, [pc, #60]	; (2000c518 <HAL_GPIO_WritePin+0x64>)
2000c4da:	f7f4 fa0b 	bl	200008f4 <assert_failed>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
2000c4de:	787b      	ldrb	r3, [r7, #1]
2000c4e0:	2b00      	cmp	r3, #0
2000c4e2:	d007      	beq.n	2000c4f4 <HAL_GPIO_WritePin+0x40>
2000c4e4:	787b      	ldrb	r3, [r7, #1]
2000c4e6:	2b01      	cmp	r3, #1
2000c4e8:	d004      	beq.n	2000c4f4 <HAL_GPIO_WritePin+0x40>
2000c4ea:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
2000c4ee:	480a      	ldr	r0, [pc, #40]	; (2000c518 <HAL_GPIO_WritePin+0x64>)
2000c4f0:	f7f4 fa00 	bl	200008f4 <assert_failed>

  if (PinState != GPIO_PIN_RESET)
2000c4f4:	787b      	ldrb	r3, [r7, #1]
2000c4f6:	2b00      	cmp	r3, #0
2000c4f8:	d003      	beq.n	2000c502 <HAL_GPIO_WritePin+0x4e>
  {
    GPIOx->BSRR = GPIO_Pin;
2000c4fa:	887a      	ldrh	r2, [r7, #2]
2000c4fc:	687b      	ldr	r3, [r7, #4]
2000c4fe:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
2000c500:	e003      	b.n	2000c50a <HAL_GPIO_WritePin+0x56>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
2000c502:	887b      	ldrh	r3, [r7, #2]
2000c504:	041a      	lsls	r2, r3, #16
2000c506:	687b      	ldr	r3, [r7, #4]
2000c508:	619a      	str	r2, [r3, #24]
}
2000c50a:	bf00      	nop
2000c50c:	3708      	adds	r7, #8
2000c50e:	46bd      	mov	sp, r7
2000c510:	bd80      	pop	{r7, pc}
2000c512:	bf00      	nop
2000c514:	ffff0000 	.word	0xffff0000
2000c518:	2001c108 	.word	0x2001c108

2000c51c <HAL_GPIO_TogglePin>:
  * @param  GPIOx: Where x can be (A..K) to select the GPIO peripheral.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
2000c51c:	b580      	push	{r7, lr}
2000c51e:	b082      	sub	sp, #8
2000c520:	af00      	add	r7, sp, #0
2000c522:	6078      	str	r0, [r7, #4]
2000c524:	460b      	mov	r3, r1
2000c526:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
2000c528:	887b      	ldrh	r3, [r7, #2]
2000c52a:	2b00      	cmp	r3, #0
2000c52c:	d004      	beq.n	2000c538 <HAL_GPIO_TogglePin+0x1c>
2000c52e:	887a      	ldrh	r2, [r7, #2]
2000c530:	4b0d      	ldr	r3, [pc, #52]	; (2000c568 <HAL_GPIO_TogglePin+0x4c>)
2000c532:	4013      	ands	r3, r2
2000c534:	2b00      	cmp	r3, #0
2000c536:	d004      	beq.n	2000c542 <HAL_GPIO_TogglePin+0x26>
2000c538:	f240 11c3 	movw	r1, #451	; 0x1c3
2000c53c:	480b      	ldr	r0, [pc, #44]	; (2000c56c <HAL_GPIO_TogglePin+0x50>)
2000c53e:	f7f4 f9d9 	bl	200008f4 <assert_failed>

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
2000c542:	687b      	ldr	r3, [r7, #4]
2000c544:	695a      	ldr	r2, [r3, #20]
2000c546:	887b      	ldrh	r3, [r7, #2]
2000c548:	401a      	ands	r2, r3
2000c54a:	887b      	ldrh	r3, [r7, #2]
2000c54c:	429a      	cmp	r2, r3
2000c54e:	d104      	bne.n	2000c55a <HAL_GPIO_TogglePin+0x3e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
2000c550:	887b      	ldrh	r3, [r7, #2]
2000c552:	041a      	lsls	r2, r3, #16
2000c554:	687b      	ldr	r3, [r7, #4]
2000c556:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
  }
}
2000c558:	e002      	b.n	2000c560 <HAL_GPIO_TogglePin+0x44>
    GPIOx->BSRR = GPIO_Pin;
2000c55a:	887a      	ldrh	r2, [r7, #2]
2000c55c:	687b      	ldr	r3, [r7, #4]
2000c55e:	619a      	str	r2, [r3, #24]
}
2000c560:	bf00      	nop
2000c562:	3708      	adds	r7, #8
2000c564:	46bd      	mov	sp, r7
2000c566:	bd80      	pop	{r7, pc}
2000c568:	ffff0000 	.word	0xffff0000
2000c56c:	2001c108 	.word	0x2001c108

2000c570 <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
2000c570:	b580      	push	{r7, lr}
2000c572:	b084      	sub	sp, #16
2000c574:	af00      	add	r7, sp, #0
2000c576:	6078      	str	r0, [r7, #4]
2000c578:	460b      	mov	r3, r1
2000c57a:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
2000c57c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
2000c580:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
2000c582:	687b      	ldr	r3, [r7, #4]
2000c584:	4a2c      	ldr	r2, [pc, #176]	; (2000c638 <HAL_GPIO_LockPin+0xc8>)
2000c586:	4293      	cmp	r3, r2
2000c588:	d02c      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c58a:	687b      	ldr	r3, [r7, #4]
2000c58c:	4a2b      	ldr	r2, [pc, #172]	; (2000c63c <HAL_GPIO_LockPin+0xcc>)
2000c58e:	4293      	cmp	r3, r2
2000c590:	d028      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c592:	687b      	ldr	r3, [r7, #4]
2000c594:	4a2a      	ldr	r2, [pc, #168]	; (2000c640 <HAL_GPIO_LockPin+0xd0>)
2000c596:	4293      	cmp	r3, r2
2000c598:	d024      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c59a:	687b      	ldr	r3, [r7, #4]
2000c59c:	4a29      	ldr	r2, [pc, #164]	; (2000c644 <HAL_GPIO_LockPin+0xd4>)
2000c59e:	4293      	cmp	r3, r2
2000c5a0:	d020      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c5a2:	687b      	ldr	r3, [r7, #4]
2000c5a4:	4a28      	ldr	r2, [pc, #160]	; (2000c648 <HAL_GPIO_LockPin+0xd8>)
2000c5a6:	4293      	cmp	r3, r2
2000c5a8:	d01c      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c5aa:	687b      	ldr	r3, [r7, #4]
2000c5ac:	4a27      	ldr	r2, [pc, #156]	; (2000c64c <HAL_GPIO_LockPin+0xdc>)
2000c5ae:	4293      	cmp	r3, r2
2000c5b0:	d018      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c5b2:	687b      	ldr	r3, [r7, #4]
2000c5b4:	4a26      	ldr	r2, [pc, #152]	; (2000c650 <HAL_GPIO_LockPin+0xe0>)
2000c5b6:	4293      	cmp	r3, r2
2000c5b8:	d014      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c5ba:	687b      	ldr	r3, [r7, #4]
2000c5bc:	4a25      	ldr	r2, [pc, #148]	; (2000c654 <HAL_GPIO_LockPin+0xe4>)
2000c5be:	4293      	cmp	r3, r2
2000c5c0:	d010      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c5c2:	687b      	ldr	r3, [r7, #4]
2000c5c4:	4a24      	ldr	r2, [pc, #144]	; (2000c658 <HAL_GPIO_LockPin+0xe8>)
2000c5c6:	4293      	cmp	r3, r2
2000c5c8:	d00c      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c5ca:	687b      	ldr	r3, [r7, #4]
2000c5cc:	4a23      	ldr	r2, [pc, #140]	; (2000c65c <HAL_GPIO_LockPin+0xec>)
2000c5ce:	4293      	cmp	r3, r2
2000c5d0:	d008      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c5d2:	687b      	ldr	r3, [r7, #4]
2000c5d4:	4a22      	ldr	r2, [pc, #136]	; (2000c660 <HAL_GPIO_LockPin+0xf0>)
2000c5d6:	4293      	cmp	r3, r2
2000c5d8:	d004      	beq.n	2000c5e4 <HAL_GPIO_LockPin+0x74>
2000c5da:	f240 11df 	movw	r1, #479	; 0x1df
2000c5de:	4821      	ldr	r0, [pc, #132]	; (2000c664 <HAL_GPIO_LockPin+0xf4>)
2000c5e0:	f7f4 f988 	bl	200008f4 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
2000c5e4:	887b      	ldrh	r3, [r7, #2]
2000c5e6:	2b00      	cmp	r3, #0
2000c5e8:	d004      	beq.n	2000c5f4 <HAL_GPIO_LockPin+0x84>
2000c5ea:	887a      	ldrh	r2, [r7, #2]
2000c5ec:	4b1e      	ldr	r3, [pc, #120]	; (2000c668 <HAL_GPIO_LockPin+0xf8>)
2000c5ee:	4013      	ands	r3, r2
2000c5f0:	2b00      	cmp	r3, #0
2000c5f2:	d004      	beq.n	2000c5fe <HAL_GPIO_LockPin+0x8e>
2000c5f4:	f44f 71f0 	mov.w	r1, #480	; 0x1e0
2000c5f8:	481a      	ldr	r0, [pc, #104]	; (2000c664 <HAL_GPIO_LockPin+0xf4>)
2000c5fa:	f7f4 f97b 	bl	200008f4 <assert_failed>

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
2000c5fe:	887a      	ldrh	r2, [r7, #2]
2000c600:	68fb      	ldr	r3, [r7, #12]
2000c602:	4313      	orrs	r3, r2
2000c604:	60fb      	str	r3, [r7, #12]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
2000c606:	68fa      	ldr	r2, [r7, #12]
2000c608:	687b      	ldr	r3, [r7, #4]
2000c60a:	61da      	str	r2, [r3, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
2000c60c:	887a      	ldrh	r2, [r7, #2]
2000c60e:	687b      	ldr	r3, [r7, #4]
2000c610:	61da      	str	r2, [r3, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
2000c612:	68fa      	ldr	r2, [r7, #12]
2000c614:	687b      	ldr	r3, [r7, #4]
2000c616:	61da      	str	r2, [r3, #28]
  /* Read LCKK register. This read is mandatory to complete key lock sequence*/
  tmp = GPIOx->LCKR;
2000c618:	687b      	ldr	r3, [r7, #4]
2000c61a:	69db      	ldr	r3, [r3, #28]
2000c61c:	60fb      	str	r3, [r7, #12]

  /* read again in order to confirm lock is active */
  if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00U)
2000c61e:	687b      	ldr	r3, [r7, #4]
2000c620:	69db      	ldr	r3, [r3, #28]
2000c622:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000c626:	2b00      	cmp	r3, #0
2000c628:	d001      	beq.n	2000c62e <HAL_GPIO_LockPin+0xbe>
  {
    return HAL_OK;
2000c62a:	2300      	movs	r3, #0
2000c62c:	e000      	b.n	2000c630 <HAL_GPIO_LockPin+0xc0>
  }
  else
  {
    return HAL_ERROR;
2000c62e:	2301      	movs	r3, #1
  }
}
2000c630:	4618      	mov	r0, r3
2000c632:	3710      	adds	r7, #16
2000c634:	46bd      	mov	sp, r7
2000c636:	bd80      	pop	{r7, pc}
2000c638:	58020000 	.word	0x58020000
2000c63c:	58020400 	.word	0x58020400
2000c640:	58020800 	.word	0x58020800
2000c644:	58020c00 	.word	0x58020c00
2000c648:	58021000 	.word	0x58021000
2000c64c:	58021400 	.word	0x58021400
2000c650:	58021800 	.word	0x58021800
2000c654:	58021c00 	.word	0x58021c00
2000c658:	58022000 	.word	0x58022000
2000c65c:	58022400 	.word	0x58022400
2000c660:	58022800 	.word	0x58022800
2000c664:	2001c108 	.word	0x2001c108
2000c668:	ffff0000 	.word	0xffff0000

2000c66c <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
2000c66c:	b580      	push	{r7, lr}
2000c66e:	b082      	sub	sp, #8
2000c670:	af00      	add	r7, sp, #0
2000c672:	4603      	mov	r3, r0
2000c674:	80fb      	strh	r3, [r7, #6]
    __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
#else
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
2000c676:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2000c67a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
2000c67e:	88fb      	ldrh	r3, [r7, #6]
2000c680:	4013      	ands	r3, r2
2000c682:	2b00      	cmp	r3, #0
2000c684:	d008      	beq.n	2000c698 <HAL_GPIO_EXTI_IRQHandler+0x2c>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
2000c686:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2000c68a:	88fb      	ldrh	r3, [r7, #6]
2000c68c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
2000c690:	88fb      	ldrh	r3, [r7, #6]
2000c692:	4618      	mov	r0, r3
2000c694:	f000 f804 	bl	2000c6a0 <HAL_GPIO_EXTI_Callback>
  }
#endif
}
2000c698:	bf00      	nop
2000c69a:	3708      	adds	r7, #8
2000c69c:	46bd      	mov	sp, r7
2000c69e:	bd80      	pop	{r7, pc}

2000c6a0 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
2000c6a0:	b480      	push	{r7}
2000c6a2:	b083      	sub	sp, #12
2000c6a4:	af00      	add	r7, sp, #0
2000c6a6:	4603      	mov	r3, r0
2000c6a8:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
2000c6aa:	bf00      	nop
2000c6ac:	370c      	adds	r7, #12
2000c6ae:	46bd      	mov	sp, r7
2000c6b0:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c6b4:	4770      	bx	lr
	...

2000c6b8 <HAL_HSEM_Take>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  HAL_HSEM_Take(uint32_t SemID, uint32_t ProcessID)
{
2000c6b8:	b580      	push	{r7, lr}
2000c6ba:	b082      	sub	sp, #8
2000c6bc:	af00      	add	r7, sp, #0
2000c6be:	6078      	str	r0, [r7, #4]
2000c6c0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_HSEM_SEMID(SemID));
2000c6c2:	687b      	ldr	r3, [r7, #4]
2000c6c4:	2b1f      	cmp	r3, #31
2000c6c6:	d903      	bls.n	2000c6d0 <HAL_HSEM_Take+0x18>
2000c6c8:	219a      	movs	r1, #154	; 0x9a
2000c6ca:	4810      	ldr	r0, [pc, #64]	; (2000c70c <HAL_HSEM_Take+0x54>)
2000c6cc:	f7f4 f912 	bl	200008f4 <assert_failed>
  assert_param(IS_HSEM_PROCESSID(ProcessID));
2000c6d0:	683b      	ldr	r3, [r7, #0]
2000c6d2:	2bff      	cmp	r3, #255	; 0xff
2000c6d4:	d903      	bls.n	2000c6de <HAL_HSEM_Take+0x26>
2000c6d6:	219b      	movs	r1, #155	; 0x9b
2000c6d8:	480c      	ldr	r0, [pc, #48]	; (2000c70c <HAL_HSEM_Take+0x54>)
2000c6da:	f7f4 f90b 	bl	200008f4 <assert_failed>
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
  }
#else
  /* First step  write R register with MasterID, processID and take bit=1*/
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK);
2000c6de:	490c      	ldr	r1, [pc, #48]	; (2000c710 <HAL_HSEM_Take+0x58>)
2000c6e0:	683a      	ldr	r2, [r7, #0]
2000c6e2:	4b0c      	ldr	r3, [pc, #48]	; (2000c714 <HAL_HSEM_Take+0x5c>)
2000c6e4:	4313      	orrs	r3, r2
2000c6e6:	687a      	ldr	r2, [r7, #4]
2000c6e8:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

  /* second step : read the R register . Take achieved if MasterID and processID match and take bit set to 1 */
  if (HSEM->R[SemID] == (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK))
2000c6ec:	4a08      	ldr	r2, [pc, #32]	; (2000c710 <HAL_HSEM_Take+0x58>)
2000c6ee:	687b      	ldr	r3, [r7, #4]
2000c6f0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
2000c6f4:	6839      	ldr	r1, [r7, #0]
2000c6f6:	4b07      	ldr	r3, [pc, #28]	; (2000c714 <HAL_HSEM_Take+0x5c>)
2000c6f8:	430b      	orrs	r3, r1
2000c6fa:	429a      	cmp	r2, r3
2000c6fc:	d101      	bne.n	2000c702 <HAL_HSEM_Take+0x4a>
  {
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
2000c6fe:	2300      	movs	r3, #0
2000c700:	e000      	b.n	2000c704 <HAL_HSEM_Take+0x4c>
  }
#endif

  /* Semaphore take fails*/
  return HAL_ERROR;
2000c702:	2301      	movs	r3, #1
}
2000c704:	4618      	mov	r0, r3
2000c706:	3708      	adds	r7, #8
2000c708:	46bd      	mov	sp, r7
2000c70a:	bd80      	pop	{r7, pc}
2000c70c:	2001c144 	.word	0x2001c144
2000c710:	58026400 	.word	0x58026400
2000c714:	80000300 	.word	0x80000300

2000c718 <HAL_HSEM_FastTake>:
  * @brief  Fast Take a semaphore with 1 Step mode.
  * @param  SemID: semaphore ID from 0 to 31
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HSEM_FastTake(uint32_t SemID)
{
2000c718:	b580      	push	{r7, lr}
2000c71a:	b082      	sub	sp, #8
2000c71c:	af00      	add	r7, sp, #0
2000c71e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_HSEM_SEMID(SemID));
2000c720:	687b      	ldr	r3, [r7, #4]
2000c722:	2b1f      	cmp	r3, #31
2000c724:	d903      	bls.n	2000c72e <HAL_HSEM_FastTake+0x16>
2000c726:	21bf      	movs	r1, #191	; 0xbf
2000c728:	4808      	ldr	r0, [pc, #32]	; (2000c74c <HAL_HSEM_FastTake+0x34>)
2000c72a:	f7f4 f8e3 	bl	200008f4 <assert_failed>
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
  }
#else
  /* Read the RLR register to take the semaphore */
  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))
2000c72e:	4a08      	ldr	r2, [pc, #32]	; (2000c750 <HAL_HSEM_FastTake+0x38>)
2000c730:	687b      	ldr	r3, [r7, #4]
2000c732:	3320      	adds	r3, #32
2000c734:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000c738:	4a06      	ldr	r2, [pc, #24]	; (2000c754 <HAL_HSEM_FastTake+0x3c>)
2000c73a:	4293      	cmp	r3, r2
2000c73c:	d101      	bne.n	2000c742 <HAL_HSEM_FastTake+0x2a>
  {
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
2000c73e:	2300      	movs	r3, #0
2000c740:	e000      	b.n	2000c744 <HAL_HSEM_FastTake+0x2c>
  }
#endif

  /* Semaphore take fails */
  return HAL_ERROR;
2000c742:	2301      	movs	r3, #1
}
2000c744:	4618      	mov	r0, r3
2000c746:	3708      	adds	r7, #8
2000c748:	46bd      	mov	sp, r7
2000c74a:	bd80      	pop	{r7, pc}
2000c74c:	2001c144 	.word	0x2001c144
2000c750:	58026400 	.word	0x58026400
2000c754:	80000300 	.word	0x80000300

2000c758 <HAL_HSEM_IsSemTaken>:
  * @brief  Check semaphore state Taken or not.
  * @param  SemID: semaphore ID
  * @retval HAL HSEM state
  */
uint32_t HAL_HSEM_IsSemTaken(uint32_t SemID)
{
2000c758:	b480      	push	{r7}
2000c75a:	b083      	sub	sp, #12
2000c75c:	af00      	add	r7, sp, #0
2000c75e:	6078      	str	r0, [r7, #4]
  return (((HSEM->R[SemID] & HSEM_R_LOCK) != 0U) ? 1UL : 0UL);
2000c760:	4a07      	ldr	r2, [pc, #28]	; (2000c780 <HAL_HSEM_IsSemTaken+0x28>)
2000c762:	687b      	ldr	r3, [r7, #4]
2000c764:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000c768:	2b00      	cmp	r3, #0
2000c76a:	da01      	bge.n	2000c770 <HAL_HSEM_IsSemTaken+0x18>
2000c76c:	2301      	movs	r3, #1
2000c76e:	e000      	b.n	2000c772 <HAL_HSEM_IsSemTaken+0x1a>
2000c770:	2300      	movs	r3, #0
}
2000c772:	4618      	mov	r0, r3
2000c774:	370c      	adds	r7, #12
2000c776:	46bd      	mov	sp, r7
2000c778:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c77c:	4770      	bx	lr
2000c77e:	bf00      	nop
2000c780:	58026400 	.word	0x58026400

2000c784 <HAL_HSEM_Release>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval None
  */
void  HAL_HSEM_Release(uint32_t SemID, uint32_t ProcessID)
{
2000c784:	b580      	push	{r7, lr}
2000c786:	b082      	sub	sp, #8
2000c788:	af00      	add	r7, sp, #0
2000c78a:	6078      	str	r0, [r7, #4]
2000c78c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_HSEM_SEMID(SemID));
2000c78e:	687b      	ldr	r3, [r7, #4]
2000c790:	2b1f      	cmp	r3, #31
2000c792:	d903      	bls.n	2000c79c <HAL_HSEM_Release+0x18>
2000c794:	21e8      	movs	r1, #232	; 0xe8
2000c796:	480a      	ldr	r0, [pc, #40]	; (2000c7c0 <HAL_HSEM_Release+0x3c>)
2000c798:	f7f4 f8ac 	bl	200008f4 <assert_failed>
  assert_param(IS_HSEM_PROCESSID(ProcessID));
2000c79c:	683b      	ldr	r3, [r7, #0]
2000c79e:	2bff      	cmp	r3, #255	; 0xff
2000c7a0:	d903      	bls.n	2000c7aa <HAL_HSEM_Release+0x26>
2000c7a2:	21e9      	movs	r1, #233	; 0xe9
2000c7a4:	4806      	ldr	r0, [pc, #24]	; (2000c7c0 <HAL_HSEM_Release+0x3c>)
2000c7a6:	f7f4 f8a5 	bl	200008f4 <assert_failed>

  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */
#if  USE_MULTI_CORE_SHARED_CODE != 0U
  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));
#else
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);
2000c7aa:	4906      	ldr	r1, [pc, #24]	; (2000c7c4 <HAL_HSEM_Release+0x40>)
2000c7ac:	683b      	ldr	r3, [r7, #0]
2000c7ae:	f443 7240 	orr.w	r2, r3, #768	; 0x300
2000c7b2:	687b      	ldr	r3, [r7, #4]
2000c7b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
2000c7b8:	bf00      	nop
2000c7ba:	3708      	adds	r7, #8
2000c7bc:	46bd      	mov	sp, r7
2000c7be:	bd80      	pop	{r7, pc}
2000c7c0:	2001c144 	.word	0x2001c144
2000c7c4:	58026400 	.word	0x58026400

2000c7c8 <HAL_HSEM_ReleaseAll>:
  * @param  Key: Semaphore Key , value from 0 to 0xFFFF
  * @param  CoreID: CoreID of the CPU that is using semaphores to be released
  * @retval None
  */
void HAL_HSEM_ReleaseAll(uint32_t Key, uint32_t CoreID)
{
2000c7c8:	b580      	push	{r7, lr}
2000c7ca:	b082      	sub	sp, #8
2000c7cc:	af00      	add	r7, sp, #0
2000c7ce:	6078      	str	r0, [r7, #4]
2000c7d0:	6039      	str	r1, [r7, #0]
  assert_param(IS_HSEM_KEY(Key));
2000c7d2:	687b      	ldr	r3, [r7, #4]
2000c7d4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000c7d8:	d303      	bcc.n	2000c7e2 <HAL_HSEM_ReleaseAll+0x1a>
2000c7da:	21fc      	movs	r1, #252	; 0xfc
2000c7dc:	480a      	ldr	r0, [pc, #40]	; (2000c808 <HAL_HSEM_ReleaseAll+0x40>)
2000c7de:	f7f4 f889 	bl	200008f4 <assert_failed>
  assert_param(IS_HSEM_COREID(CoreID));
2000c7e2:	683b      	ldr	r3, [r7, #0]
2000c7e4:	2b03      	cmp	r3, #3
2000c7e6:	d003      	beq.n	2000c7f0 <HAL_HSEM_ReleaseAll+0x28>
2000c7e8:	21fd      	movs	r1, #253	; 0xfd
2000c7ea:	4807      	ldr	r0, [pc, #28]	; (2000c808 <HAL_HSEM_ReleaseAll+0x40>)
2000c7ec:	f7f4 f882 	bl	200008f4 <assert_failed>

  HSEM->CR = ((Key << HSEM_CR_KEY_Pos) | (CoreID << HSEM_CR_COREID_Pos));
2000c7f0:	687b      	ldr	r3, [r7, #4]
2000c7f2:	041a      	lsls	r2, r3, #16
2000c7f4:	683b      	ldr	r3, [r7, #0]
2000c7f6:	021b      	lsls	r3, r3, #8
2000c7f8:	4904      	ldr	r1, [pc, #16]	; (2000c80c <HAL_HSEM_ReleaseAll+0x44>)
2000c7fa:	4313      	orrs	r3, r2
2000c7fc:	f8c1 3140 	str.w	r3, [r1, #320]	; 0x140
}
2000c800:	bf00      	nop
2000c802:	3708      	adds	r7, #8
2000c804:	46bd      	mov	sp, r7
2000c806:	bd80      	pop	{r7, pc}
2000c808:	2001c144 	.word	0x2001c144
2000c80c:	58026400 	.word	0x58026400

2000c810 <HAL_HSEM_SetClearKey>:
  * @brief  Set semaphore Key .
  * @param  Key: Semaphore Key , value from 0 to 0xFFFF
  * @retval None
  */
void  HAL_HSEM_SetClearKey(uint32_t Key)
{
2000c810:	b580      	push	{r7, lr}
2000c812:	b082      	sub	sp, #8
2000c814:	af00      	add	r7, sp, #0
2000c816:	6078      	str	r0, [r7, #4]
  assert_param(IS_HSEM_KEY(Key));
2000c818:	687b      	ldr	r3, [r7, #4]
2000c81a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000c81e:	d304      	bcc.n	2000c82a <HAL_HSEM_SetClearKey+0x1a>
2000c820:	f44f 718e 	mov.w	r1, #284	; 0x11c
2000c824:	4808      	ldr	r0, [pc, #32]	; (2000c848 <HAL_HSEM_SetClearKey+0x38>)
2000c826:	f7f4 f865 	bl	200008f4 <assert_failed>

  MODIFY_REG(HSEM->KEYR, HSEM_KEYR_KEY, (Key << HSEM_KEYR_KEY_Pos));
2000c82a:	4b08      	ldr	r3, [pc, #32]	; (2000c84c <HAL_HSEM_SetClearKey+0x3c>)
2000c82c:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
2000c830:	b29a      	uxth	r2, r3
2000c832:	687b      	ldr	r3, [r7, #4]
2000c834:	041b      	lsls	r3, r3, #16
2000c836:	4905      	ldr	r1, [pc, #20]	; (2000c84c <HAL_HSEM_SetClearKey+0x3c>)
2000c838:	4313      	orrs	r3, r2
2000c83a:	f8c1 3144 	str.w	r3, [r1, #324]	; 0x144

}
2000c83e:	bf00      	nop
2000c840:	3708      	adds	r7, #8
2000c842:	46bd      	mov	sp, r7
2000c844:	bd80      	pop	{r7, pc}
2000c846:	bf00      	nop
2000c848:	2001c144 	.word	0x2001c144
2000c84c:	58026400 	.word	0x58026400

2000c850 <HAL_HSEM_GetClearKey>:
/**
  * @brief  Get semaphore Key .
  * @retval Semaphore Key , value from 0 to 0xFFFF
  */
uint32_t HAL_HSEM_GetClearKey(void)
{
2000c850:	b480      	push	{r7}
2000c852:	af00      	add	r7, sp, #0
  return (HSEM->KEYR >> HSEM_KEYR_KEY_Pos);
2000c854:	4b04      	ldr	r3, [pc, #16]	; (2000c868 <HAL_HSEM_GetClearKey+0x18>)
2000c856:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
2000c85a:	0c1b      	lsrs	r3, r3, #16
}
2000c85c:	4618      	mov	r0, r3
2000c85e:	46bd      	mov	sp, r7
2000c860:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c864:	4770      	bx	lr
2000c866:	bf00      	nop
2000c868:	58026400 	.word	0x58026400

2000c86c <HAL_HSEM_ActivateNotification>:
  * @brief  Activate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_ActivateNotification(uint32_t SemMask)
{
2000c86c:	b480      	push	{r7}
2000c86e:	b083      	sub	sp, #12
2000c870:	af00      	add	r7, sp, #0
2000c872:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER |= SemMask;
  }
#else
  HSEM_COMMON->IER |= SemMask;
2000c874:	4b05      	ldr	r3, [pc, #20]	; (2000c88c <HAL_HSEM_ActivateNotification+0x20>)
2000c876:	681a      	ldr	r2, [r3, #0]
2000c878:	4904      	ldr	r1, [pc, #16]	; (2000c88c <HAL_HSEM_ActivateNotification+0x20>)
2000c87a:	687b      	ldr	r3, [r7, #4]
2000c87c:	4313      	orrs	r3, r2
2000c87e:	600b      	str	r3, [r1, #0]
#endif
}
2000c880:	bf00      	nop
2000c882:	370c      	adds	r7, #12
2000c884:	46bd      	mov	sp, r7
2000c886:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c88a:	4770      	bx	lr
2000c88c:	58026500 	.word	0x58026500

2000c890 <HAL_HSEM_DeactivateNotification>:
  * @brief  Deactivate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_DeactivateNotification(uint32_t SemMask)
{
2000c890:	b480      	push	{r7}
2000c892:	b083      	sub	sp, #12
2000c894:	af00      	add	r7, sp, #0
2000c896:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER &= ~SemMask;
  }
#else
  HSEM_COMMON->IER &= ~SemMask;
2000c898:	4b06      	ldr	r3, [pc, #24]	; (2000c8b4 <HAL_HSEM_DeactivateNotification+0x24>)
2000c89a:	681a      	ldr	r2, [r3, #0]
2000c89c:	687b      	ldr	r3, [r7, #4]
2000c89e:	43db      	mvns	r3, r3
2000c8a0:	4904      	ldr	r1, [pc, #16]	; (2000c8b4 <HAL_HSEM_DeactivateNotification+0x24>)
2000c8a2:	4013      	ands	r3, r2
2000c8a4:	600b      	str	r3, [r1, #0]
#endif
}
2000c8a6:	bf00      	nop
2000c8a8:	370c      	adds	r7, #12
2000c8aa:	46bd      	mov	sp, r7
2000c8ac:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c8b0:	4770      	bx	lr
2000c8b2:	bf00      	nop
2000c8b4:	58026500 	.word	0x58026500

2000c8b8 <HAL_HSEM_IRQHandler>:
/**
  * @brief  This function handles HSEM interrupt request
  * @retval None
  */
void HAL_HSEM_IRQHandler(void)
{
2000c8b8:	b580      	push	{r7, lr}
2000c8ba:	b082      	sub	sp, #8
2000c8bc:	af00      	add	r7, sp, #0
    /*Clear Flags*/
    HSEM->C2ICR = ((uint32_t)statusreg);
  }
#else
  /* Get the list of masked freed semaphores*/
  statusreg = HSEM_COMMON->MISR;
2000c8be:	4b0a      	ldr	r3, [pc, #40]	; (2000c8e8 <HAL_HSEM_IRQHandler+0x30>)
2000c8c0:	68db      	ldr	r3, [r3, #12]
2000c8c2:	607b      	str	r3, [r7, #4]

  /*Disable Interrupts*/
  HSEM_COMMON->IER &= ~((uint32_t)statusreg);
2000c8c4:	4b08      	ldr	r3, [pc, #32]	; (2000c8e8 <HAL_HSEM_IRQHandler+0x30>)
2000c8c6:	681a      	ldr	r2, [r3, #0]
2000c8c8:	687b      	ldr	r3, [r7, #4]
2000c8ca:	43db      	mvns	r3, r3
2000c8cc:	4906      	ldr	r1, [pc, #24]	; (2000c8e8 <HAL_HSEM_IRQHandler+0x30>)
2000c8ce:	4013      	ands	r3, r2
2000c8d0:	600b      	str	r3, [r1, #0]

  /*Clear Flags*/
  HSEM_COMMON->ICR = ((uint32_t)statusreg);
2000c8d2:	4a05      	ldr	r2, [pc, #20]	; (2000c8e8 <HAL_HSEM_IRQHandler+0x30>)
2000c8d4:	687b      	ldr	r3, [r7, #4]
2000c8d6:	6053      	str	r3, [r2, #4]

#endif
  /* Call FreeCallback */
  HAL_HSEM_FreeCallback(statusreg);
2000c8d8:	6878      	ldr	r0, [r7, #4]
2000c8da:	f000 f807 	bl	2000c8ec <HAL_HSEM_FreeCallback>
}
2000c8de:	bf00      	nop
2000c8e0:	3708      	adds	r7, #8
2000c8e2:	46bd      	mov	sp, r7
2000c8e4:	bd80      	pop	{r7, pc}
2000c8e6:	bf00      	nop
2000c8e8:	58026500 	.word	0x58026500

2000c8ec <HAL_HSEM_FreeCallback>:
  * @brief Semaphore Released Callback.
  * @param SemMask: Mask of Released semaphores
  * @retval None
  */
__weak void HAL_HSEM_FreeCallback(uint32_t SemMask)
{
2000c8ec:	b480      	push	{r7}
2000c8ee:	b083      	sub	sp, #12
2000c8f0:	af00      	add	r7, sp, #0
2000c8f2:	6078      	str	r0, [r7, #4]
  UNUSED(SemMask);

  /* NOTE : This function should not be modified, when the callback is needed,
  the HAL_HSEM_FreeCallback can be implemented in the user file
    */
}
2000c8f4:	bf00      	nop
2000c8f6:	370c      	adds	r7, #12
2000c8f8:	46bd      	mov	sp, r7
2000c8fa:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c8fe:	4770      	bx	lr

2000c900 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
2000c900:	b580      	push	{r7, lr}
2000c902:	b082      	sub	sp, #8
2000c904:	af00      	add	r7, sp, #0
2000c906:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
2000c908:	687b      	ldr	r3, [r7, #4]
2000c90a:	2b00      	cmp	r3, #0
2000c90c:	d101      	bne.n	2000c912 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
2000c90e:	2301      	movs	r3, #1
2000c910:	e107      	b.n	2000cb22 <HAL_I2C_Init+0x222>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
2000c912:	687b      	ldr	r3, [r7, #4]
2000c914:	681b      	ldr	r3, [r3, #0]
2000c916:	4a85      	ldr	r2, [pc, #532]	; (2000cb2c <HAL_I2C_Init+0x22c>)
2000c918:	4293      	cmp	r3, r2
2000c91a:	d013      	beq.n	2000c944 <HAL_I2C_Init+0x44>
2000c91c:	687b      	ldr	r3, [r7, #4]
2000c91e:	681b      	ldr	r3, [r3, #0]
2000c920:	4a83      	ldr	r2, [pc, #524]	; (2000cb30 <HAL_I2C_Init+0x230>)
2000c922:	4293      	cmp	r3, r2
2000c924:	d00e      	beq.n	2000c944 <HAL_I2C_Init+0x44>
2000c926:	687b      	ldr	r3, [r7, #4]
2000c928:	681b      	ldr	r3, [r3, #0]
2000c92a:	4a82      	ldr	r2, [pc, #520]	; (2000cb34 <HAL_I2C_Init+0x234>)
2000c92c:	4293      	cmp	r3, r2
2000c92e:	d009      	beq.n	2000c944 <HAL_I2C_Init+0x44>
2000c930:	687b      	ldr	r3, [r7, #4]
2000c932:	681b      	ldr	r3, [r3, #0]
2000c934:	4a80      	ldr	r2, [pc, #512]	; (2000cb38 <HAL_I2C_Init+0x238>)
2000c936:	4293      	cmp	r3, r2
2000c938:	d004      	beq.n	2000c944 <HAL_I2C_Init+0x44>
2000c93a:	f240 11e1 	movw	r1, #481	; 0x1e1
2000c93e:	487f      	ldr	r0, [pc, #508]	; (2000cb3c <HAL_I2C_Init+0x23c>)
2000c940:	f7f3 ffd8 	bl	200008f4 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
2000c944:	687b      	ldr	r3, [r7, #4]
2000c946:	689b      	ldr	r3, [r3, #8]
2000c948:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2000c94c:	d304      	bcc.n	2000c958 <HAL_I2C_Init+0x58>
2000c94e:	f44f 71f1 	mov.w	r1, #482	; 0x1e2
2000c952:	487a      	ldr	r0, [pc, #488]	; (2000cb3c <HAL_I2C_Init+0x23c>)
2000c954:	f7f3 ffce 	bl	200008f4 <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
2000c958:	687b      	ldr	r3, [r7, #4]
2000c95a:	68db      	ldr	r3, [r3, #12]
2000c95c:	2b01      	cmp	r3, #1
2000c95e:	d008      	beq.n	2000c972 <HAL_I2C_Init+0x72>
2000c960:	687b      	ldr	r3, [r7, #4]
2000c962:	68db      	ldr	r3, [r3, #12]
2000c964:	2b02      	cmp	r3, #2
2000c966:	d004      	beq.n	2000c972 <HAL_I2C_Init+0x72>
2000c968:	f240 11e3 	movw	r1, #483	; 0x1e3
2000c96c:	4873      	ldr	r0, [pc, #460]	; (2000cb3c <HAL_I2C_Init+0x23c>)
2000c96e:	f7f3 ffc1 	bl	200008f4 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
2000c972:	687b      	ldr	r3, [r7, #4]
2000c974:	691b      	ldr	r3, [r3, #16]
2000c976:	2b00      	cmp	r3, #0
2000c978:	d009      	beq.n	2000c98e <HAL_I2C_Init+0x8e>
2000c97a:	687b      	ldr	r3, [r7, #4]
2000c97c:	691b      	ldr	r3, [r3, #16]
2000c97e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000c982:	d004      	beq.n	2000c98e <HAL_I2C_Init+0x8e>
2000c984:	f44f 71f2 	mov.w	r1, #484	; 0x1e4
2000c988:	486c      	ldr	r0, [pc, #432]	; (2000cb3c <HAL_I2C_Init+0x23c>)
2000c98a:	f7f3 ffb3 	bl	200008f4 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
2000c98e:	687b      	ldr	r3, [r7, #4]
2000c990:	695b      	ldr	r3, [r3, #20]
2000c992:	2bff      	cmp	r3, #255	; 0xff
2000c994:	d904      	bls.n	2000c9a0 <HAL_I2C_Init+0xa0>
2000c996:	f240 11e5 	movw	r1, #485	; 0x1e5
2000c99a:	4868      	ldr	r0, [pc, #416]	; (2000cb3c <HAL_I2C_Init+0x23c>)
2000c99c:	f7f3 ffaa 	bl	200008f4 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
2000c9a0:	687b      	ldr	r3, [r7, #4]
2000c9a2:	699b      	ldr	r3, [r3, #24]
2000c9a4:	2b00      	cmp	r3, #0
2000c9a6:	d020      	beq.n	2000c9ea <HAL_I2C_Init+0xea>
2000c9a8:	687b      	ldr	r3, [r7, #4]
2000c9aa:	699b      	ldr	r3, [r3, #24]
2000c9ac:	2b01      	cmp	r3, #1
2000c9ae:	d01c      	beq.n	2000c9ea <HAL_I2C_Init+0xea>
2000c9b0:	687b      	ldr	r3, [r7, #4]
2000c9b2:	699b      	ldr	r3, [r3, #24]
2000c9b4:	2b02      	cmp	r3, #2
2000c9b6:	d018      	beq.n	2000c9ea <HAL_I2C_Init+0xea>
2000c9b8:	687b      	ldr	r3, [r7, #4]
2000c9ba:	699b      	ldr	r3, [r3, #24]
2000c9bc:	2b03      	cmp	r3, #3
2000c9be:	d014      	beq.n	2000c9ea <HAL_I2C_Init+0xea>
2000c9c0:	687b      	ldr	r3, [r7, #4]
2000c9c2:	699b      	ldr	r3, [r3, #24]
2000c9c4:	2b04      	cmp	r3, #4
2000c9c6:	d010      	beq.n	2000c9ea <HAL_I2C_Init+0xea>
2000c9c8:	687b      	ldr	r3, [r7, #4]
2000c9ca:	699b      	ldr	r3, [r3, #24]
2000c9cc:	2b05      	cmp	r3, #5
2000c9ce:	d00c      	beq.n	2000c9ea <HAL_I2C_Init+0xea>
2000c9d0:	687b      	ldr	r3, [r7, #4]
2000c9d2:	699b      	ldr	r3, [r3, #24]
2000c9d4:	2b06      	cmp	r3, #6
2000c9d6:	d008      	beq.n	2000c9ea <HAL_I2C_Init+0xea>
2000c9d8:	687b      	ldr	r3, [r7, #4]
2000c9da:	699b      	ldr	r3, [r3, #24]
2000c9dc:	2b07      	cmp	r3, #7
2000c9de:	d004      	beq.n	2000c9ea <HAL_I2C_Init+0xea>
2000c9e0:	f44f 71f3 	mov.w	r1, #486	; 0x1e6
2000c9e4:	4855      	ldr	r0, [pc, #340]	; (2000cb3c <HAL_I2C_Init+0x23c>)
2000c9e6:	f7f3 ff85 	bl	200008f4 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
2000c9ea:	687b      	ldr	r3, [r7, #4]
2000c9ec:	69db      	ldr	r3, [r3, #28]
2000c9ee:	2b00      	cmp	r3, #0
2000c9f0:	d009      	beq.n	2000ca06 <HAL_I2C_Init+0x106>
2000c9f2:	687b      	ldr	r3, [r7, #4]
2000c9f4:	69db      	ldr	r3, [r3, #28]
2000c9f6:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
2000c9fa:	d004      	beq.n	2000ca06 <HAL_I2C_Init+0x106>
2000c9fc:	f240 11e7 	movw	r1, #487	; 0x1e7
2000ca00:	484e      	ldr	r0, [pc, #312]	; (2000cb3c <HAL_I2C_Init+0x23c>)
2000ca02:	f7f3 ff77 	bl	200008f4 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
2000ca06:	687b      	ldr	r3, [r7, #4]
2000ca08:	6a1b      	ldr	r3, [r3, #32]
2000ca0a:	2b00      	cmp	r3, #0
2000ca0c:	d009      	beq.n	2000ca22 <HAL_I2C_Init+0x122>
2000ca0e:	687b      	ldr	r3, [r7, #4]
2000ca10:	6a1b      	ldr	r3, [r3, #32]
2000ca12:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2000ca16:	d004      	beq.n	2000ca22 <HAL_I2C_Init+0x122>
2000ca18:	f44f 71f4 	mov.w	r1, #488	; 0x1e8
2000ca1c:	4847      	ldr	r0, [pc, #284]	; (2000cb3c <HAL_I2C_Init+0x23c>)
2000ca1e:	f7f3 ff69 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_RESET)
2000ca22:	687b      	ldr	r3, [r7, #4]
2000ca24:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000ca28:	b2db      	uxtb	r3, r3
2000ca2a:	2b00      	cmp	r3, #0
2000ca2c:	d106      	bne.n	2000ca3c <HAL_I2C_Init+0x13c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
2000ca2e:	687b      	ldr	r3, [r7, #4]
2000ca30:	2200      	movs	r2, #0
2000ca32:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
2000ca36:	6878      	ldr	r0, [r7, #4]
2000ca38:	f000 f8d6 	bl	2000cbe8 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
2000ca3c:	687b      	ldr	r3, [r7, #4]
2000ca3e:	2224      	movs	r2, #36	; 0x24
2000ca40:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
2000ca44:	687b      	ldr	r3, [r7, #4]
2000ca46:	681b      	ldr	r3, [r3, #0]
2000ca48:	681a      	ldr	r2, [r3, #0]
2000ca4a:	687b      	ldr	r3, [r7, #4]
2000ca4c:	681b      	ldr	r3, [r3, #0]
2000ca4e:	f022 0201 	bic.w	r2, r2, #1
2000ca52:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
2000ca54:	687b      	ldr	r3, [r7, #4]
2000ca56:	685a      	ldr	r2, [r3, #4]
2000ca58:	687b      	ldr	r3, [r7, #4]
2000ca5a:	681b      	ldr	r3, [r3, #0]
2000ca5c:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
2000ca60:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
2000ca62:	687b      	ldr	r3, [r7, #4]
2000ca64:	681b      	ldr	r3, [r3, #0]
2000ca66:	689a      	ldr	r2, [r3, #8]
2000ca68:	687b      	ldr	r3, [r7, #4]
2000ca6a:	681b      	ldr	r3, [r3, #0]
2000ca6c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000ca70:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
2000ca72:	687b      	ldr	r3, [r7, #4]
2000ca74:	68db      	ldr	r3, [r3, #12]
2000ca76:	2b01      	cmp	r3, #1
2000ca78:	d107      	bne.n	2000ca8a <HAL_I2C_Init+0x18a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
2000ca7a:	687b      	ldr	r3, [r7, #4]
2000ca7c:	689a      	ldr	r2, [r3, #8]
2000ca7e:	687b      	ldr	r3, [r7, #4]
2000ca80:	681b      	ldr	r3, [r3, #0]
2000ca82:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000ca86:	609a      	str	r2, [r3, #8]
2000ca88:	e006      	b.n	2000ca98 <HAL_I2C_Init+0x198>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
2000ca8a:	687b      	ldr	r3, [r7, #4]
2000ca8c:	689a      	ldr	r2, [r3, #8]
2000ca8e:	687b      	ldr	r3, [r7, #4]
2000ca90:	681b      	ldr	r3, [r3, #0]
2000ca92:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
2000ca96:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2000ca98:	687b      	ldr	r3, [r7, #4]
2000ca9a:	68db      	ldr	r3, [r3, #12]
2000ca9c:	2b02      	cmp	r3, #2
2000ca9e:	d104      	bne.n	2000caaa <HAL_I2C_Init+0x1aa>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
2000caa0:	687b      	ldr	r3, [r7, #4]
2000caa2:	681b      	ldr	r3, [r3, #0]
2000caa4:	f44f 6200 	mov.w	r2, #2048	; 0x800
2000caa8:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
2000caaa:	687b      	ldr	r3, [r7, #4]
2000caac:	681b      	ldr	r3, [r3, #0]
2000caae:	6859      	ldr	r1, [r3, #4]
2000cab0:	687b      	ldr	r3, [r7, #4]
2000cab2:	681a      	ldr	r2, [r3, #0]
2000cab4:	4b22      	ldr	r3, [pc, #136]	; (2000cb40 <HAL_I2C_Init+0x240>)
2000cab6:	430b      	orrs	r3, r1
2000cab8:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
2000caba:	687b      	ldr	r3, [r7, #4]
2000cabc:	681b      	ldr	r3, [r3, #0]
2000cabe:	68da      	ldr	r2, [r3, #12]
2000cac0:	687b      	ldr	r3, [r7, #4]
2000cac2:	681b      	ldr	r3, [r3, #0]
2000cac4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000cac8:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
2000caca:	687b      	ldr	r3, [r7, #4]
2000cacc:	691a      	ldr	r2, [r3, #16]
2000cace:	687b      	ldr	r3, [r7, #4]
2000cad0:	695b      	ldr	r3, [r3, #20]
2000cad2:	ea42 0103 	orr.w	r1, r2, r3
2000cad6:	687b      	ldr	r3, [r7, #4]
2000cad8:	699b      	ldr	r3, [r3, #24]
2000cada:	021a      	lsls	r2, r3, #8
2000cadc:	687b      	ldr	r3, [r7, #4]
2000cade:	681b      	ldr	r3, [r3, #0]
2000cae0:	430a      	orrs	r2, r1
2000cae2:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
2000cae4:	687b      	ldr	r3, [r7, #4]
2000cae6:	69d9      	ldr	r1, [r3, #28]
2000cae8:	687b      	ldr	r3, [r7, #4]
2000caea:	6a1a      	ldr	r2, [r3, #32]
2000caec:	687b      	ldr	r3, [r7, #4]
2000caee:	681b      	ldr	r3, [r3, #0]
2000caf0:	430a      	orrs	r2, r1
2000caf2:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
2000caf4:	687b      	ldr	r3, [r7, #4]
2000caf6:	681b      	ldr	r3, [r3, #0]
2000caf8:	681a      	ldr	r2, [r3, #0]
2000cafa:	687b      	ldr	r3, [r7, #4]
2000cafc:	681b      	ldr	r3, [r3, #0]
2000cafe:	f042 0201 	orr.w	r2, r2, #1
2000cb02:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000cb04:	687b      	ldr	r3, [r7, #4]
2000cb06:	2200      	movs	r2, #0
2000cb08:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
2000cb0a:	687b      	ldr	r3, [r7, #4]
2000cb0c:	2220      	movs	r2, #32
2000cb0e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
2000cb12:	687b      	ldr	r3, [r7, #4]
2000cb14:	2200      	movs	r2, #0
2000cb16:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
2000cb18:	687b      	ldr	r3, [r7, #4]
2000cb1a:	2200      	movs	r2, #0
2000cb1c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
2000cb20:	2300      	movs	r3, #0
}
2000cb22:	4618      	mov	r0, r3
2000cb24:	3708      	adds	r7, #8
2000cb26:	46bd      	mov	sp, r7
2000cb28:	bd80      	pop	{r7, pc}
2000cb2a:	bf00      	nop
2000cb2c:	40005400 	.word	0x40005400
2000cb30:	40005800 	.word	0x40005800
2000cb34:	40005c00 	.word	0x40005c00
2000cb38:	58001c00 	.word	0x58001c00
2000cb3c:	2001c180 	.word	0x2001c180
2000cb40:	02008000 	.word	0x02008000

2000cb44 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
2000cb44:	b580      	push	{r7, lr}
2000cb46:	b082      	sub	sp, #8
2000cb48:	af00      	add	r7, sp, #0
2000cb4a:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
2000cb4c:	687b      	ldr	r3, [r7, #4]
2000cb4e:	2b00      	cmp	r3, #0
2000cb50:	d101      	bne.n	2000cb56 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
2000cb52:	2301      	movs	r3, #1
2000cb54:	e03a      	b.n	2000cbcc <HAL_I2C_DeInit+0x88>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
2000cb56:	687b      	ldr	r3, [r7, #4]
2000cb58:	681b      	ldr	r3, [r3, #0]
2000cb5a:	4a1e      	ldr	r2, [pc, #120]	; (2000cbd4 <HAL_I2C_DeInit+0x90>)
2000cb5c:	4293      	cmp	r3, r2
2000cb5e:	d013      	beq.n	2000cb88 <HAL_I2C_DeInit+0x44>
2000cb60:	687b      	ldr	r3, [r7, #4]
2000cb62:	681b      	ldr	r3, [r3, #0]
2000cb64:	4a1c      	ldr	r2, [pc, #112]	; (2000cbd8 <HAL_I2C_DeInit+0x94>)
2000cb66:	4293      	cmp	r3, r2
2000cb68:	d00e      	beq.n	2000cb88 <HAL_I2C_DeInit+0x44>
2000cb6a:	687b      	ldr	r3, [r7, #4]
2000cb6c:	681b      	ldr	r3, [r3, #0]
2000cb6e:	4a1b      	ldr	r2, [pc, #108]	; (2000cbdc <HAL_I2C_DeInit+0x98>)
2000cb70:	4293      	cmp	r3, r2
2000cb72:	d009      	beq.n	2000cb88 <HAL_I2C_DeInit+0x44>
2000cb74:	687b      	ldr	r3, [r7, #4]
2000cb76:	681b      	ldr	r3, [r3, #0]
2000cb78:	4a19      	ldr	r2, [pc, #100]	; (2000cbe0 <HAL_I2C_DeInit+0x9c>)
2000cb7a:	4293      	cmp	r3, r2
2000cb7c:	d004      	beq.n	2000cb88 <HAL_I2C_DeInit+0x44>
2000cb7e:	f240 214e 	movw	r1, #590	; 0x24e
2000cb82:	4818      	ldr	r0, [pc, #96]	; (2000cbe4 <HAL_I2C_DeInit+0xa0>)
2000cb84:	f7f3 feb6 	bl	200008f4 <assert_failed>

  hi2c->State = HAL_I2C_STATE_BUSY;
2000cb88:	687b      	ldr	r3, [r7, #4]
2000cb8a:	2224      	movs	r2, #36	; 0x24
2000cb8c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
2000cb90:	687b      	ldr	r3, [r7, #4]
2000cb92:	681b      	ldr	r3, [r3, #0]
2000cb94:	681a      	ldr	r2, [r3, #0]
2000cb96:	687b      	ldr	r3, [r7, #4]
2000cb98:	681b      	ldr	r3, [r3, #0]
2000cb9a:	f022 0201 	bic.w	r2, r2, #1
2000cb9e:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
2000cba0:	6878      	ldr	r0, [r7, #4]
2000cba2:	f000 f82b 	bl	2000cbfc <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000cba6:	687b      	ldr	r3, [r7, #4]
2000cba8:	2200      	movs	r2, #0
2000cbaa:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
2000cbac:	687b      	ldr	r3, [r7, #4]
2000cbae:	2200      	movs	r2, #0
2000cbb0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
2000cbb4:	687b      	ldr	r3, [r7, #4]
2000cbb6:	2200      	movs	r2, #0
2000cbb8:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
2000cbba:	687b      	ldr	r3, [r7, #4]
2000cbbc:	2200      	movs	r2, #0
2000cbbe:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
2000cbc2:	687b      	ldr	r3, [r7, #4]
2000cbc4:	2200      	movs	r2, #0
2000cbc6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2000cbca:	2300      	movs	r3, #0
}
2000cbcc:	4618      	mov	r0, r3
2000cbce:	3708      	adds	r7, #8
2000cbd0:	46bd      	mov	sp, r7
2000cbd2:	bd80      	pop	{r7, pc}
2000cbd4:	40005400 	.word	0x40005400
2000cbd8:	40005800 	.word	0x40005800
2000cbdc:	40005c00 	.word	0x40005c00
2000cbe0:	58001c00 	.word	0x58001c00
2000cbe4:	2001c180 	.word	0x2001c180

2000cbe8 <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
2000cbe8:	b480      	push	{r7}
2000cbea:	b083      	sub	sp, #12
2000cbec:	af00      	add	r7, sp, #0
2000cbee:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
2000cbf0:	bf00      	nop
2000cbf2:	370c      	adds	r7, #12
2000cbf4:	46bd      	mov	sp, r7
2000cbf6:	f85d 7b04 	ldr.w	r7, [sp], #4
2000cbfa:	4770      	bx	lr

2000cbfc <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
2000cbfc:	b480      	push	{r7}
2000cbfe:	b083      	sub	sp, #12
2000cc00:	af00      	add	r7, sp, #0
2000cc02:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
2000cc04:	bf00      	nop
2000cc06:	370c      	adds	r7, #12
2000cc08:	46bd      	mov	sp, r7
2000cc0a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000cc0e:	4770      	bx	lr

2000cc10 <HAL_I2C_Master_Transmit>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2000cc10:	b580      	push	{r7, lr}
2000cc12:	b088      	sub	sp, #32
2000cc14:	af02      	add	r7, sp, #8
2000cc16:	60f8      	str	r0, [r7, #12]
2000cc18:	607a      	str	r2, [r7, #4]
2000cc1a:	461a      	mov	r2, r3
2000cc1c:	460b      	mov	r3, r1
2000cc1e:	817b      	strh	r3, [r7, #10]
2000cc20:	4613      	mov	r3, r2
2000cc22:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000cc24:	68fb      	ldr	r3, [r7, #12]
2000cc26:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000cc2a:	b2db      	uxtb	r3, r3
2000cc2c:	2b20      	cmp	r3, #32
2000cc2e:	f040 80da 	bne.w	2000cde6 <HAL_I2C_Master_Transmit+0x1d6>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000cc32:	68fb      	ldr	r3, [r7, #12]
2000cc34:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000cc38:	2b01      	cmp	r3, #1
2000cc3a:	d101      	bne.n	2000cc40 <HAL_I2C_Master_Transmit+0x30>
2000cc3c:	2302      	movs	r3, #2
2000cc3e:	e0d3      	b.n	2000cde8 <HAL_I2C_Master_Transmit+0x1d8>
2000cc40:	68fb      	ldr	r3, [r7, #12]
2000cc42:	2201      	movs	r2, #1
2000cc44:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000cc48:	f7f5 f850 	bl	20001cec <HAL_GetTick>
2000cc4c:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2000cc4e:	697b      	ldr	r3, [r7, #20]
2000cc50:	9300      	str	r3, [sp, #0]
2000cc52:	2319      	movs	r3, #25
2000cc54:	2201      	movs	r2, #1
2000cc56:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000cc5a:	68f8      	ldr	r0, [r7, #12]
2000cc5c:	f004 fe80 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000cc60:	4603      	mov	r3, r0
2000cc62:	2b00      	cmp	r3, #0
2000cc64:	d001      	beq.n	2000cc6a <HAL_I2C_Master_Transmit+0x5a>
    {
      return HAL_ERROR;
2000cc66:	2301      	movs	r3, #1
2000cc68:	e0be      	b.n	2000cde8 <HAL_I2C_Master_Transmit+0x1d8>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2000cc6a:	68fb      	ldr	r3, [r7, #12]
2000cc6c:	2221      	movs	r2, #33	; 0x21
2000cc6e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2000cc72:	68fb      	ldr	r3, [r7, #12]
2000cc74:	2210      	movs	r2, #16
2000cc76:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000cc7a:	68fb      	ldr	r3, [r7, #12]
2000cc7c:	2200      	movs	r2, #0
2000cc7e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2000cc80:	68fb      	ldr	r3, [r7, #12]
2000cc82:	687a      	ldr	r2, [r7, #4]
2000cc84:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2000cc86:	68fb      	ldr	r3, [r7, #12]
2000cc88:	893a      	ldrh	r2, [r7, #8]
2000cc8a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2000cc8c:	68fb      	ldr	r3, [r7, #12]
2000cc8e:	2200      	movs	r2, #0
2000cc90:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000cc92:	68fb      	ldr	r3, [r7, #12]
2000cc94:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cc96:	b29b      	uxth	r3, r3
2000cc98:	2bff      	cmp	r3, #255	; 0xff
2000cc9a:	d90e      	bls.n	2000ccba <HAL_I2C_Master_Transmit+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000cc9c:	68fb      	ldr	r3, [r7, #12]
2000cc9e:	22ff      	movs	r2, #255	; 0xff
2000cca0:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
2000cca2:	68fb      	ldr	r3, [r7, #12]
2000cca4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000cca6:	b2da      	uxtb	r2, r3
2000cca8:	8979      	ldrh	r1, [r7, #10]
2000ccaa:	4b51      	ldr	r3, [pc, #324]	; (2000cdf0 <HAL_I2C_Master_Transmit+0x1e0>)
2000ccac:	9300      	str	r3, [sp, #0]
2000ccae:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000ccb2:	68f8      	ldr	r0, [r7, #12]
2000ccb4:	f004 ffe2 	bl	20011c7c <I2C_TransferConfig>
2000ccb8:	e06c      	b.n	2000cd94 <HAL_I2C_Master_Transmit+0x184>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000ccba:	68fb      	ldr	r3, [r7, #12]
2000ccbc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ccbe:	b29a      	uxth	r2, r3
2000ccc0:	68fb      	ldr	r3, [r7, #12]
2000ccc2:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
2000ccc4:	68fb      	ldr	r3, [r7, #12]
2000ccc6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ccc8:	b2da      	uxtb	r2, r3
2000ccca:	8979      	ldrh	r1, [r7, #10]
2000cccc:	4b48      	ldr	r3, [pc, #288]	; (2000cdf0 <HAL_I2C_Master_Transmit+0x1e0>)
2000ccce:	9300      	str	r3, [sp, #0]
2000ccd0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000ccd4:	68f8      	ldr	r0, [r7, #12]
2000ccd6:	f004 ffd1 	bl	20011c7c <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
2000ccda:	e05b      	b.n	2000cd94 <HAL_I2C_Master_Transmit+0x184>
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000ccdc:	697a      	ldr	r2, [r7, #20]
2000ccde:	6a39      	ldr	r1, [r7, #32]
2000cce0:	68f8      	ldr	r0, [r7, #12]
2000cce2:	f004 fe7d 	bl	200119e0 <I2C_WaitOnTXISFlagUntilTimeout>
2000cce6:	4603      	mov	r3, r0
2000cce8:	2b00      	cmp	r3, #0
2000ccea:	d001      	beq.n	2000ccf0 <HAL_I2C_Master_Transmit+0xe0>
      {
        return HAL_ERROR;
2000ccec:	2301      	movs	r3, #1
2000ccee:	e07b      	b.n	2000cde8 <HAL_I2C_Master_Transmit+0x1d8>
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2000ccf0:	68fb      	ldr	r3, [r7, #12]
2000ccf2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000ccf4:	781a      	ldrb	r2, [r3, #0]
2000ccf6:	68fb      	ldr	r3, [r7, #12]
2000ccf8:	681b      	ldr	r3, [r3, #0]
2000ccfa:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2000ccfc:	68fb      	ldr	r3, [r7, #12]
2000ccfe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000cd00:	1c5a      	adds	r2, r3, #1
2000cd02:	68fb      	ldr	r3, [r7, #12]
2000cd04:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2000cd06:	68fb      	ldr	r3, [r7, #12]
2000cd08:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cd0a:	b29b      	uxth	r3, r3
2000cd0c:	3b01      	subs	r3, #1
2000cd0e:	b29a      	uxth	r2, r3
2000cd10:	68fb      	ldr	r3, [r7, #12]
2000cd12:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2000cd14:	68fb      	ldr	r3, [r7, #12]
2000cd16:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000cd18:	3b01      	subs	r3, #1
2000cd1a:	b29a      	uxth	r2, r3
2000cd1c:	68fb      	ldr	r3, [r7, #12]
2000cd1e:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2000cd20:	68fb      	ldr	r3, [r7, #12]
2000cd22:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cd24:	b29b      	uxth	r3, r3
2000cd26:	2b00      	cmp	r3, #0
2000cd28:	d034      	beq.n	2000cd94 <HAL_I2C_Master_Transmit+0x184>
2000cd2a:	68fb      	ldr	r3, [r7, #12]
2000cd2c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000cd2e:	2b00      	cmp	r3, #0
2000cd30:	d130      	bne.n	2000cd94 <HAL_I2C_Master_Transmit+0x184>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2000cd32:	697b      	ldr	r3, [r7, #20]
2000cd34:	9300      	str	r3, [sp, #0]
2000cd36:	6a3b      	ldr	r3, [r7, #32]
2000cd38:	2200      	movs	r2, #0
2000cd3a:	2180      	movs	r1, #128	; 0x80
2000cd3c:	68f8      	ldr	r0, [r7, #12]
2000cd3e:	f004 fe0f 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000cd42:	4603      	mov	r3, r0
2000cd44:	2b00      	cmp	r3, #0
2000cd46:	d001      	beq.n	2000cd4c <HAL_I2C_Master_Transmit+0x13c>
        {
          return HAL_ERROR;
2000cd48:	2301      	movs	r3, #1
2000cd4a:	e04d      	b.n	2000cde8 <HAL_I2C_Master_Transmit+0x1d8>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000cd4c:	68fb      	ldr	r3, [r7, #12]
2000cd4e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cd50:	b29b      	uxth	r3, r3
2000cd52:	2bff      	cmp	r3, #255	; 0xff
2000cd54:	d90e      	bls.n	2000cd74 <HAL_I2C_Master_Transmit+0x164>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2000cd56:	68fb      	ldr	r3, [r7, #12]
2000cd58:	22ff      	movs	r2, #255	; 0xff
2000cd5a:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2000cd5c:	68fb      	ldr	r3, [r7, #12]
2000cd5e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000cd60:	b2da      	uxtb	r2, r3
2000cd62:	8979      	ldrh	r1, [r7, #10]
2000cd64:	2300      	movs	r3, #0
2000cd66:	9300      	str	r3, [sp, #0]
2000cd68:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000cd6c:	68f8      	ldr	r0, [r7, #12]
2000cd6e:	f004 ff85 	bl	20011c7c <I2C_TransferConfig>
2000cd72:	e00f      	b.n	2000cd94 <HAL_I2C_Master_Transmit+0x184>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2000cd74:	68fb      	ldr	r3, [r7, #12]
2000cd76:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cd78:	b29a      	uxth	r2, r3
2000cd7a:	68fb      	ldr	r3, [r7, #12]
2000cd7c:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2000cd7e:	68fb      	ldr	r3, [r7, #12]
2000cd80:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000cd82:	b2da      	uxtb	r2, r3
2000cd84:	8979      	ldrh	r1, [r7, #10]
2000cd86:	2300      	movs	r3, #0
2000cd88:	9300      	str	r3, [sp, #0]
2000cd8a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000cd8e:	68f8      	ldr	r0, [r7, #12]
2000cd90:	f004 ff74 	bl	20011c7c <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
2000cd94:	68fb      	ldr	r3, [r7, #12]
2000cd96:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cd98:	b29b      	uxth	r3, r3
2000cd9a:	2b00      	cmp	r3, #0
2000cd9c:	d19e      	bne.n	2000ccdc <HAL_I2C_Master_Transmit+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000cd9e:	697a      	ldr	r2, [r7, #20]
2000cda0:	6a39      	ldr	r1, [r7, #32]
2000cda2:	68f8      	ldr	r0, [r7, #12]
2000cda4:	f004 fe5c 	bl	20011a60 <I2C_WaitOnSTOPFlagUntilTimeout>
2000cda8:	4603      	mov	r3, r0
2000cdaa:	2b00      	cmp	r3, #0
2000cdac:	d001      	beq.n	2000cdb2 <HAL_I2C_Master_Transmit+0x1a2>
    {
      return HAL_ERROR;
2000cdae:	2301      	movs	r3, #1
2000cdb0:	e01a      	b.n	2000cde8 <HAL_I2C_Master_Transmit+0x1d8>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000cdb2:	68fb      	ldr	r3, [r7, #12]
2000cdb4:	681b      	ldr	r3, [r3, #0]
2000cdb6:	2220      	movs	r2, #32
2000cdb8:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2000cdba:	68fb      	ldr	r3, [r7, #12]
2000cdbc:	681b      	ldr	r3, [r3, #0]
2000cdbe:	6859      	ldr	r1, [r3, #4]
2000cdc0:	68fb      	ldr	r3, [r7, #12]
2000cdc2:	681a      	ldr	r2, [r3, #0]
2000cdc4:	4b0b      	ldr	r3, [pc, #44]	; (2000cdf4 <HAL_I2C_Master_Transmit+0x1e4>)
2000cdc6:	400b      	ands	r3, r1
2000cdc8:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2000cdca:	68fb      	ldr	r3, [r7, #12]
2000cdcc:	2220      	movs	r2, #32
2000cdce:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2000cdd2:	68fb      	ldr	r3, [r7, #12]
2000cdd4:	2200      	movs	r2, #0
2000cdd6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000cdda:	68fb      	ldr	r3, [r7, #12]
2000cddc:	2200      	movs	r2, #0
2000cdde:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2000cde2:	2300      	movs	r3, #0
2000cde4:	e000      	b.n	2000cde8 <HAL_I2C_Master_Transmit+0x1d8>
  }
  else
  {
    return HAL_BUSY;
2000cde6:	2302      	movs	r3, #2
  }
}
2000cde8:	4618      	mov	r0, r3
2000cdea:	3718      	adds	r7, #24
2000cdec:	46bd      	mov	sp, r7
2000cdee:	bd80      	pop	{r7, pc}
2000cdf0:	80002000 	.word	0x80002000
2000cdf4:	fe00e800 	.word	0xfe00e800

2000cdf8 <HAL_I2C_Master_Receive>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2000cdf8:	b580      	push	{r7, lr}
2000cdfa:	b088      	sub	sp, #32
2000cdfc:	af02      	add	r7, sp, #8
2000cdfe:	60f8      	str	r0, [r7, #12]
2000ce00:	607a      	str	r2, [r7, #4]
2000ce02:	461a      	mov	r2, r3
2000ce04:	460b      	mov	r3, r1
2000ce06:	817b      	strh	r3, [r7, #10]
2000ce08:	4613      	mov	r3, r2
2000ce0a:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000ce0c:	68fb      	ldr	r3, [r7, #12]
2000ce0e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000ce12:	b2db      	uxtb	r3, r3
2000ce14:	2b20      	cmp	r3, #32
2000ce16:	f040 80db 	bne.w	2000cfd0 <HAL_I2C_Master_Receive+0x1d8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000ce1a:	68fb      	ldr	r3, [r7, #12]
2000ce1c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000ce20:	2b01      	cmp	r3, #1
2000ce22:	d101      	bne.n	2000ce28 <HAL_I2C_Master_Receive+0x30>
2000ce24:	2302      	movs	r3, #2
2000ce26:	e0d4      	b.n	2000cfd2 <HAL_I2C_Master_Receive+0x1da>
2000ce28:	68fb      	ldr	r3, [r7, #12]
2000ce2a:	2201      	movs	r2, #1
2000ce2c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000ce30:	f7f4 ff5c 	bl	20001cec <HAL_GetTick>
2000ce34:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2000ce36:	697b      	ldr	r3, [r7, #20]
2000ce38:	9300      	str	r3, [sp, #0]
2000ce3a:	2319      	movs	r3, #25
2000ce3c:	2201      	movs	r2, #1
2000ce3e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000ce42:	68f8      	ldr	r0, [r7, #12]
2000ce44:	f004 fd8c 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000ce48:	4603      	mov	r3, r0
2000ce4a:	2b00      	cmp	r3, #0
2000ce4c:	d001      	beq.n	2000ce52 <HAL_I2C_Master_Receive+0x5a>
    {
      return HAL_ERROR;
2000ce4e:	2301      	movs	r3, #1
2000ce50:	e0bf      	b.n	2000cfd2 <HAL_I2C_Master_Receive+0x1da>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2000ce52:	68fb      	ldr	r3, [r7, #12]
2000ce54:	2222      	movs	r2, #34	; 0x22
2000ce56:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2000ce5a:	68fb      	ldr	r3, [r7, #12]
2000ce5c:	2210      	movs	r2, #16
2000ce5e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000ce62:	68fb      	ldr	r3, [r7, #12]
2000ce64:	2200      	movs	r2, #0
2000ce66:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2000ce68:	68fb      	ldr	r3, [r7, #12]
2000ce6a:	687a      	ldr	r2, [r7, #4]
2000ce6c:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2000ce6e:	68fb      	ldr	r3, [r7, #12]
2000ce70:	893a      	ldrh	r2, [r7, #8]
2000ce72:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2000ce74:	68fb      	ldr	r3, [r7, #12]
2000ce76:	2200      	movs	r2, #0
2000ce78:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000ce7a:	68fb      	ldr	r3, [r7, #12]
2000ce7c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ce7e:	b29b      	uxth	r3, r3
2000ce80:	2bff      	cmp	r3, #255	; 0xff
2000ce82:	d90e      	bls.n	2000cea2 <HAL_I2C_Master_Receive+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000ce84:	68fb      	ldr	r3, [r7, #12]
2000ce86:	22ff      	movs	r2, #255	; 0xff
2000ce88:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
2000ce8a:	68fb      	ldr	r3, [r7, #12]
2000ce8c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ce8e:	b2da      	uxtb	r2, r3
2000ce90:	8979      	ldrh	r1, [r7, #10]
2000ce92:	4b52      	ldr	r3, [pc, #328]	; (2000cfdc <HAL_I2C_Master_Receive+0x1e4>)
2000ce94:	9300      	str	r3, [sp, #0]
2000ce96:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000ce9a:	68f8      	ldr	r0, [r7, #12]
2000ce9c:	f004 feee 	bl	20011c7c <I2C_TransferConfig>
2000cea0:	e06d      	b.n	2000cf7e <HAL_I2C_Master_Receive+0x186>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000cea2:	68fb      	ldr	r3, [r7, #12]
2000cea4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cea6:	b29a      	uxth	r2, r3
2000cea8:	68fb      	ldr	r3, [r7, #12]
2000ceaa:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2000ceac:	68fb      	ldr	r3, [r7, #12]
2000ceae:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ceb0:	b2da      	uxtb	r2, r3
2000ceb2:	8979      	ldrh	r1, [r7, #10]
2000ceb4:	4b49      	ldr	r3, [pc, #292]	; (2000cfdc <HAL_I2C_Master_Receive+0x1e4>)
2000ceb6:	9300      	str	r3, [sp, #0]
2000ceb8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000cebc:	68f8      	ldr	r0, [r7, #12]
2000cebe:	f004 fedd 	bl	20011c7c <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
2000cec2:	e05c      	b.n	2000cf7e <HAL_I2C_Master_Receive+0x186>
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000cec4:	697a      	ldr	r2, [r7, #20]
2000cec6:	6a39      	ldr	r1, [r7, #32]
2000cec8:	68f8      	ldr	r0, [r7, #12]
2000ceca:	f004 fe05 	bl	20011ad8 <I2C_WaitOnRXNEFlagUntilTimeout>
2000cece:	4603      	mov	r3, r0
2000ced0:	2b00      	cmp	r3, #0
2000ced2:	d001      	beq.n	2000ced8 <HAL_I2C_Master_Receive+0xe0>
      {
        return HAL_ERROR;
2000ced4:	2301      	movs	r3, #1
2000ced6:	e07c      	b.n	2000cfd2 <HAL_I2C_Master_Receive+0x1da>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2000ced8:	68fb      	ldr	r3, [r7, #12]
2000ceda:	681b      	ldr	r3, [r3, #0]
2000cedc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2000cede:	68fb      	ldr	r3, [r7, #12]
2000cee0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000cee2:	b2d2      	uxtb	r2, r2
2000cee4:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2000cee6:	68fb      	ldr	r3, [r7, #12]
2000cee8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000ceea:	1c5a      	adds	r2, r3, #1
2000ceec:	68fb      	ldr	r3, [r7, #12]
2000ceee:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2000cef0:	68fb      	ldr	r3, [r7, #12]
2000cef2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000cef4:	3b01      	subs	r3, #1
2000cef6:	b29a      	uxth	r2, r3
2000cef8:	68fb      	ldr	r3, [r7, #12]
2000cefa:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2000cefc:	68fb      	ldr	r3, [r7, #12]
2000cefe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cf00:	b29b      	uxth	r3, r3
2000cf02:	3b01      	subs	r3, #1
2000cf04:	b29a      	uxth	r2, r3
2000cf06:	68fb      	ldr	r3, [r7, #12]
2000cf08:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2000cf0a:	68fb      	ldr	r3, [r7, #12]
2000cf0c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cf0e:	b29b      	uxth	r3, r3
2000cf10:	2b00      	cmp	r3, #0
2000cf12:	d034      	beq.n	2000cf7e <HAL_I2C_Master_Receive+0x186>
2000cf14:	68fb      	ldr	r3, [r7, #12]
2000cf16:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000cf18:	2b00      	cmp	r3, #0
2000cf1a:	d130      	bne.n	2000cf7e <HAL_I2C_Master_Receive+0x186>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2000cf1c:	697b      	ldr	r3, [r7, #20]
2000cf1e:	9300      	str	r3, [sp, #0]
2000cf20:	6a3b      	ldr	r3, [r7, #32]
2000cf22:	2200      	movs	r2, #0
2000cf24:	2180      	movs	r1, #128	; 0x80
2000cf26:	68f8      	ldr	r0, [r7, #12]
2000cf28:	f004 fd1a 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000cf2c:	4603      	mov	r3, r0
2000cf2e:	2b00      	cmp	r3, #0
2000cf30:	d001      	beq.n	2000cf36 <HAL_I2C_Master_Receive+0x13e>
        {
          return HAL_ERROR;
2000cf32:	2301      	movs	r3, #1
2000cf34:	e04d      	b.n	2000cfd2 <HAL_I2C_Master_Receive+0x1da>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000cf36:	68fb      	ldr	r3, [r7, #12]
2000cf38:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cf3a:	b29b      	uxth	r3, r3
2000cf3c:	2bff      	cmp	r3, #255	; 0xff
2000cf3e:	d90e      	bls.n	2000cf5e <HAL_I2C_Master_Receive+0x166>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2000cf40:	68fb      	ldr	r3, [r7, #12]
2000cf42:	22ff      	movs	r2, #255	; 0xff
2000cf44:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2000cf46:	68fb      	ldr	r3, [r7, #12]
2000cf48:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000cf4a:	b2da      	uxtb	r2, r3
2000cf4c:	8979      	ldrh	r1, [r7, #10]
2000cf4e:	2300      	movs	r3, #0
2000cf50:	9300      	str	r3, [sp, #0]
2000cf52:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000cf56:	68f8      	ldr	r0, [r7, #12]
2000cf58:	f004 fe90 	bl	20011c7c <I2C_TransferConfig>
2000cf5c:	e00f      	b.n	2000cf7e <HAL_I2C_Master_Receive+0x186>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2000cf5e:	68fb      	ldr	r3, [r7, #12]
2000cf60:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cf62:	b29a      	uxth	r2, r3
2000cf64:	68fb      	ldr	r3, [r7, #12]
2000cf66:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2000cf68:	68fb      	ldr	r3, [r7, #12]
2000cf6a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000cf6c:	b2da      	uxtb	r2, r3
2000cf6e:	8979      	ldrh	r1, [r7, #10]
2000cf70:	2300      	movs	r3, #0
2000cf72:	9300      	str	r3, [sp, #0]
2000cf74:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000cf78:	68f8      	ldr	r0, [r7, #12]
2000cf7a:	f004 fe7f 	bl	20011c7c <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
2000cf7e:	68fb      	ldr	r3, [r7, #12]
2000cf80:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000cf82:	b29b      	uxth	r3, r3
2000cf84:	2b00      	cmp	r3, #0
2000cf86:	d19d      	bne.n	2000cec4 <HAL_I2C_Master_Receive+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000cf88:	697a      	ldr	r2, [r7, #20]
2000cf8a:	6a39      	ldr	r1, [r7, #32]
2000cf8c:	68f8      	ldr	r0, [r7, #12]
2000cf8e:	f004 fd67 	bl	20011a60 <I2C_WaitOnSTOPFlagUntilTimeout>
2000cf92:	4603      	mov	r3, r0
2000cf94:	2b00      	cmp	r3, #0
2000cf96:	d001      	beq.n	2000cf9c <HAL_I2C_Master_Receive+0x1a4>
    {
      return HAL_ERROR;
2000cf98:	2301      	movs	r3, #1
2000cf9a:	e01a      	b.n	2000cfd2 <HAL_I2C_Master_Receive+0x1da>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000cf9c:	68fb      	ldr	r3, [r7, #12]
2000cf9e:	681b      	ldr	r3, [r3, #0]
2000cfa0:	2220      	movs	r2, #32
2000cfa2:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2000cfa4:	68fb      	ldr	r3, [r7, #12]
2000cfa6:	681b      	ldr	r3, [r3, #0]
2000cfa8:	6859      	ldr	r1, [r3, #4]
2000cfaa:	68fb      	ldr	r3, [r7, #12]
2000cfac:	681a      	ldr	r2, [r3, #0]
2000cfae:	4b0c      	ldr	r3, [pc, #48]	; (2000cfe0 <HAL_I2C_Master_Receive+0x1e8>)
2000cfb0:	400b      	ands	r3, r1
2000cfb2:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2000cfb4:	68fb      	ldr	r3, [r7, #12]
2000cfb6:	2220      	movs	r2, #32
2000cfb8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2000cfbc:	68fb      	ldr	r3, [r7, #12]
2000cfbe:	2200      	movs	r2, #0
2000cfc0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000cfc4:	68fb      	ldr	r3, [r7, #12]
2000cfc6:	2200      	movs	r2, #0
2000cfc8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2000cfcc:	2300      	movs	r3, #0
2000cfce:	e000      	b.n	2000cfd2 <HAL_I2C_Master_Receive+0x1da>
  }
  else
  {
    return HAL_BUSY;
2000cfd0:	2302      	movs	r3, #2
  }
}
2000cfd2:	4618      	mov	r0, r3
2000cfd4:	3718      	adds	r7, #24
2000cfd6:	46bd      	mov	sp, r7
2000cfd8:	bd80      	pop	{r7, pc}
2000cfda:	bf00      	nop
2000cfdc:	80002400 	.word	0x80002400
2000cfe0:	fe00e800 	.word	0xfe00e800

2000cfe4 <HAL_I2C_Slave_Transmit>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2000cfe4:	b580      	push	{r7, lr}
2000cfe6:	b088      	sub	sp, #32
2000cfe8:	af02      	add	r7, sp, #8
2000cfea:	60f8      	str	r0, [r7, #12]
2000cfec:	60b9      	str	r1, [r7, #8]
2000cfee:	603b      	str	r3, [r7, #0]
2000cff0:	4613      	mov	r3, r2
2000cff2:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000cff4:	68fb      	ldr	r3, [r7, #12]
2000cff6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000cffa:	b2db      	uxtb	r3, r3
2000cffc:	2b20      	cmp	r3, #32
2000cffe:	f040 80f5 	bne.w	2000d1ec <HAL_I2C_Slave_Transmit+0x208>
  {
    if ((pData == NULL) || (Size == 0U))
2000d002:	68bb      	ldr	r3, [r7, #8]
2000d004:	2b00      	cmp	r3, #0
2000d006:	d002      	beq.n	2000d00e <HAL_I2C_Slave_Transmit+0x2a>
2000d008:	88fb      	ldrh	r3, [r7, #6]
2000d00a:	2b00      	cmp	r3, #0
2000d00c:	d105      	bne.n	2000d01a <HAL_I2C_Slave_Transmit+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000d00e:	68fb      	ldr	r3, [r7, #12]
2000d010:	f44f 7200 	mov.w	r2, #512	; 0x200
2000d014:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000d016:	2301      	movs	r3, #1
2000d018:	e0e9      	b.n	2000d1ee <HAL_I2C_Slave_Transmit+0x20a>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000d01a:	68fb      	ldr	r3, [r7, #12]
2000d01c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000d020:	2b01      	cmp	r3, #1
2000d022:	d101      	bne.n	2000d028 <HAL_I2C_Slave_Transmit+0x44>
2000d024:	2302      	movs	r3, #2
2000d026:	e0e2      	b.n	2000d1ee <HAL_I2C_Slave_Transmit+0x20a>
2000d028:	68fb      	ldr	r3, [r7, #12]
2000d02a:	2201      	movs	r2, #1
2000d02c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000d030:	f7f4 fe5c 	bl	20001cec <HAL_GetTick>
2000d034:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2000d036:	68fb      	ldr	r3, [r7, #12]
2000d038:	2221      	movs	r2, #33	; 0x21
2000d03a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2000d03e:	68fb      	ldr	r3, [r7, #12]
2000d040:	2220      	movs	r2, #32
2000d042:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000d046:	68fb      	ldr	r3, [r7, #12]
2000d048:	2200      	movs	r2, #0
2000d04a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2000d04c:	68fb      	ldr	r3, [r7, #12]
2000d04e:	68ba      	ldr	r2, [r7, #8]
2000d050:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2000d052:	68fb      	ldr	r3, [r7, #12]
2000d054:	88fa      	ldrh	r2, [r7, #6]
2000d056:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2000d058:	68fb      	ldr	r3, [r7, #12]
2000d05a:	2200      	movs	r2, #0
2000d05c:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2000d05e:	68fb      	ldr	r3, [r7, #12]
2000d060:	681b      	ldr	r3, [r3, #0]
2000d062:	685a      	ldr	r2, [r3, #4]
2000d064:	68fb      	ldr	r3, [r7, #12]
2000d066:	681b      	ldr	r3, [r3, #0]
2000d068:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000d06c:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2000d06e:	697b      	ldr	r3, [r7, #20]
2000d070:	9300      	str	r3, [sp, #0]
2000d072:	683b      	ldr	r3, [r7, #0]
2000d074:	2200      	movs	r2, #0
2000d076:	2108      	movs	r1, #8
2000d078:	68f8      	ldr	r0, [r7, #12]
2000d07a:	f004 fc71 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000d07e:	4603      	mov	r3, r0
2000d080:	2b00      	cmp	r3, #0
2000d082:	d009      	beq.n	2000d098 <HAL_I2C_Slave_Transmit+0xb4>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d084:	68fb      	ldr	r3, [r7, #12]
2000d086:	681b      	ldr	r3, [r3, #0]
2000d088:	685a      	ldr	r2, [r3, #4]
2000d08a:	68fb      	ldr	r3, [r7, #12]
2000d08c:	681b      	ldr	r3, [r3, #0]
2000d08e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d092:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2000d094:	2301      	movs	r3, #1
2000d096:	e0aa      	b.n	2000d1ee <HAL_I2C_Slave_Transmit+0x20a>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2000d098:	68fb      	ldr	r3, [r7, #12]
2000d09a:	681b      	ldr	r3, [r3, #0]
2000d09c:	2208      	movs	r2, #8
2000d09e:	61da      	str	r2, [r3, #28]

    /* If 10bit addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2000d0a0:	68fb      	ldr	r3, [r7, #12]
2000d0a2:	68db      	ldr	r3, [r3, #12]
2000d0a4:	2b02      	cmp	r3, #2
2000d0a6:	d118      	bne.n	2000d0da <HAL_I2C_Slave_Transmit+0xf6>
    {
      /* Wait until ADDR flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2000d0a8:	697b      	ldr	r3, [r7, #20]
2000d0aa:	9300      	str	r3, [sp, #0]
2000d0ac:	683b      	ldr	r3, [r7, #0]
2000d0ae:	2200      	movs	r2, #0
2000d0b0:	2108      	movs	r1, #8
2000d0b2:	68f8      	ldr	r0, [r7, #12]
2000d0b4:	f004 fc54 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000d0b8:	4603      	mov	r3, r0
2000d0ba:	2b00      	cmp	r3, #0
2000d0bc:	d009      	beq.n	2000d0d2 <HAL_I2C_Slave_Transmit+0xee>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d0be:	68fb      	ldr	r3, [r7, #12]
2000d0c0:	681b      	ldr	r3, [r3, #0]
2000d0c2:	685a      	ldr	r2, [r3, #4]
2000d0c4:	68fb      	ldr	r3, [r7, #12]
2000d0c6:	681b      	ldr	r3, [r3, #0]
2000d0c8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d0cc:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
2000d0ce:	2301      	movs	r3, #1
2000d0d0:	e08d      	b.n	2000d1ee <HAL_I2C_Slave_Transmit+0x20a>
      }

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2000d0d2:	68fb      	ldr	r3, [r7, #12]
2000d0d4:	681b      	ldr	r3, [r3, #0]
2000d0d6:	2208      	movs	r2, #8
2000d0d8:	61da      	str	r2, [r3, #28]
    }

    /* Wait until DIR flag is set Transmitter mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
2000d0da:	697b      	ldr	r3, [r7, #20]
2000d0dc:	9300      	str	r3, [sp, #0]
2000d0de:	683b      	ldr	r3, [r7, #0]
2000d0e0:	2200      	movs	r2, #0
2000d0e2:	f44f 3180 	mov.w	r1, #65536	; 0x10000
2000d0e6:	68f8      	ldr	r0, [r7, #12]
2000d0e8:	f004 fc3a 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000d0ec:	4603      	mov	r3, r0
2000d0ee:	2b00      	cmp	r3, #0
2000d0f0:	d02d      	beq.n	2000d14e <HAL_I2C_Slave_Transmit+0x16a>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d0f2:	68fb      	ldr	r3, [r7, #12]
2000d0f4:	681b      	ldr	r3, [r3, #0]
2000d0f6:	685a      	ldr	r2, [r3, #4]
2000d0f8:	68fb      	ldr	r3, [r7, #12]
2000d0fa:	681b      	ldr	r3, [r3, #0]
2000d0fc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d100:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2000d102:	2301      	movs	r3, #1
2000d104:	e073      	b.n	2000d1ee <HAL_I2C_Slave_Transmit+0x20a>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000d106:	697a      	ldr	r2, [r7, #20]
2000d108:	6839      	ldr	r1, [r7, #0]
2000d10a:	68f8      	ldr	r0, [r7, #12]
2000d10c:	f004 fc68 	bl	200119e0 <I2C_WaitOnTXISFlagUntilTimeout>
2000d110:	4603      	mov	r3, r0
2000d112:	2b00      	cmp	r3, #0
2000d114:	d009      	beq.n	2000d12a <HAL_I2C_Slave_Transmit+0x146>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d116:	68fb      	ldr	r3, [r7, #12]
2000d118:	681b      	ldr	r3, [r3, #0]
2000d11a:	685a      	ldr	r2, [r3, #4]
2000d11c:	68fb      	ldr	r3, [r7, #12]
2000d11e:	681b      	ldr	r3, [r3, #0]
2000d120:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d124:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
2000d126:	2301      	movs	r3, #1
2000d128:	e061      	b.n	2000d1ee <HAL_I2C_Slave_Transmit+0x20a>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2000d12a:	68fb      	ldr	r3, [r7, #12]
2000d12c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000d12e:	781a      	ldrb	r2, [r3, #0]
2000d130:	68fb      	ldr	r3, [r7, #12]
2000d132:	681b      	ldr	r3, [r3, #0]
2000d134:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2000d136:	68fb      	ldr	r3, [r7, #12]
2000d138:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000d13a:	1c5a      	adds	r2, r3, #1
2000d13c:	68fb      	ldr	r3, [r7, #12]
2000d13e:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2000d140:	68fb      	ldr	r3, [r7, #12]
2000d142:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d144:	b29b      	uxth	r3, r3
2000d146:	3b01      	subs	r3, #1
2000d148:	b29a      	uxth	r2, r3
2000d14a:	68fb      	ldr	r3, [r7, #12]
2000d14c:	855a      	strh	r2, [r3, #42]	; 0x2a
    while (hi2c->XferCount > 0U)
2000d14e:	68fb      	ldr	r3, [r7, #12]
2000d150:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d152:	b29b      	uxth	r3, r3
2000d154:	2b00      	cmp	r3, #0
2000d156:	d1d6      	bne.n	2000d106 <HAL_I2C_Slave_Transmit+0x122>
    }

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000d158:	697a      	ldr	r2, [r7, #20]
2000d15a:	6839      	ldr	r1, [r7, #0]
2000d15c:	68f8      	ldr	r0, [r7, #12]
2000d15e:	f004 fc7f 	bl	20011a60 <I2C_WaitOnSTOPFlagUntilTimeout>
2000d162:	4603      	mov	r3, r0
2000d164:	2b00      	cmp	r3, #0
2000d166:	d011      	beq.n	2000d18c <HAL_I2C_Slave_Transmit+0x1a8>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d168:	68fb      	ldr	r3, [r7, #12]
2000d16a:	681b      	ldr	r3, [r3, #0]
2000d16c:	685a      	ldr	r2, [r3, #4]
2000d16e:	68fb      	ldr	r3, [r7, #12]
2000d170:	681b      	ldr	r3, [r3, #0]
2000d172:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d176:	605a      	str	r2, [r3, #4]

      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
2000d178:	68fb      	ldr	r3, [r7, #12]
2000d17a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000d17c:	2b04      	cmp	r3, #4
2000d17e:	d103      	bne.n	2000d188 <HAL_I2C_Slave_Transmit+0x1a4>
      {
        /* Normal use case for Transmitter mode */
        /* A NACK is generated to confirm the end of transfer */
        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000d180:	68fb      	ldr	r3, [r7, #12]
2000d182:	2200      	movs	r2, #0
2000d184:	645a      	str	r2, [r3, #68]	; 0x44
2000d186:	e001      	b.n	2000d18c <HAL_I2C_Slave_Transmit+0x1a8>
      }
      else
      {
        return HAL_ERROR;
2000d188:	2301      	movs	r3, #1
2000d18a:	e030      	b.n	2000d1ee <HAL_I2C_Slave_Transmit+0x20a>
      }
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000d18c:	68fb      	ldr	r3, [r7, #12]
2000d18e:	681b      	ldr	r3, [r3, #0]
2000d190:	2220      	movs	r2, #32
2000d192:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
2000d194:	697b      	ldr	r3, [r7, #20]
2000d196:	9300      	str	r3, [sp, #0]
2000d198:	683b      	ldr	r3, [r7, #0]
2000d19a:	2201      	movs	r2, #1
2000d19c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000d1a0:	68f8      	ldr	r0, [r7, #12]
2000d1a2:	f004 fbdd 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000d1a6:	4603      	mov	r3, r0
2000d1a8:	2b00      	cmp	r3, #0
2000d1aa:	d009      	beq.n	2000d1c0 <HAL_I2C_Slave_Transmit+0x1dc>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d1ac:	68fb      	ldr	r3, [r7, #12]
2000d1ae:	681b      	ldr	r3, [r3, #0]
2000d1b0:	685a      	ldr	r2, [r3, #4]
2000d1b2:	68fb      	ldr	r3, [r7, #12]
2000d1b4:	681b      	ldr	r3, [r3, #0]
2000d1b6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d1ba:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2000d1bc:	2301      	movs	r3, #1
2000d1be:	e016      	b.n	2000d1ee <HAL_I2C_Slave_Transmit+0x20a>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d1c0:	68fb      	ldr	r3, [r7, #12]
2000d1c2:	681b      	ldr	r3, [r3, #0]
2000d1c4:	685a      	ldr	r2, [r3, #4]
2000d1c6:	68fb      	ldr	r3, [r7, #12]
2000d1c8:	681b      	ldr	r3, [r3, #0]
2000d1ca:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d1ce:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2000d1d0:	68fb      	ldr	r3, [r7, #12]
2000d1d2:	2220      	movs	r2, #32
2000d1d4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2000d1d8:	68fb      	ldr	r3, [r7, #12]
2000d1da:	2200      	movs	r2, #0
2000d1dc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000d1e0:	68fb      	ldr	r3, [r7, #12]
2000d1e2:	2200      	movs	r2, #0
2000d1e4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2000d1e8:	2300      	movs	r3, #0
2000d1ea:	e000      	b.n	2000d1ee <HAL_I2C_Slave_Transmit+0x20a>
  }
  else
  {
    return HAL_BUSY;
2000d1ec:	2302      	movs	r3, #2
  }
}
2000d1ee:	4618      	mov	r0, r3
2000d1f0:	3718      	adds	r7, #24
2000d1f2:	46bd      	mov	sp, r7
2000d1f4:	bd80      	pop	{r7, pc}

2000d1f6 <HAL_I2C_Slave_Receive>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2000d1f6:	b580      	push	{r7, lr}
2000d1f8:	b088      	sub	sp, #32
2000d1fa:	af02      	add	r7, sp, #8
2000d1fc:	60f8      	str	r0, [r7, #12]
2000d1fe:	60b9      	str	r1, [r7, #8]
2000d200:	603b      	str	r3, [r7, #0]
2000d202:	4613      	mov	r3, r2
2000d204:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000d206:	68fb      	ldr	r3, [r7, #12]
2000d208:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000d20c:	b2db      	uxtb	r3, r3
2000d20e:	2b20      	cmp	r3, #32
2000d210:	f040 80eb 	bne.w	2000d3ea <HAL_I2C_Slave_Receive+0x1f4>
  {
    if ((pData == NULL) || (Size == 0U))
2000d214:	68bb      	ldr	r3, [r7, #8]
2000d216:	2b00      	cmp	r3, #0
2000d218:	d002      	beq.n	2000d220 <HAL_I2C_Slave_Receive+0x2a>
2000d21a:	88fb      	ldrh	r3, [r7, #6]
2000d21c:	2b00      	cmp	r3, #0
2000d21e:	d105      	bne.n	2000d22c <HAL_I2C_Slave_Receive+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000d220:	68fb      	ldr	r3, [r7, #12]
2000d222:	f44f 7200 	mov.w	r2, #512	; 0x200
2000d226:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000d228:	2301      	movs	r3, #1
2000d22a:	e0df      	b.n	2000d3ec <HAL_I2C_Slave_Receive+0x1f6>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000d22c:	68fb      	ldr	r3, [r7, #12]
2000d22e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000d232:	2b01      	cmp	r3, #1
2000d234:	d101      	bne.n	2000d23a <HAL_I2C_Slave_Receive+0x44>
2000d236:	2302      	movs	r3, #2
2000d238:	e0d8      	b.n	2000d3ec <HAL_I2C_Slave_Receive+0x1f6>
2000d23a:	68fb      	ldr	r3, [r7, #12]
2000d23c:	2201      	movs	r2, #1
2000d23e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000d242:	f7f4 fd53 	bl	20001cec <HAL_GetTick>
2000d246:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2000d248:	68fb      	ldr	r3, [r7, #12]
2000d24a:	2222      	movs	r2, #34	; 0x22
2000d24c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2000d250:	68fb      	ldr	r3, [r7, #12]
2000d252:	2220      	movs	r2, #32
2000d254:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000d258:	68fb      	ldr	r3, [r7, #12]
2000d25a:	2200      	movs	r2, #0
2000d25c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2000d25e:	68fb      	ldr	r3, [r7, #12]
2000d260:	68ba      	ldr	r2, [r7, #8]
2000d262:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2000d264:	68fb      	ldr	r3, [r7, #12]
2000d266:	88fa      	ldrh	r2, [r7, #6]
2000d268:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2000d26a:	68fb      	ldr	r3, [r7, #12]
2000d26c:	2200      	movs	r2, #0
2000d26e:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2000d270:	68fb      	ldr	r3, [r7, #12]
2000d272:	681b      	ldr	r3, [r3, #0]
2000d274:	685a      	ldr	r2, [r3, #4]
2000d276:	68fb      	ldr	r3, [r7, #12]
2000d278:	681b      	ldr	r3, [r3, #0]
2000d27a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000d27e:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2000d280:	697b      	ldr	r3, [r7, #20]
2000d282:	9300      	str	r3, [sp, #0]
2000d284:	683b      	ldr	r3, [r7, #0]
2000d286:	2200      	movs	r2, #0
2000d288:	2108      	movs	r1, #8
2000d28a:	68f8      	ldr	r0, [r7, #12]
2000d28c:	f004 fb68 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000d290:	4603      	mov	r3, r0
2000d292:	2b00      	cmp	r3, #0
2000d294:	d009      	beq.n	2000d2aa <HAL_I2C_Slave_Receive+0xb4>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d296:	68fb      	ldr	r3, [r7, #12]
2000d298:	681b      	ldr	r3, [r3, #0]
2000d29a:	685a      	ldr	r2, [r3, #4]
2000d29c:	68fb      	ldr	r3, [r7, #12]
2000d29e:	681b      	ldr	r3, [r3, #0]
2000d2a0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d2a4:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2000d2a6:	2301      	movs	r3, #1
2000d2a8:	e0a0      	b.n	2000d3ec <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2000d2aa:	68fb      	ldr	r3, [r7, #12]
2000d2ac:	681b      	ldr	r3, [r3, #0]
2000d2ae:	2208      	movs	r2, #8
2000d2b0:	61da      	str	r2, [r3, #28]

    /* Wait until DIR flag is reset Receiver mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
2000d2b2:	697b      	ldr	r3, [r7, #20]
2000d2b4:	9300      	str	r3, [sp, #0]
2000d2b6:	683b      	ldr	r3, [r7, #0]
2000d2b8:	2201      	movs	r2, #1
2000d2ba:	f44f 3180 	mov.w	r1, #65536	; 0x10000
2000d2be:	68f8      	ldr	r0, [r7, #12]
2000d2c0:	f004 fb4e 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000d2c4:	4603      	mov	r3, r0
2000d2c6:	2b00      	cmp	r3, #0
2000d2c8:	d048      	beq.n	2000d35c <HAL_I2C_Slave_Receive+0x166>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d2ca:	68fb      	ldr	r3, [r7, #12]
2000d2cc:	681b      	ldr	r3, [r3, #0]
2000d2ce:	685a      	ldr	r2, [r3, #4]
2000d2d0:	68fb      	ldr	r3, [r7, #12]
2000d2d2:	681b      	ldr	r3, [r3, #0]
2000d2d4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d2d8:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2000d2da:	2301      	movs	r3, #1
2000d2dc:	e086      	b.n	2000d3ec <HAL_I2C_Slave_Receive+0x1f6>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000d2de:	697a      	ldr	r2, [r7, #20]
2000d2e0:	6839      	ldr	r1, [r7, #0]
2000d2e2:	68f8      	ldr	r0, [r7, #12]
2000d2e4:	f004 fbf8 	bl	20011ad8 <I2C_WaitOnRXNEFlagUntilTimeout>
2000d2e8:	4603      	mov	r3, r0
2000d2ea:	2b00      	cmp	r3, #0
2000d2ec:	d023      	beq.n	2000d336 <HAL_I2C_Slave_Receive+0x140>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d2ee:	68fb      	ldr	r3, [r7, #12]
2000d2f0:	681b      	ldr	r3, [r3, #0]
2000d2f2:	685a      	ldr	r2, [r3, #4]
2000d2f4:	68fb      	ldr	r3, [r7, #12]
2000d2f6:	681b      	ldr	r3, [r3, #0]
2000d2f8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d2fc:	605a      	str	r2, [r3, #4]

        /* Store Last receive data if any */
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
2000d2fe:	68fb      	ldr	r3, [r7, #12]
2000d300:	681b      	ldr	r3, [r3, #0]
2000d302:	699b      	ldr	r3, [r3, #24]
2000d304:	f003 0304 	and.w	r3, r3, #4
2000d308:	2b04      	cmp	r3, #4
2000d30a:	d112      	bne.n	2000d332 <HAL_I2C_Slave_Receive+0x13c>
        {
          /* Read data from RXDR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2000d30c:	68fb      	ldr	r3, [r7, #12]
2000d30e:	681b      	ldr	r3, [r3, #0]
2000d310:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2000d312:	68fb      	ldr	r3, [r7, #12]
2000d314:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000d316:	b2d2      	uxtb	r2, r2
2000d318:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
2000d31a:	68fb      	ldr	r3, [r7, #12]
2000d31c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000d31e:	1c5a      	adds	r2, r3, #1
2000d320:	68fb      	ldr	r3, [r7, #12]
2000d322:	625a      	str	r2, [r3, #36]	; 0x24

          hi2c->XferCount--;
2000d324:	68fb      	ldr	r3, [r7, #12]
2000d326:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d328:	b29b      	uxth	r3, r3
2000d32a:	3b01      	subs	r3, #1
2000d32c:	b29a      	uxth	r2, r3
2000d32e:	68fb      	ldr	r3, [r7, #12]
2000d330:	855a      	strh	r2, [r3, #42]	; 0x2a
        }

        return HAL_ERROR;
2000d332:	2301      	movs	r3, #1
2000d334:	e05a      	b.n	2000d3ec <HAL_I2C_Slave_Receive+0x1f6>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2000d336:	68fb      	ldr	r3, [r7, #12]
2000d338:	681b      	ldr	r3, [r3, #0]
2000d33a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2000d33c:	68fb      	ldr	r3, [r7, #12]
2000d33e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000d340:	b2d2      	uxtb	r2, r2
2000d342:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2000d344:	68fb      	ldr	r3, [r7, #12]
2000d346:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000d348:	1c5a      	adds	r2, r3, #1
2000d34a:	68fb      	ldr	r3, [r7, #12]
2000d34c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2000d34e:	68fb      	ldr	r3, [r7, #12]
2000d350:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d352:	b29b      	uxth	r3, r3
2000d354:	3b01      	subs	r3, #1
2000d356:	b29a      	uxth	r2, r3
2000d358:	68fb      	ldr	r3, [r7, #12]
2000d35a:	855a      	strh	r2, [r3, #42]	; 0x2a
    while (hi2c->XferCount > 0U)
2000d35c:	68fb      	ldr	r3, [r7, #12]
2000d35e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d360:	b29b      	uxth	r3, r3
2000d362:	2b00      	cmp	r3, #0
2000d364:	d1bb      	bne.n	2000d2de <HAL_I2C_Slave_Receive+0xe8>
    }

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000d366:	697a      	ldr	r2, [r7, #20]
2000d368:	6839      	ldr	r1, [r7, #0]
2000d36a:	68f8      	ldr	r0, [r7, #12]
2000d36c:	f004 fb78 	bl	20011a60 <I2C_WaitOnSTOPFlagUntilTimeout>
2000d370:	4603      	mov	r3, r0
2000d372:	2b00      	cmp	r3, #0
2000d374:	d009      	beq.n	2000d38a <HAL_I2C_Slave_Receive+0x194>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d376:	68fb      	ldr	r3, [r7, #12]
2000d378:	681b      	ldr	r3, [r3, #0]
2000d37a:	685a      	ldr	r2, [r3, #4]
2000d37c:	68fb      	ldr	r3, [r7, #12]
2000d37e:	681b      	ldr	r3, [r3, #0]
2000d380:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d384:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2000d386:	2301      	movs	r3, #1
2000d388:	e030      	b.n	2000d3ec <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000d38a:	68fb      	ldr	r3, [r7, #12]
2000d38c:	681b      	ldr	r3, [r3, #0]
2000d38e:	2220      	movs	r2, #32
2000d390:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
2000d392:	697b      	ldr	r3, [r7, #20]
2000d394:	9300      	str	r3, [sp, #0]
2000d396:	683b      	ldr	r3, [r7, #0]
2000d398:	2201      	movs	r2, #1
2000d39a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000d39e:	68f8      	ldr	r0, [r7, #12]
2000d3a0:	f004 fade 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000d3a4:	4603      	mov	r3, r0
2000d3a6:	2b00      	cmp	r3, #0
2000d3a8:	d009      	beq.n	2000d3be <HAL_I2C_Slave_Receive+0x1c8>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d3aa:	68fb      	ldr	r3, [r7, #12]
2000d3ac:	681b      	ldr	r3, [r3, #0]
2000d3ae:	685a      	ldr	r2, [r3, #4]
2000d3b0:	68fb      	ldr	r3, [r7, #12]
2000d3b2:	681b      	ldr	r3, [r3, #0]
2000d3b4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d3b8:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2000d3ba:	2301      	movs	r3, #1
2000d3bc:	e016      	b.n	2000d3ec <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000d3be:	68fb      	ldr	r3, [r7, #12]
2000d3c0:	681b      	ldr	r3, [r3, #0]
2000d3c2:	685a      	ldr	r2, [r3, #4]
2000d3c4:	68fb      	ldr	r3, [r7, #12]
2000d3c6:	681b      	ldr	r3, [r3, #0]
2000d3c8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000d3cc:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2000d3ce:	68fb      	ldr	r3, [r7, #12]
2000d3d0:	2220      	movs	r2, #32
2000d3d2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2000d3d6:	68fb      	ldr	r3, [r7, #12]
2000d3d8:	2200      	movs	r2, #0
2000d3da:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000d3de:	68fb      	ldr	r3, [r7, #12]
2000d3e0:	2200      	movs	r2, #0
2000d3e2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2000d3e6:	2300      	movs	r3, #0
2000d3e8:	e000      	b.n	2000d3ec <HAL_I2C_Slave_Receive+0x1f6>
  }
  else
  {
    return HAL_BUSY;
2000d3ea:	2302      	movs	r3, #2
  }
}
2000d3ec:	4618      	mov	r0, r3
2000d3ee:	3718      	adds	r7, #24
2000d3f0:	46bd      	mov	sp, r7
2000d3f2:	bd80      	pop	{r7, pc}

2000d3f4 <HAL_I2C_Master_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
2000d3f4:	b580      	push	{r7, lr}
2000d3f6:	b088      	sub	sp, #32
2000d3f8:	af02      	add	r7, sp, #8
2000d3fa:	60f8      	str	r0, [r7, #12]
2000d3fc:	607a      	str	r2, [r7, #4]
2000d3fe:	461a      	mov	r2, r3
2000d400:	460b      	mov	r3, r1
2000d402:	817b      	strh	r3, [r7, #10]
2000d404:	4613      	mov	r3, r2
2000d406:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000d408:	68fb      	ldr	r3, [r7, #12]
2000d40a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000d40e:	b2db      	uxtb	r3, r3
2000d410:	2b20      	cmp	r3, #32
2000d412:	d153      	bne.n	2000d4bc <HAL_I2C_Master_Transmit_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2000d414:	68fb      	ldr	r3, [r7, #12]
2000d416:	681b      	ldr	r3, [r3, #0]
2000d418:	699b      	ldr	r3, [r3, #24]
2000d41a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000d41e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000d422:	d101      	bne.n	2000d428 <HAL_I2C_Master_Transmit_IT+0x34>
    {
      return HAL_BUSY;
2000d424:	2302      	movs	r3, #2
2000d426:	e04a      	b.n	2000d4be <HAL_I2C_Master_Transmit_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000d428:	68fb      	ldr	r3, [r7, #12]
2000d42a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000d42e:	2b01      	cmp	r3, #1
2000d430:	d101      	bne.n	2000d436 <HAL_I2C_Master_Transmit_IT+0x42>
2000d432:	2302      	movs	r3, #2
2000d434:	e043      	b.n	2000d4be <HAL_I2C_Master_Transmit_IT+0xca>
2000d436:	68fb      	ldr	r3, [r7, #12]
2000d438:	2201      	movs	r2, #1
2000d43a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2000d43e:	68fb      	ldr	r3, [r7, #12]
2000d440:	2221      	movs	r2, #33	; 0x21
2000d442:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2000d446:	68fb      	ldr	r3, [r7, #12]
2000d448:	2210      	movs	r2, #16
2000d44a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000d44e:	68fb      	ldr	r3, [r7, #12]
2000d450:	2200      	movs	r2, #0
2000d452:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000d454:	68fb      	ldr	r3, [r7, #12]
2000d456:	687a      	ldr	r2, [r7, #4]
2000d458:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000d45a:	68fb      	ldr	r3, [r7, #12]
2000d45c:	893a      	ldrh	r2, [r7, #8]
2000d45e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000d460:	68fb      	ldr	r3, [r7, #12]
2000d462:	4a19      	ldr	r2, [pc, #100]	; (2000d4c8 <HAL_I2C_Master_Transmit_IT+0xd4>)
2000d464:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2000d466:	68fb      	ldr	r3, [r7, #12]
2000d468:	4a18      	ldr	r2, [pc, #96]	; (2000d4cc <HAL_I2C_Master_Transmit_IT+0xd8>)
2000d46a:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000d46c:	68fb      	ldr	r3, [r7, #12]
2000d46e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d470:	b29b      	uxth	r3, r3
2000d472:	2bff      	cmp	r3, #255	; 0xff
2000d474:	d906      	bls.n	2000d484 <HAL_I2C_Master_Transmit_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000d476:	68fb      	ldr	r3, [r7, #12]
2000d478:	22ff      	movs	r2, #255	; 0xff
2000d47a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000d47c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000d480:	617b      	str	r3, [r7, #20]
2000d482:	e007      	b.n	2000d494 <HAL_I2C_Master_Transmit_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000d484:	68fb      	ldr	r3, [r7, #12]
2000d486:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d488:	b29a      	uxth	r2, r3
2000d48a:	68fb      	ldr	r3, [r7, #12]
2000d48c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2000d48e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000d492:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
2000d494:	68fb      	ldr	r3, [r7, #12]
2000d496:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000d498:	b2da      	uxtb	r2, r3
2000d49a:	8979      	ldrh	r1, [r7, #10]
2000d49c:	4b0c      	ldr	r3, [pc, #48]	; (2000d4d0 <HAL_I2C_Master_Transmit_IT+0xdc>)
2000d49e:	9300      	str	r3, [sp, #0]
2000d4a0:	697b      	ldr	r3, [r7, #20]
2000d4a2:	68f8      	ldr	r0, [r7, #12]
2000d4a4:	f004 fbea 	bl	20011c7c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000d4a8:	68fb      	ldr	r3, [r7, #12]
2000d4aa:	2200      	movs	r2, #0
2000d4ac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2000d4b0:	2101      	movs	r1, #1
2000d4b2:	68f8      	ldr	r0, [r7, #12]
2000d4b4:	f004 fc5a 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000d4b8:	2300      	movs	r3, #0
2000d4ba:	e000      	b.n	2000d4be <HAL_I2C_Master_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
2000d4bc:	2302      	movs	r3, #2
  }
}
2000d4be:	4618      	mov	r0, r3
2000d4c0:	3718      	adds	r7, #24
2000d4c2:	46bd      	mov	sp, r7
2000d4c4:	bd80      	pop	{r7, pc}
2000d4c6:	bf00      	nop
2000d4c8:	ffff0000 	.word	0xffff0000
2000d4cc:	2000fdf3 	.word	0x2000fdf3
2000d4d0:	80002000 	.word	0x80002000

2000d4d4 <HAL_I2C_Master_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
2000d4d4:	b580      	push	{r7, lr}
2000d4d6:	b088      	sub	sp, #32
2000d4d8:	af02      	add	r7, sp, #8
2000d4da:	60f8      	str	r0, [r7, #12]
2000d4dc:	607a      	str	r2, [r7, #4]
2000d4de:	461a      	mov	r2, r3
2000d4e0:	460b      	mov	r3, r1
2000d4e2:	817b      	strh	r3, [r7, #10]
2000d4e4:	4613      	mov	r3, r2
2000d4e6:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000d4e8:	68fb      	ldr	r3, [r7, #12]
2000d4ea:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000d4ee:	b2db      	uxtb	r3, r3
2000d4f0:	2b20      	cmp	r3, #32
2000d4f2:	d153      	bne.n	2000d59c <HAL_I2C_Master_Receive_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2000d4f4:	68fb      	ldr	r3, [r7, #12]
2000d4f6:	681b      	ldr	r3, [r3, #0]
2000d4f8:	699b      	ldr	r3, [r3, #24]
2000d4fa:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000d4fe:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000d502:	d101      	bne.n	2000d508 <HAL_I2C_Master_Receive_IT+0x34>
    {
      return HAL_BUSY;
2000d504:	2302      	movs	r3, #2
2000d506:	e04a      	b.n	2000d59e <HAL_I2C_Master_Receive_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000d508:	68fb      	ldr	r3, [r7, #12]
2000d50a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000d50e:	2b01      	cmp	r3, #1
2000d510:	d101      	bne.n	2000d516 <HAL_I2C_Master_Receive_IT+0x42>
2000d512:	2302      	movs	r3, #2
2000d514:	e043      	b.n	2000d59e <HAL_I2C_Master_Receive_IT+0xca>
2000d516:	68fb      	ldr	r3, [r7, #12]
2000d518:	2201      	movs	r2, #1
2000d51a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2000d51e:	68fb      	ldr	r3, [r7, #12]
2000d520:	2222      	movs	r2, #34	; 0x22
2000d522:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2000d526:	68fb      	ldr	r3, [r7, #12]
2000d528:	2210      	movs	r2, #16
2000d52a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000d52e:	68fb      	ldr	r3, [r7, #12]
2000d530:	2200      	movs	r2, #0
2000d532:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000d534:	68fb      	ldr	r3, [r7, #12]
2000d536:	687a      	ldr	r2, [r7, #4]
2000d538:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000d53a:	68fb      	ldr	r3, [r7, #12]
2000d53c:	893a      	ldrh	r2, [r7, #8]
2000d53e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000d540:	68fb      	ldr	r3, [r7, #12]
2000d542:	4a19      	ldr	r2, [pc, #100]	; (2000d5a8 <HAL_I2C_Master_Receive_IT+0xd4>)
2000d544:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2000d546:	68fb      	ldr	r3, [r7, #12]
2000d548:	4a18      	ldr	r2, [pc, #96]	; (2000d5ac <HAL_I2C_Master_Receive_IT+0xd8>)
2000d54a:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000d54c:	68fb      	ldr	r3, [r7, #12]
2000d54e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d550:	b29b      	uxth	r3, r3
2000d552:	2bff      	cmp	r3, #255	; 0xff
2000d554:	d906      	bls.n	2000d564 <HAL_I2C_Master_Receive_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000d556:	68fb      	ldr	r3, [r7, #12]
2000d558:	22ff      	movs	r2, #255	; 0xff
2000d55a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000d55c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000d560:	617b      	str	r3, [r7, #20]
2000d562:	e007      	b.n	2000d574 <HAL_I2C_Master_Receive_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000d564:	68fb      	ldr	r3, [r7, #12]
2000d566:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d568:	b29a      	uxth	r2, r3
2000d56a:	68fb      	ldr	r3, [r7, #12]
2000d56c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2000d56e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000d572:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2000d574:	68fb      	ldr	r3, [r7, #12]
2000d576:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000d578:	b2da      	uxtb	r2, r3
2000d57a:	8979      	ldrh	r1, [r7, #10]
2000d57c:	4b0c      	ldr	r3, [pc, #48]	; (2000d5b0 <HAL_I2C_Master_Receive_IT+0xdc>)
2000d57e:	9300      	str	r3, [sp, #0]
2000d580:	697b      	ldr	r3, [r7, #20]
2000d582:	68f8      	ldr	r0, [r7, #12]
2000d584:	f004 fb7a 	bl	20011c7c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000d588:	68fb      	ldr	r3, [r7, #12]
2000d58a:	2200      	movs	r2, #0
2000d58c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2000d590:	2102      	movs	r1, #2
2000d592:	68f8      	ldr	r0, [r7, #12]
2000d594:	f004 fbea 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000d598:	2300      	movs	r3, #0
2000d59a:	e000      	b.n	2000d59e <HAL_I2C_Master_Receive_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
2000d59c:	2302      	movs	r3, #2
  }
}
2000d59e:	4618      	mov	r0, r3
2000d5a0:	3718      	adds	r7, #24
2000d5a2:	46bd      	mov	sp, r7
2000d5a4:	bd80      	pop	{r7, pc}
2000d5a6:	bf00      	nop
2000d5a8:	ffff0000 	.word	0xffff0000
2000d5ac:	2000fdf3 	.word	0x2000fdf3
2000d5b0:	80002400 	.word	0x80002400

2000d5b4 <HAL_I2C_Slave_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2000d5b4:	b580      	push	{r7, lr}
2000d5b6:	b084      	sub	sp, #16
2000d5b8:	af00      	add	r7, sp, #0
2000d5ba:	60f8      	str	r0, [r7, #12]
2000d5bc:	60b9      	str	r1, [r7, #8]
2000d5be:	4613      	mov	r3, r2
2000d5c0:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
2000d5c2:	68fb      	ldr	r3, [r7, #12]
2000d5c4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000d5c8:	b2db      	uxtb	r3, r3
2000d5ca:	2b20      	cmp	r3, #32
2000d5cc:	d139      	bne.n	2000d642 <HAL_I2C_Slave_Transmit_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000d5ce:	68fb      	ldr	r3, [r7, #12]
2000d5d0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000d5d4:	2b01      	cmp	r3, #1
2000d5d6:	d101      	bne.n	2000d5dc <HAL_I2C_Slave_Transmit_IT+0x28>
2000d5d8:	2302      	movs	r3, #2
2000d5da:	e033      	b.n	2000d644 <HAL_I2C_Slave_Transmit_IT+0x90>
2000d5dc:	68fb      	ldr	r3, [r7, #12]
2000d5de:	2201      	movs	r2, #1
2000d5e0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2000d5e4:	68fb      	ldr	r3, [r7, #12]
2000d5e6:	2221      	movs	r2, #33	; 0x21
2000d5e8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2000d5ec:	68fb      	ldr	r3, [r7, #12]
2000d5ee:	2220      	movs	r2, #32
2000d5f0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000d5f4:	68fb      	ldr	r3, [r7, #12]
2000d5f6:	2200      	movs	r2, #0
2000d5f8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2000d5fa:	68fb      	ldr	r3, [r7, #12]
2000d5fc:	681b      	ldr	r3, [r3, #0]
2000d5fe:	685a      	ldr	r2, [r3, #4]
2000d600:	68fb      	ldr	r3, [r7, #12]
2000d602:	681b      	ldr	r3, [r3, #0]
2000d604:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000d608:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000d60a:	68fb      	ldr	r3, [r7, #12]
2000d60c:	68ba      	ldr	r2, [r7, #8]
2000d60e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000d610:	68fb      	ldr	r3, [r7, #12]
2000d612:	88fa      	ldrh	r2, [r7, #6]
2000d614:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2000d616:	68fb      	ldr	r3, [r7, #12]
2000d618:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d61a:	b29a      	uxth	r2, r3
2000d61c:	68fb      	ldr	r3, [r7, #12]
2000d61e:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000d620:	68fb      	ldr	r3, [r7, #12]
2000d622:	4a0a      	ldr	r2, [pc, #40]	; (2000d64c <HAL_I2C_Slave_Transmit_IT+0x98>)
2000d624:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2000d626:	68fb      	ldr	r3, [r7, #12]
2000d628:	4a09      	ldr	r2, [pc, #36]	; (2000d650 <HAL_I2C_Slave_Transmit_IT+0x9c>)
2000d62a:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000d62c:	68fb      	ldr	r3, [r7, #12]
2000d62e:	2200      	movs	r2, #0
2000d630:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
2000d634:	f248 0101 	movw	r1, #32769	; 0x8001
2000d638:	68f8      	ldr	r0, [r7, #12]
2000d63a:	f004 fb97 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000d63e:	2300      	movs	r3, #0
2000d640:	e000      	b.n	2000d644 <HAL_I2C_Slave_Transmit_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
2000d642:	2302      	movs	r3, #2
  }
}
2000d644:	4618      	mov	r0, r3
2000d646:	3710      	adds	r7, #16
2000d648:	46bd      	mov	sp, r7
2000d64a:	bd80      	pop	{r7, pc}
2000d64c:	ffff0000 	.word	0xffff0000
2000d650:	20010045 	.word	0x20010045

2000d654 <HAL_I2C_Slave_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2000d654:	b580      	push	{r7, lr}
2000d656:	b084      	sub	sp, #16
2000d658:	af00      	add	r7, sp, #0
2000d65a:	60f8      	str	r0, [r7, #12]
2000d65c:	60b9      	str	r1, [r7, #8]
2000d65e:	4613      	mov	r3, r2
2000d660:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
2000d662:	68fb      	ldr	r3, [r7, #12]
2000d664:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000d668:	b2db      	uxtb	r3, r3
2000d66a:	2b20      	cmp	r3, #32
2000d66c:	d139      	bne.n	2000d6e2 <HAL_I2C_Slave_Receive_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000d66e:	68fb      	ldr	r3, [r7, #12]
2000d670:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000d674:	2b01      	cmp	r3, #1
2000d676:	d101      	bne.n	2000d67c <HAL_I2C_Slave_Receive_IT+0x28>
2000d678:	2302      	movs	r3, #2
2000d67a:	e033      	b.n	2000d6e4 <HAL_I2C_Slave_Receive_IT+0x90>
2000d67c:	68fb      	ldr	r3, [r7, #12]
2000d67e:	2201      	movs	r2, #1
2000d680:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2000d684:	68fb      	ldr	r3, [r7, #12]
2000d686:	2222      	movs	r2, #34	; 0x22
2000d688:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2000d68c:	68fb      	ldr	r3, [r7, #12]
2000d68e:	2220      	movs	r2, #32
2000d690:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000d694:	68fb      	ldr	r3, [r7, #12]
2000d696:	2200      	movs	r2, #0
2000d698:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2000d69a:	68fb      	ldr	r3, [r7, #12]
2000d69c:	681b      	ldr	r3, [r3, #0]
2000d69e:	685a      	ldr	r2, [r3, #4]
2000d6a0:	68fb      	ldr	r3, [r7, #12]
2000d6a2:	681b      	ldr	r3, [r3, #0]
2000d6a4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000d6a8:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000d6aa:	68fb      	ldr	r3, [r7, #12]
2000d6ac:	68ba      	ldr	r2, [r7, #8]
2000d6ae:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000d6b0:	68fb      	ldr	r3, [r7, #12]
2000d6b2:	88fa      	ldrh	r2, [r7, #6]
2000d6b4:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2000d6b6:	68fb      	ldr	r3, [r7, #12]
2000d6b8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d6ba:	b29a      	uxth	r2, r3
2000d6bc:	68fb      	ldr	r3, [r7, #12]
2000d6be:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000d6c0:	68fb      	ldr	r3, [r7, #12]
2000d6c2:	4a0a      	ldr	r2, [pc, #40]	; (2000d6ec <HAL_I2C_Slave_Receive_IT+0x98>)
2000d6c4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2000d6c6:	68fb      	ldr	r3, [r7, #12]
2000d6c8:	4a09      	ldr	r2, [pc, #36]	; (2000d6f0 <HAL_I2C_Slave_Receive_IT+0x9c>)
2000d6ca:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000d6cc:	68fb      	ldr	r3, [r7, #12]
2000d6ce:	2200      	movs	r2, #0
2000d6d0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2000d6d4:	f248 0102 	movw	r1, #32770	; 0x8002
2000d6d8:	68f8      	ldr	r0, [r7, #12]
2000d6da:	f004 fb47 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000d6de:	2300      	movs	r3, #0
2000d6e0:	e000      	b.n	2000d6e4 <HAL_I2C_Slave_Receive_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
2000d6e2:	2302      	movs	r3, #2
  }
}
2000d6e4:	4618      	mov	r0, r3
2000d6e6:	3710      	adds	r7, #16
2000d6e8:	46bd      	mov	sp, r7
2000d6ea:	bd80      	pop	{r7, pc}
2000d6ec:	ffff0000 	.word	0xffff0000
2000d6f0:	20010045 	.word	0x20010045

2000d6f4 <HAL_I2C_Master_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
2000d6f4:	b580      	push	{r7, lr}
2000d6f6:	b088      	sub	sp, #32
2000d6f8:	af02      	add	r7, sp, #8
2000d6fa:	60f8      	str	r0, [r7, #12]
2000d6fc:	607a      	str	r2, [r7, #4]
2000d6fe:	461a      	mov	r2, r3
2000d700:	460b      	mov	r3, r1
2000d702:	817b      	strh	r3, [r7, #10]
2000d704:	4613      	mov	r3, r2
2000d706:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000d708:	68fb      	ldr	r3, [r7, #12]
2000d70a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000d70e:	b2db      	uxtb	r3, r3
2000d710:	2b20      	cmp	r3, #32
2000d712:	f040 80cd 	bne.w	2000d8b0 <HAL_I2C_Master_Transmit_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2000d716:	68fb      	ldr	r3, [r7, #12]
2000d718:	681b      	ldr	r3, [r3, #0]
2000d71a:	699b      	ldr	r3, [r3, #24]
2000d71c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000d720:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000d724:	d101      	bne.n	2000d72a <HAL_I2C_Master_Transmit_DMA+0x36>
    {
      return HAL_BUSY;
2000d726:	2302      	movs	r3, #2
2000d728:	e0c3      	b.n	2000d8b2 <HAL_I2C_Master_Transmit_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000d72a:	68fb      	ldr	r3, [r7, #12]
2000d72c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000d730:	2b01      	cmp	r3, #1
2000d732:	d101      	bne.n	2000d738 <HAL_I2C_Master_Transmit_DMA+0x44>
2000d734:	2302      	movs	r3, #2
2000d736:	e0bc      	b.n	2000d8b2 <HAL_I2C_Master_Transmit_DMA+0x1be>
2000d738:	68fb      	ldr	r3, [r7, #12]
2000d73a:	2201      	movs	r2, #1
2000d73c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2000d740:	68fb      	ldr	r3, [r7, #12]
2000d742:	2221      	movs	r2, #33	; 0x21
2000d744:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2000d748:	68fb      	ldr	r3, [r7, #12]
2000d74a:	2210      	movs	r2, #16
2000d74c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000d750:	68fb      	ldr	r3, [r7, #12]
2000d752:	2200      	movs	r2, #0
2000d754:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000d756:	68fb      	ldr	r3, [r7, #12]
2000d758:	687a      	ldr	r2, [r7, #4]
2000d75a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000d75c:	68fb      	ldr	r3, [r7, #12]
2000d75e:	893a      	ldrh	r2, [r7, #8]
2000d760:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000d762:	68fb      	ldr	r3, [r7, #12]
2000d764:	4a55      	ldr	r2, [pc, #340]	; (2000d8bc <HAL_I2C_Master_Transmit_DMA+0x1c8>)
2000d766:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2000d768:	68fb      	ldr	r3, [r7, #12]
2000d76a:	4a55      	ldr	r2, [pc, #340]	; (2000d8c0 <HAL_I2C_Master_Transmit_DMA+0x1cc>)
2000d76c:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000d76e:	68fb      	ldr	r3, [r7, #12]
2000d770:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d772:	b29b      	uxth	r3, r3
2000d774:	2bff      	cmp	r3, #255	; 0xff
2000d776:	d906      	bls.n	2000d786 <HAL_I2C_Master_Transmit_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000d778:	68fb      	ldr	r3, [r7, #12]
2000d77a:	22ff      	movs	r2, #255	; 0xff
2000d77c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000d77e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000d782:	617b      	str	r3, [r7, #20]
2000d784:	e007      	b.n	2000d796 <HAL_I2C_Master_Transmit_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000d786:	68fb      	ldr	r3, [r7, #12]
2000d788:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d78a:	b29a      	uxth	r2, r3
2000d78c:	68fb      	ldr	r3, [r7, #12]
2000d78e:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2000d790:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000d794:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
2000d796:	68fb      	ldr	r3, [r7, #12]
2000d798:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000d79a:	2b00      	cmp	r3, #0
2000d79c:	d070      	beq.n	2000d880 <HAL_I2C_Master_Transmit_DMA+0x18c>
    {
      if (hi2c->hdmatx != NULL)
2000d79e:	68fb      	ldr	r3, [r7, #12]
2000d7a0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000d7a2:	2b00      	cmp	r3, #0
2000d7a4:	d020      	beq.n	2000d7e8 <HAL_I2C_Master_Transmit_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2000d7a6:	68fb      	ldr	r3, [r7, #12]
2000d7a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000d7aa:	4a46      	ldr	r2, [pc, #280]	; (2000d8c4 <HAL_I2C_Master_Transmit_DMA+0x1d0>)
2000d7ac:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2000d7ae:	68fb      	ldr	r3, [r7, #12]
2000d7b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000d7b2:	4a45      	ldr	r2, [pc, #276]	; (2000d8c8 <HAL_I2C_Master_Transmit_DMA+0x1d4>)
2000d7b4:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
2000d7b6:	68fb      	ldr	r3, [r7, #12]
2000d7b8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000d7ba:	2200      	movs	r2, #0
2000d7bc:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
2000d7be:	68fb      	ldr	r3, [r7, #12]
2000d7c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000d7c2:	2200      	movs	r2, #0
2000d7c4:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2000d7c6:	68fb      	ldr	r3, [r7, #12]
2000d7c8:	6b98      	ldr	r0, [r3, #56]	; 0x38
2000d7ca:	6879      	ldr	r1, [r7, #4]
2000d7cc:	68fb      	ldr	r3, [r7, #12]
2000d7ce:	681b      	ldr	r3, [r3, #0]
2000d7d0:	3328      	adds	r3, #40	; 0x28
2000d7d2:	461a      	mov	r2, r3
2000d7d4:	68fb      	ldr	r3, [r7, #12]
2000d7d6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000d7d8:	f7f7 f86a 	bl	200048b0 <HAL_DMA_Start_IT>
2000d7dc:	4603      	mov	r3, r0
2000d7de:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2000d7e0:	7cfb      	ldrb	r3, [r7, #19]
2000d7e2:	2b00      	cmp	r3, #0
2000d7e4:	d138      	bne.n	2000d858 <HAL_I2C_Master_Transmit_DMA+0x164>
2000d7e6:	e013      	b.n	2000d810 <HAL_I2C_Master_Transmit_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
2000d7e8:	68fb      	ldr	r3, [r7, #12]
2000d7ea:	2220      	movs	r2, #32
2000d7ec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2000d7f0:	68fb      	ldr	r3, [r7, #12]
2000d7f2:	2200      	movs	r2, #0
2000d7f4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2000d7f8:	68fb      	ldr	r3, [r7, #12]
2000d7fa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000d7fc:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2000d800:	68fb      	ldr	r3, [r7, #12]
2000d802:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2000d804:	68fb      	ldr	r3, [r7, #12]
2000d806:	2200      	movs	r2, #0
2000d808:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2000d80c:	2301      	movs	r3, #1
2000d80e:	e050      	b.n	2000d8b2 <HAL_I2C_Master_Transmit_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
2000d810:	68fb      	ldr	r3, [r7, #12]
2000d812:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000d814:	b2da      	uxtb	r2, r3
2000d816:	8979      	ldrh	r1, [r7, #10]
2000d818:	4b2c      	ldr	r3, [pc, #176]	; (2000d8cc <HAL_I2C_Master_Transmit_DMA+0x1d8>)
2000d81a:	9300      	str	r3, [sp, #0]
2000d81c:	697b      	ldr	r3, [r7, #20]
2000d81e:	68f8      	ldr	r0, [r7, #12]
2000d820:	f004 fa2c 	bl	20011c7c <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2000d824:	68fb      	ldr	r3, [r7, #12]
2000d826:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d828:	b29a      	uxth	r2, r3
2000d82a:	68fb      	ldr	r3, [r7, #12]
2000d82c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000d82e:	1ad3      	subs	r3, r2, r3
2000d830:	b29a      	uxth	r2, r3
2000d832:	68fb      	ldr	r3, [r7, #12]
2000d834:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000d836:	68fb      	ldr	r3, [r7, #12]
2000d838:	2200      	movs	r2, #0
2000d83a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2000d83e:	2110      	movs	r1, #16
2000d840:	68f8      	ldr	r0, [r7, #12]
2000d842:	f004 fa93 	bl	20011d6c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2000d846:	68fb      	ldr	r3, [r7, #12]
2000d848:	681b      	ldr	r3, [r3, #0]
2000d84a:	681a      	ldr	r2, [r3, #0]
2000d84c:	68fb      	ldr	r3, [r7, #12]
2000d84e:	681b      	ldr	r3, [r3, #0]
2000d850:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2000d854:	601a      	str	r2, [r3, #0]
2000d856:	e029      	b.n	2000d8ac <HAL_I2C_Master_Transmit_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2000d858:	68fb      	ldr	r3, [r7, #12]
2000d85a:	2220      	movs	r2, #32
2000d85c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2000d860:	68fb      	ldr	r3, [r7, #12]
2000d862:	2200      	movs	r2, #0
2000d864:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000d868:	68fb      	ldr	r3, [r7, #12]
2000d86a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000d86c:	f043 0210 	orr.w	r2, r3, #16
2000d870:	68fb      	ldr	r3, [r7, #12]
2000d872:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000d874:	68fb      	ldr	r3, [r7, #12]
2000d876:	2200      	movs	r2, #0
2000d878:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2000d87c:	2301      	movs	r3, #1
2000d87e:	e018      	b.n	2000d8b2 <HAL_I2C_Master_Transmit_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2000d880:	68fb      	ldr	r3, [r7, #12]
2000d882:	4a13      	ldr	r2, [pc, #76]	; (2000d8d0 <HAL_I2C_Master_Transmit_DMA+0x1dc>)
2000d884:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
2000d886:	68fb      	ldr	r3, [r7, #12]
2000d888:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000d88a:	b2da      	uxtb	r2, r3
2000d88c:	8979      	ldrh	r1, [r7, #10]
2000d88e:	4b0f      	ldr	r3, [pc, #60]	; (2000d8cc <HAL_I2C_Master_Transmit_DMA+0x1d8>)
2000d890:	9300      	str	r3, [sp, #0]
2000d892:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000d896:	68f8      	ldr	r0, [r7, #12]
2000d898:	f004 f9f0 	bl	20011c7c <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000d89c:	68fb      	ldr	r3, [r7, #12]
2000d89e:	2200      	movs	r2, #0
2000d8a0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2000d8a4:	2101      	movs	r1, #1
2000d8a6:	68f8      	ldr	r0, [r7, #12]
2000d8a8:	f004 fa60 	bl	20011d6c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2000d8ac:	2300      	movs	r3, #0
2000d8ae:	e000      	b.n	2000d8b2 <HAL_I2C_Master_Transmit_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
2000d8b0:	2302      	movs	r3, #2
  }
}
2000d8b2:	4618      	mov	r0, r3
2000d8b4:	3718      	adds	r7, #24
2000d8b6:	46bd      	mov	sp, r7
2000d8b8:	bd80      	pop	{r7, pc}
2000d8ba:	bf00      	nop
2000d8bc:	ffff0000 	.word	0xffff0000
2000d8c0:	2001024b 	.word	0x2001024b
2000d8c4:	200113e3 	.word	0x200113e3
2000d8c8:	200116b5 	.word	0x200116b5
2000d8cc:	80002000 	.word	0x80002000
2000d8d0:	2000fdf3 	.word	0x2000fdf3

2000d8d4 <HAL_I2C_Master_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
2000d8d4:	b580      	push	{r7, lr}
2000d8d6:	b088      	sub	sp, #32
2000d8d8:	af02      	add	r7, sp, #8
2000d8da:	60f8      	str	r0, [r7, #12]
2000d8dc:	607a      	str	r2, [r7, #4]
2000d8de:	461a      	mov	r2, r3
2000d8e0:	460b      	mov	r3, r1
2000d8e2:	817b      	strh	r3, [r7, #10]
2000d8e4:	4613      	mov	r3, r2
2000d8e6:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000d8e8:	68fb      	ldr	r3, [r7, #12]
2000d8ea:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000d8ee:	b2db      	uxtb	r3, r3
2000d8f0:	2b20      	cmp	r3, #32
2000d8f2:	f040 80cd 	bne.w	2000da90 <HAL_I2C_Master_Receive_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2000d8f6:	68fb      	ldr	r3, [r7, #12]
2000d8f8:	681b      	ldr	r3, [r3, #0]
2000d8fa:	699b      	ldr	r3, [r3, #24]
2000d8fc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000d900:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000d904:	d101      	bne.n	2000d90a <HAL_I2C_Master_Receive_DMA+0x36>
    {
      return HAL_BUSY;
2000d906:	2302      	movs	r3, #2
2000d908:	e0c3      	b.n	2000da92 <HAL_I2C_Master_Receive_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000d90a:	68fb      	ldr	r3, [r7, #12]
2000d90c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000d910:	2b01      	cmp	r3, #1
2000d912:	d101      	bne.n	2000d918 <HAL_I2C_Master_Receive_DMA+0x44>
2000d914:	2302      	movs	r3, #2
2000d916:	e0bc      	b.n	2000da92 <HAL_I2C_Master_Receive_DMA+0x1be>
2000d918:	68fb      	ldr	r3, [r7, #12]
2000d91a:	2201      	movs	r2, #1
2000d91c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2000d920:	68fb      	ldr	r3, [r7, #12]
2000d922:	2222      	movs	r2, #34	; 0x22
2000d924:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2000d928:	68fb      	ldr	r3, [r7, #12]
2000d92a:	2210      	movs	r2, #16
2000d92c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000d930:	68fb      	ldr	r3, [r7, #12]
2000d932:	2200      	movs	r2, #0
2000d934:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000d936:	68fb      	ldr	r3, [r7, #12]
2000d938:	687a      	ldr	r2, [r7, #4]
2000d93a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000d93c:	68fb      	ldr	r3, [r7, #12]
2000d93e:	893a      	ldrh	r2, [r7, #8]
2000d940:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000d942:	68fb      	ldr	r3, [r7, #12]
2000d944:	4a55      	ldr	r2, [pc, #340]	; (2000da9c <HAL_I2C_Master_Receive_DMA+0x1c8>)
2000d946:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2000d948:	68fb      	ldr	r3, [r7, #12]
2000d94a:	4a55      	ldr	r2, [pc, #340]	; (2000daa0 <HAL_I2C_Master_Receive_DMA+0x1cc>)
2000d94c:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000d94e:	68fb      	ldr	r3, [r7, #12]
2000d950:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d952:	b29b      	uxth	r3, r3
2000d954:	2bff      	cmp	r3, #255	; 0xff
2000d956:	d906      	bls.n	2000d966 <HAL_I2C_Master_Receive_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000d958:	68fb      	ldr	r3, [r7, #12]
2000d95a:	22ff      	movs	r2, #255	; 0xff
2000d95c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000d95e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000d962:	617b      	str	r3, [r7, #20]
2000d964:	e007      	b.n	2000d976 <HAL_I2C_Master_Receive_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000d966:	68fb      	ldr	r3, [r7, #12]
2000d968:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000d96a:	b29a      	uxth	r2, r3
2000d96c:	68fb      	ldr	r3, [r7, #12]
2000d96e:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2000d970:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000d974:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
2000d976:	68fb      	ldr	r3, [r7, #12]
2000d978:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000d97a:	2b00      	cmp	r3, #0
2000d97c:	d070      	beq.n	2000da60 <HAL_I2C_Master_Receive_DMA+0x18c>
    {
      if (hi2c->hdmarx != NULL)
2000d97e:	68fb      	ldr	r3, [r7, #12]
2000d980:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000d982:	2b00      	cmp	r3, #0
2000d984:	d020      	beq.n	2000d9c8 <HAL_I2C_Master_Receive_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2000d986:	68fb      	ldr	r3, [r7, #12]
2000d988:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000d98a:	4a46      	ldr	r2, [pc, #280]	; (2000daa4 <HAL_I2C_Master_Receive_DMA+0x1d0>)
2000d98c:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2000d98e:	68fb      	ldr	r3, [r7, #12]
2000d990:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000d992:	4a45      	ldr	r2, [pc, #276]	; (2000daa8 <HAL_I2C_Master_Receive_DMA+0x1d4>)
2000d994:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2000d996:	68fb      	ldr	r3, [r7, #12]
2000d998:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000d99a:	2200      	movs	r2, #0
2000d99c:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
2000d99e:	68fb      	ldr	r3, [r7, #12]
2000d9a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000d9a2:	2200      	movs	r2, #0
2000d9a4:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2000d9a6:	68fb      	ldr	r3, [r7, #12]
2000d9a8:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2000d9aa:	68fb      	ldr	r3, [r7, #12]
2000d9ac:	681b      	ldr	r3, [r3, #0]
2000d9ae:	3324      	adds	r3, #36	; 0x24
2000d9b0:	4619      	mov	r1, r3
2000d9b2:	687a      	ldr	r2, [r7, #4]
2000d9b4:	68fb      	ldr	r3, [r7, #12]
2000d9b6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000d9b8:	f7f6 ff7a 	bl	200048b0 <HAL_DMA_Start_IT>
2000d9bc:	4603      	mov	r3, r0
2000d9be:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2000d9c0:	7cfb      	ldrb	r3, [r7, #19]
2000d9c2:	2b00      	cmp	r3, #0
2000d9c4:	d138      	bne.n	2000da38 <HAL_I2C_Master_Receive_DMA+0x164>
2000d9c6:	e013      	b.n	2000d9f0 <HAL_I2C_Master_Receive_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
2000d9c8:	68fb      	ldr	r3, [r7, #12]
2000d9ca:	2220      	movs	r2, #32
2000d9cc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2000d9d0:	68fb      	ldr	r3, [r7, #12]
2000d9d2:	2200      	movs	r2, #0
2000d9d4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2000d9d8:	68fb      	ldr	r3, [r7, #12]
2000d9da:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000d9dc:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2000d9e0:	68fb      	ldr	r3, [r7, #12]
2000d9e2:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2000d9e4:	68fb      	ldr	r3, [r7, #12]
2000d9e6:	2200      	movs	r2, #0
2000d9e8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2000d9ec:	2301      	movs	r3, #1
2000d9ee:	e050      	b.n	2000da92 <HAL_I2C_Master_Receive_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2000d9f0:	68fb      	ldr	r3, [r7, #12]
2000d9f2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000d9f4:	b2da      	uxtb	r2, r3
2000d9f6:	8979      	ldrh	r1, [r7, #10]
2000d9f8:	4b2c      	ldr	r3, [pc, #176]	; (2000daac <HAL_I2C_Master_Receive_DMA+0x1d8>)
2000d9fa:	9300      	str	r3, [sp, #0]
2000d9fc:	697b      	ldr	r3, [r7, #20]
2000d9fe:	68f8      	ldr	r0, [r7, #12]
2000da00:	f004 f93c 	bl	20011c7c <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2000da04:	68fb      	ldr	r3, [r7, #12]
2000da06:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000da08:	b29a      	uxth	r2, r3
2000da0a:	68fb      	ldr	r3, [r7, #12]
2000da0c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000da0e:	1ad3      	subs	r3, r2, r3
2000da10:	b29a      	uxth	r2, r3
2000da12:	68fb      	ldr	r3, [r7, #12]
2000da14:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000da16:	68fb      	ldr	r3, [r7, #12]
2000da18:	2200      	movs	r2, #0
2000da1a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2000da1e:	2110      	movs	r1, #16
2000da20:	68f8      	ldr	r0, [r7, #12]
2000da22:	f004 f9a3 	bl	20011d6c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2000da26:	68fb      	ldr	r3, [r7, #12]
2000da28:	681b      	ldr	r3, [r3, #0]
2000da2a:	681a      	ldr	r2, [r3, #0]
2000da2c:	68fb      	ldr	r3, [r7, #12]
2000da2e:	681b      	ldr	r3, [r3, #0]
2000da30:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000da34:	601a      	str	r2, [r3, #0]
2000da36:	e029      	b.n	2000da8c <HAL_I2C_Master_Receive_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2000da38:	68fb      	ldr	r3, [r7, #12]
2000da3a:	2220      	movs	r2, #32
2000da3c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2000da40:	68fb      	ldr	r3, [r7, #12]
2000da42:	2200      	movs	r2, #0
2000da44:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000da48:	68fb      	ldr	r3, [r7, #12]
2000da4a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000da4c:	f043 0210 	orr.w	r2, r3, #16
2000da50:	68fb      	ldr	r3, [r7, #12]
2000da52:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000da54:	68fb      	ldr	r3, [r7, #12]
2000da56:	2200      	movs	r2, #0
2000da58:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2000da5c:	2301      	movs	r3, #1
2000da5e:	e018      	b.n	2000da92 <HAL_I2C_Master_Receive_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2000da60:	68fb      	ldr	r3, [r7, #12]
2000da62:	4a13      	ldr	r2, [pc, #76]	; (2000dab0 <HAL_I2C_Master_Receive_DMA+0x1dc>)
2000da64:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2000da66:	68fb      	ldr	r3, [r7, #12]
2000da68:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000da6a:	b2da      	uxtb	r2, r3
2000da6c:	8979      	ldrh	r1, [r7, #10]
2000da6e:	4b0f      	ldr	r3, [pc, #60]	; (2000daac <HAL_I2C_Master_Receive_DMA+0x1d8>)
2000da70:	9300      	str	r3, [sp, #0]
2000da72:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000da76:	68f8      	ldr	r0, [r7, #12]
2000da78:	f004 f900 	bl	20011c7c <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000da7c:	68fb      	ldr	r3, [r7, #12]
2000da7e:	2200      	movs	r2, #0
2000da80:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2000da84:	2101      	movs	r1, #1
2000da86:	68f8      	ldr	r0, [r7, #12]
2000da88:	f004 f970 	bl	20011d6c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2000da8c:	2300      	movs	r3, #0
2000da8e:	e000      	b.n	2000da92 <HAL_I2C_Master_Receive_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
2000da90:	2302      	movs	r3, #2
  }
}
2000da92:	4618      	mov	r0, r3
2000da94:	3718      	adds	r7, #24
2000da96:	46bd      	mov	sp, r7
2000da98:	bd80      	pop	{r7, pc}
2000da9a:	bf00      	nop
2000da9c:	ffff0000 	.word	0xffff0000
2000daa0:	2001024b 	.word	0x2001024b
2000daa4:	200114b9 	.word	0x200114b9
2000daa8:	200116b5 	.word	0x200116b5
2000daac:	80002400 	.word	0x80002400
2000dab0:	2000fdf3 	.word	0x2000fdf3

2000dab4 <HAL_I2C_Slave_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2000dab4:	b580      	push	{r7, lr}
2000dab6:	b086      	sub	sp, #24
2000dab8:	af00      	add	r7, sp, #0
2000daba:	60f8      	str	r0, [r7, #12]
2000dabc:	60b9      	str	r1, [r7, #8]
2000dabe:	4613      	mov	r3, r2
2000dac0:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000dac2:	68fb      	ldr	r3, [r7, #12]
2000dac4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000dac8:	b2db      	uxtb	r3, r3
2000daca:	2b20      	cmp	r3, #32
2000dacc:	f040 809b 	bne.w	2000dc06 <HAL_I2C_Slave_Transmit_DMA+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
2000dad0:	68bb      	ldr	r3, [r7, #8]
2000dad2:	2b00      	cmp	r3, #0
2000dad4:	d002      	beq.n	2000dadc <HAL_I2C_Slave_Transmit_DMA+0x28>
2000dad6:	88fb      	ldrh	r3, [r7, #6]
2000dad8:	2b00      	cmp	r3, #0
2000dada:	d105      	bne.n	2000dae8 <HAL_I2C_Slave_Transmit_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000dadc:	68fb      	ldr	r3, [r7, #12]
2000dade:	f44f 7200 	mov.w	r2, #512	; 0x200
2000dae2:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000dae4:	2301      	movs	r3, #1
2000dae6:	e08f      	b.n	2000dc08 <HAL_I2C_Slave_Transmit_DMA+0x154>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000dae8:	68fb      	ldr	r3, [r7, #12]
2000daea:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000daee:	2b01      	cmp	r3, #1
2000daf0:	d101      	bne.n	2000daf6 <HAL_I2C_Slave_Transmit_DMA+0x42>
2000daf2:	2302      	movs	r3, #2
2000daf4:	e088      	b.n	2000dc08 <HAL_I2C_Slave_Transmit_DMA+0x154>
2000daf6:	68fb      	ldr	r3, [r7, #12]
2000daf8:	2201      	movs	r2, #1
2000dafa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2000dafe:	68fb      	ldr	r3, [r7, #12]
2000db00:	2221      	movs	r2, #33	; 0x21
2000db02:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2000db06:	68fb      	ldr	r3, [r7, #12]
2000db08:	2220      	movs	r2, #32
2000db0a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000db0e:	68fb      	ldr	r3, [r7, #12]
2000db10:	2200      	movs	r2, #0
2000db12:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000db14:	68fb      	ldr	r3, [r7, #12]
2000db16:	68ba      	ldr	r2, [r7, #8]
2000db18:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000db1a:	68fb      	ldr	r3, [r7, #12]
2000db1c:	88fa      	ldrh	r2, [r7, #6]
2000db1e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2000db20:	68fb      	ldr	r3, [r7, #12]
2000db22:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000db24:	b29a      	uxth	r2, r3
2000db26:	68fb      	ldr	r3, [r7, #12]
2000db28:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000db2a:	68fb      	ldr	r3, [r7, #12]
2000db2c:	4a38      	ldr	r2, [pc, #224]	; (2000dc10 <HAL_I2C_Slave_Transmit_DMA+0x15c>)
2000db2e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2000db30:	68fb      	ldr	r3, [r7, #12]
2000db32:	4a38      	ldr	r2, [pc, #224]	; (2000dc14 <HAL_I2C_Slave_Transmit_DMA+0x160>)
2000db34:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
2000db36:	68fb      	ldr	r3, [r7, #12]
2000db38:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000db3a:	2b00      	cmp	r3, #0
2000db3c:	d020      	beq.n	2000db80 <HAL_I2C_Slave_Transmit_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2000db3e:	68fb      	ldr	r3, [r7, #12]
2000db40:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000db42:	4a35      	ldr	r2, [pc, #212]	; (2000dc18 <HAL_I2C_Slave_Transmit_DMA+0x164>)
2000db44:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2000db46:	68fb      	ldr	r3, [r7, #12]
2000db48:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000db4a:	4a34      	ldr	r2, [pc, #208]	; (2000dc1c <HAL_I2C_Slave_Transmit_DMA+0x168>)
2000db4c:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2000db4e:	68fb      	ldr	r3, [r7, #12]
2000db50:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000db52:	2200      	movs	r2, #0
2000db54:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2000db56:	68fb      	ldr	r3, [r7, #12]
2000db58:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000db5a:	2200      	movs	r2, #0
2000db5c:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2000db5e:	68fb      	ldr	r3, [r7, #12]
2000db60:	6b98      	ldr	r0, [r3, #56]	; 0x38
2000db62:	68b9      	ldr	r1, [r7, #8]
2000db64:	68fb      	ldr	r3, [r7, #12]
2000db66:	681b      	ldr	r3, [r3, #0]
2000db68:	3328      	adds	r3, #40	; 0x28
2000db6a:	461a      	mov	r2, r3
2000db6c:	68fb      	ldr	r3, [r7, #12]
2000db6e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000db70:	f7f6 fe9e 	bl	200048b0 <HAL_DMA_Start_IT>
2000db74:	4603      	mov	r3, r0
2000db76:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2000db78:	7dfb      	ldrb	r3, [r7, #23]
2000db7a:	2b00      	cmp	r3, #0
2000db7c:	d12f      	bne.n	2000dbde <HAL_I2C_Slave_Transmit_DMA+0x12a>
2000db7e:	e013      	b.n	2000dba8 <HAL_I2C_Slave_Transmit_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2000db80:	68fb      	ldr	r3, [r7, #12]
2000db82:	2228      	movs	r2, #40	; 0x28
2000db84:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000db88:	68fb      	ldr	r3, [r7, #12]
2000db8a:	2200      	movs	r2, #0
2000db8c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2000db90:	68fb      	ldr	r3, [r7, #12]
2000db92:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000db94:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2000db98:	68fb      	ldr	r3, [r7, #12]
2000db9a:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000db9c:	68fb      	ldr	r3, [r7, #12]
2000db9e:	2200      	movs	r2, #0
2000dba0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000dba4:	2301      	movs	r3, #1
2000dba6:	e02f      	b.n	2000dc08 <HAL_I2C_Slave_Transmit_DMA+0x154>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2000dba8:	68fb      	ldr	r3, [r7, #12]
2000dbaa:	681b      	ldr	r3, [r3, #0]
2000dbac:	685a      	ldr	r2, [r3, #4]
2000dbae:	68fb      	ldr	r3, [r7, #12]
2000dbb0:	681b      	ldr	r3, [r3, #0]
2000dbb2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000dbb6:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000dbb8:	68fb      	ldr	r3, [r7, #12]
2000dbba:	2200      	movs	r2, #0
2000dbbc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2000dbc0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000dbc4:	68f8      	ldr	r0, [r7, #12]
2000dbc6:	f004 f8d1 	bl	20011d6c <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2000dbca:	68fb      	ldr	r3, [r7, #12]
2000dbcc:	681b      	ldr	r3, [r3, #0]
2000dbce:	681a      	ldr	r2, [r3, #0]
2000dbd0:	68fb      	ldr	r3, [r7, #12]
2000dbd2:	681b      	ldr	r3, [r3, #0]
2000dbd4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2000dbd8:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2000dbda:	2300      	movs	r3, #0
2000dbdc:	e014      	b.n	2000dc08 <HAL_I2C_Slave_Transmit_DMA+0x154>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2000dbde:	68fb      	ldr	r3, [r7, #12]
2000dbe0:	2228      	movs	r2, #40	; 0x28
2000dbe2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000dbe6:	68fb      	ldr	r3, [r7, #12]
2000dbe8:	2200      	movs	r2, #0
2000dbea:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000dbee:	68fb      	ldr	r3, [r7, #12]
2000dbf0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000dbf2:	f043 0210 	orr.w	r2, r3, #16
2000dbf6:	68fb      	ldr	r3, [r7, #12]
2000dbf8:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000dbfa:	68fb      	ldr	r3, [r7, #12]
2000dbfc:	2200      	movs	r2, #0
2000dbfe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000dc02:	2301      	movs	r3, #1
2000dc04:	e000      	b.n	2000dc08 <HAL_I2C_Slave_Transmit_DMA+0x154>
  }
  else
  {
    return HAL_BUSY;
2000dc06:	2302      	movs	r3, #2
  }
}
2000dc08:	4618      	mov	r0, r3
2000dc0a:	3718      	adds	r7, #24
2000dc0c:	46bd      	mov	sp, r7
2000dc0e:	bd80      	pop	{r7, pc}
2000dc10:	ffff0000 	.word	0xffff0000
2000dc14:	20010431 	.word	0x20010431
2000dc18:	20011479 	.word	0x20011479
2000dc1c:	200116b5 	.word	0x200116b5

2000dc20 <HAL_I2C_Slave_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2000dc20:	b580      	push	{r7, lr}
2000dc22:	b086      	sub	sp, #24
2000dc24:	af00      	add	r7, sp, #0
2000dc26:	60f8      	str	r0, [r7, #12]
2000dc28:	60b9      	str	r1, [r7, #8]
2000dc2a:	4613      	mov	r3, r2
2000dc2c:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000dc2e:	68fb      	ldr	r3, [r7, #12]
2000dc30:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000dc34:	b2db      	uxtb	r3, r3
2000dc36:	2b20      	cmp	r3, #32
2000dc38:	f040 809b 	bne.w	2000dd72 <HAL_I2C_Slave_Receive_DMA+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
2000dc3c:	68bb      	ldr	r3, [r7, #8]
2000dc3e:	2b00      	cmp	r3, #0
2000dc40:	d002      	beq.n	2000dc48 <HAL_I2C_Slave_Receive_DMA+0x28>
2000dc42:	88fb      	ldrh	r3, [r7, #6]
2000dc44:	2b00      	cmp	r3, #0
2000dc46:	d105      	bne.n	2000dc54 <HAL_I2C_Slave_Receive_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000dc48:	68fb      	ldr	r3, [r7, #12]
2000dc4a:	f44f 7200 	mov.w	r2, #512	; 0x200
2000dc4e:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000dc50:	2301      	movs	r3, #1
2000dc52:	e08f      	b.n	2000dd74 <HAL_I2C_Slave_Receive_DMA+0x154>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000dc54:	68fb      	ldr	r3, [r7, #12]
2000dc56:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000dc5a:	2b01      	cmp	r3, #1
2000dc5c:	d101      	bne.n	2000dc62 <HAL_I2C_Slave_Receive_DMA+0x42>
2000dc5e:	2302      	movs	r3, #2
2000dc60:	e088      	b.n	2000dd74 <HAL_I2C_Slave_Receive_DMA+0x154>
2000dc62:	68fb      	ldr	r3, [r7, #12]
2000dc64:	2201      	movs	r2, #1
2000dc66:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2000dc6a:	68fb      	ldr	r3, [r7, #12]
2000dc6c:	2222      	movs	r2, #34	; 0x22
2000dc6e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2000dc72:	68fb      	ldr	r3, [r7, #12]
2000dc74:	2220      	movs	r2, #32
2000dc76:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000dc7a:	68fb      	ldr	r3, [r7, #12]
2000dc7c:	2200      	movs	r2, #0
2000dc7e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000dc80:	68fb      	ldr	r3, [r7, #12]
2000dc82:	68ba      	ldr	r2, [r7, #8]
2000dc84:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000dc86:	68fb      	ldr	r3, [r7, #12]
2000dc88:	88fa      	ldrh	r2, [r7, #6]
2000dc8a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2000dc8c:	68fb      	ldr	r3, [r7, #12]
2000dc8e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000dc90:	b29a      	uxth	r2, r3
2000dc92:	68fb      	ldr	r3, [r7, #12]
2000dc94:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000dc96:	68fb      	ldr	r3, [r7, #12]
2000dc98:	4a38      	ldr	r2, [pc, #224]	; (2000dd7c <HAL_I2C_Slave_Receive_DMA+0x15c>)
2000dc9a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2000dc9c:	68fb      	ldr	r3, [r7, #12]
2000dc9e:	4a38      	ldr	r2, [pc, #224]	; (2000dd80 <HAL_I2C_Slave_Receive_DMA+0x160>)
2000dca0:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
2000dca2:	68fb      	ldr	r3, [r7, #12]
2000dca4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000dca6:	2b00      	cmp	r3, #0
2000dca8:	d020      	beq.n	2000dcec <HAL_I2C_Slave_Receive_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2000dcaa:	68fb      	ldr	r3, [r7, #12]
2000dcac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000dcae:	4a35      	ldr	r2, [pc, #212]	; (2000dd84 <HAL_I2C_Slave_Receive_DMA+0x164>)
2000dcb0:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2000dcb2:	68fb      	ldr	r3, [r7, #12]
2000dcb4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000dcb6:	4a34      	ldr	r2, [pc, #208]	; (2000dd88 <HAL_I2C_Slave_Receive_DMA+0x168>)
2000dcb8:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2000dcba:	68fb      	ldr	r3, [r7, #12]
2000dcbc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000dcbe:	2200      	movs	r2, #0
2000dcc0:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2000dcc2:	68fb      	ldr	r3, [r7, #12]
2000dcc4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000dcc6:	2200      	movs	r2, #0
2000dcc8:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2000dcca:	68fb      	ldr	r3, [r7, #12]
2000dccc:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2000dcce:	68fb      	ldr	r3, [r7, #12]
2000dcd0:	681b      	ldr	r3, [r3, #0]
2000dcd2:	3324      	adds	r3, #36	; 0x24
2000dcd4:	4619      	mov	r1, r3
2000dcd6:	68ba      	ldr	r2, [r7, #8]
2000dcd8:	68fb      	ldr	r3, [r7, #12]
2000dcda:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000dcdc:	f7f6 fde8 	bl	200048b0 <HAL_DMA_Start_IT>
2000dce0:	4603      	mov	r3, r0
2000dce2:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2000dce4:	7dfb      	ldrb	r3, [r7, #23]
2000dce6:	2b00      	cmp	r3, #0
2000dce8:	d12f      	bne.n	2000dd4a <HAL_I2C_Slave_Receive_DMA+0x12a>
2000dcea:	e013      	b.n	2000dd14 <HAL_I2C_Slave_Receive_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2000dcec:	68fb      	ldr	r3, [r7, #12]
2000dcee:	2228      	movs	r2, #40	; 0x28
2000dcf0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000dcf4:	68fb      	ldr	r3, [r7, #12]
2000dcf6:	2200      	movs	r2, #0
2000dcf8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2000dcfc:	68fb      	ldr	r3, [r7, #12]
2000dcfe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000dd00:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2000dd04:	68fb      	ldr	r3, [r7, #12]
2000dd06:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000dd08:	68fb      	ldr	r3, [r7, #12]
2000dd0a:	2200      	movs	r2, #0
2000dd0c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000dd10:	2301      	movs	r3, #1
2000dd12:	e02f      	b.n	2000dd74 <HAL_I2C_Slave_Receive_DMA+0x154>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2000dd14:	68fb      	ldr	r3, [r7, #12]
2000dd16:	681b      	ldr	r3, [r3, #0]
2000dd18:	685a      	ldr	r2, [r3, #4]
2000dd1a:	68fb      	ldr	r3, [r7, #12]
2000dd1c:	681b      	ldr	r3, [r3, #0]
2000dd1e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000dd22:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000dd24:	68fb      	ldr	r3, [r7, #12]
2000dd26:	2200      	movs	r2, #0
2000dd28:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2000dd2c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000dd30:	68f8      	ldr	r0, [r7, #12]
2000dd32:	f004 f81b 	bl	20011d6c <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2000dd36:	68fb      	ldr	r3, [r7, #12]
2000dd38:	681b      	ldr	r3, [r3, #0]
2000dd3a:	681a      	ldr	r2, [r3, #0]
2000dd3c:	68fb      	ldr	r3, [r7, #12]
2000dd3e:	681b      	ldr	r3, [r3, #0]
2000dd40:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000dd44:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2000dd46:	2300      	movs	r3, #0
2000dd48:	e014      	b.n	2000dd74 <HAL_I2C_Slave_Receive_DMA+0x154>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2000dd4a:	68fb      	ldr	r3, [r7, #12]
2000dd4c:	2228      	movs	r2, #40	; 0x28
2000dd4e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000dd52:	68fb      	ldr	r3, [r7, #12]
2000dd54:	2200      	movs	r2, #0
2000dd56:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000dd5a:	68fb      	ldr	r3, [r7, #12]
2000dd5c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000dd5e:	f043 0210 	orr.w	r2, r3, #16
2000dd62:	68fb      	ldr	r3, [r7, #12]
2000dd64:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000dd66:	68fb      	ldr	r3, [r7, #12]
2000dd68:	2200      	movs	r2, #0
2000dd6a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000dd6e:	2301      	movs	r3, #1
2000dd70:	e000      	b.n	2000dd74 <HAL_I2C_Slave_Receive_DMA+0x154>
  }
  else
  {
    return HAL_BUSY;
2000dd72:	2302      	movs	r3, #2
  }
}
2000dd74:	4618      	mov	r0, r3
2000dd76:	3718      	adds	r7, #24
2000dd78:	46bd      	mov	sp, r7
2000dd7a:	bd80      	pop	{r7, pc}
2000dd7c:	ffff0000 	.word	0xffff0000
2000dd80:	20010431 	.word	0x20010431
2000dd84:	20011551 	.word	0x20011551
2000dd88:	200116b5 	.word	0x200116b5

2000dd8c <HAL_I2C_Mem_Write>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2000dd8c:	b580      	push	{r7, lr}
2000dd8e:	b088      	sub	sp, #32
2000dd90:	af02      	add	r7, sp, #8
2000dd92:	60f8      	str	r0, [r7, #12]
2000dd94:	4608      	mov	r0, r1
2000dd96:	4611      	mov	r1, r2
2000dd98:	461a      	mov	r2, r3
2000dd9a:	4603      	mov	r3, r0
2000dd9c:	817b      	strh	r3, [r7, #10]
2000dd9e:	460b      	mov	r3, r1
2000dda0:	813b      	strh	r3, [r7, #8]
2000dda2:	4613      	mov	r3, r2
2000dda4:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
2000dda6:	88fb      	ldrh	r3, [r7, #6]
2000dda8:	2b01      	cmp	r3, #1
2000ddaa:	d007      	beq.n	2000ddbc <HAL_I2C_Mem_Write+0x30>
2000ddac:	88fb      	ldrh	r3, [r7, #6]
2000ddae:	2b02      	cmp	r3, #2
2000ddb0:	d004      	beq.n	2000ddbc <HAL_I2C_Mem_Write+0x30>
2000ddb2:	f44f 610f 	mov.w	r1, #2288	; 0x8f0
2000ddb6:	4884      	ldr	r0, [pc, #528]	; (2000dfc8 <HAL_I2C_Mem_Write+0x23c>)
2000ddb8:	f7f2 fd9c 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2000ddbc:	68fb      	ldr	r3, [r7, #12]
2000ddbe:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000ddc2:	b2db      	uxtb	r3, r3
2000ddc4:	2b20      	cmp	r3, #32
2000ddc6:	f040 80f9 	bne.w	2000dfbc <HAL_I2C_Mem_Write+0x230>
  {
    if ((pData == NULL) || (Size == 0U))
2000ddca:	6a3b      	ldr	r3, [r7, #32]
2000ddcc:	2b00      	cmp	r3, #0
2000ddce:	d002      	beq.n	2000ddd6 <HAL_I2C_Mem_Write+0x4a>
2000ddd0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2000ddd2:	2b00      	cmp	r3, #0
2000ddd4:	d105      	bne.n	2000dde2 <HAL_I2C_Mem_Write+0x56>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000ddd6:	68fb      	ldr	r3, [r7, #12]
2000ddd8:	f44f 7200 	mov.w	r2, #512	; 0x200
2000dddc:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000ddde:	2301      	movs	r3, #1
2000dde0:	e0ed      	b.n	2000dfbe <HAL_I2C_Mem_Write+0x232>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000dde2:	68fb      	ldr	r3, [r7, #12]
2000dde4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000dde8:	2b01      	cmp	r3, #1
2000ddea:	d101      	bne.n	2000ddf0 <HAL_I2C_Mem_Write+0x64>
2000ddec:	2302      	movs	r3, #2
2000ddee:	e0e6      	b.n	2000dfbe <HAL_I2C_Mem_Write+0x232>
2000ddf0:	68fb      	ldr	r3, [r7, #12]
2000ddf2:	2201      	movs	r2, #1
2000ddf4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000ddf8:	f7f3 ff78 	bl	20001cec <HAL_GetTick>
2000ddfc:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2000ddfe:	697b      	ldr	r3, [r7, #20]
2000de00:	9300      	str	r3, [sp, #0]
2000de02:	2319      	movs	r3, #25
2000de04:	2201      	movs	r2, #1
2000de06:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000de0a:	68f8      	ldr	r0, [r7, #12]
2000de0c:	f003 fda8 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000de10:	4603      	mov	r3, r0
2000de12:	2b00      	cmp	r3, #0
2000de14:	d001      	beq.n	2000de1a <HAL_I2C_Mem_Write+0x8e>
    {
      return HAL_ERROR;
2000de16:	2301      	movs	r3, #1
2000de18:	e0d1      	b.n	2000dfbe <HAL_I2C_Mem_Write+0x232>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2000de1a:	68fb      	ldr	r3, [r7, #12]
2000de1c:	2221      	movs	r2, #33	; 0x21
2000de1e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2000de22:	68fb      	ldr	r3, [r7, #12]
2000de24:	2240      	movs	r2, #64	; 0x40
2000de26:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000de2a:	68fb      	ldr	r3, [r7, #12]
2000de2c:	2200      	movs	r2, #0
2000de2e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2000de30:	68fb      	ldr	r3, [r7, #12]
2000de32:	6a3a      	ldr	r2, [r7, #32]
2000de34:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2000de36:	68fb      	ldr	r3, [r7, #12]
2000de38:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2000de3a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2000de3c:	68fb      	ldr	r3, [r7, #12]
2000de3e:	2200      	movs	r2, #0
2000de40:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2000de42:	88f8      	ldrh	r0, [r7, #6]
2000de44:	893a      	ldrh	r2, [r7, #8]
2000de46:	8979      	ldrh	r1, [r7, #10]
2000de48:	697b      	ldr	r3, [r7, #20]
2000de4a:	9301      	str	r3, [sp, #4]
2000de4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000de4e:	9300      	str	r3, [sp, #0]
2000de50:	4603      	mov	r3, r0
2000de52:	68f8      	ldr	r0, [r7, #12]
2000de54:	f002 fccc 	bl	200107f0 <I2C_RequestMemoryWrite>
2000de58:	4603      	mov	r3, r0
2000de5a:	2b00      	cmp	r3, #0
2000de5c:	d005      	beq.n	2000de6a <HAL_I2C_Mem_Write+0xde>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000de5e:	68fb      	ldr	r3, [r7, #12]
2000de60:	2200      	movs	r2, #0
2000de62:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000de66:	2301      	movs	r3, #1
2000de68:	e0a9      	b.n	2000dfbe <HAL_I2C_Mem_Write+0x232>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000de6a:	68fb      	ldr	r3, [r7, #12]
2000de6c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000de6e:	b29b      	uxth	r3, r3
2000de70:	2bff      	cmp	r3, #255	; 0xff
2000de72:	d90e      	bls.n	2000de92 <HAL_I2C_Mem_Write+0x106>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000de74:	68fb      	ldr	r3, [r7, #12]
2000de76:	22ff      	movs	r2, #255	; 0xff
2000de78:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2000de7a:	68fb      	ldr	r3, [r7, #12]
2000de7c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000de7e:	b2da      	uxtb	r2, r3
2000de80:	8979      	ldrh	r1, [r7, #10]
2000de82:	2300      	movs	r3, #0
2000de84:	9300      	str	r3, [sp, #0]
2000de86:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000de8a:	68f8      	ldr	r0, [r7, #12]
2000de8c:	f003 fef6 	bl	20011c7c <I2C_TransferConfig>
2000de90:	e00f      	b.n	2000deb2 <HAL_I2C_Mem_Write+0x126>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000de92:	68fb      	ldr	r3, [r7, #12]
2000de94:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000de96:	b29a      	uxth	r2, r3
2000de98:	68fb      	ldr	r3, [r7, #12]
2000de9a:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2000de9c:	68fb      	ldr	r3, [r7, #12]
2000de9e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000dea0:	b2da      	uxtb	r2, r3
2000dea2:	8979      	ldrh	r1, [r7, #10]
2000dea4:	2300      	movs	r3, #0
2000dea6:	9300      	str	r3, [sp, #0]
2000dea8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000deac:	68f8      	ldr	r0, [r7, #12]
2000deae:	f003 fee5 	bl	20011c7c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000deb2:	697a      	ldr	r2, [r7, #20]
2000deb4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2000deb6:	68f8      	ldr	r0, [r7, #12]
2000deb8:	f003 fd92 	bl	200119e0 <I2C_WaitOnTXISFlagUntilTimeout>
2000debc:	4603      	mov	r3, r0
2000debe:	2b00      	cmp	r3, #0
2000dec0:	d001      	beq.n	2000dec6 <HAL_I2C_Mem_Write+0x13a>
      {
        return HAL_ERROR;
2000dec2:	2301      	movs	r3, #1
2000dec4:	e07b      	b.n	2000dfbe <HAL_I2C_Mem_Write+0x232>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2000dec6:	68fb      	ldr	r3, [r7, #12]
2000dec8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000deca:	781a      	ldrb	r2, [r3, #0]
2000decc:	68fb      	ldr	r3, [r7, #12]
2000dece:	681b      	ldr	r3, [r3, #0]
2000ded0:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2000ded2:	68fb      	ldr	r3, [r7, #12]
2000ded4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000ded6:	1c5a      	adds	r2, r3, #1
2000ded8:	68fb      	ldr	r3, [r7, #12]
2000deda:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2000dedc:	68fb      	ldr	r3, [r7, #12]
2000dede:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000dee0:	b29b      	uxth	r3, r3
2000dee2:	3b01      	subs	r3, #1
2000dee4:	b29a      	uxth	r2, r3
2000dee6:	68fb      	ldr	r3, [r7, #12]
2000dee8:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2000deea:	68fb      	ldr	r3, [r7, #12]
2000deec:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000deee:	3b01      	subs	r3, #1
2000def0:	b29a      	uxth	r2, r3
2000def2:	68fb      	ldr	r3, [r7, #12]
2000def4:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2000def6:	68fb      	ldr	r3, [r7, #12]
2000def8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000defa:	b29b      	uxth	r3, r3
2000defc:	2b00      	cmp	r3, #0
2000defe:	d034      	beq.n	2000df6a <HAL_I2C_Mem_Write+0x1de>
2000df00:	68fb      	ldr	r3, [r7, #12]
2000df02:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000df04:	2b00      	cmp	r3, #0
2000df06:	d130      	bne.n	2000df6a <HAL_I2C_Mem_Write+0x1de>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2000df08:	697b      	ldr	r3, [r7, #20]
2000df0a:	9300      	str	r3, [sp, #0]
2000df0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000df0e:	2200      	movs	r2, #0
2000df10:	2180      	movs	r1, #128	; 0x80
2000df12:	68f8      	ldr	r0, [r7, #12]
2000df14:	f003 fd24 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000df18:	4603      	mov	r3, r0
2000df1a:	2b00      	cmp	r3, #0
2000df1c:	d001      	beq.n	2000df22 <HAL_I2C_Mem_Write+0x196>
        {
          return HAL_ERROR;
2000df1e:	2301      	movs	r3, #1
2000df20:	e04d      	b.n	2000dfbe <HAL_I2C_Mem_Write+0x232>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000df22:	68fb      	ldr	r3, [r7, #12]
2000df24:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000df26:	b29b      	uxth	r3, r3
2000df28:	2bff      	cmp	r3, #255	; 0xff
2000df2a:	d90e      	bls.n	2000df4a <HAL_I2C_Mem_Write+0x1be>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2000df2c:	68fb      	ldr	r3, [r7, #12]
2000df2e:	22ff      	movs	r2, #255	; 0xff
2000df30:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2000df32:	68fb      	ldr	r3, [r7, #12]
2000df34:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000df36:	b2da      	uxtb	r2, r3
2000df38:	8979      	ldrh	r1, [r7, #10]
2000df3a:	2300      	movs	r3, #0
2000df3c:	9300      	str	r3, [sp, #0]
2000df3e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000df42:	68f8      	ldr	r0, [r7, #12]
2000df44:	f003 fe9a 	bl	20011c7c <I2C_TransferConfig>
2000df48:	e00f      	b.n	2000df6a <HAL_I2C_Mem_Write+0x1de>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2000df4a:	68fb      	ldr	r3, [r7, #12]
2000df4c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000df4e:	b29a      	uxth	r2, r3
2000df50:	68fb      	ldr	r3, [r7, #12]
2000df52:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2000df54:	68fb      	ldr	r3, [r7, #12]
2000df56:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000df58:	b2da      	uxtb	r2, r3
2000df5a:	8979      	ldrh	r1, [r7, #10]
2000df5c:	2300      	movs	r3, #0
2000df5e:	9300      	str	r3, [sp, #0]
2000df60:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000df64:	68f8      	ldr	r0, [r7, #12]
2000df66:	f003 fe89 	bl	20011c7c <I2C_TransferConfig>
        }
      }

    }
    while (hi2c->XferCount > 0U);
2000df6a:	68fb      	ldr	r3, [r7, #12]
2000df6c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000df6e:	b29b      	uxth	r3, r3
2000df70:	2b00      	cmp	r3, #0
2000df72:	d19e      	bne.n	2000deb2 <HAL_I2C_Mem_Write+0x126>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000df74:	697a      	ldr	r2, [r7, #20]
2000df76:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2000df78:	68f8      	ldr	r0, [r7, #12]
2000df7a:	f003 fd71 	bl	20011a60 <I2C_WaitOnSTOPFlagUntilTimeout>
2000df7e:	4603      	mov	r3, r0
2000df80:	2b00      	cmp	r3, #0
2000df82:	d001      	beq.n	2000df88 <HAL_I2C_Mem_Write+0x1fc>
    {
      return HAL_ERROR;
2000df84:	2301      	movs	r3, #1
2000df86:	e01a      	b.n	2000dfbe <HAL_I2C_Mem_Write+0x232>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000df88:	68fb      	ldr	r3, [r7, #12]
2000df8a:	681b      	ldr	r3, [r3, #0]
2000df8c:	2220      	movs	r2, #32
2000df8e:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2000df90:	68fb      	ldr	r3, [r7, #12]
2000df92:	681b      	ldr	r3, [r3, #0]
2000df94:	6859      	ldr	r1, [r3, #4]
2000df96:	68fb      	ldr	r3, [r7, #12]
2000df98:	681a      	ldr	r2, [r3, #0]
2000df9a:	4b0c      	ldr	r3, [pc, #48]	; (2000dfcc <HAL_I2C_Mem_Write+0x240>)
2000df9c:	400b      	ands	r3, r1
2000df9e:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2000dfa0:	68fb      	ldr	r3, [r7, #12]
2000dfa2:	2220      	movs	r2, #32
2000dfa4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2000dfa8:	68fb      	ldr	r3, [r7, #12]
2000dfaa:	2200      	movs	r2, #0
2000dfac:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000dfb0:	68fb      	ldr	r3, [r7, #12]
2000dfb2:	2200      	movs	r2, #0
2000dfb4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2000dfb8:	2300      	movs	r3, #0
2000dfba:	e000      	b.n	2000dfbe <HAL_I2C_Mem_Write+0x232>
  }
  else
  {
    return HAL_BUSY;
2000dfbc:	2302      	movs	r3, #2
  }
}
2000dfbe:	4618      	mov	r0, r3
2000dfc0:	3718      	adds	r7, #24
2000dfc2:	46bd      	mov	sp, r7
2000dfc4:	bd80      	pop	{r7, pc}
2000dfc6:	bf00      	nop
2000dfc8:	2001c180 	.word	0x2001c180
2000dfcc:	fe00e800 	.word	0xfe00e800

2000dfd0 <HAL_I2C_Mem_Read>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2000dfd0:	b580      	push	{r7, lr}
2000dfd2:	b088      	sub	sp, #32
2000dfd4:	af02      	add	r7, sp, #8
2000dfd6:	60f8      	str	r0, [r7, #12]
2000dfd8:	4608      	mov	r0, r1
2000dfda:	4611      	mov	r1, r2
2000dfdc:	461a      	mov	r2, r3
2000dfde:	4603      	mov	r3, r0
2000dfe0:	817b      	strh	r3, [r7, #10]
2000dfe2:	460b      	mov	r3, r1
2000dfe4:	813b      	strh	r3, [r7, #8]
2000dfe6:	4613      	mov	r3, r2
2000dfe8:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
2000dfea:	88fb      	ldrh	r3, [r7, #6]
2000dfec:	2b01      	cmp	r3, #1
2000dfee:	d007      	beq.n	2000e000 <HAL_I2C_Mem_Read+0x30>
2000dff0:	88fb      	ldrh	r3, [r7, #6]
2000dff2:	2b02      	cmp	r3, #2
2000dff4:	d004      	beq.n	2000e000 <HAL_I2C_Mem_Read+0x30>
2000dff6:	f640 1177 	movw	r1, #2423	; 0x977
2000dffa:	4886      	ldr	r0, [pc, #536]	; (2000e214 <HAL_I2C_Mem_Read+0x244>)
2000dffc:	f7f2 fc7a 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2000e000:	68fb      	ldr	r3, [r7, #12]
2000e002:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000e006:	b2db      	uxtb	r3, r3
2000e008:	2b20      	cmp	r3, #32
2000e00a:	f040 80fd 	bne.w	2000e208 <HAL_I2C_Mem_Read+0x238>
  {
    if ((pData == NULL) || (Size == 0U))
2000e00e:	6a3b      	ldr	r3, [r7, #32]
2000e010:	2b00      	cmp	r3, #0
2000e012:	d002      	beq.n	2000e01a <HAL_I2C_Mem_Read+0x4a>
2000e014:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2000e016:	2b00      	cmp	r3, #0
2000e018:	d105      	bne.n	2000e026 <HAL_I2C_Mem_Read+0x56>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000e01a:	68fb      	ldr	r3, [r7, #12]
2000e01c:	f44f 7200 	mov.w	r2, #512	; 0x200
2000e020:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000e022:	2301      	movs	r3, #1
2000e024:	e0f1      	b.n	2000e20a <HAL_I2C_Mem_Read+0x23a>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000e026:	68fb      	ldr	r3, [r7, #12]
2000e028:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000e02c:	2b01      	cmp	r3, #1
2000e02e:	d101      	bne.n	2000e034 <HAL_I2C_Mem_Read+0x64>
2000e030:	2302      	movs	r3, #2
2000e032:	e0ea      	b.n	2000e20a <HAL_I2C_Mem_Read+0x23a>
2000e034:	68fb      	ldr	r3, [r7, #12]
2000e036:	2201      	movs	r2, #1
2000e038:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000e03c:	f7f3 fe56 	bl	20001cec <HAL_GetTick>
2000e040:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2000e042:	697b      	ldr	r3, [r7, #20]
2000e044:	9300      	str	r3, [sp, #0]
2000e046:	2319      	movs	r3, #25
2000e048:	2201      	movs	r2, #1
2000e04a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000e04e:	68f8      	ldr	r0, [r7, #12]
2000e050:	f003 fc86 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000e054:	4603      	mov	r3, r0
2000e056:	2b00      	cmp	r3, #0
2000e058:	d001      	beq.n	2000e05e <HAL_I2C_Mem_Read+0x8e>
    {
      return HAL_ERROR;
2000e05a:	2301      	movs	r3, #1
2000e05c:	e0d5      	b.n	2000e20a <HAL_I2C_Mem_Read+0x23a>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2000e05e:	68fb      	ldr	r3, [r7, #12]
2000e060:	2222      	movs	r2, #34	; 0x22
2000e062:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2000e066:	68fb      	ldr	r3, [r7, #12]
2000e068:	2240      	movs	r2, #64	; 0x40
2000e06a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000e06e:	68fb      	ldr	r3, [r7, #12]
2000e070:	2200      	movs	r2, #0
2000e072:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2000e074:	68fb      	ldr	r3, [r7, #12]
2000e076:	6a3a      	ldr	r2, [r7, #32]
2000e078:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2000e07a:	68fb      	ldr	r3, [r7, #12]
2000e07c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2000e07e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2000e080:	68fb      	ldr	r3, [r7, #12]
2000e082:	2200      	movs	r2, #0
2000e084:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2000e086:	88f8      	ldrh	r0, [r7, #6]
2000e088:	893a      	ldrh	r2, [r7, #8]
2000e08a:	8979      	ldrh	r1, [r7, #10]
2000e08c:	697b      	ldr	r3, [r7, #20]
2000e08e:	9301      	str	r3, [sp, #4]
2000e090:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000e092:	9300      	str	r3, [sp, #0]
2000e094:	4603      	mov	r3, r0
2000e096:	68f8      	ldr	r0, [r7, #12]
2000e098:	f002 fbfe 	bl	20010898 <I2C_RequestMemoryRead>
2000e09c:	4603      	mov	r3, r0
2000e09e:	2b00      	cmp	r3, #0
2000e0a0:	d005      	beq.n	2000e0ae <HAL_I2C_Mem_Read+0xde>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000e0a2:	68fb      	ldr	r3, [r7, #12]
2000e0a4:	2200      	movs	r2, #0
2000e0a6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000e0aa:	2301      	movs	r3, #1
2000e0ac:	e0ad      	b.n	2000e20a <HAL_I2C_Mem_Read+0x23a>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000e0ae:	68fb      	ldr	r3, [r7, #12]
2000e0b0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e0b2:	b29b      	uxth	r3, r3
2000e0b4:	2bff      	cmp	r3, #255	; 0xff
2000e0b6:	d90e      	bls.n	2000e0d6 <HAL_I2C_Mem_Read+0x106>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000e0b8:	68fb      	ldr	r3, [r7, #12]
2000e0ba:	22ff      	movs	r2, #255	; 0xff
2000e0bc:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
2000e0be:	68fb      	ldr	r3, [r7, #12]
2000e0c0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e0c2:	b2da      	uxtb	r2, r3
2000e0c4:	8979      	ldrh	r1, [r7, #10]
2000e0c6:	4b54      	ldr	r3, [pc, #336]	; (2000e218 <HAL_I2C_Mem_Read+0x248>)
2000e0c8:	9300      	str	r3, [sp, #0]
2000e0ca:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000e0ce:	68f8      	ldr	r0, [r7, #12]
2000e0d0:	f003 fdd4 	bl	20011c7c <I2C_TransferConfig>
2000e0d4:	e00f      	b.n	2000e0f6 <HAL_I2C_Mem_Read+0x126>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000e0d6:	68fb      	ldr	r3, [r7, #12]
2000e0d8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e0da:	b29a      	uxth	r2, r3
2000e0dc:	68fb      	ldr	r3, [r7, #12]
2000e0de:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2000e0e0:	68fb      	ldr	r3, [r7, #12]
2000e0e2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e0e4:	b2da      	uxtb	r2, r3
2000e0e6:	8979      	ldrh	r1, [r7, #10]
2000e0e8:	4b4b      	ldr	r3, [pc, #300]	; (2000e218 <HAL_I2C_Mem_Read+0x248>)
2000e0ea:	9300      	str	r3, [sp, #0]
2000e0ec:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000e0f0:	68f8      	ldr	r0, [r7, #12]
2000e0f2:	f003 fdc3 	bl	20011c7c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
2000e0f6:	697b      	ldr	r3, [r7, #20]
2000e0f8:	9300      	str	r3, [sp, #0]
2000e0fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000e0fc:	2200      	movs	r2, #0
2000e0fe:	2104      	movs	r1, #4
2000e100:	68f8      	ldr	r0, [r7, #12]
2000e102:	f003 fc2d 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000e106:	4603      	mov	r3, r0
2000e108:	2b00      	cmp	r3, #0
2000e10a:	d001      	beq.n	2000e110 <HAL_I2C_Mem_Read+0x140>
      {
        return HAL_ERROR;
2000e10c:	2301      	movs	r3, #1
2000e10e:	e07c      	b.n	2000e20a <HAL_I2C_Mem_Read+0x23a>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2000e110:	68fb      	ldr	r3, [r7, #12]
2000e112:	681b      	ldr	r3, [r3, #0]
2000e114:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2000e116:	68fb      	ldr	r3, [r7, #12]
2000e118:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000e11a:	b2d2      	uxtb	r2, r2
2000e11c:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2000e11e:	68fb      	ldr	r3, [r7, #12]
2000e120:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000e122:	1c5a      	adds	r2, r3, #1
2000e124:	68fb      	ldr	r3, [r7, #12]
2000e126:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2000e128:	68fb      	ldr	r3, [r7, #12]
2000e12a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e12c:	3b01      	subs	r3, #1
2000e12e:	b29a      	uxth	r2, r3
2000e130:	68fb      	ldr	r3, [r7, #12]
2000e132:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2000e134:	68fb      	ldr	r3, [r7, #12]
2000e136:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e138:	b29b      	uxth	r3, r3
2000e13a:	3b01      	subs	r3, #1
2000e13c:	b29a      	uxth	r2, r3
2000e13e:	68fb      	ldr	r3, [r7, #12]
2000e140:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2000e142:	68fb      	ldr	r3, [r7, #12]
2000e144:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e146:	b29b      	uxth	r3, r3
2000e148:	2b00      	cmp	r3, #0
2000e14a:	d034      	beq.n	2000e1b6 <HAL_I2C_Mem_Read+0x1e6>
2000e14c:	68fb      	ldr	r3, [r7, #12]
2000e14e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e150:	2b00      	cmp	r3, #0
2000e152:	d130      	bne.n	2000e1b6 <HAL_I2C_Mem_Read+0x1e6>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2000e154:	697b      	ldr	r3, [r7, #20]
2000e156:	9300      	str	r3, [sp, #0]
2000e158:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000e15a:	2200      	movs	r2, #0
2000e15c:	2180      	movs	r1, #128	; 0x80
2000e15e:	68f8      	ldr	r0, [r7, #12]
2000e160:	f003 fbfe 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000e164:	4603      	mov	r3, r0
2000e166:	2b00      	cmp	r3, #0
2000e168:	d001      	beq.n	2000e16e <HAL_I2C_Mem_Read+0x19e>
        {
          return HAL_ERROR;
2000e16a:	2301      	movs	r3, #1
2000e16c:	e04d      	b.n	2000e20a <HAL_I2C_Mem_Read+0x23a>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000e16e:	68fb      	ldr	r3, [r7, #12]
2000e170:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e172:	b29b      	uxth	r3, r3
2000e174:	2bff      	cmp	r3, #255	; 0xff
2000e176:	d90e      	bls.n	2000e196 <HAL_I2C_Mem_Read+0x1c6>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2000e178:	68fb      	ldr	r3, [r7, #12]
2000e17a:	22ff      	movs	r2, #255	; 0xff
2000e17c:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2000e17e:	68fb      	ldr	r3, [r7, #12]
2000e180:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e182:	b2da      	uxtb	r2, r3
2000e184:	8979      	ldrh	r1, [r7, #10]
2000e186:	2300      	movs	r3, #0
2000e188:	9300      	str	r3, [sp, #0]
2000e18a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000e18e:	68f8      	ldr	r0, [r7, #12]
2000e190:	f003 fd74 	bl	20011c7c <I2C_TransferConfig>
2000e194:	e00f      	b.n	2000e1b6 <HAL_I2C_Mem_Read+0x1e6>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2000e196:	68fb      	ldr	r3, [r7, #12]
2000e198:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e19a:	b29a      	uxth	r2, r3
2000e19c:	68fb      	ldr	r3, [r7, #12]
2000e19e:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2000e1a0:	68fb      	ldr	r3, [r7, #12]
2000e1a2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e1a4:	b2da      	uxtb	r2, r3
2000e1a6:	8979      	ldrh	r1, [r7, #10]
2000e1a8:	2300      	movs	r3, #0
2000e1aa:	9300      	str	r3, [sp, #0]
2000e1ac:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000e1b0:	68f8      	ldr	r0, [r7, #12]
2000e1b2:	f003 fd63 	bl	20011c7c <I2C_TransferConfig>
        }
      }
    }
    while (hi2c->XferCount > 0U);
2000e1b6:	68fb      	ldr	r3, [r7, #12]
2000e1b8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e1ba:	b29b      	uxth	r3, r3
2000e1bc:	2b00      	cmp	r3, #0
2000e1be:	d19a      	bne.n	2000e0f6 <HAL_I2C_Mem_Read+0x126>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000e1c0:	697a      	ldr	r2, [r7, #20]
2000e1c2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2000e1c4:	68f8      	ldr	r0, [r7, #12]
2000e1c6:	f003 fc4b 	bl	20011a60 <I2C_WaitOnSTOPFlagUntilTimeout>
2000e1ca:	4603      	mov	r3, r0
2000e1cc:	2b00      	cmp	r3, #0
2000e1ce:	d001      	beq.n	2000e1d4 <HAL_I2C_Mem_Read+0x204>
    {
      return HAL_ERROR;
2000e1d0:	2301      	movs	r3, #1
2000e1d2:	e01a      	b.n	2000e20a <HAL_I2C_Mem_Read+0x23a>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000e1d4:	68fb      	ldr	r3, [r7, #12]
2000e1d6:	681b      	ldr	r3, [r3, #0]
2000e1d8:	2220      	movs	r2, #32
2000e1da:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2000e1dc:	68fb      	ldr	r3, [r7, #12]
2000e1de:	681b      	ldr	r3, [r3, #0]
2000e1e0:	6859      	ldr	r1, [r3, #4]
2000e1e2:	68fb      	ldr	r3, [r7, #12]
2000e1e4:	681a      	ldr	r2, [r3, #0]
2000e1e6:	4b0d      	ldr	r3, [pc, #52]	; (2000e21c <HAL_I2C_Mem_Read+0x24c>)
2000e1e8:	400b      	ands	r3, r1
2000e1ea:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2000e1ec:	68fb      	ldr	r3, [r7, #12]
2000e1ee:	2220      	movs	r2, #32
2000e1f0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2000e1f4:	68fb      	ldr	r3, [r7, #12]
2000e1f6:	2200      	movs	r2, #0
2000e1f8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000e1fc:	68fb      	ldr	r3, [r7, #12]
2000e1fe:	2200      	movs	r2, #0
2000e200:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2000e204:	2300      	movs	r3, #0
2000e206:	e000      	b.n	2000e20a <HAL_I2C_Mem_Read+0x23a>
  }
  else
  {
    return HAL_BUSY;
2000e208:	2302      	movs	r3, #2
  }
}
2000e20a:	4618      	mov	r0, r3
2000e20c:	3718      	adds	r7, #24
2000e20e:	46bd      	mov	sp, r7
2000e210:	bd80      	pop	{r7, pc}
2000e212:	bf00      	nop
2000e214:	2001c180 	.word	0x2001c180
2000e218:	80002400 	.word	0x80002400
2000e21c:	fe00e800 	.word	0xfe00e800

2000e220 <HAL_I2C_Mem_Write_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2000e220:	b580      	push	{r7, lr}
2000e222:	b088      	sub	sp, #32
2000e224:	af02      	add	r7, sp, #8
2000e226:	60f8      	str	r0, [r7, #12]
2000e228:	4608      	mov	r0, r1
2000e22a:	4611      	mov	r1, r2
2000e22c:	461a      	mov	r2, r3
2000e22e:	4603      	mov	r3, r0
2000e230:	817b      	strh	r3, [r7, #10]
2000e232:	460b      	mov	r3, r1
2000e234:	813b      	strh	r3, [r7, #8]
2000e236:	4613      	mov	r3, r2
2000e238:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;
  uint32_t xfermode;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
2000e23a:	88fb      	ldrh	r3, [r7, #6]
2000e23c:	2b01      	cmp	r3, #1
2000e23e:	d007      	beq.n	2000e250 <HAL_I2C_Mem_Write_IT+0x30>
2000e240:	88fb      	ldrh	r3, [r7, #6]
2000e242:	2b02      	cmp	r3, #2
2000e244:	d004      	beq.n	2000e250 <HAL_I2C_Mem_Write_IT+0x30>
2000e246:	f640 11fd 	movw	r1, #2557	; 0x9fd
2000e24a:	4842      	ldr	r0, [pc, #264]	; (2000e354 <HAL_I2C_Mem_Write_IT+0x134>)
2000e24c:	f7f2 fb52 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2000e250:	68fb      	ldr	r3, [r7, #12]
2000e252:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000e256:	b2db      	uxtb	r3, r3
2000e258:	2b20      	cmp	r3, #32
2000e25a:	d176      	bne.n	2000e34a <HAL_I2C_Mem_Write_IT+0x12a>
  {
    if ((pData == NULL) || (Size == 0U))
2000e25c:	6a3b      	ldr	r3, [r7, #32]
2000e25e:	2b00      	cmp	r3, #0
2000e260:	d002      	beq.n	2000e268 <HAL_I2C_Mem_Write_IT+0x48>
2000e262:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2000e264:	2b00      	cmp	r3, #0
2000e266:	d105      	bne.n	2000e274 <HAL_I2C_Mem_Write_IT+0x54>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000e268:	68fb      	ldr	r3, [r7, #12]
2000e26a:	f44f 7200 	mov.w	r2, #512	; 0x200
2000e26e:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000e270:	2301      	movs	r3, #1
2000e272:	e06b      	b.n	2000e34c <HAL_I2C_Mem_Write_IT+0x12c>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2000e274:	68fb      	ldr	r3, [r7, #12]
2000e276:	681b      	ldr	r3, [r3, #0]
2000e278:	699b      	ldr	r3, [r3, #24]
2000e27a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000e27e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000e282:	d101      	bne.n	2000e288 <HAL_I2C_Mem_Write_IT+0x68>
    {
      return HAL_BUSY;
2000e284:	2302      	movs	r3, #2
2000e286:	e061      	b.n	2000e34c <HAL_I2C_Mem_Write_IT+0x12c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000e288:	68fb      	ldr	r3, [r7, #12]
2000e28a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000e28e:	2b01      	cmp	r3, #1
2000e290:	d101      	bne.n	2000e296 <HAL_I2C_Mem_Write_IT+0x76>
2000e292:	2302      	movs	r3, #2
2000e294:	e05a      	b.n	2000e34c <HAL_I2C_Mem_Write_IT+0x12c>
2000e296:	68fb      	ldr	r3, [r7, #12]
2000e298:	2201      	movs	r2, #1
2000e29a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000e29e:	f7f3 fd25 	bl	20001cec <HAL_GetTick>
2000e2a2:	6138      	str	r0, [r7, #16]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2000e2a4:	68fb      	ldr	r3, [r7, #12]
2000e2a6:	2221      	movs	r2, #33	; 0x21
2000e2a8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2000e2ac:	68fb      	ldr	r3, [r7, #12]
2000e2ae:	2240      	movs	r2, #64	; 0x40
2000e2b0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000e2b4:	68fb      	ldr	r3, [r7, #12]
2000e2b6:	2200      	movs	r2, #0
2000e2b8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000e2ba:	68fb      	ldr	r3, [r7, #12]
2000e2bc:	6a3a      	ldr	r2, [r7, #32]
2000e2be:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000e2c0:	68fb      	ldr	r3, [r7, #12]
2000e2c2:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2000e2c4:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000e2c6:	68fb      	ldr	r3, [r7, #12]
2000e2c8:	4a23      	ldr	r2, [pc, #140]	; (2000e358 <HAL_I2C_Mem_Write_IT+0x138>)
2000e2ca:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2000e2cc:	68fb      	ldr	r3, [r7, #12]
2000e2ce:	4a23      	ldr	r2, [pc, #140]	; (2000e35c <HAL_I2C_Mem_Write_IT+0x13c>)
2000e2d0:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000e2d2:	68fb      	ldr	r3, [r7, #12]
2000e2d4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e2d6:	b29b      	uxth	r3, r3
2000e2d8:	2bff      	cmp	r3, #255	; 0xff
2000e2da:	d906      	bls.n	2000e2ea <HAL_I2C_Mem_Write_IT+0xca>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000e2dc:	68fb      	ldr	r3, [r7, #12]
2000e2de:	22ff      	movs	r2, #255	; 0xff
2000e2e0:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000e2e2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000e2e6:	617b      	str	r3, [r7, #20]
2000e2e8:	e007      	b.n	2000e2fa <HAL_I2C_Mem_Write_IT+0xda>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000e2ea:	68fb      	ldr	r3, [r7, #12]
2000e2ec:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e2ee:	b29a      	uxth	r2, r3
2000e2f0:	68fb      	ldr	r3, [r7, #12]
2000e2f2:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2000e2f4:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000e2f8:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2000e2fa:	88f8      	ldrh	r0, [r7, #6]
2000e2fc:	893a      	ldrh	r2, [r7, #8]
2000e2fe:	8979      	ldrh	r1, [r7, #10]
2000e300:	693b      	ldr	r3, [r7, #16]
2000e302:	9301      	str	r3, [sp, #4]
2000e304:	2319      	movs	r3, #25
2000e306:	9300      	str	r3, [sp, #0]
2000e308:	4603      	mov	r3, r0
2000e30a:	68f8      	ldr	r0, [r7, #12]
2000e30c:	f002 fa70 	bl	200107f0 <I2C_RequestMemoryWrite>
2000e310:	4603      	mov	r3, r0
2000e312:	2b00      	cmp	r3, #0
2000e314:	d005      	beq.n	2000e322 <HAL_I2C_Mem_Write_IT+0x102>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000e316:	68fb      	ldr	r3, [r7, #12]
2000e318:	2200      	movs	r2, #0
2000e31a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000e31e:	2301      	movs	r3, #1
2000e320:	e014      	b.n	2000e34c <HAL_I2C_Mem_Write_IT+0x12c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2000e322:	68fb      	ldr	r3, [r7, #12]
2000e324:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e326:	b2da      	uxtb	r2, r3
2000e328:	8979      	ldrh	r1, [r7, #10]
2000e32a:	2300      	movs	r3, #0
2000e32c:	9300      	str	r3, [sp, #0]
2000e32e:	697b      	ldr	r3, [r7, #20]
2000e330:	68f8      	ldr	r0, [r7, #12]
2000e332:	f003 fca3 	bl	20011c7c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000e336:	68fb      	ldr	r3, [r7, #12]
2000e338:	2200      	movs	r2, #0
2000e33a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2000e33e:	2101      	movs	r1, #1
2000e340:	68f8      	ldr	r0, [r7, #12]
2000e342:	f003 fd13 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000e346:	2300      	movs	r3, #0
2000e348:	e000      	b.n	2000e34c <HAL_I2C_Mem_Write_IT+0x12c>
  }
  else
  {
    return HAL_BUSY;
2000e34a:	2302      	movs	r3, #2
  }
}
2000e34c:	4618      	mov	r0, r3
2000e34e:	3718      	adds	r7, #24
2000e350:	46bd      	mov	sp, r7
2000e352:	bd80      	pop	{r7, pc}
2000e354:	2001c180 	.word	0x2001c180
2000e358:	ffff0000 	.word	0xffff0000
2000e35c:	2000fdf3 	.word	0x2000fdf3

2000e360 <HAL_I2C_Mem_Read_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2000e360:	b580      	push	{r7, lr}
2000e362:	b088      	sub	sp, #32
2000e364:	af02      	add	r7, sp, #8
2000e366:	60f8      	str	r0, [r7, #12]
2000e368:	4608      	mov	r0, r1
2000e36a:	4611      	mov	r1, r2
2000e36c:	461a      	mov	r2, r3
2000e36e:	4603      	mov	r3, r0
2000e370:	817b      	strh	r3, [r7, #10]
2000e372:	460b      	mov	r3, r1
2000e374:	813b      	strh	r3, [r7, #8]
2000e376:	4613      	mov	r3, r2
2000e378:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;
  uint32_t xfermode;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
2000e37a:	88fb      	ldrh	r3, [r7, #6]
2000e37c:	2b01      	cmp	r3, #1
2000e37e:	d007      	beq.n	2000e390 <HAL_I2C_Mem_Read_IT+0x30>
2000e380:	88fb      	ldrh	r3, [r7, #6]
2000e382:	2b02      	cmp	r3, #2
2000e384:	d004      	beq.n	2000e390 <HAL_I2C_Mem_Read_IT+0x30>
2000e386:	f640 2158 	movw	r1, #2648	; 0xa58
2000e38a:	4842      	ldr	r0, [pc, #264]	; (2000e494 <HAL_I2C_Mem_Read_IT+0x134>)
2000e38c:	f7f2 fab2 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2000e390:	68fb      	ldr	r3, [r7, #12]
2000e392:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000e396:	b2db      	uxtb	r3, r3
2000e398:	2b20      	cmp	r3, #32
2000e39a:	d176      	bne.n	2000e48a <HAL_I2C_Mem_Read_IT+0x12a>
  {
    if ((pData == NULL) || (Size == 0U))
2000e39c:	6a3b      	ldr	r3, [r7, #32]
2000e39e:	2b00      	cmp	r3, #0
2000e3a0:	d002      	beq.n	2000e3a8 <HAL_I2C_Mem_Read_IT+0x48>
2000e3a2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2000e3a4:	2b00      	cmp	r3, #0
2000e3a6:	d105      	bne.n	2000e3b4 <HAL_I2C_Mem_Read_IT+0x54>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000e3a8:	68fb      	ldr	r3, [r7, #12]
2000e3aa:	f44f 7200 	mov.w	r2, #512	; 0x200
2000e3ae:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000e3b0:	2301      	movs	r3, #1
2000e3b2:	e06b      	b.n	2000e48c <HAL_I2C_Mem_Read_IT+0x12c>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2000e3b4:	68fb      	ldr	r3, [r7, #12]
2000e3b6:	681b      	ldr	r3, [r3, #0]
2000e3b8:	699b      	ldr	r3, [r3, #24]
2000e3ba:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000e3be:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000e3c2:	d101      	bne.n	2000e3c8 <HAL_I2C_Mem_Read_IT+0x68>
    {
      return HAL_BUSY;
2000e3c4:	2302      	movs	r3, #2
2000e3c6:	e061      	b.n	2000e48c <HAL_I2C_Mem_Read_IT+0x12c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000e3c8:	68fb      	ldr	r3, [r7, #12]
2000e3ca:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000e3ce:	2b01      	cmp	r3, #1
2000e3d0:	d101      	bne.n	2000e3d6 <HAL_I2C_Mem_Read_IT+0x76>
2000e3d2:	2302      	movs	r3, #2
2000e3d4:	e05a      	b.n	2000e48c <HAL_I2C_Mem_Read_IT+0x12c>
2000e3d6:	68fb      	ldr	r3, [r7, #12]
2000e3d8:	2201      	movs	r2, #1
2000e3da:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000e3de:	f7f3 fc85 	bl	20001cec <HAL_GetTick>
2000e3e2:	6138      	str	r0, [r7, #16]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2000e3e4:	68fb      	ldr	r3, [r7, #12]
2000e3e6:	2222      	movs	r2, #34	; 0x22
2000e3e8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2000e3ec:	68fb      	ldr	r3, [r7, #12]
2000e3ee:	2240      	movs	r2, #64	; 0x40
2000e3f0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000e3f4:	68fb      	ldr	r3, [r7, #12]
2000e3f6:	2200      	movs	r2, #0
2000e3f8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000e3fa:	68fb      	ldr	r3, [r7, #12]
2000e3fc:	6a3a      	ldr	r2, [r7, #32]
2000e3fe:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000e400:	68fb      	ldr	r3, [r7, #12]
2000e402:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2000e404:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000e406:	68fb      	ldr	r3, [r7, #12]
2000e408:	4a23      	ldr	r2, [pc, #140]	; (2000e498 <HAL_I2C_Mem_Read_IT+0x138>)
2000e40a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2000e40c:	68fb      	ldr	r3, [r7, #12]
2000e40e:	4a23      	ldr	r2, [pc, #140]	; (2000e49c <HAL_I2C_Mem_Read_IT+0x13c>)
2000e410:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000e412:	68fb      	ldr	r3, [r7, #12]
2000e414:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e416:	b29b      	uxth	r3, r3
2000e418:	2bff      	cmp	r3, #255	; 0xff
2000e41a:	d906      	bls.n	2000e42a <HAL_I2C_Mem_Read_IT+0xca>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000e41c:	68fb      	ldr	r3, [r7, #12]
2000e41e:	22ff      	movs	r2, #255	; 0xff
2000e420:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000e422:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000e426:	617b      	str	r3, [r7, #20]
2000e428:	e007      	b.n	2000e43a <HAL_I2C_Mem_Read_IT+0xda>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000e42a:	68fb      	ldr	r3, [r7, #12]
2000e42c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e42e:	b29a      	uxth	r2, r3
2000e430:	68fb      	ldr	r3, [r7, #12]
2000e432:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2000e434:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000e438:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2000e43a:	88f8      	ldrh	r0, [r7, #6]
2000e43c:	893a      	ldrh	r2, [r7, #8]
2000e43e:	8979      	ldrh	r1, [r7, #10]
2000e440:	693b      	ldr	r3, [r7, #16]
2000e442:	9301      	str	r3, [sp, #4]
2000e444:	2319      	movs	r3, #25
2000e446:	9300      	str	r3, [sp, #0]
2000e448:	4603      	mov	r3, r0
2000e44a:	68f8      	ldr	r0, [r7, #12]
2000e44c:	f002 fa24 	bl	20010898 <I2C_RequestMemoryRead>
2000e450:	4603      	mov	r3, r0
2000e452:	2b00      	cmp	r3, #0
2000e454:	d005      	beq.n	2000e462 <HAL_I2C_Mem_Read_IT+0x102>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000e456:	68fb      	ldr	r3, [r7, #12]
2000e458:	2200      	movs	r2, #0
2000e45a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000e45e:	2301      	movs	r3, #1
2000e460:	e014      	b.n	2000e48c <HAL_I2C_Mem_Read_IT+0x12c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2000e462:	68fb      	ldr	r3, [r7, #12]
2000e464:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e466:	b2da      	uxtb	r2, r3
2000e468:	8979      	ldrh	r1, [r7, #10]
2000e46a:	4b0d      	ldr	r3, [pc, #52]	; (2000e4a0 <HAL_I2C_Mem_Read_IT+0x140>)
2000e46c:	9300      	str	r3, [sp, #0]
2000e46e:	697b      	ldr	r3, [r7, #20]
2000e470:	68f8      	ldr	r0, [r7, #12]
2000e472:	f003 fc03 	bl	20011c7c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000e476:	68fb      	ldr	r3, [r7, #12]
2000e478:	2200      	movs	r2, #0
2000e47a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2000e47e:	2102      	movs	r1, #2
2000e480:	68f8      	ldr	r0, [r7, #12]
2000e482:	f003 fc73 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000e486:	2300      	movs	r3, #0
2000e488:	e000      	b.n	2000e48c <HAL_I2C_Mem_Read_IT+0x12c>
  }
  else
  {
    return HAL_BUSY;
2000e48a:	2302      	movs	r3, #2
  }
}
2000e48c:	4618      	mov	r0, r3
2000e48e:	3718      	adds	r7, #24
2000e490:	46bd      	mov	sp, r7
2000e492:	bd80      	pop	{r7, pc}
2000e494:	2001c180 	.word	0x2001c180
2000e498:	ffff0000 	.word	0xffff0000
2000e49c:	2000fdf3 	.word	0x2000fdf3
2000e4a0:	80002400 	.word	0x80002400

2000e4a4 <HAL_I2C_Mem_Write_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2000e4a4:	b580      	push	{r7, lr}
2000e4a6:	b08a      	sub	sp, #40	; 0x28
2000e4a8:	af02      	add	r7, sp, #8
2000e4aa:	60f8      	str	r0, [r7, #12]
2000e4ac:	4608      	mov	r0, r1
2000e4ae:	4611      	mov	r1, r2
2000e4b0:	461a      	mov	r2, r3
2000e4b2:	4603      	mov	r3, r0
2000e4b4:	817b      	strh	r3, [r7, #10]
2000e4b6:	460b      	mov	r3, r1
2000e4b8:	813b      	strh	r3, [r7, #8]
2000e4ba:	4613      	mov	r3, r2
2000e4bc:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
2000e4be:	88fb      	ldrh	r3, [r7, #6]
2000e4c0:	2b01      	cmp	r3, #1
2000e4c2:	d007      	beq.n	2000e4d4 <HAL_I2C_Mem_Write_DMA+0x30>
2000e4c4:	88fb      	ldrh	r3, [r7, #6]
2000e4c6:	2b02      	cmp	r3, #2
2000e4c8:	d004      	beq.n	2000e4d4 <HAL_I2C_Mem_Write_DMA+0x30>
2000e4ca:	f640 21b3 	movw	r1, #2739	; 0xab3
2000e4ce:	4872      	ldr	r0, [pc, #456]	; (2000e698 <HAL_I2C_Mem_Write_DMA+0x1f4>)
2000e4d0:	f7f2 fa10 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2000e4d4:	68fb      	ldr	r3, [r7, #12]
2000e4d6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000e4da:	b2db      	uxtb	r3, r3
2000e4dc:	2b20      	cmp	r3, #32
2000e4de:	f040 80d5 	bne.w	2000e68c <HAL_I2C_Mem_Write_DMA+0x1e8>
  {
    if ((pData == NULL) || (Size == 0U))
2000e4e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000e4e4:	2b00      	cmp	r3, #0
2000e4e6:	d002      	beq.n	2000e4ee <HAL_I2C_Mem_Write_DMA+0x4a>
2000e4e8:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
2000e4ea:	2b00      	cmp	r3, #0
2000e4ec:	d105      	bne.n	2000e4fa <HAL_I2C_Mem_Write_DMA+0x56>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000e4ee:	68fb      	ldr	r3, [r7, #12]
2000e4f0:	f44f 7200 	mov.w	r2, #512	; 0x200
2000e4f4:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000e4f6:	2301      	movs	r3, #1
2000e4f8:	e0c9      	b.n	2000e68e <HAL_I2C_Mem_Write_DMA+0x1ea>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2000e4fa:	68fb      	ldr	r3, [r7, #12]
2000e4fc:	681b      	ldr	r3, [r3, #0]
2000e4fe:	699b      	ldr	r3, [r3, #24]
2000e500:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000e504:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000e508:	d101      	bne.n	2000e50e <HAL_I2C_Mem_Write_DMA+0x6a>
    {
      return HAL_BUSY;
2000e50a:	2302      	movs	r3, #2
2000e50c:	e0bf      	b.n	2000e68e <HAL_I2C_Mem_Write_DMA+0x1ea>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000e50e:	68fb      	ldr	r3, [r7, #12]
2000e510:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000e514:	2b01      	cmp	r3, #1
2000e516:	d101      	bne.n	2000e51c <HAL_I2C_Mem_Write_DMA+0x78>
2000e518:	2302      	movs	r3, #2
2000e51a:	e0b8      	b.n	2000e68e <HAL_I2C_Mem_Write_DMA+0x1ea>
2000e51c:	68fb      	ldr	r3, [r7, #12]
2000e51e:	2201      	movs	r2, #1
2000e520:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000e524:	f7f3 fbe2 	bl	20001cec <HAL_GetTick>
2000e528:	61b8      	str	r0, [r7, #24]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2000e52a:	68fb      	ldr	r3, [r7, #12]
2000e52c:	2221      	movs	r2, #33	; 0x21
2000e52e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2000e532:	68fb      	ldr	r3, [r7, #12]
2000e534:	2240      	movs	r2, #64	; 0x40
2000e536:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000e53a:	68fb      	ldr	r3, [r7, #12]
2000e53c:	2200      	movs	r2, #0
2000e53e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000e540:	68fb      	ldr	r3, [r7, #12]
2000e542:	6aba      	ldr	r2, [r7, #40]	; 0x28
2000e544:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000e546:	68fb      	ldr	r3, [r7, #12]
2000e548:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
2000e54a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000e54c:	68fb      	ldr	r3, [r7, #12]
2000e54e:	4a53      	ldr	r2, [pc, #332]	; (2000e69c <HAL_I2C_Mem_Write_DMA+0x1f8>)
2000e550:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2000e552:	68fb      	ldr	r3, [r7, #12]
2000e554:	4a52      	ldr	r2, [pc, #328]	; (2000e6a0 <HAL_I2C_Mem_Write_DMA+0x1fc>)
2000e556:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000e558:	68fb      	ldr	r3, [r7, #12]
2000e55a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e55c:	b29b      	uxth	r3, r3
2000e55e:	2bff      	cmp	r3, #255	; 0xff
2000e560:	d906      	bls.n	2000e570 <HAL_I2C_Mem_Write_DMA+0xcc>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000e562:	68fb      	ldr	r3, [r7, #12]
2000e564:	22ff      	movs	r2, #255	; 0xff
2000e566:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000e568:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000e56c:	61fb      	str	r3, [r7, #28]
2000e56e:	e007      	b.n	2000e580 <HAL_I2C_Mem_Write_DMA+0xdc>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000e570:	68fb      	ldr	r3, [r7, #12]
2000e572:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e574:	b29a      	uxth	r2, r3
2000e576:	68fb      	ldr	r3, [r7, #12]
2000e578:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2000e57a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000e57e:	61fb      	str	r3, [r7, #28]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2000e580:	88f8      	ldrh	r0, [r7, #6]
2000e582:	893a      	ldrh	r2, [r7, #8]
2000e584:	8979      	ldrh	r1, [r7, #10]
2000e586:	69bb      	ldr	r3, [r7, #24]
2000e588:	9301      	str	r3, [sp, #4]
2000e58a:	2319      	movs	r3, #25
2000e58c:	9300      	str	r3, [sp, #0]
2000e58e:	4603      	mov	r3, r0
2000e590:	68f8      	ldr	r0, [r7, #12]
2000e592:	f002 f92d 	bl	200107f0 <I2C_RequestMemoryWrite>
2000e596:	4603      	mov	r3, r0
2000e598:	2b00      	cmp	r3, #0
2000e59a:	d005      	beq.n	2000e5a8 <HAL_I2C_Mem_Write_DMA+0x104>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000e59c:	68fb      	ldr	r3, [r7, #12]
2000e59e:	2200      	movs	r2, #0
2000e5a0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000e5a4:	2301      	movs	r3, #1
2000e5a6:	e072      	b.n	2000e68e <HAL_I2C_Mem_Write_DMA+0x1ea>
    }


    if (hi2c->hdmatx != NULL)
2000e5a8:	68fb      	ldr	r3, [r7, #12]
2000e5aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000e5ac:	2b00      	cmp	r3, #0
2000e5ae:	d020      	beq.n	2000e5f2 <HAL_I2C_Mem_Write_DMA+0x14e>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2000e5b0:	68fb      	ldr	r3, [r7, #12]
2000e5b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000e5b4:	4a3b      	ldr	r2, [pc, #236]	; (2000e6a4 <HAL_I2C_Mem_Write_DMA+0x200>)
2000e5b6:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2000e5b8:	68fb      	ldr	r3, [r7, #12]
2000e5ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000e5bc:	4a3a      	ldr	r2, [pc, #232]	; (2000e6a8 <HAL_I2C_Mem_Write_DMA+0x204>)
2000e5be:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2000e5c0:	68fb      	ldr	r3, [r7, #12]
2000e5c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000e5c4:	2200      	movs	r2, #0
2000e5c6:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2000e5c8:	68fb      	ldr	r3, [r7, #12]
2000e5ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000e5cc:	2200      	movs	r2, #0
2000e5ce:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2000e5d0:	68fb      	ldr	r3, [r7, #12]
2000e5d2:	6b98      	ldr	r0, [r3, #56]	; 0x38
2000e5d4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2000e5d6:	68fb      	ldr	r3, [r7, #12]
2000e5d8:	681b      	ldr	r3, [r3, #0]
2000e5da:	3328      	adds	r3, #40	; 0x28
2000e5dc:	461a      	mov	r2, r3
2000e5de:	68fb      	ldr	r3, [r7, #12]
2000e5e0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e5e2:	f7f6 f965 	bl	200048b0 <HAL_DMA_Start_IT>
2000e5e6:	4603      	mov	r3, r0
2000e5e8:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2000e5ea:	7dfb      	ldrb	r3, [r7, #23]
2000e5ec:	2b00      	cmp	r3, #0
2000e5ee:	d139      	bne.n	2000e664 <HAL_I2C_Mem_Write_DMA+0x1c0>
2000e5f0:	e013      	b.n	2000e61a <HAL_I2C_Mem_Write_DMA+0x176>
      hi2c->State     = HAL_I2C_STATE_READY;
2000e5f2:	68fb      	ldr	r3, [r7, #12]
2000e5f4:	2220      	movs	r2, #32
2000e5f6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000e5fa:	68fb      	ldr	r3, [r7, #12]
2000e5fc:	2200      	movs	r2, #0
2000e5fe:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2000e602:	68fb      	ldr	r3, [r7, #12]
2000e604:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000e606:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2000e60a:	68fb      	ldr	r3, [r7, #12]
2000e60c:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000e60e:	68fb      	ldr	r3, [r7, #12]
2000e610:	2200      	movs	r2, #0
2000e612:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000e616:	2301      	movs	r3, #1
2000e618:	e039      	b.n	2000e68e <HAL_I2C_Mem_Write_DMA+0x1ea>
    {
      /* Send Slave Address */
      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2000e61a:	68fb      	ldr	r3, [r7, #12]
2000e61c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e61e:	b2da      	uxtb	r2, r3
2000e620:	8979      	ldrh	r1, [r7, #10]
2000e622:	2300      	movs	r3, #0
2000e624:	9300      	str	r3, [sp, #0]
2000e626:	69fb      	ldr	r3, [r7, #28]
2000e628:	68f8      	ldr	r0, [r7, #12]
2000e62a:	f003 fb27 	bl	20011c7c <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2000e62e:	68fb      	ldr	r3, [r7, #12]
2000e630:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e632:	b29a      	uxth	r2, r3
2000e634:	68fb      	ldr	r3, [r7, #12]
2000e636:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e638:	1ad3      	subs	r3, r2, r3
2000e63a:	b29a      	uxth	r2, r3
2000e63c:	68fb      	ldr	r3, [r7, #12]
2000e63e:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000e640:	68fb      	ldr	r3, [r7, #12]
2000e642:	2200      	movs	r2, #0
2000e644:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR and NACK interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2000e648:	2110      	movs	r1, #16
2000e64a:	68f8      	ldr	r0, [r7, #12]
2000e64c:	f003 fb8e 	bl	20011d6c <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2000e650:	68fb      	ldr	r3, [r7, #12]
2000e652:	681b      	ldr	r3, [r3, #0]
2000e654:	681a      	ldr	r2, [r3, #0]
2000e656:	68fb      	ldr	r3, [r7, #12]
2000e658:	681b      	ldr	r3, [r3, #0]
2000e65a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2000e65e:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2000e660:	2300      	movs	r3, #0
2000e662:	e014      	b.n	2000e68e <HAL_I2C_Mem_Write_DMA+0x1ea>
      hi2c->State     = HAL_I2C_STATE_READY;
2000e664:	68fb      	ldr	r3, [r7, #12]
2000e666:	2220      	movs	r2, #32
2000e668:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000e66c:	68fb      	ldr	r3, [r7, #12]
2000e66e:	2200      	movs	r2, #0
2000e670:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000e674:	68fb      	ldr	r3, [r7, #12]
2000e676:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000e678:	f043 0210 	orr.w	r2, r3, #16
2000e67c:	68fb      	ldr	r3, [r7, #12]
2000e67e:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000e680:	68fb      	ldr	r3, [r7, #12]
2000e682:	2200      	movs	r2, #0
2000e684:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000e688:	2301      	movs	r3, #1
2000e68a:	e000      	b.n	2000e68e <HAL_I2C_Mem_Write_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
2000e68c:	2302      	movs	r3, #2
  }
}
2000e68e:	4618      	mov	r0, r3
2000e690:	3720      	adds	r7, #32
2000e692:	46bd      	mov	sp, r7
2000e694:	bd80      	pop	{r7, pc}
2000e696:	bf00      	nop
2000e698:	2001c180 	.word	0x2001c180
2000e69c:	ffff0000 	.word	0xffff0000
2000e6a0:	2001024b 	.word	0x2001024b
2000e6a4:	200113e3 	.word	0x200113e3
2000e6a8:	200116b5 	.word	0x200116b5

2000e6ac <HAL_I2C_Mem_Read_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be read
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2000e6ac:	b580      	push	{r7, lr}
2000e6ae:	b08a      	sub	sp, #40	; 0x28
2000e6b0:	af02      	add	r7, sp, #8
2000e6b2:	60f8      	str	r0, [r7, #12]
2000e6b4:	4608      	mov	r0, r1
2000e6b6:	4611      	mov	r1, r2
2000e6b8:	461a      	mov	r2, r3
2000e6ba:	4603      	mov	r3, r0
2000e6bc:	817b      	strh	r3, [r7, #10]
2000e6be:	460b      	mov	r3, r1
2000e6c0:	813b      	strh	r3, [r7, #8]
2000e6c2:	4613      	mov	r3, r2
2000e6c4:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
2000e6c6:	88fb      	ldrh	r3, [r7, #6]
2000e6c8:	2b01      	cmp	r3, #1
2000e6ca:	d007      	beq.n	2000e6dc <HAL_I2C_Mem_Read_DMA+0x30>
2000e6cc:	88fb      	ldrh	r3, [r7, #6]
2000e6ce:	2b02      	cmp	r3, #2
2000e6d0:	d004      	beq.n	2000e6dc <HAL_I2C_Mem_Read_DMA+0x30>
2000e6d2:	f640 3143 	movw	r1, #2883	; 0xb43
2000e6d6:	4872      	ldr	r0, [pc, #456]	; (2000e8a0 <HAL_I2C_Mem_Read_DMA+0x1f4>)
2000e6d8:	f7f2 f90c 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2000e6dc:	68fb      	ldr	r3, [r7, #12]
2000e6de:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000e6e2:	b2db      	uxtb	r3, r3
2000e6e4:	2b20      	cmp	r3, #32
2000e6e6:	f040 80d5 	bne.w	2000e894 <HAL_I2C_Mem_Read_DMA+0x1e8>
  {
    if ((pData == NULL) || (Size == 0U))
2000e6ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000e6ec:	2b00      	cmp	r3, #0
2000e6ee:	d002      	beq.n	2000e6f6 <HAL_I2C_Mem_Read_DMA+0x4a>
2000e6f0:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
2000e6f2:	2b00      	cmp	r3, #0
2000e6f4:	d105      	bne.n	2000e702 <HAL_I2C_Mem_Read_DMA+0x56>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000e6f6:	68fb      	ldr	r3, [r7, #12]
2000e6f8:	f44f 7200 	mov.w	r2, #512	; 0x200
2000e6fc:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000e6fe:	2301      	movs	r3, #1
2000e700:	e0c9      	b.n	2000e896 <HAL_I2C_Mem_Read_DMA+0x1ea>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2000e702:	68fb      	ldr	r3, [r7, #12]
2000e704:	681b      	ldr	r3, [r3, #0]
2000e706:	699b      	ldr	r3, [r3, #24]
2000e708:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000e70c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000e710:	d101      	bne.n	2000e716 <HAL_I2C_Mem_Read_DMA+0x6a>
    {
      return HAL_BUSY;
2000e712:	2302      	movs	r3, #2
2000e714:	e0bf      	b.n	2000e896 <HAL_I2C_Mem_Read_DMA+0x1ea>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000e716:	68fb      	ldr	r3, [r7, #12]
2000e718:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000e71c:	2b01      	cmp	r3, #1
2000e71e:	d101      	bne.n	2000e724 <HAL_I2C_Mem_Read_DMA+0x78>
2000e720:	2302      	movs	r3, #2
2000e722:	e0b8      	b.n	2000e896 <HAL_I2C_Mem_Read_DMA+0x1ea>
2000e724:	68fb      	ldr	r3, [r7, #12]
2000e726:	2201      	movs	r2, #1
2000e728:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000e72c:	f7f3 fade 	bl	20001cec <HAL_GetTick>
2000e730:	61b8      	str	r0, [r7, #24]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2000e732:	68fb      	ldr	r3, [r7, #12]
2000e734:	2222      	movs	r2, #34	; 0x22
2000e736:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2000e73a:	68fb      	ldr	r3, [r7, #12]
2000e73c:	2240      	movs	r2, #64	; 0x40
2000e73e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000e742:	68fb      	ldr	r3, [r7, #12]
2000e744:	2200      	movs	r2, #0
2000e746:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000e748:	68fb      	ldr	r3, [r7, #12]
2000e74a:	6aba      	ldr	r2, [r7, #40]	; 0x28
2000e74c:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000e74e:	68fb      	ldr	r3, [r7, #12]
2000e750:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
2000e752:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000e754:	68fb      	ldr	r3, [r7, #12]
2000e756:	4a53      	ldr	r2, [pc, #332]	; (2000e8a4 <HAL_I2C_Mem_Read_DMA+0x1f8>)
2000e758:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2000e75a:	68fb      	ldr	r3, [r7, #12]
2000e75c:	4a52      	ldr	r2, [pc, #328]	; (2000e8a8 <HAL_I2C_Mem_Read_DMA+0x1fc>)
2000e75e:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000e760:	68fb      	ldr	r3, [r7, #12]
2000e762:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e764:	b29b      	uxth	r3, r3
2000e766:	2bff      	cmp	r3, #255	; 0xff
2000e768:	d906      	bls.n	2000e778 <HAL_I2C_Mem_Read_DMA+0xcc>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000e76a:	68fb      	ldr	r3, [r7, #12]
2000e76c:	22ff      	movs	r2, #255	; 0xff
2000e76e:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000e770:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000e774:	61fb      	str	r3, [r7, #28]
2000e776:	e007      	b.n	2000e788 <HAL_I2C_Mem_Read_DMA+0xdc>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000e778:	68fb      	ldr	r3, [r7, #12]
2000e77a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e77c:	b29a      	uxth	r2, r3
2000e77e:	68fb      	ldr	r3, [r7, #12]
2000e780:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2000e782:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000e786:	61fb      	str	r3, [r7, #28]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2000e788:	88f8      	ldrh	r0, [r7, #6]
2000e78a:	893a      	ldrh	r2, [r7, #8]
2000e78c:	8979      	ldrh	r1, [r7, #10]
2000e78e:	69bb      	ldr	r3, [r7, #24]
2000e790:	9301      	str	r3, [sp, #4]
2000e792:	2319      	movs	r3, #25
2000e794:	9300      	str	r3, [sp, #0]
2000e796:	4603      	mov	r3, r0
2000e798:	68f8      	ldr	r0, [r7, #12]
2000e79a:	f002 f87d 	bl	20010898 <I2C_RequestMemoryRead>
2000e79e:	4603      	mov	r3, r0
2000e7a0:	2b00      	cmp	r3, #0
2000e7a2:	d005      	beq.n	2000e7b0 <HAL_I2C_Mem_Read_DMA+0x104>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000e7a4:	68fb      	ldr	r3, [r7, #12]
2000e7a6:	2200      	movs	r2, #0
2000e7a8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000e7ac:	2301      	movs	r3, #1
2000e7ae:	e072      	b.n	2000e896 <HAL_I2C_Mem_Read_DMA+0x1ea>
    }

    if (hi2c->hdmarx != NULL)
2000e7b0:	68fb      	ldr	r3, [r7, #12]
2000e7b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000e7b4:	2b00      	cmp	r3, #0
2000e7b6:	d020      	beq.n	2000e7fa <HAL_I2C_Mem_Read_DMA+0x14e>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2000e7b8:	68fb      	ldr	r3, [r7, #12]
2000e7ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000e7bc:	4a3b      	ldr	r2, [pc, #236]	; (2000e8ac <HAL_I2C_Mem_Read_DMA+0x200>)
2000e7be:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2000e7c0:	68fb      	ldr	r3, [r7, #12]
2000e7c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000e7c4:	4a3a      	ldr	r2, [pc, #232]	; (2000e8b0 <HAL_I2C_Mem_Read_DMA+0x204>)
2000e7c6:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2000e7c8:	68fb      	ldr	r3, [r7, #12]
2000e7ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000e7cc:	2200      	movs	r2, #0
2000e7ce:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2000e7d0:	68fb      	ldr	r3, [r7, #12]
2000e7d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000e7d4:	2200      	movs	r2, #0
2000e7d6:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2000e7d8:	68fb      	ldr	r3, [r7, #12]
2000e7da:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2000e7dc:	68fb      	ldr	r3, [r7, #12]
2000e7de:	681b      	ldr	r3, [r3, #0]
2000e7e0:	3324      	adds	r3, #36	; 0x24
2000e7e2:	4619      	mov	r1, r3
2000e7e4:	6aba      	ldr	r2, [r7, #40]	; 0x28
2000e7e6:	68fb      	ldr	r3, [r7, #12]
2000e7e8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e7ea:	f7f6 f861 	bl	200048b0 <HAL_DMA_Start_IT>
2000e7ee:	4603      	mov	r3, r0
2000e7f0:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2000e7f2:	7dfb      	ldrb	r3, [r7, #23]
2000e7f4:	2b00      	cmp	r3, #0
2000e7f6:	d139      	bne.n	2000e86c <HAL_I2C_Mem_Read_DMA+0x1c0>
2000e7f8:	e013      	b.n	2000e822 <HAL_I2C_Mem_Read_DMA+0x176>
      hi2c->State     = HAL_I2C_STATE_READY;
2000e7fa:	68fb      	ldr	r3, [r7, #12]
2000e7fc:	2220      	movs	r2, #32
2000e7fe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000e802:	68fb      	ldr	r3, [r7, #12]
2000e804:	2200      	movs	r2, #0
2000e806:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2000e80a:	68fb      	ldr	r3, [r7, #12]
2000e80c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000e80e:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2000e812:	68fb      	ldr	r3, [r7, #12]
2000e814:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000e816:	68fb      	ldr	r3, [r7, #12]
2000e818:	2200      	movs	r2, #0
2000e81a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000e81e:	2301      	movs	r3, #1
2000e820:	e039      	b.n	2000e896 <HAL_I2C_Mem_Read_DMA+0x1ea>
    {
      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2000e822:	68fb      	ldr	r3, [r7, #12]
2000e824:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e826:	b2da      	uxtb	r2, r3
2000e828:	8979      	ldrh	r1, [r7, #10]
2000e82a:	4b22      	ldr	r3, [pc, #136]	; (2000e8b4 <HAL_I2C_Mem_Read_DMA+0x208>)
2000e82c:	9300      	str	r3, [sp, #0]
2000e82e:	69fb      	ldr	r3, [r7, #28]
2000e830:	68f8      	ldr	r0, [r7, #12]
2000e832:	f003 fa23 	bl	20011c7c <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2000e836:	68fb      	ldr	r3, [r7, #12]
2000e838:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000e83a:	b29a      	uxth	r2, r3
2000e83c:	68fb      	ldr	r3, [r7, #12]
2000e83e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000e840:	1ad3      	subs	r3, r2, r3
2000e842:	b29a      	uxth	r2, r3
2000e844:	68fb      	ldr	r3, [r7, #12]
2000e846:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000e848:	68fb      	ldr	r3, [r7, #12]
2000e84a:	2200      	movs	r2, #0
2000e84c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR and NACK interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2000e850:	2110      	movs	r1, #16
2000e852:	68f8      	ldr	r0, [r7, #12]
2000e854:	f003 fa8a 	bl	20011d6c <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2000e858:	68fb      	ldr	r3, [r7, #12]
2000e85a:	681b      	ldr	r3, [r3, #0]
2000e85c:	681a      	ldr	r2, [r3, #0]
2000e85e:	68fb      	ldr	r3, [r7, #12]
2000e860:	681b      	ldr	r3, [r3, #0]
2000e862:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000e866:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2000e868:	2300      	movs	r3, #0
2000e86a:	e014      	b.n	2000e896 <HAL_I2C_Mem_Read_DMA+0x1ea>
      hi2c->State     = HAL_I2C_STATE_READY;
2000e86c:	68fb      	ldr	r3, [r7, #12]
2000e86e:	2220      	movs	r2, #32
2000e870:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000e874:	68fb      	ldr	r3, [r7, #12]
2000e876:	2200      	movs	r2, #0
2000e878:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000e87c:	68fb      	ldr	r3, [r7, #12]
2000e87e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000e880:	f043 0210 	orr.w	r2, r3, #16
2000e884:	68fb      	ldr	r3, [r7, #12]
2000e886:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000e888:	68fb      	ldr	r3, [r7, #12]
2000e88a:	2200      	movs	r2, #0
2000e88c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000e890:	2301      	movs	r3, #1
2000e892:	e000      	b.n	2000e896 <HAL_I2C_Mem_Read_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
2000e894:	2302      	movs	r3, #2
  }
}
2000e896:	4618      	mov	r0, r3
2000e898:	3720      	adds	r7, #32
2000e89a:	46bd      	mov	sp, r7
2000e89c:	bd80      	pop	{r7, pc}
2000e89e:	bf00      	nop
2000e8a0:	2001c180 	.word	0x2001c180
2000e8a4:	ffff0000 	.word	0xffff0000
2000e8a8:	2001024b 	.word	0x2001024b
2000e8ac:	200114b9 	.word	0x200114b9
2000e8b0:	200116b5 	.word	0x200116b5
2000e8b4:	80002400 	.word	0x80002400

2000e8b8 <HAL_I2C_IsDeviceReady>:
  * @param  Trials Number of trials
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
{
2000e8b8:	b580      	push	{r7, lr}
2000e8ba:	b08a      	sub	sp, #40	; 0x28
2000e8bc:	af02      	add	r7, sp, #8
2000e8be:	60f8      	str	r0, [r7, #12]
2000e8c0:	607a      	str	r2, [r7, #4]
2000e8c2:	603b      	str	r3, [r7, #0]
2000e8c4:	460b      	mov	r3, r1
2000e8c6:	817b      	strh	r3, [r7, #10]
  uint32_t tickstart;

  __IO uint32_t I2C_Trials = 0UL;
2000e8c8:	2300      	movs	r3, #0
2000e8ca:	617b      	str	r3, [r7, #20]

  FlagStatus tmp1;
  FlagStatus tmp2;

  if (hi2c->State == HAL_I2C_STATE_READY)
2000e8cc:	68fb      	ldr	r3, [r7, #12]
2000e8ce:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000e8d2:	b2db      	uxtb	r3, r3
2000e8d4:	2b20      	cmp	r3, #32
2000e8d6:	f040 80ef 	bne.w	2000eab8 <HAL_I2C_IsDeviceReady+0x200>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2000e8da:	68fb      	ldr	r3, [r7, #12]
2000e8dc:	681b      	ldr	r3, [r3, #0]
2000e8de:	699b      	ldr	r3, [r3, #24]
2000e8e0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000e8e4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000e8e8:	d101      	bne.n	2000e8ee <HAL_I2C_IsDeviceReady+0x36>
    {
      return HAL_BUSY;
2000e8ea:	2302      	movs	r3, #2
2000e8ec:	e0e5      	b.n	2000eaba <HAL_I2C_IsDeviceReady+0x202>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000e8ee:	68fb      	ldr	r3, [r7, #12]
2000e8f0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000e8f4:	2b01      	cmp	r3, #1
2000e8f6:	d101      	bne.n	2000e8fc <HAL_I2C_IsDeviceReady+0x44>
2000e8f8:	2302      	movs	r3, #2
2000e8fa:	e0de      	b.n	2000eaba <HAL_I2C_IsDeviceReady+0x202>
2000e8fc:	68fb      	ldr	r3, [r7, #12]
2000e8fe:	2201      	movs	r2, #1
2000e900:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2000e904:	68fb      	ldr	r3, [r7, #12]
2000e906:	2224      	movs	r2, #36	; 0x24
2000e908:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000e90c:	68fb      	ldr	r3, [r7, #12]
2000e90e:	2200      	movs	r2, #0
2000e910:	645a      	str	r2, [r3, #68]	; 0x44

    do
    {
      /* Generate Start */
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
2000e912:	68fb      	ldr	r3, [r7, #12]
2000e914:	68db      	ldr	r3, [r3, #12]
2000e916:	2b01      	cmp	r3, #1
2000e918:	d105      	bne.n	2000e926 <HAL_I2C_IsDeviceReady+0x6e>
2000e91a:	897b      	ldrh	r3, [r7, #10]
2000e91c:	f3c3 0209 	ubfx	r2, r3, #0, #10
2000e920:	4b68      	ldr	r3, [pc, #416]	; (2000eac4 <HAL_I2C_IsDeviceReady+0x20c>)
2000e922:	4313      	orrs	r3, r2
2000e924:	e004      	b.n	2000e930 <HAL_I2C_IsDeviceReady+0x78>
2000e926:	897b      	ldrh	r3, [r7, #10]
2000e928:	f3c3 0309 	ubfx	r3, r3, #0, #10
2000e92c:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
2000e930:	68fa      	ldr	r2, [r7, #12]
2000e932:	6812      	ldr	r2, [r2, #0]
2000e934:	6053      	str	r3, [r2, #4]

      /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
      /* Wait until STOPF flag is set or a NACK flag is set*/
      tickstart = HAL_GetTick();
2000e936:	f7f3 f9d9 	bl	20001cec <HAL_GetTick>
2000e93a:	61b8      	str	r0, [r7, #24]

      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2000e93c:	68fb      	ldr	r3, [r7, #12]
2000e93e:	681b      	ldr	r3, [r3, #0]
2000e940:	699b      	ldr	r3, [r3, #24]
2000e942:	f003 0320 	and.w	r3, r3, #32
2000e946:	2b20      	cmp	r3, #32
2000e948:	bf0c      	ite	eq
2000e94a:	2301      	moveq	r3, #1
2000e94c:	2300      	movne	r3, #0
2000e94e:	b2db      	uxtb	r3, r3
2000e950:	77fb      	strb	r3, [r7, #31]
      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2000e952:	68fb      	ldr	r3, [r7, #12]
2000e954:	681b      	ldr	r3, [r3, #0]
2000e956:	699b      	ldr	r3, [r3, #24]
2000e958:	f003 0310 	and.w	r3, r3, #16
2000e95c:	2b10      	cmp	r3, #16
2000e95e:	bf0c      	ite	eq
2000e960:	2301      	moveq	r3, #1
2000e962:	2300      	movne	r3, #0
2000e964:	b2db      	uxtb	r3, r3
2000e966:	77bb      	strb	r3, [r7, #30]

      while ((tmp1 == RESET) && (tmp2 == RESET))
2000e968:	e034      	b.n	2000e9d4 <HAL_I2C_IsDeviceReady+0x11c>
      {
        if (Timeout != HAL_MAX_DELAY)
2000e96a:	683b      	ldr	r3, [r7, #0]
2000e96c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
2000e970:	d01a      	beq.n	2000e9a8 <HAL_I2C_IsDeviceReady+0xf0>
        {
          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2000e972:	f7f3 f9bb 	bl	20001cec <HAL_GetTick>
2000e976:	4602      	mov	r2, r0
2000e978:	69bb      	ldr	r3, [r7, #24]
2000e97a:	1ad3      	subs	r3, r2, r3
2000e97c:	683a      	ldr	r2, [r7, #0]
2000e97e:	429a      	cmp	r2, r3
2000e980:	d302      	bcc.n	2000e988 <HAL_I2C_IsDeviceReady+0xd0>
2000e982:	683b      	ldr	r3, [r7, #0]
2000e984:	2b00      	cmp	r3, #0
2000e986:	d10f      	bne.n	2000e9a8 <HAL_I2C_IsDeviceReady+0xf0>
          {
            /* Update I2C state */
            hi2c->State = HAL_I2C_STATE_READY;
2000e988:	68fb      	ldr	r3, [r7, #12]
2000e98a:	2220      	movs	r2, #32
2000e98c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

            /* Update I2C error code */
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2000e990:	68fb      	ldr	r3, [r7, #12]
2000e992:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000e994:	f043 0220 	orr.w	r2, r3, #32
2000e998:	68fb      	ldr	r3, [r7, #12]
2000e99a:	645a      	str	r2, [r3, #68]	; 0x44

            /* Process Unlocked */
            __HAL_UNLOCK(hi2c);
2000e99c:	68fb      	ldr	r3, [r7, #12]
2000e99e:	2200      	movs	r2, #0
2000e9a0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

            return HAL_ERROR;
2000e9a4:	2301      	movs	r3, #1
2000e9a6:	e088      	b.n	2000eaba <HAL_I2C_IsDeviceReady+0x202>
          }
        }

        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2000e9a8:	68fb      	ldr	r3, [r7, #12]
2000e9aa:	681b      	ldr	r3, [r3, #0]
2000e9ac:	699b      	ldr	r3, [r3, #24]
2000e9ae:	f003 0320 	and.w	r3, r3, #32
2000e9b2:	2b20      	cmp	r3, #32
2000e9b4:	bf0c      	ite	eq
2000e9b6:	2301      	moveq	r3, #1
2000e9b8:	2300      	movne	r3, #0
2000e9ba:	b2db      	uxtb	r3, r3
2000e9bc:	77fb      	strb	r3, [r7, #31]
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2000e9be:	68fb      	ldr	r3, [r7, #12]
2000e9c0:	681b      	ldr	r3, [r3, #0]
2000e9c2:	699b      	ldr	r3, [r3, #24]
2000e9c4:	f003 0310 	and.w	r3, r3, #16
2000e9c8:	2b10      	cmp	r3, #16
2000e9ca:	bf0c      	ite	eq
2000e9cc:	2301      	moveq	r3, #1
2000e9ce:	2300      	movne	r3, #0
2000e9d0:	b2db      	uxtb	r3, r3
2000e9d2:	77bb      	strb	r3, [r7, #30]
      while ((tmp1 == RESET) && (tmp2 == RESET))
2000e9d4:	7ffb      	ldrb	r3, [r7, #31]
2000e9d6:	2b00      	cmp	r3, #0
2000e9d8:	d102      	bne.n	2000e9e0 <HAL_I2C_IsDeviceReady+0x128>
2000e9da:	7fbb      	ldrb	r3, [r7, #30]
2000e9dc:	2b00      	cmp	r3, #0
2000e9de:	d0c4      	beq.n	2000e96a <HAL_I2C_IsDeviceReady+0xb2>
      }

      /* Check if the NACKF flag has not been set */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
2000e9e0:	68fb      	ldr	r3, [r7, #12]
2000e9e2:	681b      	ldr	r3, [r3, #0]
2000e9e4:	699b      	ldr	r3, [r3, #24]
2000e9e6:	f003 0310 	and.w	r3, r3, #16
2000e9ea:	2b10      	cmp	r3, #16
2000e9ec:	d01a      	beq.n	2000ea24 <HAL_I2C_IsDeviceReady+0x16c>
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2000e9ee:	69bb      	ldr	r3, [r7, #24]
2000e9f0:	9300      	str	r3, [sp, #0]
2000e9f2:	683b      	ldr	r3, [r7, #0]
2000e9f4:	2200      	movs	r2, #0
2000e9f6:	2120      	movs	r1, #32
2000e9f8:	68f8      	ldr	r0, [r7, #12]
2000e9fa:	f002 ffb1 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000e9fe:	4603      	mov	r3, r0
2000ea00:	2b00      	cmp	r3, #0
2000ea02:	d001      	beq.n	2000ea08 <HAL_I2C_IsDeviceReady+0x150>
        {
          return HAL_ERROR;
2000ea04:	2301      	movs	r3, #1
2000ea06:	e058      	b.n	2000eaba <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000ea08:	68fb      	ldr	r3, [r7, #12]
2000ea0a:	681b      	ldr	r3, [r3, #0]
2000ea0c:	2220      	movs	r2, #32
2000ea0e:	61da      	str	r2, [r3, #28]

        /* Device is ready */
        hi2c->State = HAL_I2C_STATE_READY;
2000ea10:	68fb      	ldr	r3, [r7, #12]
2000ea12:	2220      	movs	r2, #32
2000ea14:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000ea18:	68fb      	ldr	r3, [r7, #12]
2000ea1a:	2200      	movs	r2, #0
2000ea1c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_OK;
2000ea20:	2300      	movs	r3, #0
2000ea22:	e04a      	b.n	2000eaba <HAL_I2C_IsDeviceReady+0x202>
      }
      else
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2000ea24:	69bb      	ldr	r3, [r7, #24]
2000ea26:	9300      	str	r3, [sp, #0]
2000ea28:	683b      	ldr	r3, [r7, #0]
2000ea2a:	2200      	movs	r2, #0
2000ea2c:	2120      	movs	r1, #32
2000ea2e:	68f8      	ldr	r0, [r7, #12]
2000ea30:	f002 ff96 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000ea34:	4603      	mov	r3, r0
2000ea36:	2b00      	cmp	r3, #0
2000ea38:	d001      	beq.n	2000ea3e <HAL_I2C_IsDeviceReady+0x186>
        {
          return HAL_ERROR;
2000ea3a:	2301      	movs	r3, #1
2000ea3c:	e03d      	b.n	2000eaba <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2000ea3e:	68fb      	ldr	r3, [r7, #12]
2000ea40:	681b      	ldr	r3, [r3, #0]
2000ea42:	2210      	movs	r2, #16
2000ea44:	61da      	str	r2, [r3, #28]

        /* Clear STOP Flag, auto generated with autoend*/
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000ea46:	68fb      	ldr	r3, [r7, #12]
2000ea48:	681b      	ldr	r3, [r3, #0]
2000ea4a:	2220      	movs	r2, #32
2000ea4c:	61da      	str	r2, [r3, #28]
      }

      /* Check if the maximum allowed number of trials has been reached */
      if (I2C_Trials == Trials)
2000ea4e:	697b      	ldr	r3, [r7, #20]
2000ea50:	687a      	ldr	r2, [r7, #4]
2000ea52:	429a      	cmp	r2, r3
2000ea54:	d118      	bne.n	2000ea88 <HAL_I2C_IsDeviceReady+0x1d0>
      {
        /* Generate Stop */
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
2000ea56:	68fb      	ldr	r3, [r7, #12]
2000ea58:	681b      	ldr	r3, [r3, #0]
2000ea5a:	685a      	ldr	r2, [r3, #4]
2000ea5c:	68fb      	ldr	r3, [r7, #12]
2000ea5e:	681b      	ldr	r3, [r3, #0]
2000ea60:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2000ea64:	605a      	str	r2, [r3, #4]

        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2000ea66:	69bb      	ldr	r3, [r7, #24]
2000ea68:	9300      	str	r3, [sp, #0]
2000ea6a:	683b      	ldr	r3, [r7, #0]
2000ea6c:	2200      	movs	r2, #0
2000ea6e:	2120      	movs	r1, #32
2000ea70:	68f8      	ldr	r0, [r7, #12]
2000ea72:	f002 ff75 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
2000ea76:	4603      	mov	r3, r0
2000ea78:	2b00      	cmp	r3, #0
2000ea7a:	d001      	beq.n	2000ea80 <HAL_I2C_IsDeviceReady+0x1c8>
        {
          return HAL_ERROR;
2000ea7c:	2301      	movs	r3, #1
2000ea7e:	e01c      	b.n	2000eaba <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000ea80:	68fb      	ldr	r3, [r7, #12]
2000ea82:	681b      	ldr	r3, [r3, #0]
2000ea84:	2220      	movs	r2, #32
2000ea86:	61da      	str	r2, [r3, #28]
      }

      /* Increment Trials */
      I2C_Trials++;
2000ea88:	697b      	ldr	r3, [r7, #20]
2000ea8a:	3301      	adds	r3, #1
2000ea8c:	617b      	str	r3, [r7, #20]
    }
    while (I2C_Trials < Trials);
2000ea8e:	697b      	ldr	r3, [r7, #20]
2000ea90:	687a      	ldr	r2, [r7, #4]
2000ea92:	429a      	cmp	r2, r3
2000ea94:	f63f af3d 	bhi.w	2000e912 <HAL_I2C_IsDeviceReady+0x5a>

    /* Update I2C state */
    hi2c->State = HAL_I2C_STATE_READY;
2000ea98:	68fb      	ldr	r3, [r7, #12]
2000ea9a:	2220      	movs	r2, #32
2000ea9c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Update I2C error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2000eaa0:	68fb      	ldr	r3, [r7, #12]
2000eaa2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000eaa4:	f043 0220 	orr.w	r2, r3, #32
2000eaa8:	68fb      	ldr	r3, [r7, #12]
2000eaaa:	645a      	str	r2, [r3, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000eaac:	68fb      	ldr	r3, [r7, #12]
2000eaae:	2200      	movs	r2, #0
2000eab0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
2000eab4:	2301      	movs	r3, #1
2000eab6:	e000      	b.n	2000eaba <HAL_I2C_IsDeviceReady+0x202>
  }
  else
  {
    return HAL_BUSY;
2000eab8:	2302      	movs	r3, #2
  }
}
2000eaba:	4618      	mov	r0, r3
2000eabc:	3720      	adds	r7, #32
2000eabe:	46bd      	mov	sp, r7
2000eac0:	bd80      	pop	{r7, pc}
2000eac2:	bf00      	nop
2000eac4:	02002000 	.word	0x02002000

2000eac8 <HAL_I2C_Master_Seq_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2000eac8:	b580      	push	{r7, lr}
2000eaca:	b088      	sub	sp, #32
2000eacc:	af02      	add	r7, sp, #8
2000eace:	60f8      	str	r0, [r7, #12]
2000ead0:	607a      	str	r2, [r7, #4]
2000ead2:	461a      	mov	r2, r3
2000ead4:	460b      	mov	r3, r1
2000ead6:	817b      	strh	r3, [r7, #10]
2000ead8:	4613      	mov	r3, r2
2000eada:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
2000eadc:	4b4b      	ldr	r3, [pc, #300]	; (2000ec0c <HAL_I2C_Master_Seq_Transmit_IT+0x144>)
2000eade:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
2000eae0:	6a3b      	ldr	r3, [r7, #32]
2000eae2:	2b00      	cmp	r3, #0
2000eae4:	d01e      	beq.n	2000eb24 <HAL_I2C_Master_Seq_Transmit_IT+0x5c>
2000eae6:	6a3b      	ldr	r3, [r7, #32]
2000eae8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000eaec:	d01a      	beq.n	2000eb24 <HAL_I2C_Master_Seq_Transmit_IT+0x5c>
2000eaee:	6a3b      	ldr	r3, [r7, #32]
2000eaf0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000eaf4:	d016      	beq.n	2000eb24 <HAL_I2C_Master_Seq_Transmit_IT+0x5c>
2000eaf6:	6a3b      	ldr	r3, [r7, #32]
2000eaf8:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000eafc:	d012      	beq.n	2000eb24 <HAL_I2C_Master_Seq_Transmit_IT+0x5c>
2000eafe:	6a3b      	ldr	r3, [r7, #32]
2000eb00:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000eb04:	d00e      	beq.n	2000eb24 <HAL_I2C_Master_Seq_Transmit_IT+0x5c>
2000eb06:	6a3b      	ldr	r3, [r7, #32]
2000eb08:	2b00      	cmp	r3, #0
2000eb0a:	d00b      	beq.n	2000eb24 <HAL_I2C_Master_Seq_Transmit_IT+0x5c>
2000eb0c:	6a3b      	ldr	r3, [r7, #32]
2000eb0e:	2baa      	cmp	r3, #170	; 0xaa
2000eb10:	d008      	beq.n	2000eb24 <HAL_I2C_Master_Seq_Transmit_IT+0x5c>
2000eb12:	6a3b      	ldr	r3, [r7, #32]
2000eb14:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000eb18:	d004      	beq.n	2000eb24 <HAL_I2C_Master_Seq_Transmit_IT+0x5c>
2000eb1a:	f640 415d 	movw	r1, #3165	; 0xc5d
2000eb1e:	483c      	ldr	r0, [pc, #240]	; (2000ec10 <HAL_I2C_Master_Seq_Transmit_IT+0x148>)
2000eb20:	f7f1 fee8 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2000eb24:	68fb      	ldr	r3, [r7, #12]
2000eb26:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000eb2a:	b2db      	uxtb	r3, r3
2000eb2c:	2b20      	cmp	r3, #32
2000eb2e:	d167      	bne.n	2000ec00 <HAL_I2C_Master_Seq_Transmit_IT+0x138>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000eb30:	68fb      	ldr	r3, [r7, #12]
2000eb32:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000eb36:	2b01      	cmp	r3, #1
2000eb38:	d101      	bne.n	2000eb3e <HAL_I2C_Master_Seq_Transmit_IT+0x76>
2000eb3a:	2302      	movs	r3, #2
2000eb3c:	e061      	b.n	2000ec02 <HAL_I2C_Master_Seq_Transmit_IT+0x13a>
2000eb3e:	68fb      	ldr	r3, [r7, #12]
2000eb40:	2201      	movs	r2, #1
2000eb42:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2000eb46:	68fb      	ldr	r3, [r7, #12]
2000eb48:	2221      	movs	r2, #33	; 0x21
2000eb4a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2000eb4e:	68fb      	ldr	r3, [r7, #12]
2000eb50:	2210      	movs	r2, #16
2000eb52:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000eb56:	68fb      	ldr	r3, [r7, #12]
2000eb58:	2200      	movs	r2, #0
2000eb5a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000eb5c:	68fb      	ldr	r3, [r7, #12]
2000eb5e:	687a      	ldr	r2, [r7, #4]
2000eb60:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000eb62:	68fb      	ldr	r3, [r7, #12]
2000eb64:	893a      	ldrh	r2, [r7, #8]
2000eb66:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2000eb68:	68fb      	ldr	r3, [r7, #12]
2000eb6a:	6a3a      	ldr	r2, [r7, #32]
2000eb6c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2000eb6e:	68fb      	ldr	r3, [r7, #12]
2000eb70:	4a28      	ldr	r2, [pc, #160]	; (2000ec14 <HAL_I2C_Master_Seq_Transmit_IT+0x14c>)
2000eb72:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000eb74:	68fb      	ldr	r3, [r7, #12]
2000eb76:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000eb78:	b29b      	uxth	r3, r3
2000eb7a:	2bff      	cmp	r3, #255	; 0xff
2000eb7c:	d906      	bls.n	2000eb8c <HAL_I2C_Master_Seq_Transmit_IT+0xc4>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000eb7e:	68fb      	ldr	r3, [r7, #12]
2000eb80:	22ff      	movs	r2, #255	; 0xff
2000eb82:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000eb84:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000eb88:	617b      	str	r3, [r7, #20]
2000eb8a:	e007      	b.n	2000eb9c <HAL_I2C_Master_Seq_Transmit_IT+0xd4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000eb8c:	68fb      	ldr	r3, [r7, #12]
2000eb8e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000eb90:	b29a      	uxth	r2, r3
2000eb92:	68fb      	ldr	r3, [r7, #12]
2000eb94:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2000eb96:	68fb      	ldr	r3, [r7, #12]
2000eb98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000eb9a:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2000eb9c:	68fb      	ldr	r3, [r7, #12]
2000eb9e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000eba0:	2b11      	cmp	r3, #17
2000eba2:	d10e      	bne.n	2000ebc2 <HAL_I2C_Master_Seq_Transmit_IT+0xfa>
2000eba4:	6a3b      	ldr	r3, [r7, #32]
2000eba6:	2baa      	cmp	r3, #170	; 0xaa
2000eba8:	d003      	beq.n	2000ebb2 <HAL_I2C_Master_Seq_Transmit_IT+0xea>
2000ebaa:	6a3b      	ldr	r3, [r7, #32]
2000ebac:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000ebb0:	d101      	bne.n	2000ebb6 <HAL_I2C_Master_Seq_Transmit_IT+0xee>
2000ebb2:	2301      	movs	r3, #1
2000ebb4:	e000      	b.n	2000ebb8 <HAL_I2C_Master_Seq_Transmit_IT+0xf0>
2000ebb6:	2300      	movs	r3, #0
2000ebb8:	2b00      	cmp	r3, #0
2000ebba:	d102      	bne.n	2000ebc2 <HAL_I2C_Master_Seq_Transmit_IT+0xfa>
    {
      xferrequest = I2C_NO_STARTSTOP;
2000ebbc:	2300      	movs	r3, #0
2000ebbe:	613b      	str	r3, [r7, #16]
2000ebc0:	e00a      	b.n	2000ebd8 <HAL_I2C_Master_Seq_Transmit_IT+0x110>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2000ebc2:	68f8      	ldr	r0, [r7, #12]
2000ebc4:	f003 f994 	bl	20011ef0 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2000ebc8:	68fb      	ldr	r3, [r7, #12]
2000ebca:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ebcc:	b29b      	uxth	r3, r3
2000ebce:	2bfe      	cmp	r3, #254	; 0xfe
2000ebd0:	d802      	bhi.n	2000ebd8 <HAL_I2C_Master_Seq_Transmit_IT+0x110>
      {
        xfermode = hi2c->XferOptions;
2000ebd2:	68fb      	ldr	r3, [r7, #12]
2000ebd4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000ebd6:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to write */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2000ebd8:	68fb      	ldr	r3, [r7, #12]
2000ebda:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ebdc:	b2da      	uxtb	r2, r3
2000ebde:	8979      	ldrh	r1, [r7, #10]
2000ebe0:	693b      	ldr	r3, [r7, #16]
2000ebe2:	9300      	str	r3, [sp, #0]
2000ebe4:	697b      	ldr	r3, [r7, #20]
2000ebe6:	68f8      	ldr	r0, [r7, #12]
2000ebe8:	f003 f848 	bl	20011c7c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000ebec:	68fb      	ldr	r3, [r7, #12]
2000ebee:	2200      	movs	r2, #0
2000ebf0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2000ebf4:	2101      	movs	r1, #1
2000ebf6:	68f8      	ldr	r0, [r7, #12]
2000ebf8:	f003 f8b8 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000ebfc:	2300      	movs	r3, #0
2000ebfe:	e000      	b.n	2000ec02 <HAL_I2C_Master_Seq_Transmit_IT+0x13a>
  }
  else
  {
    return HAL_BUSY;
2000ec00:	2302      	movs	r3, #2
  }
}
2000ec02:	4618      	mov	r0, r3
2000ec04:	3718      	adds	r7, #24
2000ec06:	46bd      	mov	sp, r7
2000ec08:	bd80      	pop	{r7, pc}
2000ec0a:	bf00      	nop
2000ec0c:	80002000 	.word	0x80002000
2000ec10:	2001c180 	.word	0x2001c180
2000ec14:	2000fdf3 	.word	0x2000fdf3

2000ec18 <HAL_I2C_Master_Seq_Transmit_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2000ec18:	b580      	push	{r7, lr}
2000ec1a:	b08a      	sub	sp, #40	; 0x28
2000ec1c:	af02      	add	r7, sp, #8
2000ec1e:	60f8      	str	r0, [r7, #12]
2000ec20:	607a      	str	r2, [r7, #4]
2000ec22:	461a      	mov	r2, r3
2000ec24:	460b      	mov	r3, r1
2000ec26:	817b      	strh	r3, [r7, #10]
2000ec28:	4613      	mov	r3, r2
2000ec2a:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
2000ec2c:	4b88      	ldr	r3, [pc, #544]	; (2000ee50 <HAL_I2C_Master_Seq_Transmit_DMA+0x238>)
2000ec2e:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
2000ec30:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000ec32:	2b00      	cmp	r3, #0
2000ec34:	d01e      	beq.n	2000ec74 <HAL_I2C_Master_Seq_Transmit_DMA+0x5c>
2000ec36:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000ec38:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000ec3c:	d01a      	beq.n	2000ec74 <HAL_I2C_Master_Seq_Transmit_DMA+0x5c>
2000ec3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000ec40:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000ec44:	d016      	beq.n	2000ec74 <HAL_I2C_Master_Seq_Transmit_DMA+0x5c>
2000ec46:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000ec48:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000ec4c:	d012      	beq.n	2000ec74 <HAL_I2C_Master_Seq_Transmit_DMA+0x5c>
2000ec4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000ec50:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000ec54:	d00e      	beq.n	2000ec74 <HAL_I2C_Master_Seq_Transmit_DMA+0x5c>
2000ec56:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000ec58:	2b00      	cmp	r3, #0
2000ec5a:	d00b      	beq.n	2000ec74 <HAL_I2C_Master_Seq_Transmit_DMA+0x5c>
2000ec5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000ec5e:	2baa      	cmp	r3, #170	; 0xaa
2000ec60:	d008      	beq.n	2000ec74 <HAL_I2C_Master_Seq_Transmit_DMA+0x5c>
2000ec62:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000ec64:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000ec68:	d004      	beq.n	2000ec74 <HAL_I2C_Master_Seq_Transmit_DMA+0x5c>
2000ec6a:	f640 41b2 	movw	r1, #3250	; 0xcb2
2000ec6e:	4879      	ldr	r0, [pc, #484]	; (2000ee54 <HAL_I2C_Master_Seq_Transmit_DMA+0x23c>)
2000ec70:	f7f1 fe40 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2000ec74:	68fb      	ldr	r3, [r7, #12]
2000ec76:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000ec7a:	b2db      	uxtb	r3, r3
2000ec7c:	2b20      	cmp	r3, #32
2000ec7e:	f040 80e1 	bne.w	2000ee44 <HAL_I2C_Master_Seq_Transmit_DMA+0x22c>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000ec82:	68fb      	ldr	r3, [r7, #12]
2000ec84:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000ec88:	2b01      	cmp	r3, #1
2000ec8a:	d101      	bne.n	2000ec90 <HAL_I2C_Master_Seq_Transmit_DMA+0x78>
2000ec8c:	2302      	movs	r3, #2
2000ec8e:	e0da      	b.n	2000ee46 <HAL_I2C_Master_Seq_Transmit_DMA+0x22e>
2000ec90:	68fb      	ldr	r3, [r7, #12]
2000ec92:	2201      	movs	r2, #1
2000ec94:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2000ec98:	68fb      	ldr	r3, [r7, #12]
2000ec9a:	2221      	movs	r2, #33	; 0x21
2000ec9c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2000eca0:	68fb      	ldr	r3, [r7, #12]
2000eca2:	2210      	movs	r2, #16
2000eca4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000eca8:	68fb      	ldr	r3, [r7, #12]
2000ecaa:	2200      	movs	r2, #0
2000ecac:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000ecae:	68fb      	ldr	r3, [r7, #12]
2000ecb0:	687a      	ldr	r2, [r7, #4]
2000ecb2:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000ecb4:	68fb      	ldr	r3, [r7, #12]
2000ecb6:	893a      	ldrh	r2, [r7, #8]
2000ecb8:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2000ecba:	68fb      	ldr	r3, [r7, #12]
2000ecbc:	6aba      	ldr	r2, [r7, #40]	; 0x28
2000ecbe:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2000ecc0:	68fb      	ldr	r3, [r7, #12]
2000ecc2:	4a65      	ldr	r2, [pc, #404]	; (2000ee58 <HAL_I2C_Master_Seq_Transmit_DMA+0x240>)
2000ecc4:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000ecc6:	68fb      	ldr	r3, [r7, #12]
2000ecc8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ecca:	b29b      	uxth	r3, r3
2000eccc:	2bff      	cmp	r3, #255	; 0xff
2000ecce:	d906      	bls.n	2000ecde <HAL_I2C_Master_Seq_Transmit_DMA+0xc6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000ecd0:	68fb      	ldr	r3, [r7, #12]
2000ecd2:	22ff      	movs	r2, #255	; 0xff
2000ecd4:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000ecd6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000ecda:	61fb      	str	r3, [r7, #28]
2000ecdc:	e007      	b.n	2000ecee <HAL_I2C_Master_Seq_Transmit_DMA+0xd6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000ecde:	68fb      	ldr	r3, [r7, #12]
2000ece0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ece2:	b29a      	uxth	r2, r3
2000ece4:	68fb      	ldr	r3, [r7, #12]
2000ece6:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2000ece8:	68fb      	ldr	r3, [r7, #12]
2000ecea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000ecec:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2000ecee:	68fb      	ldr	r3, [r7, #12]
2000ecf0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000ecf2:	2b11      	cmp	r3, #17
2000ecf4:	d10e      	bne.n	2000ed14 <HAL_I2C_Master_Seq_Transmit_DMA+0xfc>
2000ecf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000ecf8:	2baa      	cmp	r3, #170	; 0xaa
2000ecfa:	d003      	beq.n	2000ed04 <HAL_I2C_Master_Seq_Transmit_DMA+0xec>
2000ecfc:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000ecfe:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000ed02:	d101      	bne.n	2000ed08 <HAL_I2C_Master_Seq_Transmit_DMA+0xf0>
2000ed04:	2301      	movs	r3, #1
2000ed06:	e000      	b.n	2000ed0a <HAL_I2C_Master_Seq_Transmit_DMA+0xf2>
2000ed08:	2300      	movs	r3, #0
2000ed0a:	2b00      	cmp	r3, #0
2000ed0c:	d102      	bne.n	2000ed14 <HAL_I2C_Master_Seq_Transmit_DMA+0xfc>
    {
      xferrequest = I2C_NO_STARTSTOP;
2000ed0e:	2300      	movs	r3, #0
2000ed10:	61bb      	str	r3, [r7, #24]
2000ed12:	e00a      	b.n	2000ed2a <HAL_I2C_Master_Seq_Transmit_DMA+0x112>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2000ed14:	68f8      	ldr	r0, [r7, #12]
2000ed16:	f003 f8eb 	bl	20011ef0 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2000ed1a:	68fb      	ldr	r3, [r7, #12]
2000ed1c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ed1e:	b29b      	uxth	r3, r3
2000ed20:	2bfe      	cmp	r3, #254	; 0xfe
2000ed22:	d802      	bhi.n	2000ed2a <HAL_I2C_Master_Seq_Transmit_DMA+0x112>
      {
        xfermode = hi2c->XferOptions;
2000ed24:	68fb      	ldr	r3, [r7, #12]
2000ed26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000ed28:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2000ed2a:	68fb      	ldr	r3, [r7, #12]
2000ed2c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ed2e:	2b00      	cmp	r3, #0
2000ed30:	d070      	beq.n	2000ee14 <HAL_I2C_Master_Seq_Transmit_DMA+0x1fc>
    {
      if (hi2c->hdmatx != NULL)
2000ed32:	68fb      	ldr	r3, [r7, #12]
2000ed34:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000ed36:	2b00      	cmp	r3, #0
2000ed38:	d020      	beq.n	2000ed7c <HAL_I2C_Master_Seq_Transmit_DMA+0x164>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2000ed3a:	68fb      	ldr	r3, [r7, #12]
2000ed3c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000ed3e:	4a47      	ldr	r2, [pc, #284]	; (2000ee5c <HAL_I2C_Master_Seq_Transmit_DMA+0x244>)
2000ed40:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2000ed42:	68fb      	ldr	r3, [r7, #12]
2000ed44:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000ed46:	4a46      	ldr	r2, [pc, #280]	; (2000ee60 <HAL_I2C_Master_Seq_Transmit_DMA+0x248>)
2000ed48:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
2000ed4a:	68fb      	ldr	r3, [r7, #12]
2000ed4c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000ed4e:	2200      	movs	r2, #0
2000ed50:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
2000ed52:	68fb      	ldr	r3, [r7, #12]
2000ed54:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000ed56:	2200      	movs	r2, #0
2000ed58:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2000ed5a:	68fb      	ldr	r3, [r7, #12]
2000ed5c:	6b98      	ldr	r0, [r3, #56]	; 0x38
2000ed5e:	6879      	ldr	r1, [r7, #4]
2000ed60:	68fb      	ldr	r3, [r7, #12]
2000ed62:	681b      	ldr	r3, [r3, #0]
2000ed64:	3328      	adds	r3, #40	; 0x28
2000ed66:	461a      	mov	r2, r3
2000ed68:	68fb      	ldr	r3, [r7, #12]
2000ed6a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ed6c:	f7f5 fda0 	bl	200048b0 <HAL_DMA_Start_IT>
2000ed70:	4603      	mov	r3, r0
2000ed72:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2000ed74:	7dfb      	ldrb	r3, [r7, #23]
2000ed76:	2b00      	cmp	r3, #0
2000ed78:	d138      	bne.n	2000edec <HAL_I2C_Master_Seq_Transmit_DMA+0x1d4>
2000ed7a:	e013      	b.n	2000eda4 <HAL_I2C_Master_Seq_Transmit_DMA+0x18c>
        hi2c->State     = HAL_I2C_STATE_READY;
2000ed7c:	68fb      	ldr	r3, [r7, #12]
2000ed7e:	2220      	movs	r2, #32
2000ed80:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2000ed84:	68fb      	ldr	r3, [r7, #12]
2000ed86:	2200      	movs	r2, #0
2000ed88:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2000ed8c:	68fb      	ldr	r3, [r7, #12]
2000ed8e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000ed90:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2000ed94:	68fb      	ldr	r3, [r7, #12]
2000ed96:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2000ed98:	68fb      	ldr	r3, [r7, #12]
2000ed9a:	2200      	movs	r2, #0
2000ed9c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2000eda0:	2301      	movs	r3, #1
2000eda2:	e050      	b.n	2000ee46 <HAL_I2C_Master_Seq_Transmit_DMA+0x22e>
      {
        /* Send Slave Address and set NBYTES to write */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2000eda4:	68fb      	ldr	r3, [r7, #12]
2000eda6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000eda8:	b2da      	uxtb	r2, r3
2000edaa:	8979      	ldrh	r1, [r7, #10]
2000edac:	69bb      	ldr	r3, [r7, #24]
2000edae:	9300      	str	r3, [sp, #0]
2000edb0:	69fb      	ldr	r3, [r7, #28]
2000edb2:	68f8      	ldr	r0, [r7, #12]
2000edb4:	f002 ff62 	bl	20011c7c <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2000edb8:	68fb      	ldr	r3, [r7, #12]
2000edba:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000edbc:	b29a      	uxth	r2, r3
2000edbe:	68fb      	ldr	r3, [r7, #12]
2000edc0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000edc2:	1ad3      	subs	r3, r2, r3
2000edc4:	b29a      	uxth	r2, r3
2000edc6:	68fb      	ldr	r3, [r7, #12]
2000edc8:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000edca:	68fb      	ldr	r3, [r7, #12]
2000edcc:	2200      	movs	r2, #0
2000edce:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2000edd2:	2110      	movs	r1, #16
2000edd4:	68f8      	ldr	r0, [r7, #12]
2000edd6:	f002 ffc9 	bl	20011d6c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2000edda:	68fb      	ldr	r3, [r7, #12]
2000eddc:	681b      	ldr	r3, [r3, #0]
2000edde:	681a      	ldr	r2, [r3, #0]
2000ede0:	68fb      	ldr	r3, [r7, #12]
2000ede2:	681b      	ldr	r3, [r3, #0]
2000ede4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2000ede8:	601a      	str	r2, [r3, #0]
2000edea:	e029      	b.n	2000ee40 <HAL_I2C_Master_Seq_Transmit_DMA+0x228>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2000edec:	68fb      	ldr	r3, [r7, #12]
2000edee:	2220      	movs	r2, #32
2000edf0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2000edf4:	68fb      	ldr	r3, [r7, #12]
2000edf6:	2200      	movs	r2, #0
2000edf8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000edfc:	68fb      	ldr	r3, [r7, #12]
2000edfe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000ee00:	f043 0210 	orr.w	r2, r3, #16
2000ee04:	68fb      	ldr	r3, [r7, #12]
2000ee06:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000ee08:	68fb      	ldr	r3, [r7, #12]
2000ee0a:	2200      	movs	r2, #0
2000ee0c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2000ee10:	2301      	movs	r3, #1
2000ee12:	e018      	b.n	2000ee46 <HAL_I2C_Master_Seq_Transmit_DMA+0x22e>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2000ee14:	68fb      	ldr	r3, [r7, #12]
2000ee16:	4a13      	ldr	r2, [pc, #76]	; (2000ee64 <HAL_I2C_Master_Seq_Transmit_DMA+0x24c>)
2000ee18:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
2000ee1a:	68fb      	ldr	r3, [r7, #12]
2000ee1c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ee1e:	b2da      	uxtb	r2, r3
2000ee20:	8979      	ldrh	r1, [r7, #10]
2000ee22:	4b0b      	ldr	r3, [pc, #44]	; (2000ee50 <HAL_I2C_Master_Seq_Transmit_DMA+0x238>)
2000ee24:	9300      	str	r3, [sp, #0]
2000ee26:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000ee2a:	68f8      	ldr	r0, [r7, #12]
2000ee2c:	f002 ff26 	bl	20011c7c <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000ee30:	68fb      	ldr	r3, [r7, #12]
2000ee32:	2200      	movs	r2, #0
2000ee34:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2000ee38:	2101      	movs	r1, #1
2000ee3a:	68f8      	ldr	r0, [r7, #12]
2000ee3c:	f002 ff96 	bl	20011d6c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2000ee40:	2300      	movs	r3, #0
2000ee42:	e000      	b.n	2000ee46 <HAL_I2C_Master_Seq_Transmit_DMA+0x22e>
  }
  else
  {
    return HAL_BUSY;
2000ee44:	2302      	movs	r3, #2
  }
}
2000ee46:	4618      	mov	r0, r3
2000ee48:	3720      	adds	r7, #32
2000ee4a:	46bd      	mov	sp, r7
2000ee4c:	bd80      	pop	{r7, pc}
2000ee4e:	bf00      	nop
2000ee50:	80002000 	.word	0x80002000
2000ee54:	2001c180 	.word	0x2001c180
2000ee58:	2001024b 	.word	0x2001024b
2000ee5c:	200113e3 	.word	0x200113e3
2000ee60:	200116b5 	.word	0x200116b5
2000ee64:	2000fdf3 	.word	0x2000fdf3

2000ee68 <HAL_I2C_Master_Seq_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2000ee68:	b580      	push	{r7, lr}
2000ee6a:	b088      	sub	sp, #32
2000ee6c:	af02      	add	r7, sp, #8
2000ee6e:	60f8      	str	r0, [r7, #12]
2000ee70:	607a      	str	r2, [r7, #4]
2000ee72:	461a      	mov	r2, r3
2000ee74:	460b      	mov	r3, r1
2000ee76:	817b      	strh	r3, [r7, #10]
2000ee78:	4613      	mov	r3, r2
2000ee7a:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
2000ee7c:	4b4b      	ldr	r3, [pc, #300]	; (2000efac <HAL_I2C_Master_Seq_Receive_IT+0x144>)
2000ee7e:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
2000ee80:	6a3b      	ldr	r3, [r7, #32]
2000ee82:	2b00      	cmp	r3, #0
2000ee84:	d01e      	beq.n	2000eec4 <HAL_I2C_Master_Seq_Receive_IT+0x5c>
2000ee86:	6a3b      	ldr	r3, [r7, #32]
2000ee88:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000ee8c:	d01a      	beq.n	2000eec4 <HAL_I2C_Master_Seq_Receive_IT+0x5c>
2000ee8e:	6a3b      	ldr	r3, [r7, #32]
2000ee90:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000ee94:	d016      	beq.n	2000eec4 <HAL_I2C_Master_Seq_Receive_IT+0x5c>
2000ee96:	6a3b      	ldr	r3, [r7, #32]
2000ee98:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000ee9c:	d012      	beq.n	2000eec4 <HAL_I2C_Master_Seq_Receive_IT+0x5c>
2000ee9e:	6a3b      	ldr	r3, [r7, #32]
2000eea0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000eea4:	d00e      	beq.n	2000eec4 <HAL_I2C_Master_Seq_Receive_IT+0x5c>
2000eea6:	6a3b      	ldr	r3, [r7, #32]
2000eea8:	2b00      	cmp	r3, #0
2000eeaa:	d00b      	beq.n	2000eec4 <HAL_I2C_Master_Seq_Receive_IT+0x5c>
2000eeac:	6a3b      	ldr	r3, [r7, #32]
2000eeae:	2baa      	cmp	r3, #170	; 0xaa
2000eeb0:	d008      	beq.n	2000eec4 <HAL_I2C_Master_Seq_Receive_IT+0x5c>
2000eeb2:	6a3b      	ldr	r3, [r7, #32]
2000eeb4:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000eeb8:	d004      	beq.n	2000eec4 <HAL_I2C_Master_Seq_Receive_IT+0x5c>
2000eeba:	f640 5153 	movw	r1, #3411	; 0xd53
2000eebe:	483c      	ldr	r0, [pc, #240]	; (2000efb0 <HAL_I2C_Master_Seq_Receive_IT+0x148>)
2000eec0:	f7f1 fd18 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2000eec4:	68fb      	ldr	r3, [r7, #12]
2000eec6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000eeca:	b2db      	uxtb	r3, r3
2000eecc:	2b20      	cmp	r3, #32
2000eece:	d167      	bne.n	2000efa0 <HAL_I2C_Master_Seq_Receive_IT+0x138>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000eed0:	68fb      	ldr	r3, [r7, #12]
2000eed2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000eed6:	2b01      	cmp	r3, #1
2000eed8:	d101      	bne.n	2000eede <HAL_I2C_Master_Seq_Receive_IT+0x76>
2000eeda:	2302      	movs	r3, #2
2000eedc:	e061      	b.n	2000efa2 <HAL_I2C_Master_Seq_Receive_IT+0x13a>
2000eede:	68fb      	ldr	r3, [r7, #12]
2000eee0:	2201      	movs	r2, #1
2000eee2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2000eee6:	68fb      	ldr	r3, [r7, #12]
2000eee8:	2222      	movs	r2, #34	; 0x22
2000eeea:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2000eeee:	68fb      	ldr	r3, [r7, #12]
2000eef0:	2210      	movs	r2, #16
2000eef2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000eef6:	68fb      	ldr	r3, [r7, #12]
2000eef8:	2200      	movs	r2, #0
2000eefa:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000eefc:	68fb      	ldr	r3, [r7, #12]
2000eefe:	687a      	ldr	r2, [r7, #4]
2000ef00:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000ef02:	68fb      	ldr	r3, [r7, #12]
2000ef04:	893a      	ldrh	r2, [r7, #8]
2000ef06:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2000ef08:	68fb      	ldr	r3, [r7, #12]
2000ef0a:	6a3a      	ldr	r2, [r7, #32]
2000ef0c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2000ef0e:	68fb      	ldr	r3, [r7, #12]
2000ef10:	4a28      	ldr	r2, [pc, #160]	; (2000efb4 <HAL_I2C_Master_Seq_Receive_IT+0x14c>)
2000ef12:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000ef14:	68fb      	ldr	r3, [r7, #12]
2000ef16:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ef18:	b29b      	uxth	r3, r3
2000ef1a:	2bff      	cmp	r3, #255	; 0xff
2000ef1c:	d906      	bls.n	2000ef2c <HAL_I2C_Master_Seq_Receive_IT+0xc4>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000ef1e:	68fb      	ldr	r3, [r7, #12]
2000ef20:	22ff      	movs	r2, #255	; 0xff
2000ef22:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000ef24:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000ef28:	617b      	str	r3, [r7, #20]
2000ef2a:	e007      	b.n	2000ef3c <HAL_I2C_Master_Seq_Receive_IT+0xd4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000ef2c:	68fb      	ldr	r3, [r7, #12]
2000ef2e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ef30:	b29a      	uxth	r2, r3
2000ef32:	68fb      	ldr	r3, [r7, #12]
2000ef34:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2000ef36:	68fb      	ldr	r3, [r7, #12]
2000ef38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000ef3a:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2000ef3c:	68fb      	ldr	r3, [r7, #12]
2000ef3e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000ef40:	2b12      	cmp	r3, #18
2000ef42:	d10e      	bne.n	2000ef62 <HAL_I2C_Master_Seq_Receive_IT+0xfa>
2000ef44:	6a3b      	ldr	r3, [r7, #32]
2000ef46:	2baa      	cmp	r3, #170	; 0xaa
2000ef48:	d003      	beq.n	2000ef52 <HAL_I2C_Master_Seq_Receive_IT+0xea>
2000ef4a:	6a3b      	ldr	r3, [r7, #32]
2000ef4c:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000ef50:	d101      	bne.n	2000ef56 <HAL_I2C_Master_Seq_Receive_IT+0xee>
2000ef52:	2301      	movs	r3, #1
2000ef54:	e000      	b.n	2000ef58 <HAL_I2C_Master_Seq_Receive_IT+0xf0>
2000ef56:	2300      	movs	r3, #0
2000ef58:	2b00      	cmp	r3, #0
2000ef5a:	d102      	bne.n	2000ef62 <HAL_I2C_Master_Seq_Receive_IT+0xfa>
    {
      xferrequest = I2C_NO_STARTSTOP;
2000ef5c:	2300      	movs	r3, #0
2000ef5e:	613b      	str	r3, [r7, #16]
2000ef60:	e00a      	b.n	2000ef78 <HAL_I2C_Master_Seq_Receive_IT+0x110>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2000ef62:	68f8      	ldr	r0, [r7, #12]
2000ef64:	f002 ffc4 	bl	20011ef0 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2000ef68:	68fb      	ldr	r3, [r7, #12]
2000ef6a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ef6c:	b29b      	uxth	r3, r3
2000ef6e:	2bfe      	cmp	r3, #254	; 0xfe
2000ef70:	d802      	bhi.n	2000ef78 <HAL_I2C_Master_Seq_Receive_IT+0x110>
      {
        xfermode = hi2c->XferOptions;
2000ef72:	68fb      	ldr	r3, [r7, #12]
2000ef74:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000ef76:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to read */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2000ef78:	68fb      	ldr	r3, [r7, #12]
2000ef7a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ef7c:	b2da      	uxtb	r2, r3
2000ef7e:	8979      	ldrh	r1, [r7, #10]
2000ef80:	693b      	ldr	r3, [r7, #16]
2000ef82:	9300      	str	r3, [sp, #0]
2000ef84:	697b      	ldr	r3, [r7, #20]
2000ef86:	68f8      	ldr	r0, [r7, #12]
2000ef88:	f002 fe78 	bl	20011c7c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000ef8c:	68fb      	ldr	r3, [r7, #12]
2000ef8e:	2200      	movs	r2, #0
2000ef90:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2000ef94:	2102      	movs	r1, #2
2000ef96:	68f8      	ldr	r0, [r7, #12]
2000ef98:	f002 fee8 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000ef9c:	2300      	movs	r3, #0
2000ef9e:	e000      	b.n	2000efa2 <HAL_I2C_Master_Seq_Receive_IT+0x13a>
  }
  else
  {
    return HAL_BUSY;
2000efa0:	2302      	movs	r3, #2
  }
}
2000efa2:	4618      	mov	r0, r3
2000efa4:	3718      	adds	r7, #24
2000efa6:	46bd      	mov	sp, r7
2000efa8:	bd80      	pop	{r7, pc}
2000efaa:	bf00      	nop
2000efac:	80002400 	.word	0x80002400
2000efb0:	2001c180 	.word	0x2001c180
2000efb4:	2000fdf3 	.word	0x2000fdf3

2000efb8 <HAL_I2C_Master_Seq_Receive_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2000efb8:	b580      	push	{r7, lr}
2000efba:	b08a      	sub	sp, #40	; 0x28
2000efbc:	af02      	add	r7, sp, #8
2000efbe:	60f8      	str	r0, [r7, #12]
2000efc0:	607a      	str	r2, [r7, #4]
2000efc2:	461a      	mov	r2, r3
2000efc4:	460b      	mov	r3, r1
2000efc6:	817b      	strh	r3, [r7, #10]
2000efc8:	4613      	mov	r3, r2
2000efca:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
2000efcc:	4b88      	ldr	r3, [pc, #544]	; (2000f1f0 <HAL_I2C_Master_Seq_Receive_DMA+0x238>)
2000efce:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
2000efd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000efd2:	2b00      	cmp	r3, #0
2000efd4:	d01e      	beq.n	2000f014 <HAL_I2C_Master_Seq_Receive_DMA+0x5c>
2000efd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000efd8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000efdc:	d01a      	beq.n	2000f014 <HAL_I2C_Master_Seq_Receive_DMA+0x5c>
2000efde:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000efe0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000efe4:	d016      	beq.n	2000f014 <HAL_I2C_Master_Seq_Receive_DMA+0x5c>
2000efe6:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000efe8:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000efec:	d012      	beq.n	2000f014 <HAL_I2C_Master_Seq_Receive_DMA+0x5c>
2000efee:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000eff0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000eff4:	d00e      	beq.n	2000f014 <HAL_I2C_Master_Seq_Receive_DMA+0x5c>
2000eff6:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000eff8:	2b00      	cmp	r3, #0
2000effa:	d00b      	beq.n	2000f014 <HAL_I2C_Master_Seq_Receive_DMA+0x5c>
2000effc:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000effe:	2baa      	cmp	r3, #170	; 0xaa
2000f000:	d008      	beq.n	2000f014 <HAL_I2C_Master_Seq_Receive_DMA+0x5c>
2000f002:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000f004:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000f008:	d004      	beq.n	2000f014 <HAL_I2C_Master_Seq_Receive_DMA+0x5c>
2000f00a:	f640 51a8 	movw	r1, #3496	; 0xda8
2000f00e:	4879      	ldr	r0, [pc, #484]	; (2000f1f4 <HAL_I2C_Master_Seq_Receive_DMA+0x23c>)
2000f010:	f7f1 fc70 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2000f014:	68fb      	ldr	r3, [r7, #12]
2000f016:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f01a:	b2db      	uxtb	r3, r3
2000f01c:	2b20      	cmp	r3, #32
2000f01e:	f040 80e1 	bne.w	2000f1e4 <HAL_I2C_Master_Seq_Receive_DMA+0x22c>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000f022:	68fb      	ldr	r3, [r7, #12]
2000f024:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000f028:	2b01      	cmp	r3, #1
2000f02a:	d101      	bne.n	2000f030 <HAL_I2C_Master_Seq_Receive_DMA+0x78>
2000f02c:	2302      	movs	r3, #2
2000f02e:	e0da      	b.n	2000f1e6 <HAL_I2C_Master_Seq_Receive_DMA+0x22e>
2000f030:	68fb      	ldr	r3, [r7, #12]
2000f032:	2201      	movs	r2, #1
2000f034:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2000f038:	68fb      	ldr	r3, [r7, #12]
2000f03a:	2222      	movs	r2, #34	; 0x22
2000f03c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2000f040:	68fb      	ldr	r3, [r7, #12]
2000f042:	2210      	movs	r2, #16
2000f044:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000f048:	68fb      	ldr	r3, [r7, #12]
2000f04a:	2200      	movs	r2, #0
2000f04c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000f04e:	68fb      	ldr	r3, [r7, #12]
2000f050:	687a      	ldr	r2, [r7, #4]
2000f052:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000f054:	68fb      	ldr	r3, [r7, #12]
2000f056:	893a      	ldrh	r2, [r7, #8]
2000f058:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2000f05a:	68fb      	ldr	r3, [r7, #12]
2000f05c:	6aba      	ldr	r2, [r7, #40]	; 0x28
2000f05e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2000f060:	68fb      	ldr	r3, [r7, #12]
2000f062:	4a65      	ldr	r2, [pc, #404]	; (2000f1f8 <HAL_I2C_Master_Seq_Receive_DMA+0x240>)
2000f064:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000f066:	68fb      	ldr	r3, [r7, #12]
2000f068:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000f06a:	b29b      	uxth	r3, r3
2000f06c:	2bff      	cmp	r3, #255	; 0xff
2000f06e:	d906      	bls.n	2000f07e <HAL_I2C_Master_Seq_Receive_DMA+0xc6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2000f070:	68fb      	ldr	r3, [r7, #12]
2000f072:	22ff      	movs	r2, #255	; 0xff
2000f074:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000f076:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000f07a:	61fb      	str	r3, [r7, #28]
2000f07c:	e007      	b.n	2000f08e <HAL_I2C_Master_Seq_Receive_DMA+0xd6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000f07e:	68fb      	ldr	r3, [r7, #12]
2000f080:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000f082:	b29a      	uxth	r2, r3
2000f084:	68fb      	ldr	r3, [r7, #12]
2000f086:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2000f088:	68fb      	ldr	r3, [r7, #12]
2000f08a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000f08c:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2000f08e:	68fb      	ldr	r3, [r7, #12]
2000f090:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000f092:	2b12      	cmp	r3, #18
2000f094:	d10e      	bne.n	2000f0b4 <HAL_I2C_Master_Seq_Receive_DMA+0xfc>
2000f096:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000f098:	2baa      	cmp	r3, #170	; 0xaa
2000f09a:	d003      	beq.n	2000f0a4 <HAL_I2C_Master_Seq_Receive_DMA+0xec>
2000f09c:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000f09e:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000f0a2:	d101      	bne.n	2000f0a8 <HAL_I2C_Master_Seq_Receive_DMA+0xf0>
2000f0a4:	2301      	movs	r3, #1
2000f0a6:	e000      	b.n	2000f0aa <HAL_I2C_Master_Seq_Receive_DMA+0xf2>
2000f0a8:	2300      	movs	r3, #0
2000f0aa:	2b00      	cmp	r3, #0
2000f0ac:	d102      	bne.n	2000f0b4 <HAL_I2C_Master_Seq_Receive_DMA+0xfc>
    {
      xferrequest = I2C_NO_STARTSTOP;
2000f0ae:	2300      	movs	r3, #0
2000f0b0:	61bb      	str	r3, [r7, #24]
2000f0b2:	e00a      	b.n	2000f0ca <HAL_I2C_Master_Seq_Receive_DMA+0x112>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2000f0b4:	68f8      	ldr	r0, [r7, #12]
2000f0b6:	f002 ff1b 	bl	20011ef0 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2000f0ba:	68fb      	ldr	r3, [r7, #12]
2000f0bc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000f0be:	b29b      	uxth	r3, r3
2000f0c0:	2bfe      	cmp	r3, #254	; 0xfe
2000f0c2:	d802      	bhi.n	2000f0ca <HAL_I2C_Master_Seq_Receive_DMA+0x112>
      {
        xfermode = hi2c->XferOptions;
2000f0c4:	68fb      	ldr	r3, [r7, #12]
2000f0c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000f0c8:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2000f0ca:	68fb      	ldr	r3, [r7, #12]
2000f0cc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000f0ce:	2b00      	cmp	r3, #0
2000f0d0:	d070      	beq.n	2000f1b4 <HAL_I2C_Master_Seq_Receive_DMA+0x1fc>
    {
      if (hi2c->hdmarx != NULL)
2000f0d2:	68fb      	ldr	r3, [r7, #12]
2000f0d4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f0d6:	2b00      	cmp	r3, #0
2000f0d8:	d020      	beq.n	2000f11c <HAL_I2C_Master_Seq_Receive_DMA+0x164>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2000f0da:	68fb      	ldr	r3, [r7, #12]
2000f0dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f0de:	4a47      	ldr	r2, [pc, #284]	; (2000f1fc <HAL_I2C_Master_Seq_Receive_DMA+0x244>)
2000f0e0:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2000f0e2:	68fb      	ldr	r3, [r7, #12]
2000f0e4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f0e6:	4a46      	ldr	r2, [pc, #280]	; (2000f200 <HAL_I2C_Master_Seq_Receive_DMA+0x248>)
2000f0e8:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2000f0ea:	68fb      	ldr	r3, [r7, #12]
2000f0ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f0ee:	2200      	movs	r2, #0
2000f0f0:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
2000f0f2:	68fb      	ldr	r3, [r7, #12]
2000f0f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f0f6:	2200      	movs	r2, #0
2000f0f8:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2000f0fa:	68fb      	ldr	r3, [r7, #12]
2000f0fc:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2000f0fe:	68fb      	ldr	r3, [r7, #12]
2000f100:	681b      	ldr	r3, [r3, #0]
2000f102:	3324      	adds	r3, #36	; 0x24
2000f104:	4619      	mov	r1, r3
2000f106:	687a      	ldr	r2, [r7, #4]
2000f108:	68fb      	ldr	r3, [r7, #12]
2000f10a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000f10c:	f7f5 fbd0 	bl	200048b0 <HAL_DMA_Start_IT>
2000f110:	4603      	mov	r3, r0
2000f112:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2000f114:	7dfb      	ldrb	r3, [r7, #23]
2000f116:	2b00      	cmp	r3, #0
2000f118:	d138      	bne.n	2000f18c <HAL_I2C_Master_Seq_Receive_DMA+0x1d4>
2000f11a:	e013      	b.n	2000f144 <HAL_I2C_Master_Seq_Receive_DMA+0x18c>
        hi2c->State     = HAL_I2C_STATE_READY;
2000f11c:	68fb      	ldr	r3, [r7, #12]
2000f11e:	2220      	movs	r2, #32
2000f120:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2000f124:	68fb      	ldr	r3, [r7, #12]
2000f126:	2200      	movs	r2, #0
2000f128:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2000f12c:	68fb      	ldr	r3, [r7, #12]
2000f12e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000f130:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2000f134:	68fb      	ldr	r3, [r7, #12]
2000f136:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2000f138:	68fb      	ldr	r3, [r7, #12]
2000f13a:	2200      	movs	r2, #0
2000f13c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2000f140:	2301      	movs	r3, #1
2000f142:	e050      	b.n	2000f1e6 <HAL_I2C_Master_Seq_Receive_DMA+0x22e>
      {
        /* Send Slave Address and set NBYTES to read */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2000f144:	68fb      	ldr	r3, [r7, #12]
2000f146:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000f148:	b2da      	uxtb	r2, r3
2000f14a:	8979      	ldrh	r1, [r7, #10]
2000f14c:	69bb      	ldr	r3, [r7, #24]
2000f14e:	9300      	str	r3, [sp, #0]
2000f150:	69fb      	ldr	r3, [r7, #28]
2000f152:	68f8      	ldr	r0, [r7, #12]
2000f154:	f002 fd92 	bl	20011c7c <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2000f158:	68fb      	ldr	r3, [r7, #12]
2000f15a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000f15c:	b29a      	uxth	r2, r3
2000f15e:	68fb      	ldr	r3, [r7, #12]
2000f160:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000f162:	1ad3      	subs	r3, r2, r3
2000f164:	b29a      	uxth	r2, r3
2000f166:	68fb      	ldr	r3, [r7, #12]
2000f168:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000f16a:	68fb      	ldr	r3, [r7, #12]
2000f16c:	2200      	movs	r2, #0
2000f16e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2000f172:	2110      	movs	r1, #16
2000f174:	68f8      	ldr	r0, [r7, #12]
2000f176:	f002 fdf9 	bl	20011d6c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2000f17a:	68fb      	ldr	r3, [r7, #12]
2000f17c:	681b      	ldr	r3, [r3, #0]
2000f17e:	681a      	ldr	r2, [r3, #0]
2000f180:	68fb      	ldr	r3, [r7, #12]
2000f182:	681b      	ldr	r3, [r3, #0]
2000f184:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000f188:	601a      	str	r2, [r3, #0]
2000f18a:	e029      	b.n	2000f1e0 <HAL_I2C_Master_Seq_Receive_DMA+0x228>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2000f18c:	68fb      	ldr	r3, [r7, #12]
2000f18e:	2220      	movs	r2, #32
2000f190:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2000f194:	68fb      	ldr	r3, [r7, #12]
2000f196:	2200      	movs	r2, #0
2000f198:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000f19c:	68fb      	ldr	r3, [r7, #12]
2000f19e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000f1a0:	f043 0210 	orr.w	r2, r3, #16
2000f1a4:	68fb      	ldr	r3, [r7, #12]
2000f1a6:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000f1a8:	68fb      	ldr	r3, [r7, #12]
2000f1aa:	2200      	movs	r2, #0
2000f1ac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2000f1b0:	2301      	movs	r3, #1
2000f1b2:	e018      	b.n	2000f1e6 <HAL_I2C_Master_Seq_Receive_DMA+0x22e>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2000f1b4:	68fb      	ldr	r3, [r7, #12]
2000f1b6:	4a13      	ldr	r2, [pc, #76]	; (2000f204 <HAL_I2C_Master_Seq_Receive_DMA+0x24c>)
2000f1b8:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2000f1ba:	68fb      	ldr	r3, [r7, #12]
2000f1bc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000f1be:	b2da      	uxtb	r2, r3
2000f1c0:	8979      	ldrh	r1, [r7, #10]
2000f1c2:	4b0b      	ldr	r3, [pc, #44]	; (2000f1f0 <HAL_I2C_Master_Seq_Receive_DMA+0x238>)
2000f1c4:	9300      	str	r3, [sp, #0]
2000f1c6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000f1ca:	68f8      	ldr	r0, [r7, #12]
2000f1cc:	f002 fd56 	bl	20011c7c <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000f1d0:	68fb      	ldr	r3, [r7, #12]
2000f1d2:	2200      	movs	r2, #0
2000f1d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2000f1d8:	2101      	movs	r1, #1
2000f1da:	68f8      	ldr	r0, [r7, #12]
2000f1dc:	f002 fdc6 	bl	20011d6c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2000f1e0:	2300      	movs	r3, #0
2000f1e2:	e000      	b.n	2000f1e6 <HAL_I2C_Master_Seq_Receive_DMA+0x22e>
  }
  else
  {
    return HAL_BUSY;
2000f1e4:	2302      	movs	r3, #2
  }
}
2000f1e6:	4618      	mov	r0, r3
2000f1e8:	3720      	adds	r7, #32
2000f1ea:	46bd      	mov	sp, r7
2000f1ec:	bd80      	pop	{r7, pc}
2000f1ee:	bf00      	nop
2000f1f0:	80002400 	.word	0x80002400
2000f1f4:	2001c180 	.word	0x2001c180
2000f1f8:	2001024b 	.word	0x2001024b
2000f1fc:	200114b9 	.word	0x200114b9
2000f200:	200116b5 	.word	0x200116b5
2000f204:	2000fdf3 	.word	0x2000fdf3

2000f208 <HAL_I2C_Slave_Seq_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2000f208:	b580      	push	{r7, lr}
2000f20a:	b084      	sub	sp, #16
2000f20c:	af00      	add	r7, sp, #0
2000f20e:	60f8      	str	r0, [r7, #12]
2000f210:	60b9      	str	r1, [r7, #8]
2000f212:	603b      	str	r3, [r7, #0]
2000f214:	4613      	mov	r3, r2
2000f216:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
2000f218:	683b      	ldr	r3, [r7, #0]
2000f21a:	2b00      	cmp	r3, #0
2000f21c:	d01e      	beq.n	2000f25c <HAL_I2C_Slave_Seq_Transmit_IT+0x54>
2000f21e:	683b      	ldr	r3, [r7, #0]
2000f220:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000f224:	d01a      	beq.n	2000f25c <HAL_I2C_Slave_Seq_Transmit_IT+0x54>
2000f226:	683b      	ldr	r3, [r7, #0]
2000f228:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000f22c:	d016      	beq.n	2000f25c <HAL_I2C_Slave_Seq_Transmit_IT+0x54>
2000f22e:	683b      	ldr	r3, [r7, #0]
2000f230:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000f234:	d012      	beq.n	2000f25c <HAL_I2C_Slave_Seq_Transmit_IT+0x54>
2000f236:	683b      	ldr	r3, [r7, #0]
2000f238:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000f23c:	d00e      	beq.n	2000f25c <HAL_I2C_Slave_Seq_Transmit_IT+0x54>
2000f23e:	683b      	ldr	r3, [r7, #0]
2000f240:	2b00      	cmp	r3, #0
2000f242:	d00b      	beq.n	2000f25c <HAL_I2C_Slave_Seq_Transmit_IT+0x54>
2000f244:	683b      	ldr	r3, [r7, #0]
2000f246:	2baa      	cmp	r3, #170	; 0xaa
2000f248:	d008      	beq.n	2000f25c <HAL_I2C_Slave_Seq_Transmit_IT+0x54>
2000f24a:	683b      	ldr	r3, [r7, #0]
2000f24c:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000f250:	d004      	beq.n	2000f25c <HAL_I2C_Slave_Seq_Transmit_IT+0x54>
2000f252:	f640 6144 	movw	r1, #3652	; 0xe44
2000f256:	484d      	ldr	r0, [pc, #308]	; (2000f38c <HAL_I2C_Slave_Seq_Transmit_IT+0x184>)
2000f258:	f7f1 fb4c 	bl	200008f4 <assert_failed>

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2000f25c:	68fb      	ldr	r3, [r7, #12]
2000f25e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f262:	b2db      	uxtb	r3, r3
2000f264:	f003 0328 	and.w	r3, r3, #40	; 0x28
2000f268:	2b28      	cmp	r3, #40	; 0x28
2000f26a:	f040 808a 	bne.w	2000f382 <HAL_I2C_Slave_Seq_Transmit_IT+0x17a>
  {
    if ((pData == NULL) || (Size == 0U))
2000f26e:	68bb      	ldr	r3, [r7, #8]
2000f270:	2b00      	cmp	r3, #0
2000f272:	d002      	beq.n	2000f27a <HAL_I2C_Slave_Seq_Transmit_IT+0x72>
2000f274:	88fb      	ldrh	r3, [r7, #6]
2000f276:	2b00      	cmp	r3, #0
2000f278:	d105      	bne.n	2000f286 <HAL_I2C_Slave_Seq_Transmit_IT+0x7e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000f27a:	68fb      	ldr	r3, [r7, #12]
2000f27c:	f44f 7200 	mov.w	r2, #512	; 0x200
2000f280:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000f282:	2301      	movs	r3, #1
2000f284:	e07e      	b.n	2000f384 <HAL_I2C_Slave_Seq_Transmit_IT+0x17c>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2000f286:	f248 0101 	movw	r1, #32769	; 0x8001
2000f28a:	68f8      	ldr	r0, [r7, #12]
2000f28c:	f002 fdd2 	bl	20011e34 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000f290:	68fb      	ldr	r3, [r7, #12]
2000f292:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000f296:	2b01      	cmp	r3, #1
2000f298:	d101      	bne.n	2000f29e <HAL_I2C_Slave_Seq_Transmit_IT+0x96>
2000f29a:	2302      	movs	r3, #2
2000f29c:	e072      	b.n	2000f384 <HAL_I2C_Slave_Seq_Transmit_IT+0x17c>
2000f29e:	68fb      	ldr	r3, [r7, #12]
2000f2a0:	2201      	movs	r2, #1
2000f2a2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2000f2a6:	68fb      	ldr	r3, [r7, #12]
2000f2a8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f2ac:	b2db      	uxtb	r3, r3
2000f2ae:	2b2a      	cmp	r3, #42	; 0x2a
2000f2b0:	d12a      	bne.n	2000f308 <HAL_I2C_Slave_Seq_Transmit_IT+0x100>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2000f2b2:	2102      	movs	r1, #2
2000f2b4:	68f8      	ldr	r0, [r7, #12]
2000f2b6:	f002 fdbd 	bl	20011e34 <I2C_Disable_IRQ>

      /* Abort DMA Xfer if any */
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2000f2ba:	68fb      	ldr	r3, [r7, #12]
2000f2bc:	681b      	ldr	r3, [r3, #0]
2000f2be:	681b      	ldr	r3, [r3, #0]
2000f2c0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000f2c4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000f2c8:	d11e      	bne.n	2000f308 <HAL_I2C_Slave_Seq_Transmit_IT+0x100>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2000f2ca:	68fb      	ldr	r3, [r7, #12]
2000f2cc:	681b      	ldr	r3, [r3, #0]
2000f2ce:	681a      	ldr	r2, [r3, #0]
2000f2d0:	68fb      	ldr	r3, [r7, #12]
2000f2d2:	681b      	ldr	r3, [r3, #0]
2000f2d4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000f2d8:	601a      	str	r2, [r3, #0]

        if (hi2c->hdmarx != NULL)
2000f2da:	68fb      	ldr	r3, [r7, #12]
2000f2dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f2de:	2b00      	cmp	r3, #0
2000f2e0:	d012      	beq.n	2000f308 <HAL_I2C_Slave_Seq_Transmit_IT+0x100>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2000f2e2:	68fb      	ldr	r3, [r7, #12]
2000f2e4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f2e6:	4a2a      	ldr	r2, [pc, #168]	; (2000f390 <HAL_I2C_Slave_Seq_Transmit_IT+0x188>)
2000f2e8:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2000f2ea:	68fb      	ldr	r3, [r7, #12]
2000f2ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f2ee:	4618      	mov	r0, r3
2000f2f0:	f7f6 f874 	bl	200053dc <HAL_DMA_Abort_IT>
2000f2f4:	4603      	mov	r3, r0
2000f2f6:	2b00      	cmp	r3, #0
2000f2f8:	d006      	beq.n	2000f308 <HAL_I2C_Slave_Seq_Transmit_IT+0x100>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2000f2fa:	68fb      	ldr	r3, [r7, #12]
2000f2fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f2fe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000f300:	68fa      	ldr	r2, [r7, #12]
2000f302:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2000f304:	4610      	mov	r0, r2
2000f306:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2000f308:	68fb      	ldr	r3, [r7, #12]
2000f30a:	2229      	movs	r2, #41	; 0x29
2000f30c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2000f310:	68fb      	ldr	r3, [r7, #12]
2000f312:	2220      	movs	r2, #32
2000f314:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000f318:	68fb      	ldr	r3, [r7, #12]
2000f31a:	2200      	movs	r2, #0
2000f31c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2000f31e:	68fb      	ldr	r3, [r7, #12]
2000f320:	681b      	ldr	r3, [r3, #0]
2000f322:	685a      	ldr	r2, [r3, #4]
2000f324:	68fb      	ldr	r3, [r7, #12]
2000f326:	681b      	ldr	r3, [r3, #0]
2000f328:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000f32c:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000f32e:	68fb      	ldr	r3, [r7, #12]
2000f330:	68ba      	ldr	r2, [r7, #8]
2000f332:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000f334:	68fb      	ldr	r3, [r7, #12]
2000f336:	88fa      	ldrh	r2, [r7, #6]
2000f338:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2000f33a:	68fb      	ldr	r3, [r7, #12]
2000f33c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000f33e:	b29a      	uxth	r2, r3
2000f340:	68fb      	ldr	r3, [r7, #12]
2000f342:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2000f344:	68fb      	ldr	r3, [r7, #12]
2000f346:	683a      	ldr	r2, [r7, #0]
2000f348:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2000f34a:	68fb      	ldr	r3, [r7, #12]
2000f34c:	4a11      	ldr	r2, [pc, #68]	; (2000f394 <HAL_I2C_Slave_Seq_Transmit_IT+0x18c>)
2000f34e:	635a      	str	r2, [r3, #52]	; 0x34

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
2000f350:	68fb      	ldr	r3, [r7, #12]
2000f352:	681b      	ldr	r3, [r3, #0]
2000f354:	699b      	ldr	r3, [r3, #24]
2000f356:	0c1b      	lsrs	r3, r3, #16
2000f358:	b2db      	uxtb	r3, r3
2000f35a:	f003 0301 	and.w	r3, r3, #1
2000f35e:	b2db      	uxtb	r3, r3
2000f360:	2b01      	cmp	r3, #1
2000f362:	d103      	bne.n	2000f36c <HAL_I2C_Slave_Seq_Transmit_IT+0x164>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2000f364:	68fb      	ldr	r3, [r7, #12]
2000f366:	681b      	ldr	r3, [r3, #0]
2000f368:	2208      	movs	r2, #8
2000f36a:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000f36c:	68fb      	ldr	r3, [r7, #12]
2000f36e:	2200      	movs	r2, #0
2000f370:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
2000f374:	f248 0101 	movw	r1, #32769	; 0x8001
2000f378:	68f8      	ldr	r0, [r7, #12]
2000f37a:	f002 fcf7 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000f37e:	2300      	movs	r3, #0
2000f380:	e000      	b.n	2000f384 <HAL_I2C_Slave_Seq_Transmit_IT+0x17c>
  }
  else
  {
    return HAL_ERROR;
2000f382:	2301      	movs	r3, #1
  }
}
2000f384:	4618      	mov	r0, r3
2000f386:	3710      	adds	r7, #16
2000f388:	46bd      	mov	sp, r7
2000f38a:	bd80      	pop	{r7, pc}
2000f38c:	2001c180 	.word	0x2001c180
2000f390:	20011925 	.word	0x20011925
2000f394:	20010045 	.word	0x20010045

2000f398 <HAL_I2C_Slave_Seq_Transmit_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2000f398:	b580      	push	{r7, lr}
2000f39a:	b086      	sub	sp, #24
2000f39c:	af00      	add	r7, sp, #0
2000f39e:	60f8      	str	r0, [r7, #12]
2000f3a0:	60b9      	str	r1, [r7, #8]
2000f3a2:	603b      	str	r3, [r7, #0]
2000f3a4:	4613      	mov	r3, r2
2000f3a6:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
2000f3a8:	683b      	ldr	r3, [r7, #0]
2000f3aa:	2b00      	cmp	r3, #0
2000f3ac:	d01e      	beq.n	2000f3ec <HAL_I2C_Slave_Seq_Transmit_DMA+0x54>
2000f3ae:	683b      	ldr	r3, [r7, #0]
2000f3b0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000f3b4:	d01a      	beq.n	2000f3ec <HAL_I2C_Slave_Seq_Transmit_DMA+0x54>
2000f3b6:	683b      	ldr	r3, [r7, #0]
2000f3b8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000f3bc:	d016      	beq.n	2000f3ec <HAL_I2C_Slave_Seq_Transmit_DMA+0x54>
2000f3be:	683b      	ldr	r3, [r7, #0]
2000f3c0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000f3c4:	d012      	beq.n	2000f3ec <HAL_I2C_Slave_Seq_Transmit_DMA+0x54>
2000f3c6:	683b      	ldr	r3, [r7, #0]
2000f3c8:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000f3cc:	d00e      	beq.n	2000f3ec <HAL_I2C_Slave_Seq_Transmit_DMA+0x54>
2000f3ce:	683b      	ldr	r3, [r7, #0]
2000f3d0:	2b00      	cmp	r3, #0
2000f3d2:	d00b      	beq.n	2000f3ec <HAL_I2C_Slave_Seq_Transmit_DMA+0x54>
2000f3d4:	683b      	ldr	r3, [r7, #0]
2000f3d6:	2baa      	cmp	r3, #170	; 0xaa
2000f3d8:	d008      	beq.n	2000f3ec <HAL_I2C_Slave_Seq_Transmit_DMA+0x54>
2000f3da:	683b      	ldr	r3, [r7, #0]
2000f3dc:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000f3e0:	d004      	beq.n	2000f3ec <HAL_I2C_Slave_Seq_Transmit_DMA+0x54>
2000f3e2:	f640 61a5 	movw	r1, #3749	; 0xea5
2000f3e6:	4895      	ldr	r0, [pc, #596]	; (2000f63c <HAL_I2C_Slave_Seq_Transmit_DMA+0x2a4>)
2000f3e8:	f7f1 fa84 	bl	200008f4 <assert_failed>

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2000f3ec:	68fb      	ldr	r3, [r7, #12]
2000f3ee:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f3f2:	b2db      	uxtb	r3, r3
2000f3f4:	f003 0328 	and.w	r3, r3, #40	; 0x28
2000f3f8:	2b28      	cmp	r3, #40	; 0x28
2000f3fa:	f040 811a 	bne.w	2000f632 <HAL_I2C_Slave_Seq_Transmit_DMA+0x29a>
  {
    if ((pData == NULL) || (Size == 0U))
2000f3fe:	68bb      	ldr	r3, [r7, #8]
2000f400:	2b00      	cmp	r3, #0
2000f402:	d002      	beq.n	2000f40a <HAL_I2C_Slave_Seq_Transmit_DMA+0x72>
2000f404:	88fb      	ldrh	r3, [r7, #6]
2000f406:	2b00      	cmp	r3, #0
2000f408:	d105      	bne.n	2000f416 <HAL_I2C_Slave_Seq_Transmit_DMA+0x7e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000f40a:	68fb      	ldr	r3, [r7, #12]
2000f40c:	f44f 7200 	mov.w	r2, #512	; 0x200
2000f410:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000f412:	2301      	movs	r3, #1
2000f414:	e10e      	b.n	2000f634 <HAL_I2C_Slave_Seq_Transmit_DMA+0x29c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000f416:	68fb      	ldr	r3, [r7, #12]
2000f418:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000f41c:	2b01      	cmp	r3, #1
2000f41e:	d101      	bne.n	2000f424 <HAL_I2C_Slave_Seq_Transmit_DMA+0x8c>
2000f420:	2302      	movs	r3, #2
2000f422:	e107      	b.n	2000f634 <HAL_I2C_Slave_Seq_Transmit_DMA+0x29c>
2000f424:	68fb      	ldr	r3, [r7, #12]
2000f426:	2201      	movs	r2, #1
2000f428:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2000f42c:	f248 0101 	movw	r1, #32769	; 0x8001
2000f430:	68f8      	ldr	r0, [r7, #12]
2000f432:	f002 fcff 	bl	20011e34 <I2C_Disable_IRQ>

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2000f436:	68fb      	ldr	r3, [r7, #12]
2000f438:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f43c:	b2db      	uxtb	r3, r3
2000f43e:	2b2a      	cmp	r3, #42	; 0x2a
2000f440:	d12b      	bne.n	2000f49a <HAL_I2C_Slave_Seq_Transmit_DMA+0x102>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2000f442:	2102      	movs	r1, #2
2000f444:	68f8      	ldr	r0, [r7, #12]
2000f446:	f002 fcf5 	bl	20011e34 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2000f44a:	68fb      	ldr	r3, [r7, #12]
2000f44c:	681b      	ldr	r3, [r3, #0]
2000f44e:	681b      	ldr	r3, [r3, #0]
2000f450:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000f454:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000f458:	d14c      	bne.n	2000f4f4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x15c>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
2000f45a:	68fb      	ldr	r3, [r7, #12]
2000f45c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f45e:	2b00      	cmp	r3, #0
2000f460:	d048      	beq.n	2000f4f4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x15c>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2000f462:	68fb      	ldr	r3, [r7, #12]
2000f464:	681b      	ldr	r3, [r3, #0]
2000f466:	681a      	ldr	r2, [r3, #0]
2000f468:	68fb      	ldr	r3, [r7, #12]
2000f46a:	681b      	ldr	r3, [r3, #0]
2000f46c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000f470:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2000f472:	68fb      	ldr	r3, [r7, #12]
2000f474:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f476:	4a72      	ldr	r2, [pc, #456]	; (2000f640 <HAL_I2C_Slave_Seq_Transmit_DMA+0x2a8>)
2000f478:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2000f47a:	68fb      	ldr	r3, [r7, #12]
2000f47c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f47e:	4618      	mov	r0, r3
2000f480:	f7f5 ffac 	bl	200053dc <HAL_DMA_Abort_IT>
2000f484:	4603      	mov	r3, r0
2000f486:	2b00      	cmp	r3, #0
2000f488:	d034      	beq.n	2000f4f4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x15c>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2000f48a:	68fb      	ldr	r3, [r7, #12]
2000f48c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f48e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000f490:	68fa      	ldr	r2, [r7, #12]
2000f492:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2000f494:	4610      	mov	r0, r2
2000f496:	4798      	blx	r3
2000f498:	e02c      	b.n	2000f4f4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x15c>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2000f49a:	68fb      	ldr	r3, [r7, #12]
2000f49c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f4a0:	b2db      	uxtb	r3, r3
2000f4a2:	2b29      	cmp	r3, #41	; 0x29
2000f4a4:	d126      	bne.n	2000f4f4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x15c>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2000f4a6:	68fb      	ldr	r3, [r7, #12]
2000f4a8:	681b      	ldr	r3, [r3, #0]
2000f4aa:	681b      	ldr	r3, [r3, #0]
2000f4ac:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2000f4b0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2000f4b4:	d11e      	bne.n	2000f4f4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x15c>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2000f4b6:	68fb      	ldr	r3, [r7, #12]
2000f4b8:	681b      	ldr	r3, [r3, #0]
2000f4ba:	681a      	ldr	r2, [r3, #0]
2000f4bc:	68fb      	ldr	r3, [r7, #12]
2000f4be:	681b      	ldr	r3, [r3, #0]
2000f4c0:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2000f4c4:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2000f4c6:	68fb      	ldr	r3, [r7, #12]
2000f4c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f4ca:	2b00      	cmp	r3, #0
2000f4cc:	d012      	beq.n	2000f4f4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x15c>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2000f4ce:	68fb      	ldr	r3, [r7, #12]
2000f4d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f4d2:	4a5b      	ldr	r2, [pc, #364]	; (2000f640 <HAL_I2C_Slave_Seq_Transmit_DMA+0x2a8>)
2000f4d4:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2000f4d6:	68fb      	ldr	r3, [r7, #12]
2000f4d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f4da:	4618      	mov	r0, r3
2000f4dc:	f7f5 ff7e 	bl	200053dc <HAL_DMA_Abort_IT>
2000f4e0:	4603      	mov	r3, r0
2000f4e2:	2b00      	cmp	r3, #0
2000f4e4:	d006      	beq.n	2000f4f4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x15c>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2000f4e6:	68fb      	ldr	r3, [r7, #12]
2000f4e8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f4ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000f4ec:	68fa      	ldr	r2, [r7, #12]
2000f4ee:	6b92      	ldr	r2, [r2, #56]	; 0x38
2000f4f0:	4610      	mov	r0, r2
2000f4f2:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2000f4f4:	68fb      	ldr	r3, [r7, #12]
2000f4f6:	2229      	movs	r2, #41	; 0x29
2000f4f8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2000f4fc:	68fb      	ldr	r3, [r7, #12]
2000f4fe:	2220      	movs	r2, #32
2000f500:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000f504:	68fb      	ldr	r3, [r7, #12]
2000f506:	2200      	movs	r2, #0
2000f508:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2000f50a:	68fb      	ldr	r3, [r7, #12]
2000f50c:	681b      	ldr	r3, [r3, #0]
2000f50e:	685a      	ldr	r2, [r3, #4]
2000f510:	68fb      	ldr	r3, [r7, #12]
2000f512:	681b      	ldr	r3, [r3, #0]
2000f514:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000f518:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000f51a:	68fb      	ldr	r3, [r7, #12]
2000f51c:	68ba      	ldr	r2, [r7, #8]
2000f51e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000f520:	68fb      	ldr	r3, [r7, #12]
2000f522:	88fa      	ldrh	r2, [r7, #6]
2000f524:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2000f526:	68fb      	ldr	r3, [r7, #12]
2000f528:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000f52a:	b29a      	uxth	r2, r3
2000f52c:	68fb      	ldr	r3, [r7, #12]
2000f52e:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2000f530:	68fb      	ldr	r3, [r7, #12]
2000f532:	683a      	ldr	r2, [r7, #0]
2000f534:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2000f536:	68fb      	ldr	r3, [r7, #12]
2000f538:	4a42      	ldr	r2, [pc, #264]	; (2000f644 <HAL_I2C_Slave_Seq_Transmit_DMA+0x2ac>)
2000f53a:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
2000f53c:	68fb      	ldr	r3, [r7, #12]
2000f53e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f540:	2b00      	cmp	r3, #0
2000f542:	d020      	beq.n	2000f586 <HAL_I2C_Slave_Seq_Transmit_DMA+0x1ee>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2000f544:	68fb      	ldr	r3, [r7, #12]
2000f546:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f548:	4a3f      	ldr	r2, [pc, #252]	; (2000f648 <HAL_I2C_Slave_Seq_Transmit_DMA+0x2b0>)
2000f54a:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2000f54c:	68fb      	ldr	r3, [r7, #12]
2000f54e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f550:	4a3e      	ldr	r2, [pc, #248]	; (2000f64c <HAL_I2C_Slave_Seq_Transmit_DMA+0x2b4>)
2000f552:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2000f554:	68fb      	ldr	r3, [r7, #12]
2000f556:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f558:	2200      	movs	r2, #0
2000f55a:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2000f55c:	68fb      	ldr	r3, [r7, #12]
2000f55e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f560:	2200      	movs	r2, #0
2000f562:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2000f564:	68fb      	ldr	r3, [r7, #12]
2000f566:	6b98      	ldr	r0, [r3, #56]	; 0x38
2000f568:	68b9      	ldr	r1, [r7, #8]
2000f56a:	68fb      	ldr	r3, [r7, #12]
2000f56c:	681b      	ldr	r3, [r3, #0]
2000f56e:	3328      	adds	r3, #40	; 0x28
2000f570:	461a      	mov	r2, r3
2000f572:	68fb      	ldr	r3, [r7, #12]
2000f574:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000f576:	f7f5 f99b 	bl	200048b0 <HAL_DMA_Start_IT>
2000f57a:	4603      	mov	r3, r0
2000f57c:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2000f57e:	7dfb      	ldrb	r3, [r7, #23]
2000f580:	2b00      	cmp	r3, #0
2000f582:	d12b      	bne.n	2000f5dc <HAL_I2C_Slave_Seq_Transmit_DMA+0x244>
2000f584:	e013      	b.n	2000f5ae <HAL_I2C_Slave_Seq_Transmit_DMA+0x216>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2000f586:	68fb      	ldr	r3, [r7, #12]
2000f588:	2228      	movs	r2, #40	; 0x28
2000f58a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000f58e:	68fb      	ldr	r3, [r7, #12]
2000f590:	2200      	movs	r2, #0
2000f592:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2000f596:	68fb      	ldr	r3, [r7, #12]
2000f598:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000f59a:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2000f59e:	68fb      	ldr	r3, [r7, #12]
2000f5a0:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000f5a2:	68fb      	ldr	r3, [r7, #12]
2000f5a4:	2200      	movs	r2, #0
2000f5a6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000f5aa:	2301      	movs	r3, #1
2000f5ac:	e042      	b.n	2000f634 <HAL_I2C_Slave_Seq_Transmit_DMA+0x29c>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2000f5ae:	68fb      	ldr	r3, [r7, #12]
2000f5b0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000f5b2:	b29a      	uxth	r2, r3
2000f5b4:	68fb      	ldr	r3, [r7, #12]
2000f5b6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000f5b8:	1ad3      	subs	r3, r2, r3
2000f5ba:	b29a      	uxth	r2, r3
2000f5bc:	68fb      	ldr	r3, [r7, #12]
2000f5be:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
2000f5c0:	68fb      	ldr	r3, [r7, #12]
2000f5c2:	2200      	movs	r2, #0
2000f5c4:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
2000f5c6:	68fb      	ldr	r3, [r7, #12]
2000f5c8:	681b      	ldr	r3, [r3, #0]
2000f5ca:	699b      	ldr	r3, [r3, #24]
2000f5cc:	0c1b      	lsrs	r3, r3, #16
2000f5ce:	b2db      	uxtb	r3, r3
2000f5d0:	f003 0301 	and.w	r3, r3, #1
2000f5d4:	b2db      	uxtb	r3, r3
2000f5d6:	2b01      	cmp	r3, #1
2000f5d8:	d118      	bne.n	2000f60c <HAL_I2C_Slave_Seq_Transmit_DMA+0x274>
2000f5da:	e013      	b.n	2000f604 <HAL_I2C_Slave_Seq_Transmit_DMA+0x26c>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2000f5dc:	68fb      	ldr	r3, [r7, #12]
2000f5de:	2228      	movs	r2, #40	; 0x28
2000f5e0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000f5e4:	68fb      	ldr	r3, [r7, #12]
2000f5e6:	2200      	movs	r2, #0
2000f5e8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000f5ec:	68fb      	ldr	r3, [r7, #12]
2000f5ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000f5f0:	f043 0210 	orr.w	r2, r3, #16
2000f5f4:	68fb      	ldr	r3, [r7, #12]
2000f5f6:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000f5f8:	68fb      	ldr	r3, [r7, #12]
2000f5fa:	2200      	movs	r2, #0
2000f5fc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000f600:	2301      	movs	r3, #1
2000f602:	e017      	b.n	2000f634 <HAL_I2C_Slave_Seq_Transmit_DMA+0x29c>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2000f604:	68fb      	ldr	r3, [r7, #12]
2000f606:	681b      	ldr	r3, [r3, #0]
2000f608:	2208      	movs	r2, #8
2000f60a:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000f60c:	68fb      	ldr	r3, [r7, #12]
2000f60e:	2200      	movs	r2, #0
2000f610:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* Enable ERR, STOP, NACK, ADDR interrupts */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2000f614:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000f618:	68f8      	ldr	r0, [r7, #12]
2000f61a:	f002 fba7 	bl	20011d6c <I2C_Enable_IRQ>

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2000f61e:	68fb      	ldr	r3, [r7, #12]
2000f620:	681b      	ldr	r3, [r3, #0]
2000f622:	681a      	ldr	r2, [r3, #0]
2000f624:	68fb      	ldr	r3, [r7, #12]
2000f626:	681b      	ldr	r3, [r3, #0]
2000f628:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2000f62c:	601a      	str	r2, [r3, #0]

    return HAL_OK;
2000f62e:	2300      	movs	r3, #0
2000f630:	e000      	b.n	2000f634 <HAL_I2C_Slave_Seq_Transmit_DMA+0x29c>
  }
  else
  {
    return HAL_ERROR;
2000f632:	2301      	movs	r3, #1
  }
}
2000f634:	4618      	mov	r0, r3
2000f636:	3718      	adds	r7, #24
2000f638:	46bd      	mov	sp, r7
2000f63a:	bd80      	pop	{r7, pc}
2000f63c:	2001c180 	.word	0x2001c180
2000f640:	20011925 	.word	0x20011925
2000f644:	20010431 	.word	0x20010431
2000f648:	20011479 	.word	0x20011479
2000f64c:	200116b5 	.word	0x200116b5

2000f650 <HAL_I2C_Slave_Seq_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2000f650:	b580      	push	{r7, lr}
2000f652:	b084      	sub	sp, #16
2000f654:	af00      	add	r7, sp, #0
2000f656:	60f8      	str	r0, [r7, #12]
2000f658:	60b9      	str	r1, [r7, #8]
2000f65a:	603b      	str	r3, [r7, #0]
2000f65c:	4613      	mov	r3, r2
2000f65e:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
2000f660:	683b      	ldr	r3, [r7, #0]
2000f662:	2b00      	cmp	r3, #0
2000f664:	d01e      	beq.n	2000f6a4 <HAL_I2C_Slave_Seq_Receive_IT+0x54>
2000f666:	683b      	ldr	r3, [r7, #0]
2000f668:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000f66c:	d01a      	beq.n	2000f6a4 <HAL_I2C_Slave_Seq_Receive_IT+0x54>
2000f66e:	683b      	ldr	r3, [r7, #0]
2000f670:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000f674:	d016      	beq.n	2000f6a4 <HAL_I2C_Slave_Seq_Receive_IT+0x54>
2000f676:	683b      	ldr	r3, [r7, #0]
2000f678:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000f67c:	d012      	beq.n	2000f6a4 <HAL_I2C_Slave_Seq_Receive_IT+0x54>
2000f67e:	683b      	ldr	r3, [r7, #0]
2000f680:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000f684:	d00e      	beq.n	2000f6a4 <HAL_I2C_Slave_Seq_Receive_IT+0x54>
2000f686:	683b      	ldr	r3, [r7, #0]
2000f688:	2b00      	cmp	r3, #0
2000f68a:	d00b      	beq.n	2000f6a4 <HAL_I2C_Slave_Seq_Receive_IT+0x54>
2000f68c:	683b      	ldr	r3, [r7, #0]
2000f68e:	2baa      	cmp	r3, #170	; 0xaa
2000f690:	d008      	beq.n	2000f6a4 <HAL_I2C_Slave_Seq_Receive_IT+0x54>
2000f692:	683b      	ldr	r3, [r7, #0]
2000f694:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000f698:	d004      	beq.n	2000f6a4 <HAL_I2C_Slave_Seq_Receive_IT+0x54>
2000f69a:	f640 7156 	movw	r1, #3926	; 0xf56
2000f69e:	484d      	ldr	r0, [pc, #308]	; (2000f7d4 <HAL_I2C_Slave_Seq_Receive_IT+0x184>)
2000f6a0:	f7f1 f928 	bl	200008f4 <assert_failed>

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2000f6a4:	68fb      	ldr	r3, [r7, #12]
2000f6a6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f6aa:	b2db      	uxtb	r3, r3
2000f6ac:	f003 0328 	and.w	r3, r3, #40	; 0x28
2000f6b0:	2b28      	cmp	r3, #40	; 0x28
2000f6b2:	f040 808a 	bne.w	2000f7ca <HAL_I2C_Slave_Seq_Receive_IT+0x17a>
  {
    if ((pData == NULL) || (Size == 0U))
2000f6b6:	68bb      	ldr	r3, [r7, #8]
2000f6b8:	2b00      	cmp	r3, #0
2000f6ba:	d002      	beq.n	2000f6c2 <HAL_I2C_Slave_Seq_Receive_IT+0x72>
2000f6bc:	88fb      	ldrh	r3, [r7, #6]
2000f6be:	2b00      	cmp	r3, #0
2000f6c0:	d105      	bne.n	2000f6ce <HAL_I2C_Slave_Seq_Receive_IT+0x7e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000f6c2:	68fb      	ldr	r3, [r7, #12]
2000f6c4:	f44f 7200 	mov.w	r2, #512	; 0x200
2000f6c8:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000f6ca:	2301      	movs	r3, #1
2000f6cc:	e07e      	b.n	2000f7cc <HAL_I2C_Slave_Seq_Receive_IT+0x17c>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2000f6ce:	f248 0102 	movw	r1, #32770	; 0x8002
2000f6d2:	68f8      	ldr	r0, [r7, #12]
2000f6d4:	f002 fbae 	bl	20011e34 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000f6d8:	68fb      	ldr	r3, [r7, #12]
2000f6da:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000f6de:	2b01      	cmp	r3, #1
2000f6e0:	d101      	bne.n	2000f6e6 <HAL_I2C_Slave_Seq_Receive_IT+0x96>
2000f6e2:	2302      	movs	r3, #2
2000f6e4:	e072      	b.n	2000f7cc <HAL_I2C_Slave_Seq_Receive_IT+0x17c>
2000f6e6:	68fb      	ldr	r3, [r7, #12]
2000f6e8:	2201      	movs	r2, #1
2000f6ea:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2000f6ee:	68fb      	ldr	r3, [r7, #12]
2000f6f0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f6f4:	b2db      	uxtb	r3, r3
2000f6f6:	2b29      	cmp	r3, #41	; 0x29
2000f6f8:	d12a      	bne.n	2000f750 <HAL_I2C_Slave_Seq_Receive_IT+0x100>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2000f6fa:	2101      	movs	r1, #1
2000f6fc:	68f8      	ldr	r0, [r7, #12]
2000f6fe:	f002 fb99 	bl	20011e34 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2000f702:	68fb      	ldr	r3, [r7, #12]
2000f704:	681b      	ldr	r3, [r3, #0]
2000f706:	681b      	ldr	r3, [r3, #0]
2000f708:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2000f70c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2000f710:	d11e      	bne.n	2000f750 <HAL_I2C_Slave_Seq_Receive_IT+0x100>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2000f712:	68fb      	ldr	r3, [r7, #12]
2000f714:	681b      	ldr	r3, [r3, #0]
2000f716:	681a      	ldr	r2, [r3, #0]
2000f718:	68fb      	ldr	r3, [r7, #12]
2000f71a:	681b      	ldr	r3, [r3, #0]
2000f71c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2000f720:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2000f722:	68fb      	ldr	r3, [r7, #12]
2000f724:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f726:	2b00      	cmp	r3, #0
2000f728:	d012      	beq.n	2000f750 <HAL_I2C_Slave_Seq_Receive_IT+0x100>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2000f72a:	68fb      	ldr	r3, [r7, #12]
2000f72c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f72e:	4a2a      	ldr	r2, [pc, #168]	; (2000f7d8 <HAL_I2C_Slave_Seq_Receive_IT+0x188>)
2000f730:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2000f732:	68fb      	ldr	r3, [r7, #12]
2000f734:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f736:	4618      	mov	r0, r3
2000f738:	f7f5 fe50 	bl	200053dc <HAL_DMA_Abort_IT>
2000f73c:	4603      	mov	r3, r0
2000f73e:	2b00      	cmp	r3, #0
2000f740:	d006      	beq.n	2000f750 <HAL_I2C_Slave_Seq_Receive_IT+0x100>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2000f742:	68fb      	ldr	r3, [r7, #12]
2000f744:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f746:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000f748:	68fa      	ldr	r2, [r7, #12]
2000f74a:	6b92      	ldr	r2, [r2, #56]	; 0x38
2000f74c:	4610      	mov	r0, r2
2000f74e:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2000f750:	68fb      	ldr	r3, [r7, #12]
2000f752:	222a      	movs	r2, #42	; 0x2a
2000f754:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2000f758:	68fb      	ldr	r3, [r7, #12]
2000f75a:	2220      	movs	r2, #32
2000f75c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000f760:	68fb      	ldr	r3, [r7, #12]
2000f762:	2200      	movs	r2, #0
2000f764:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2000f766:	68fb      	ldr	r3, [r7, #12]
2000f768:	681b      	ldr	r3, [r3, #0]
2000f76a:	685a      	ldr	r2, [r3, #4]
2000f76c:	68fb      	ldr	r3, [r7, #12]
2000f76e:	681b      	ldr	r3, [r3, #0]
2000f770:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000f774:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000f776:	68fb      	ldr	r3, [r7, #12]
2000f778:	68ba      	ldr	r2, [r7, #8]
2000f77a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000f77c:	68fb      	ldr	r3, [r7, #12]
2000f77e:	88fa      	ldrh	r2, [r7, #6]
2000f780:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2000f782:	68fb      	ldr	r3, [r7, #12]
2000f784:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000f786:	b29a      	uxth	r2, r3
2000f788:	68fb      	ldr	r3, [r7, #12]
2000f78a:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2000f78c:	68fb      	ldr	r3, [r7, #12]
2000f78e:	683a      	ldr	r2, [r7, #0]
2000f790:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2000f792:	68fb      	ldr	r3, [r7, #12]
2000f794:	4a11      	ldr	r2, [pc, #68]	; (2000f7dc <HAL_I2C_Slave_Seq_Receive_IT+0x18c>)
2000f796:	635a      	str	r2, [r3, #52]	; 0x34

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
2000f798:	68fb      	ldr	r3, [r7, #12]
2000f79a:	681b      	ldr	r3, [r3, #0]
2000f79c:	699b      	ldr	r3, [r3, #24]
2000f79e:	0c1b      	lsrs	r3, r3, #16
2000f7a0:	b2db      	uxtb	r3, r3
2000f7a2:	f003 0301 	and.w	r3, r3, #1
2000f7a6:	b2db      	uxtb	r3, r3
2000f7a8:	2b00      	cmp	r3, #0
2000f7aa:	d103      	bne.n	2000f7b4 <HAL_I2C_Slave_Seq_Receive_IT+0x164>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2000f7ac:	68fb      	ldr	r3, [r7, #12]
2000f7ae:	681b      	ldr	r3, [r3, #0]
2000f7b0:	2208      	movs	r2, #8
2000f7b2:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000f7b4:	68fb      	ldr	r3, [r7, #12]
2000f7b6:	2200      	movs	r2, #0
2000f7b8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2000f7bc:	f248 0102 	movw	r1, #32770	; 0x8002
2000f7c0:	68f8      	ldr	r0, [r7, #12]
2000f7c2:	f002 fad3 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000f7c6:	2300      	movs	r3, #0
2000f7c8:	e000      	b.n	2000f7cc <HAL_I2C_Slave_Seq_Receive_IT+0x17c>
  }
  else
  {
    return HAL_ERROR;
2000f7ca:	2301      	movs	r3, #1
  }
}
2000f7cc:	4618      	mov	r0, r3
2000f7ce:	3710      	adds	r7, #16
2000f7d0:	46bd      	mov	sp, r7
2000f7d2:	bd80      	pop	{r7, pc}
2000f7d4:	2001c180 	.word	0x2001c180
2000f7d8:	20011925 	.word	0x20011925
2000f7dc:	20010045 	.word	0x20010045

2000f7e0 <HAL_I2C_Slave_Seq_Receive_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2000f7e0:	b580      	push	{r7, lr}
2000f7e2:	b086      	sub	sp, #24
2000f7e4:	af00      	add	r7, sp, #0
2000f7e6:	60f8      	str	r0, [r7, #12]
2000f7e8:	60b9      	str	r1, [r7, #8]
2000f7ea:	603b      	str	r3, [r7, #0]
2000f7ec:	4613      	mov	r3, r2
2000f7ee:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
2000f7f0:	683b      	ldr	r3, [r7, #0]
2000f7f2:	2b00      	cmp	r3, #0
2000f7f4:	d01e      	beq.n	2000f834 <HAL_I2C_Slave_Seq_Receive_DMA+0x54>
2000f7f6:	683b      	ldr	r3, [r7, #0]
2000f7f8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000f7fc:	d01a      	beq.n	2000f834 <HAL_I2C_Slave_Seq_Receive_DMA+0x54>
2000f7fe:	683b      	ldr	r3, [r7, #0]
2000f800:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000f804:	d016      	beq.n	2000f834 <HAL_I2C_Slave_Seq_Receive_DMA+0x54>
2000f806:	683b      	ldr	r3, [r7, #0]
2000f808:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000f80c:	d012      	beq.n	2000f834 <HAL_I2C_Slave_Seq_Receive_DMA+0x54>
2000f80e:	683b      	ldr	r3, [r7, #0]
2000f810:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000f814:	d00e      	beq.n	2000f834 <HAL_I2C_Slave_Seq_Receive_DMA+0x54>
2000f816:	683b      	ldr	r3, [r7, #0]
2000f818:	2b00      	cmp	r3, #0
2000f81a:	d00b      	beq.n	2000f834 <HAL_I2C_Slave_Seq_Receive_DMA+0x54>
2000f81c:	683b      	ldr	r3, [r7, #0]
2000f81e:	2baa      	cmp	r3, #170	; 0xaa
2000f820:	d008      	beq.n	2000f834 <HAL_I2C_Slave_Seq_Receive_DMA+0x54>
2000f822:	683b      	ldr	r3, [r7, #0]
2000f824:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000f828:	d004      	beq.n	2000f834 <HAL_I2C_Slave_Seq_Receive_DMA+0x54>
2000f82a:	f640 71b7 	movw	r1, #4023	; 0xfb7
2000f82e:	4895      	ldr	r0, [pc, #596]	; (2000fa84 <HAL_I2C_Slave_Seq_Receive_DMA+0x2a4>)
2000f830:	f7f1 f860 	bl	200008f4 <assert_failed>

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2000f834:	68fb      	ldr	r3, [r7, #12]
2000f836:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f83a:	b2db      	uxtb	r3, r3
2000f83c:	f003 0328 	and.w	r3, r3, #40	; 0x28
2000f840:	2b28      	cmp	r3, #40	; 0x28
2000f842:	f040 811a 	bne.w	2000fa7a <HAL_I2C_Slave_Seq_Receive_DMA+0x29a>
  {
    if ((pData == NULL) || (Size == 0U))
2000f846:	68bb      	ldr	r3, [r7, #8]
2000f848:	2b00      	cmp	r3, #0
2000f84a:	d002      	beq.n	2000f852 <HAL_I2C_Slave_Seq_Receive_DMA+0x72>
2000f84c:	88fb      	ldrh	r3, [r7, #6]
2000f84e:	2b00      	cmp	r3, #0
2000f850:	d105      	bne.n	2000f85e <HAL_I2C_Slave_Seq_Receive_DMA+0x7e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000f852:	68fb      	ldr	r3, [r7, #12]
2000f854:	f44f 7200 	mov.w	r2, #512	; 0x200
2000f858:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000f85a:	2301      	movs	r3, #1
2000f85c:	e10e      	b.n	2000fa7c <HAL_I2C_Slave_Seq_Receive_DMA+0x29c>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2000f85e:	f248 0102 	movw	r1, #32770	; 0x8002
2000f862:	68f8      	ldr	r0, [r7, #12]
2000f864:	f002 fae6 	bl	20011e34 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2000f868:	68fb      	ldr	r3, [r7, #12]
2000f86a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000f86e:	2b01      	cmp	r3, #1
2000f870:	d101      	bne.n	2000f876 <HAL_I2C_Slave_Seq_Receive_DMA+0x96>
2000f872:	2302      	movs	r3, #2
2000f874:	e102      	b.n	2000fa7c <HAL_I2C_Slave_Seq_Receive_DMA+0x29c>
2000f876:	68fb      	ldr	r3, [r7, #12]
2000f878:	2201      	movs	r2, #1
2000f87a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2000f87e:	68fb      	ldr	r3, [r7, #12]
2000f880:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f884:	b2db      	uxtb	r3, r3
2000f886:	2b29      	cmp	r3, #41	; 0x29
2000f888:	d12b      	bne.n	2000f8e2 <HAL_I2C_Slave_Seq_Receive_DMA+0x102>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2000f88a:	2101      	movs	r1, #1
2000f88c:	68f8      	ldr	r0, [r7, #12]
2000f88e:	f002 fad1 	bl	20011e34 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2000f892:	68fb      	ldr	r3, [r7, #12]
2000f894:	681b      	ldr	r3, [r3, #0]
2000f896:	681b      	ldr	r3, [r3, #0]
2000f898:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2000f89c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2000f8a0:	d14c      	bne.n	2000f93c <HAL_I2C_Slave_Seq_Receive_DMA+0x15c>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2000f8a2:	68fb      	ldr	r3, [r7, #12]
2000f8a4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f8a6:	2b00      	cmp	r3, #0
2000f8a8:	d048      	beq.n	2000f93c <HAL_I2C_Slave_Seq_Receive_DMA+0x15c>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2000f8aa:	68fb      	ldr	r3, [r7, #12]
2000f8ac:	681b      	ldr	r3, [r3, #0]
2000f8ae:	681a      	ldr	r2, [r3, #0]
2000f8b0:	68fb      	ldr	r3, [r7, #12]
2000f8b2:	681b      	ldr	r3, [r3, #0]
2000f8b4:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2000f8b8:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2000f8ba:	68fb      	ldr	r3, [r7, #12]
2000f8bc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f8be:	4a72      	ldr	r2, [pc, #456]	; (2000fa88 <HAL_I2C_Slave_Seq_Receive_DMA+0x2a8>)
2000f8c0:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2000f8c2:	68fb      	ldr	r3, [r7, #12]
2000f8c4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f8c6:	4618      	mov	r0, r3
2000f8c8:	f7f5 fd88 	bl	200053dc <HAL_DMA_Abort_IT>
2000f8cc:	4603      	mov	r3, r0
2000f8ce:	2b00      	cmp	r3, #0
2000f8d0:	d034      	beq.n	2000f93c <HAL_I2C_Slave_Seq_Receive_DMA+0x15c>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2000f8d2:	68fb      	ldr	r3, [r7, #12]
2000f8d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000f8d6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000f8d8:	68fa      	ldr	r2, [r7, #12]
2000f8da:	6b92      	ldr	r2, [r2, #56]	; 0x38
2000f8dc:	4610      	mov	r0, r2
2000f8de:	4798      	blx	r3
2000f8e0:	e02c      	b.n	2000f93c <HAL_I2C_Slave_Seq_Receive_DMA+0x15c>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2000f8e2:	68fb      	ldr	r3, [r7, #12]
2000f8e4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000f8e8:	b2db      	uxtb	r3, r3
2000f8ea:	2b2a      	cmp	r3, #42	; 0x2a
2000f8ec:	d126      	bne.n	2000f93c <HAL_I2C_Slave_Seq_Receive_DMA+0x15c>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2000f8ee:	68fb      	ldr	r3, [r7, #12]
2000f8f0:	681b      	ldr	r3, [r3, #0]
2000f8f2:	681b      	ldr	r3, [r3, #0]
2000f8f4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000f8f8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000f8fc:	d11e      	bne.n	2000f93c <HAL_I2C_Slave_Seq_Receive_DMA+0x15c>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2000f8fe:	68fb      	ldr	r3, [r7, #12]
2000f900:	681b      	ldr	r3, [r3, #0]
2000f902:	681a      	ldr	r2, [r3, #0]
2000f904:	68fb      	ldr	r3, [r7, #12]
2000f906:	681b      	ldr	r3, [r3, #0]
2000f908:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000f90c:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
2000f90e:	68fb      	ldr	r3, [r7, #12]
2000f910:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f912:	2b00      	cmp	r3, #0
2000f914:	d012      	beq.n	2000f93c <HAL_I2C_Slave_Seq_Receive_DMA+0x15c>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2000f916:	68fb      	ldr	r3, [r7, #12]
2000f918:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f91a:	4a5b      	ldr	r2, [pc, #364]	; (2000fa88 <HAL_I2C_Slave_Seq_Receive_DMA+0x2a8>)
2000f91c:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2000f91e:	68fb      	ldr	r3, [r7, #12]
2000f920:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f922:	4618      	mov	r0, r3
2000f924:	f7f5 fd5a 	bl	200053dc <HAL_DMA_Abort_IT>
2000f928:	4603      	mov	r3, r0
2000f92a:	2b00      	cmp	r3, #0
2000f92c:	d006      	beq.n	2000f93c <HAL_I2C_Slave_Seq_Receive_DMA+0x15c>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2000f92e:	68fb      	ldr	r3, [r7, #12]
2000f930:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f932:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000f934:	68fa      	ldr	r2, [r7, #12]
2000f936:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2000f938:	4610      	mov	r0, r2
2000f93a:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2000f93c:	68fb      	ldr	r3, [r7, #12]
2000f93e:	222a      	movs	r2, #42	; 0x2a
2000f940:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2000f944:	68fb      	ldr	r3, [r7, #12]
2000f946:	2220      	movs	r2, #32
2000f948:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000f94c:	68fb      	ldr	r3, [r7, #12]
2000f94e:	2200      	movs	r2, #0
2000f950:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2000f952:	68fb      	ldr	r3, [r7, #12]
2000f954:	681b      	ldr	r3, [r3, #0]
2000f956:	685a      	ldr	r2, [r3, #4]
2000f958:	68fb      	ldr	r3, [r7, #12]
2000f95a:	681b      	ldr	r3, [r3, #0]
2000f95c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000f960:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000f962:	68fb      	ldr	r3, [r7, #12]
2000f964:	68ba      	ldr	r2, [r7, #8]
2000f966:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000f968:	68fb      	ldr	r3, [r7, #12]
2000f96a:	88fa      	ldrh	r2, [r7, #6]
2000f96c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2000f96e:	68fb      	ldr	r3, [r7, #12]
2000f970:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000f972:	b29a      	uxth	r2, r3
2000f974:	68fb      	ldr	r3, [r7, #12]
2000f976:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2000f978:	68fb      	ldr	r3, [r7, #12]
2000f97a:	683a      	ldr	r2, [r7, #0]
2000f97c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2000f97e:	68fb      	ldr	r3, [r7, #12]
2000f980:	4a42      	ldr	r2, [pc, #264]	; (2000fa8c <HAL_I2C_Slave_Seq_Receive_DMA+0x2ac>)
2000f982:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
2000f984:	68fb      	ldr	r3, [r7, #12]
2000f986:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f988:	2b00      	cmp	r3, #0
2000f98a:	d020      	beq.n	2000f9ce <HAL_I2C_Slave_Seq_Receive_DMA+0x1ee>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2000f98c:	68fb      	ldr	r3, [r7, #12]
2000f98e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f990:	4a3f      	ldr	r2, [pc, #252]	; (2000fa90 <HAL_I2C_Slave_Seq_Receive_DMA+0x2b0>)
2000f992:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2000f994:	68fb      	ldr	r3, [r7, #12]
2000f996:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f998:	4a3e      	ldr	r2, [pc, #248]	; (2000fa94 <HAL_I2C_Slave_Seq_Receive_DMA+0x2b4>)
2000f99a:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2000f99c:	68fb      	ldr	r3, [r7, #12]
2000f99e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f9a0:	2200      	movs	r2, #0
2000f9a2:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2000f9a4:	68fb      	ldr	r3, [r7, #12]
2000f9a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000f9a8:	2200      	movs	r2, #0
2000f9aa:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2000f9ac:	68fb      	ldr	r3, [r7, #12]
2000f9ae:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2000f9b0:	68fb      	ldr	r3, [r7, #12]
2000f9b2:	681b      	ldr	r3, [r3, #0]
2000f9b4:	3324      	adds	r3, #36	; 0x24
2000f9b6:	4619      	mov	r1, r3
2000f9b8:	68ba      	ldr	r2, [r7, #8]
2000f9ba:	68fb      	ldr	r3, [r7, #12]
2000f9bc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000f9be:	f7f4 ff77 	bl	200048b0 <HAL_DMA_Start_IT>
2000f9c2:	4603      	mov	r3, r0
2000f9c4:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2000f9c6:	7dfb      	ldrb	r3, [r7, #23]
2000f9c8:	2b00      	cmp	r3, #0
2000f9ca:	d12b      	bne.n	2000fa24 <HAL_I2C_Slave_Seq_Receive_DMA+0x244>
2000f9cc:	e013      	b.n	2000f9f6 <HAL_I2C_Slave_Seq_Receive_DMA+0x216>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2000f9ce:	68fb      	ldr	r3, [r7, #12]
2000f9d0:	2228      	movs	r2, #40	; 0x28
2000f9d2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000f9d6:	68fb      	ldr	r3, [r7, #12]
2000f9d8:	2200      	movs	r2, #0
2000f9da:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2000f9de:	68fb      	ldr	r3, [r7, #12]
2000f9e0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000f9e2:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2000f9e6:	68fb      	ldr	r3, [r7, #12]
2000f9e8:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000f9ea:	68fb      	ldr	r3, [r7, #12]
2000f9ec:	2200      	movs	r2, #0
2000f9ee:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000f9f2:	2301      	movs	r3, #1
2000f9f4:	e042      	b.n	2000fa7c <HAL_I2C_Slave_Seq_Receive_DMA+0x29c>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2000f9f6:	68fb      	ldr	r3, [r7, #12]
2000f9f8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000f9fa:	b29a      	uxth	r2, r3
2000f9fc:	68fb      	ldr	r3, [r7, #12]
2000f9fe:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000fa00:	1ad3      	subs	r3, r2, r3
2000fa02:	b29a      	uxth	r2, r3
2000fa04:	68fb      	ldr	r3, [r7, #12]
2000fa06:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
2000fa08:	68fb      	ldr	r3, [r7, #12]
2000fa0a:	2200      	movs	r2, #0
2000fa0c:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
2000fa0e:	68fb      	ldr	r3, [r7, #12]
2000fa10:	681b      	ldr	r3, [r3, #0]
2000fa12:	699b      	ldr	r3, [r3, #24]
2000fa14:	0c1b      	lsrs	r3, r3, #16
2000fa16:	b2db      	uxtb	r3, r3
2000fa18:	f003 0301 	and.w	r3, r3, #1
2000fa1c:	b2db      	uxtb	r3, r3
2000fa1e:	2b00      	cmp	r3, #0
2000fa20:	d118      	bne.n	2000fa54 <HAL_I2C_Slave_Seq_Receive_DMA+0x274>
2000fa22:	e013      	b.n	2000fa4c <HAL_I2C_Slave_Seq_Receive_DMA+0x26c>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2000fa24:	68fb      	ldr	r3, [r7, #12]
2000fa26:	2228      	movs	r2, #40	; 0x28
2000fa28:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000fa2c:	68fb      	ldr	r3, [r7, #12]
2000fa2e:	2200      	movs	r2, #0
2000fa30:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000fa34:	68fb      	ldr	r3, [r7, #12]
2000fa36:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000fa38:	f043 0210 	orr.w	r2, r3, #16
2000fa3c:	68fb      	ldr	r3, [r7, #12]
2000fa3e:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000fa40:	68fb      	ldr	r3, [r7, #12]
2000fa42:	2200      	movs	r2, #0
2000fa44:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000fa48:	2301      	movs	r3, #1
2000fa4a:	e017      	b.n	2000fa7c <HAL_I2C_Slave_Seq_Receive_DMA+0x29c>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2000fa4c:	68fb      	ldr	r3, [r7, #12]
2000fa4e:	681b      	ldr	r3, [r3, #0]
2000fa50:	2208      	movs	r2, #8
2000fa52:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000fa54:	68fb      	ldr	r3, [r7, #12]
2000fa56:	2200      	movs	r2, #0
2000fa58:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2000fa5c:	f248 0102 	movw	r1, #32770	; 0x8002
2000fa60:	68f8      	ldr	r0, [r7, #12]
2000fa62:	f002 f983 	bl	20011d6c <I2C_Enable_IRQ>

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2000fa66:	68fb      	ldr	r3, [r7, #12]
2000fa68:	681b      	ldr	r3, [r3, #0]
2000fa6a:	681a      	ldr	r2, [r3, #0]
2000fa6c:	68fb      	ldr	r3, [r7, #12]
2000fa6e:	681b      	ldr	r3, [r3, #0]
2000fa70:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000fa74:	601a      	str	r2, [r3, #0]

    return HAL_OK;
2000fa76:	2300      	movs	r3, #0
2000fa78:	e000      	b.n	2000fa7c <HAL_I2C_Slave_Seq_Receive_DMA+0x29c>
  }
  else
  {
    return HAL_ERROR;
2000fa7a:	2301      	movs	r3, #1
  }
}
2000fa7c:	4618      	mov	r0, r3
2000fa7e:	3718      	adds	r7, #24
2000fa80:	46bd      	mov	sp, r7
2000fa82:	bd80      	pop	{r7, pc}
2000fa84:	2001c180 	.word	0x2001c180
2000fa88:	20011925 	.word	0x20011925
2000fa8c:	20010431 	.word	0x20010431
2000fa90:	20011551 	.word	0x20011551
2000fa94:	200116b5 	.word	0x200116b5

2000fa98 <HAL_I2C_EnableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
{
2000fa98:	b580      	push	{r7, lr}
2000fa9a:	b082      	sub	sp, #8
2000fa9c:	af00      	add	r7, sp, #0
2000fa9e:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_READY)
2000faa0:	687b      	ldr	r3, [r7, #4]
2000faa2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000faa6:	b2db      	uxtb	r3, r3
2000faa8:	2b20      	cmp	r3, #32
2000faaa:	d10d      	bne.n	2000fac8 <HAL_I2C_EnableListen_IT+0x30>
  {
    hi2c->State = HAL_I2C_STATE_LISTEN;
2000faac:	687b      	ldr	r3, [r7, #4]
2000faae:	2228      	movs	r2, #40	; 0x28
2000fab0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR = I2C_Slave_ISR_IT;
2000fab4:	687b      	ldr	r3, [r7, #4]
2000fab6:	4a07      	ldr	r2, [pc, #28]	; (2000fad4 <HAL_I2C_EnableListen_IT+0x3c>)
2000fab8:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable the Address Match interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2000faba:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000fabe:	6878      	ldr	r0, [r7, #4]
2000fac0:	f002 f954 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000fac4:	2300      	movs	r3, #0
2000fac6:	e000      	b.n	2000faca <HAL_I2C_EnableListen_IT+0x32>
  }
  else
  {
    return HAL_BUSY;
2000fac8:	2302      	movs	r3, #2
  }
}
2000faca:	4618      	mov	r0, r3
2000facc:	3708      	adds	r7, #8
2000face:	46bd      	mov	sp, r7
2000fad0:	bd80      	pop	{r7, pc}
2000fad2:	bf00      	nop
2000fad4:	20010045 	.word	0x20010045

2000fad8 <HAL_I2C_DisableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
{
2000fad8:	b580      	push	{r7, lr}
2000fada:	b084      	sub	sp, #16
2000fadc:	af00      	add	r7, sp, #0
2000fade:	6078      	str	r0, [r7, #4]
  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp;

  /* Disable Address listen mode only if a transfer is not ongoing */
  if (hi2c->State == HAL_I2C_STATE_LISTEN)
2000fae0:	687b      	ldr	r3, [r7, #4]
2000fae2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000fae6:	b2db      	uxtb	r3, r3
2000fae8:	2b28      	cmp	r3, #40	; 0x28
2000faea:	d121      	bne.n	2000fb30 <HAL_I2C_DisableListen_IT+0x58>
  {
    tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
2000faec:	687b      	ldr	r3, [r7, #4]
2000faee:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000faf2:	b2db      	uxtb	r3, r3
2000faf4:	f003 0303 	and.w	r3, r3, #3
2000faf8:	60fb      	str	r3, [r7, #12]
    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
2000fafa:	687b      	ldr	r3, [r7, #4]
2000fafc:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2000fb00:	b2db      	uxtb	r3, r3
2000fb02:	461a      	mov	r2, r3
2000fb04:	68fb      	ldr	r3, [r7, #12]
2000fb06:	431a      	orrs	r2, r3
2000fb08:	687b      	ldr	r3, [r7, #4]
2000fb0a:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_READY;
2000fb0c:	687b      	ldr	r3, [r7, #4]
2000fb0e:	2220      	movs	r2, #32
2000fb10:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2000fb14:	687b      	ldr	r3, [r7, #4]
2000fb16:	2200      	movs	r2, #0
2000fb18:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->XferISR = NULL;
2000fb1c:	687b      	ldr	r3, [r7, #4]
2000fb1e:	2200      	movs	r2, #0
2000fb20:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable the Address Match interrupt */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2000fb22:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000fb26:	6878      	ldr	r0, [r7, #4]
2000fb28:	f002 f984 	bl	20011e34 <I2C_Disable_IRQ>

    return HAL_OK;
2000fb2c:	2300      	movs	r3, #0
2000fb2e:	e000      	b.n	2000fb32 <HAL_I2C_DisableListen_IT+0x5a>
  }
  else
  {
    return HAL_BUSY;
2000fb30:	2302      	movs	r3, #2
  }
}
2000fb32:	4618      	mov	r0, r3
2000fb34:	3710      	adds	r7, #16
2000fb36:	46bd      	mov	sp, r7
2000fb38:	bd80      	pop	{r7, pc}
	...

2000fb3c <HAL_I2C_Master_Abort_IT>:
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
{
2000fb3c:	b580      	push	{r7, lr}
2000fb3e:	b084      	sub	sp, #16
2000fb40:	af02      	add	r7, sp, #8
2000fb42:	6078      	str	r0, [r7, #4]
2000fb44:	460b      	mov	r3, r1
2000fb46:	807b      	strh	r3, [r7, #2]
  if (hi2c->Mode == HAL_I2C_MODE_MASTER)
2000fb48:	687b      	ldr	r3, [r7, #4]
2000fb4a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2000fb4e:	b2db      	uxtb	r3, r3
2000fb50:	2b10      	cmp	r3, #16
2000fb52:	d13c      	bne.n	2000fbce <HAL_I2C_Master_Abort_IT+0x92>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000fb54:	687b      	ldr	r3, [r7, #4]
2000fb56:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000fb5a:	2b01      	cmp	r3, #1
2000fb5c:	d101      	bne.n	2000fb62 <HAL_I2C_Master_Abort_IT+0x26>
2000fb5e:	2302      	movs	r3, #2
2000fb60:	e036      	b.n	2000fbd0 <HAL_I2C_Master_Abort_IT+0x94>
2000fb62:	687b      	ldr	r3, [r7, #4]
2000fb64:	2201      	movs	r2, #1
2000fb66:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts and Store Previous state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2000fb6a:	687b      	ldr	r3, [r7, #4]
2000fb6c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000fb70:	b2db      	uxtb	r3, r3
2000fb72:	2b21      	cmp	r3, #33	; 0x21
2000fb74:	d107      	bne.n	2000fb86 <HAL_I2C_Master_Abort_IT+0x4a>
    {
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2000fb76:	2101      	movs	r1, #1
2000fb78:	6878      	ldr	r0, [r7, #4]
2000fb7a:	f002 f95b 	bl	20011e34 <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2000fb7e:	687b      	ldr	r3, [r7, #4]
2000fb80:	2211      	movs	r2, #17
2000fb82:	631a      	str	r2, [r3, #48]	; 0x30
2000fb84:	e00c      	b.n	2000fba0 <HAL_I2C_Master_Abort_IT+0x64>
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2000fb86:	687b      	ldr	r3, [r7, #4]
2000fb88:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000fb8c:	b2db      	uxtb	r3, r3
2000fb8e:	2b22      	cmp	r3, #34	; 0x22
2000fb90:	d106      	bne.n	2000fba0 <HAL_I2C_Master_Abort_IT+0x64>
    {
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2000fb92:	2102      	movs	r1, #2
2000fb94:	6878      	ldr	r0, [r7, #4]
2000fb96:	f002 f94d 	bl	20011e34 <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2000fb9a:	687b      	ldr	r3, [r7, #4]
2000fb9c:	2212      	movs	r2, #18
2000fb9e:	631a      	str	r2, [r3, #48]	; 0x30
    {
      /* Do nothing */
    }

    /* Set State at HAL_I2C_STATE_ABORT */
    hi2c->State = HAL_I2C_STATE_ABORT;
2000fba0:	687b      	ldr	r3, [r7, #4]
2000fba2:	2260      	movs	r2, #96	; 0x60
2000fba4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */
    /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */
    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
2000fba8:	8879      	ldrh	r1, [r7, #2]
2000fbaa:	4b0b      	ldr	r3, [pc, #44]	; (2000fbd8 <HAL_I2C_Master_Abort_IT+0x9c>)
2000fbac:	9300      	str	r3, [sp, #0]
2000fbae:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000fbb2:	2201      	movs	r2, #1
2000fbb4:	6878      	ldr	r0, [r7, #4]
2000fbb6:	f002 f861 	bl	20011c7c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000fbba:	687b      	ldr	r3, [r7, #4]
2000fbbc:	2200      	movs	r2, #0
2000fbbe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2000fbc2:	2120      	movs	r1, #32
2000fbc4:	6878      	ldr	r0, [r7, #4]
2000fbc6:	f002 f8d1 	bl	20011d6c <I2C_Enable_IRQ>

    return HAL_OK;
2000fbca:	2300      	movs	r3, #0
2000fbcc:	e000      	b.n	2000fbd0 <HAL_I2C_Master_Abort_IT+0x94>
  }
  else
  {
    /* Wrong usage of abort function */
    /* This function should be used only in case of abort monitored by master device */
    return HAL_ERROR;
2000fbce:	2301      	movs	r3, #1
  }
}
2000fbd0:	4618      	mov	r0, r3
2000fbd2:	3708      	adds	r7, #8
2000fbd4:	46bd      	mov	sp, r7
2000fbd6:	bd80      	pop	{r7, pc}
2000fbd8:	80004000 	.word	0x80004000

2000fbdc <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
2000fbdc:	b580      	push	{r7, lr}
2000fbde:	b084      	sub	sp, #16
2000fbe0:	af00      	add	r7, sp, #0
2000fbe2:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
2000fbe4:	687b      	ldr	r3, [r7, #4]
2000fbe6:	681b      	ldr	r3, [r3, #0]
2000fbe8:	699b      	ldr	r3, [r3, #24]
2000fbea:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
2000fbec:	687b      	ldr	r3, [r7, #4]
2000fbee:	681b      	ldr	r3, [r3, #0]
2000fbf0:	681b      	ldr	r3, [r3, #0]
2000fbf2:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
2000fbf4:	687b      	ldr	r3, [r7, #4]
2000fbf6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000fbf8:	2b00      	cmp	r3, #0
2000fbfa:	d005      	beq.n	2000fc08 <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
2000fbfc:	687b      	ldr	r3, [r7, #4]
2000fbfe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000fc00:	68ba      	ldr	r2, [r7, #8]
2000fc02:	68f9      	ldr	r1, [r7, #12]
2000fc04:	6878      	ldr	r0, [r7, #4]
2000fc06:	4798      	blx	r3
  }
}
2000fc08:	bf00      	nop
2000fc0a:	3710      	adds	r7, #16
2000fc0c:	46bd      	mov	sp, r7
2000fc0e:	bd80      	pop	{r7, pc}

2000fc10 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
2000fc10:	b580      	push	{r7, lr}
2000fc12:	b086      	sub	sp, #24
2000fc14:	af00      	add	r7, sp, #0
2000fc16:	6078      	str	r0, [r7, #4]
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
2000fc18:	687b      	ldr	r3, [r7, #4]
2000fc1a:	681b      	ldr	r3, [r3, #0]
2000fc1c:	699b      	ldr	r3, [r3, #24]
2000fc1e:	617b      	str	r3, [r7, #20]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
2000fc20:	687b      	ldr	r3, [r7, #4]
2000fc22:	681b      	ldr	r3, [r3, #0]
2000fc24:	681b      	ldr	r3, [r3, #0]
2000fc26:	613b      	str	r3, [r7, #16]
  uint32_t tmperror;

  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2000fc28:	697b      	ldr	r3, [r7, #20]
2000fc2a:	0a1b      	lsrs	r3, r3, #8
2000fc2c:	f003 0301 	and.w	r3, r3, #1
2000fc30:	2b00      	cmp	r3, #0
2000fc32:	d010      	beq.n	2000fc56 <HAL_I2C_ER_IRQHandler+0x46>
2000fc34:	693b      	ldr	r3, [r7, #16]
2000fc36:	09db      	lsrs	r3, r3, #7
2000fc38:	f003 0301 	and.w	r3, r3, #1
2000fc3c:	2b00      	cmp	r3, #0
2000fc3e:	d00a      	beq.n	2000fc56 <HAL_I2C_ER_IRQHandler+0x46>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
2000fc40:	687b      	ldr	r3, [r7, #4]
2000fc42:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000fc44:	f043 0201 	orr.w	r2, r3, #1
2000fc48:	687b      	ldr	r3, [r7, #4]
2000fc4a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
2000fc4c:	687b      	ldr	r3, [r7, #4]
2000fc4e:	681b      	ldr	r3, [r3, #0]
2000fc50:	f44f 7280 	mov.w	r2, #256	; 0x100
2000fc54:	61da      	str	r2, [r3, #28]
  }

  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2000fc56:	697b      	ldr	r3, [r7, #20]
2000fc58:	0a9b      	lsrs	r3, r3, #10
2000fc5a:	f003 0301 	and.w	r3, r3, #1
2000fc5e:	2b00      	cmp	r3, #0
2000fc60:	d010      	beq.n	2000fc84 <HAL_I2C_ER_IRQHandler+0x74>
2000fc62:	693b      	ldr	r3, [r7, #16]
2000fc64:	09db      	lsrs	r3, r3, #7
2000fc66:	f003 0301 	and.w	r3, r3, #1
2000fc6a:	2b00      	cmp	r3, #0
2000fc6c:	d00a      	beq.n	2000fc84 <HAL_I2C_ER_IRQHandler+0x74>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
2000fc6e:	687b      	ldr	r3, [r7, #4]
2000fc70:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000fc72:	f043 0208 	orr.w	r2, r3, #8
2000fc76:	687b      	ldr	r3, [r7, #4]
2000fc78:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
2000fc7a:	687b      	ldr	r3, [r7, #4]
2000fc7c:	681b      	ldr	r3, [r3, #0]
2000fc7e:	f44f 6280 	mov.w	r2, #1024	; 0x400
2000fc82:	61da      	str	r2, [r3, #28]
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2000fc84:	697b      	ldr	r3, [r7, #20]
2000fc86:	0a5b      	lsrs	r3, r3, #9
2000fc88:	f003 0301 	and.w	r3, r3, #1
2000fc8c:	2b00      	cmp	r3, #0
2000fc8e:	d010      	beq.n	2000fcb2 <HAL_I2C_ER_IRQHandler+0xa2>
2000fc90:	693b      	ldr	r3, [r7, #16]
2000fc92:	09db      	lsrs	r3, r3, #7
2000fc94:	f003 0301 	and.w	r3, r3, #1
2000fc98:	2b00      	cmp	r3, #0
2000fc9a:	d00a      	beq.n	2000fcb2 <HAL_I2C_ER_IRQHandler+0xa2>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
2000fc9c:	687b      	ldr	r3, [r7, #4]
2000fc9e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000fca0:	f043 0202 	orr.w	r2, r3, #2
2000fca4:	687b      	ldr	r3, [r7, #4]
2000fca6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
2000fca8:	687b      	ldr	r3, [r7, #4]
2000fcaa:	681b      	ldr	r3, [r3, #0]
2000fcac:	f44f 7200 	mov.w	r2, #512	; 0x200
2000fcb0:	61da      	str	r2, [r3, #28]
  }

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
2000fcb2:	687b      	ldr	r3, [r7, #4]
2000fcb4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000fcb6:	60fb      	str	r3, [r7, #12]

  /* Call the Error Callback in case of Error detected */
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
2000fcb8:	68fb      	ldr	r3, [r7, #12]
2000fcba:	f003 030b 	and.w	r3, r3, #11
2000fcbe:	2b00      	cmp	r3, #0
2000fcc0:	d003      	beq.n	2000fcca <HAL_I2C_ER_IRQHandler+0xba>
  {
    I2C_ITError(hi2c, tmperror);
2000fcc2:	68f9      	ldr	r1, [r7, #12]
2000fcc4:	6878      	ldr	r0, [r7, #4]
2000fcc6:	f001 fa71 	bl	200111ac <I2C_ITError>
  }
}
2000fcca:	bf00      	nop
2000fccc:	3718      	adds	r7, #24
2000fcce:	46bd      	mov	sp, r7
2000fcd0:	bd80      	pop	{r7, pc}

2000fcd2 <HAL_I2C_MasterTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2000fcd2:	b480      	push	{r7}
2000fcd4:	b083      	sub	sp, #12
2000fcd6:	af00      	add	r7, sp, #0
2000fcd8:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   */
}
2000fcda:	bf00      	nop
2000fcdc:	370c      	adds	r7, #12
2000fcde:	46bd      	mov	sp, r7
2000fce0:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fce4:	4770      	bx	lr

2000fce6 <HAL_I2C_MasterRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2000fce6:	b480      	push	{r7}
2000fce8:	b083      	sub	sp, #12
2000fcea:	af00      	add	r7, sp, #0
2000fcec:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   */
}
2000fcee:	bf00      	nop
2000fcf0:	370c      	adds	r7, #12
2000fcf2:	46bd      	mov	sp, r7
2000fcf4:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fcf8:	4770      	bx	lr

2000fcfa <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2000fcfa:	b480      	push	{r7}
2000fcfc:	b083      	sub	sp, #12
2000fcfe:	af00      	add	r7, sp, #0
2000fd00:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */
}
2000fd02:	bf00      	nop
2000fd04:	370c      	adds	r7, #12
2000fd06:	46bd      	mov	sp, r7
2000fd08:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fd0c:	4770      	bx	lr

2000fd0e <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2000fd0e:	b480      	push	{r7}
2000fd10:	b083      	sub	sp, #12
2000fd12:	af00      	add	r7, sp, #0
2000fd14:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */
}
2000fd16:	bf00      	nop
2000fd18:	370c      	adds	r7, #12
2000fd1a:	46bd      	mov	sp, r7
2000fd1c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fd20:	4770      	bx	lr

2000fd22 <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
2000fd22:	b480      	push	{r7}
2000fd24:	b083      	sub	sp, #12
2000fd26:	af00      	add	r7, sp, #0
2000fd28:	6078      	str	r0, [r7, #4]
2000fd2a:	460b      	mov	r3, r1
2000fd2c:	70fb      	strb	r3, [r7, #3]
2000fd2e:	4613      	mov	r3, r2
2000fd30:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
2000fd32:	bf00      	nop
2000fd34:	370c      	adds	r7, #12
2000fd36:	46bd      	mov	sp, r7
2000fd38:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fd3c:	4770      	bx	lr

2000fd3e <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
2000fd3e:	b480      	push	{r7}
2000fd40:	b083      	sub	sp, #12
2000fd42:	af00      	add	r7, sp, #0
2000fd44:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   */
}
2000fd46:	bf00      	nop
2000fd48:	370c      	adds	r7, #12
2000fd4a:	46bd      	mov	sp, r7
2000fd4c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fd50:	4770      	bx	lr

2000fd52 <HAL_I2C_MemTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2000fd52:	b480      	push	{r7}
2000fd54:	b083      	sub	sp, #12
2000fd56:	af00      	add	r7, sp, #0
2000fd58:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   */
}
2000fd5a:	bf00      	nop
2000fd5c:	370c      	adds	r7, #12
2000fd5e:	46bd      	mov	sp, r7
2000fd60:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fd64:	4770      	bx	lr

2000fd66 <HAL_I2C_MemRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2000fd66:	b480      	push	{r7}
2000fd68:	b083      	sub	sp, #12
2000fd6a:	af00      	add	r7, sp, #0
2000fd6c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   */
}
2000fd6e:	bf00      	nop
2000fd70:	370c      	adds	r7, #12
2000fd72:	46bd      	mov	sp, r7
2000fd74:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fd78:	4770      	bx	lr

2000fd7a <HAL_I2C_ErrorCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
2000fd7a:	b480      	push	{r7}
2000fd7c:	b083      	sub	sp, #12
2000fd7e:	af00      	add	r7, sp, #0
2000fd80:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ErrorCallback could be implemented in the user file
   */
}
2000fd82:	bf00      	nop
2000fd84:	370c      	adds	r7, #12
2000fd86:	46bd      	mov	sp, r7
2000fd88:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fd8c:	4770      	bx	lr

2000fd8e <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
2000fd8e:	b480      	push	{r7}
2000fd90:	b083      	sub	sp, #12
2000fd92:	af00      	add	r7, sp, #0
2000fd94:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */
}
2000fd96:	bf00      	nop
2000fd98:	370c      	adds	r7, #12
2000fd9a:	46bd      	mov	sp, r7
2000fd9c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fda0:	4770      	bx	lr

2000fda2 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
2000fda2:	b480      	push	{r7}
2000fda4:	b083      	sub	sp, #12
2000fda6:	af00      	add	r7, sp, #0
2000fda8:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
2000fdaa:	687b      	ldr	r3, [r7, #4]
2000fdac:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000fdb0:	b2db      	uxtb	r3, r3
}
2000fdb2:	4618      	mov	r0, r3
2000fdb4:	370c      	adds	r7, #12
2000fdb6:	46bd      	mov	sp, r7
2000fdb8:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fdbc:	4770      	bx	lr

2000fdbe <HAL_I2C_GetMode>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL mode
  */
HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
{
2000fdbe:	b480      	push	{r7}
2000fdc0:	b083      	sub	sp, #12
2000fdc2:	af00      	add	r7, sp, #0
2000fdc4:	6078      	str	r0, [r7, #4]
  return hi2c->Mode;
2000fdc6:	687b      	ldr	r3, [r7, #4]
2000fdc8:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2000fdcc:	b2db      	uxtb	r3, r3
}
2000fdce:	4618      	mov	r0, r3
2000fdd0:	370c      	adds	r7, #12
2000fdd2:	46bd      	mov	sp, r7
2000fdd4:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fdd8:	4770      	bx	lr

2000fdda <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
* @retval I2C Error Code
*/
uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
{
2000fdda:	b480      	push	{r7}
2000fddc:	b083      	sub	sp, #12
2000fdde:	af00      	add	r7, sp, #0
2000fde0:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
2000fde2:	687b      	ldr	r3, [r7, #4]
2000fde4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
2000fde6:	4618      	mov	r0, r3
2000fde8:	370c      	adds	r7, #12
2000fdea:	46bd      	mov	sp, r7
2000fdec:	f85d 7b04 	ldr.w	r7, [sp], #4
2000fdf0:	4770      	bx	lr

2000fdf2 <I2C_Master_ISR_IT>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
2000fdf2:	b580      	push	{r7, lr}
2000fdf4:	b088      	sub	sp, #32
2000fdf6:	af02      	add	r7, sp, #8
2000fdf8:	60f8      	str	r0, [r7, #12]
2000fdfa:	60b9      	str	r1, [r7, #8]
2000fdfc:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t tmpITFlags = ITFlags;
2000fdfe:	68bb      	ldr	r3, [r7, #8]
2000fe00:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
2000fe02:	68fb      	ldr	r3, [r7, #12]
2000fe04:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000fe08:	2b01      	cmp	r3, #1
2000fe0a:	d101      	bne.n	2000fe10 <I2C_Master_ISR_IT+0x1e>
2000fe0c:	2302      	movs	r3, #2
2000fe0e:	e115      	b.n	2001003c <I2C_Master_ISR_IT+0x24a>
2000fe10:	68fb      	ldr	r3, [r7, #12]
2000fe12:	2201      	movs	r2, #1
2000fe14:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2000fe18:	697b      	ldr	r3, [r7, #20]
2000fe1a:	091b      	lsrs	r3, r3, #4
2000fe1c:	f003 0301 	and.w	r3, r3, #1
2000fe20:	2b00      	cmp	r3, #0
2000fe22:	d013      	beq.n	2000fe4c <I2C_Master_ISR_IT+0x5a>
2000fe24:	687b      	ldr	r3, [r7, #4]
2000fe26:	091b      	lsrs	r3, r3, #4
2000fe28:	f003 0301 	and.w	r3, r3, #1
2000fe2c:	2b00      	cmp	r3, #0
2000fe2e:	d00d      	beq.n	2000fe4c <I2C_Master_ISR_IT+0x5a>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2000fe30:	68fb      	ldr	r3, [r7, #12]
2000fe32:	681b      	ldr	r3, [r3, #0]
2000fe34:	2210      	movs	r2, #16
2000fe36:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    /* No need to generate STOP, it is automatically done */
    /* Error callback will be send during stop flag treatment */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2000fe38:	68fb      	ldr	r3, [r7, #12]
2000fe3a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000fe3c:	f043 0204 	orr.w	r2, r3, #4
2000fe40:	68fb      	ldr	r3, [r7, #12]
2000fe42:	645a      	str	r2, [r3, #68]	; 0x44

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2000fe44:	68f8      	ldr	r0, [r7, #12]
2000fe46:	f001 faa8 	bl	2001139a <I2C_Flush_TXDR>
2000fe4a:	e0e2      	b.n	20010012 <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
2000fe4c:	697b      	ldr	r3, [r7, #20]
2000fe4e:	089b      	lsrs	r3, r3, #2
2000fe50:	f003 0301 	and.w	r3, r3, #1
2000fe54:	2b00      	cmp	r3, #0
2000fe56:	d023      	beq.n	2000fea0 <I2C_Master_ISR_IT+0xae>
2000fe58:	687b      	ldr	r3, [r7, #4]
2000fe5a:	089b      	lsrs	r3, r3, #2
2000fe5c:	f003 0301 	and.w	r3, r3, #1
2000fe60:	2b00      	cmp	r3, #0
2000fe62:	d01d      	beq.n	2000fea0 <I2C_Master_ISR_IT+0xae>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
2000fe64:	697b      	ldr	r3, [r7, #20]
2000fe66:	f023 0304 	bic.w	r3, r3, #4
2000fe6a:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2000fe6c:	68fb      	ldr	r3, [r7, #12]
2000fe6e:	681b      	ldr	r3, [r3, #0]
2000fe70:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2000fe72:	68fb      	ldr	r3, [r7, #12]
2000fe74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000fe76:	b2d2      	uxtb	r2, r2
2000fe78:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2000fe7a:	68fb      	ldr	r3, [r7, #12]
2000fe7c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000fe7e:	1c5a      	adds	r2, r3, #1
2000fe80:	68fb      	ldr	r3, [r7, #12]
2000fe82:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2000fe84:	68fb      	ldr	r3, [r7, #12]
2000fe86:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000fe88:	3b01      	subs	r3, #1
2000fe8a:	b29a      	uxth	r2, r3
2000fe8c:	68fb      	ldr	r3, [r7, #12]
2000fe8e:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2000fe90:	68fb      	ldr	r3, [r7, #12]
2000fe92:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000fe94:	b29b      	uxth	r3, r3
2000fe96:	3b01      	subs	r3, #1
2000fe98:	b29a      	uxth	r2, r3
2000fe9a:	68fb      	ldr	r3, [r7, #12]
2000fe9c:	855a      	strh	r2, [r3, #42]	; 0x2a
2000fe9e:	e0b8      	b.n	20010012 <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2000fea0:	697b      	ldr	r3, [r7, #20]
2000fea2:	085b      	lsrs	r3, r3, #1
2000fea4:	f003 0301 	and.w	r3, r3, #1
2000fea8:	2b00      	cmp	r3, #0
2000feaa:	d01e      	beq.n	2000feea <I2C_Master_ISR_IT+0xf8>
2000feac:	687b      	ldr	r3, [r7, #4]
2000feae:	085b      	lsrs	r3, r3, #1
2000feb0:	f003 0301 	and.w	r3, r3, #1
2000feb4:	2b00      	cmp	r3, #0
2000feb6:	d018      	beq.n	2000feea <I2C_Master_ISR_IT+0xf8>
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2000feb8:	68fb      	ldr	r3, [r7, #12]
2000feba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000febc:	781a      	ldrb	r2, [r3, #0]
2000febe:	68fb      	ldr	r3, [r7, #12]
2000fec0:	681b      	ldr	r3, [r3, #0]
2000fec2:	629a      	str	r2, [r3, #40]	; 0x28

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2000fec4:	68fb      	ldr	r3, [r7, #12]
2000fec6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000fec8:	1c5a      	adds	r2, r3, #1
2000feca:	68fb      	ldr	r3, [r7, #12]
2000fecc:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2000fece:	68fb      	ldr	r3, [r7, #12]
2000fed0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000fed2:	3b01      	subs	r3, #1
2000fed4:	b29a      	uxth	r2, r3
2000fed6:	68fb      	ldr	r3, [r7, #12]
2000fed8:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2000feda:	68fb      	ldr	r3, [r7, #12]
2000fedc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000fede:	b29b      	uxth	r3, r3
2000fee0:	3b01      	subs	r3, #1
2000fee2:	b29a      	uxth	r2, r3
2000fee4:	68fb      	ldr	r3, [r7, #12]
2000fee6:	855a      	strh	r2, [r3, #42]	; 0x2a
2000fee8:	e093      	b.n	20010012 <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2000feea:	697b      	ldr	r3, [r7, #20]
2000feec:	09db      	lsrs	r3, r3, #7
2000feee:	f003 0301 	and.w	r3, r3, #1
2000fef2:	2b00      	cmp	r3, #0
2000fef4:	d05e      	beq.n	2000ffb4 <I2C_Master_ISR_IT+0x1c2>
2000fef6:	687b      	ldr	r3, [r7, #4]
2000fef8:	099b      	lsrs	r3, r3, #6
2000fefa:	f003 0301 	and.w	r3, r3, #1
2000fefe:	2b00      	cmp	r3, #0
2000ff00:	d058      	beq.n	2000ffb4 <I2C_Master_ISR_IT+0x1c2>
  {
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2000ff02:	68fb      	ldr	r3, [r7, #12]
2000ff04:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ff06:	b29b      	uxth	r3, r3
2000ff08:	2b00      	cmp	r3, #0
2000ff0a:	d041      	beq.n	2000ff90 <I2C_Master_ISR_IT+0x19e>
2000ff0c:	68fb      	ldr	r3, [r7, #12]
2000ff0e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ff10:	2b00      	cmp	r3, #0
2000ff12:	d13d      	bne.n	2000ff90 <I2C_Master_ISR_IT+0x19e>
    {
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
2000ff14:	68fb      	ldr	r3, [r7, #12]
2000ff16:	681b      	ldr	r3, [r3, #0]
2000ff18:	685b      	ldr	r3, [r3, #4]
2000ff1a:	b29b      	uxth	r3, r3
2000ff1c:	f3c3 0309 	ubfx	r3, r3, #0, #10
2000ff20:	827b      	strh	r3, [r7, #18]

      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000ff22:	68fb      	ldr	r3, [r7, #12]
2000ff24:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ff26:	b29b      	uxth	r3, r3
2000ff28:	2bff      	cmp	r3, #255	; 0xff
2000ff2a:	d90e      	bls.n	2000ff4a <I2C_Master_ISR_IT+0x158>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2000ff2c:	68fb      	ldr	r3, [r7, #12]
2000ff2e:	22ff      	movs	r2, #255	; 0xff
2000ff30:	851a      	strh	r2, [r3, #40]	; 0x28
        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2000ff32:	68fb      	ldr	r3, [r7, #12]
2000ff34:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ff36:	b2da      	uxtb	r2, r3
2000ff38:	8a79      	ldrh	r1, [r7, #18]
2000ff3a:	2300      	movs	r3, #0
2000ff3c:	9300      	str	r3, [sp, #0]
2000ff3e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000ff42:	68f8      	ldr	r0, [r7, #12]
2000ff44:	f001 fe9a 	bl	20011c7c <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000ff48:	e033      	b.n	2000ffb2 <I2C_Master_ISR_IT+0x1c0>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2000ff4a:	68fb      	ldr	r3, [r7, #12]
2000ff4c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ff4e:	b29a      	uxth	r2, r3
2000ff50:	68fb      	ldr	r3, [r7, #12]
2000ff52:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2000ff54:	68fb      	ldr	r3, [r7, #12]
2000ff56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000ff58:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2000ff5c:	d00c      	beq.n	2000ff78 <I2C_Master_ISR_IT+0x186>
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
2000ff5e:	68fb      	ldr	r3, [r7, #12]
2000ff60:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ff62:	b2da      	uxtb	r2, r3
2000ff64:	68fb      	ldr	r3, [r7, #12]
2000ff66:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
2000ff68:	8a79      	ldrh	r1, [r7, #18]
2000ff6a:	2300      	movs	r3, #0
2000ff6c:	9300      	str	r3, [sp, #0]
2000ff6e:	4603      	mov	r3, r0
2000ff70:	68f8      	ldr	r0, [r7, #12]
2000ff72:	f001 fe83 	bl	20011c7c <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000ff76:	e01c      	b.n	2000ffb2 <I2C_Master_ISR_IT+0x1c0>
        }
        else
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2000ff78:	68fb      	ldr	r3, [r7, #12]
2000ff7a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000ff7c:	b2da      	uxtb	r2, r3
2000ff7e:	8a79      	ldrh	r1, [r7, #18]
2000ff80:	2300      	movs	r3, #0
2000ff82:	9300      	str	r3, [sp, #0]
2000ff84:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000ff88:	68f8      	ldr	r0, [r7, #12]
2000ff8a:	f001 fe77 	bl	20011c7c <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2000ff8e:	e010      	b.n	2000ffb2 <I2C_Master_ISR_IT+0x1c0>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2000ff90:	68fb      	ldr	r3, [r7, #12]
2000ff92:	681b      	ldr	r3, [r3, #0]
2000ff94:	685b      	ldr	r3, [r3, #4]
2000ff96:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000ff9a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000ff9e:	d003      	beq.n	2000ffa8 <I2C_Master_ISR_IT+0x1b6>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
2000ffa0:	68f8      	ldr	r0, [r7, #12]
2000ffa2:	f000 fd51 	bl	20010a48 <I2C_ITMasterSeqCplt>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2000ffa6:	e034      	b.n	20010012 <I2C_Master_ISR_IT+0x220>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2000ffa8:	2140      	movs	r1, #64	; 0x40
2000ffaa:	68f8      	ldr	r0, [r7, #12]
2000ffac:	f001 f8fe 	bl	200111ac <I2C_ITError>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2000ffb0:	e02f      	b.n	20010012 <I2C_Master_ISR_IT+0x220>
2000ffb2:	e02e      	b.n	20010012 <I2C_Master_ISR_IT+0x220>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2000ffb4:	697b      	ldr	r3, [r7, #20]
2000ffb6:	099b      	lsrs	r3, r3, #6
2000ffb8:	f003 0301 	and.w	r3, r3, #1
2000ffbc:	2b00      	cmp	r3, #0
2000ffbe:	d028      	beq.n	20010012 <I2C_Master_ISR_IT+0x220>
2000ffc0:	687b      	ldr	r3, [r7, #4]
2000ffc2:	099b      	lsrs	r3, r3, #6
2000ffc4:	f003 0301 	and.w	r3, r3, #1
2000ffc8:	2b00      	cmp	r3, #0
2000ffca:	d022      	beq.n	20010012 <I2C_Master_ISR_IT+0x220>
  {
    if (hi2c->XferCount == 0U)
2000ffcc:	68fb      	ldr	r3, [r7, #12]
2000ffce:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000ffd0:	b29b      	uxth	r3, r3
2000ffd2:	2b00      	cmp	r3, #0
2000ffd4:	d119      	bne.n	2001000a <I2C_Master_ISR_IT+0x218>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2000ffd6:	68fb      	ldr	r3, [r7, #12]
2000ffd8:	681b      	ldr	r3, [r3, #0]
2000ffda:	685b      	ldr	r3, [r3, #4]
2000ffdc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000ffe0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000ffe4:	d015      	beq.n	20010012 <I2C_Master_ISR_IT+0x220>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
2000ffe6:	68fb      	ldr	r3, [r7, #12]
2000ffe8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000ffea:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2000ffee:	d108      	bne.n	20010002 <I2C_Master_ISR_IT+0x210>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
2000fff0:	68fb      	ldr	r3, [r7, #12]
2000fff2:	681b      	ldr	r3, [r3, #0]
2000fff4:	685a      	ldr	r2, [r3, #4]
2000fff6:	68fb      	ldr	r3, [r7, #12]
2000fff8:	681b      	ldr	r3, [r3, #0]
2000fffa:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2000fffe:	605a      	str	r2, [r3, #4]
20010000:	e007      	b.n	20010012 <I2C_Master_ISR_IT+0x220>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
20010002:	68f8      	ldr	r0, [r7, #12]
20010004:	f000 fd20 	bl	20010a48 <I2C_ITMasterSeqCplt>
20010008:	e003      	b.n	20010012 <I2C_Master_ISR_IT+0x220>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2001000a:	2140      	movs	r1, #64	; 0x40
2001000c:	68f8      	ldr	r0, [r7, #12]
2001000e:	f001 f8cd 	bl	200111ac <I2C_ITError>
  else
  {
    /* Nothing to do */
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
20010012:	697b      	ldr	r3, [r7, #20]
20010014:	095b      	lsrs	r3, r3, #5
20010016:	f003 0301 	and.w	r3, r3, #1
2001001a:	2b00      	cmp	r3, #0
2001001c:	d009      	beq.n	20010032 <I2C_Master_ISR_IT+0x240>
2001001e:	687b      	ldr	r3, [r7, #4]
20010020:	095b      	lsrs	r3, r3, #5
20010022:	f003 0301 	and.w	r3, r3, #1
20010026:	2b00      	cmp	r3, #0
20010028:	d003      	beq.n	20010032 <I2C_Master_ISR_IT+0x240>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, tmpITFlags);
2001002a:	6979      	ldr	r1, [r7, #20]
2001002c:	68f8      	ldr	r0, [r7, #12]
2001002e:	f000 fda7 	bl	20010b80 <I2C_ITMasterCplt>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
20010032:	68fb      	ldr	r3, [r7, #12]
20010034:	2200      	movs	r2, #0
20010036:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2001003a:	2300      	movs	r3, #0
}
2001003c:	4618      	mov	r0, r3
2001003e:	3718      	adds	r7, #24
20010040:	46bd      	mov	sp, r7
20010042:	bd80      	pop	{r7, pc}

20010044 <I2C_Slave_ISR_IT>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
20010044:	b580      	push	{r7, lr}
20010046:	b086      	sub	sp, #24
20010048:	af00      	add	r7, sp, #0
2001004a:	60f8      	str	r0, [r7, #12]
2001004c:	60b9      	str	r1, [r7, #8]
2001004e:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
20010050:	68fb      	ldr	r3, [r7, #12]
20010052:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20010054:	617b      	str	r3, [r7, #20]
  uint32_t tmpITFlags = ITFlags;
20010056:	68bb      	ldr	r3, [r7, #8]
20010058:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hi2c);
2001005a:	68fb      	ldr	r3, [r7, #12]
2001005c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20010060:	2b01      	cmp	r3, #1
20010062:	d101      	bne.n	20010068 <I2C_Slave_ISR_IT+0x24>
20010064:	2302      	movs	r3, #2
20010066:	e0ec      	b.n	20010242 <I2C_Slave_ISR_IT+0x1fe>
20010068:	68fb      	ldr	r3, [r7, #12]
2001006a:	2201      	movs	r2, #1
2001006c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
20010070:	693b      	ldr	r3, [r7, #16]
20010072:	095b      	lsrs	r3, r3, #5
20010074:	f003 0301 	and.w	r3, r3, #1
20010078:	2b00      	cmp	r3, #0
2001007a:	d009      	beq.n	20010090 <I2C_Slave_ISR_IT+0x4c>
2001007c:	687b      	ldr	r3, [r7, #4]
2001007e:	095b      	lsrs	r3, r3, #5
20010080:	f003 0301 	and.w	r3, r3, #1
20010084:	2b00      	cmp	r3, #0
20010086:	d003      	beq.n	20010090 <I2C_Slave_ISR_IT+0x4c>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
20010088:	6939      	ldr	r1, [r7, #16]
2001008a:	68f8      	ldr	r0, [r7, #12]
2001008c:	f000 fe40 	bl	20010d10 <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
20010090:	693b      	ldr	r3, [r7, #16]
20010092:	091b      	lsrs	r3, r3, #4
20010094:	f003 0301 	and.w	r3, r3, #1
20010098:	2b00      	cmp	r3, #0
2001009a:	d04d      	beq.n	20010138 <I2C_Slave_ISR_IT+0xf4>
2001009c:	687b      	ldr	r3, [r7, #4]
2001009e:	091b      	lsrs	r3, r3, #4
200100a0:	f003 0301 	and.w	r3, r3, #1
200100a4:	2b00      	cmp	r3, #0
200100a6:	d047      	beq.n	20010138 <I2C_Slave_ISR_IT+0xf4>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
200100a8:	68fb      	ldr	r3, [r7, #12]
200100aa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200100ac:	b29b      	uxth	r3, r3
200100ae:	2b00      	cmp	r3, #0
200100b0:	d128      	bne.n	20010104 <I2C_Slave_ISR_IT+0xc0>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
200100b2:	68fb      	ldr	r3, [r7, #12]
200100b4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200100b8:	b2db      	uxtb	r3, r3
200100ba:	2b28      	cmp	r3, #40	; 0x28
200100bc:	d108      	bne.n	200100d0 <I2C_Slave_ISR_IT+0x8c>
200100be:	697b      	ldr	r3, [r7, #20]
200100c0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200100c4:	d104      	bne.n	200100d0 <I2C_Slave_ISR_IT+0x8c>
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
200100c6:	6939      	ldr	r1, [r7, #16]
200100c8:	68f8      	ldr	r0, [r7, #12]
200100ca:	f001 f819 	bl	20011100 <I2C_ITListenCplt>
200100ce:	e032      	b.n	20010136 <I2C_Slave_ISR_IT+0xf2>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
200100d0:	68fb      	ldr	r3, [r7, #12]
200100d2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200100d6:	b2db      	uxtb	r3, r3
200100d8:	2b29      	cmp	r3, #41	; 0x29
200100da:	d10e      	bne.n	200100fa <I2C_Slave_ISR_IT+0xb6>
200100dc:	697b      	ldr	r3, [r7, #20]
200100de:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
200100e2:	d00a      	beq.n	200100fa <I2C_Slave_ISR_IT+0xb6>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
200100e4:	68fb      	ldr	r3, [r7, #12]
200100e6:	681b      	ldr	r3, [r3, #0]
200100e8:	2210      	movs	r2, #16
200100ea:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
200100ec:	68f8      	ldr	r0, [r7, #12]
200100ee:	f001 f954 	bl	2001139a <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
200100f2:	68f8      	ldr	r0, [r7, #12]
200100f4:	f000 fce5 	bl	20010ac2 <I2C_ITSlaveSeqCplt>
200100f8:	e01d      	b.n	20010136 <I2C_Slave_ISR_IT+0xf2>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
200100fa:	68fb      	ldr	r3, [r7, #12]
200100fc:	681b      	ldr	r3, [r3, #0]
200100fe:	2210      	movs	r2, #16
20010100:	61da      	str	r2, [r3, #28]
    if (hi2c->XferCount == 0U)
20010102:	e096      	b.n	20010232 <I2C_Slave_ISR_IT+0x1ee>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20010104:	68fb      	ldr	r3, [r7, #12]
20010106:	681b      	ldr	r3, [r3, #0]
20010108:	2210      	movs	r2, #16
2001010a:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2001010c:	68fb      	ldr	r3, [r7, #12]
2001010e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20010110:	f043 0204 	orr.w	r2, r3, #4
20010114:	68fb      	ldr	r3, [r7, #12]
20010116:	645a      	str	r2, [r3, #68]	; 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
20010118:	697b      	ldr	r3, [r7, #20]
2001011a:	2b00      	cmp	r3, #0
2001011c:	d004      	beq.n	20010128 <I2C_Slave_ISR_IT+0xe4>
2001011e:	697b      	ldr	r3, [r7, #20]
20010120:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20010124:	f040 8085 	bne.w	20010232 <I2C_Slave_ISR_IT+0x1ee>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
20010128:	68fb      	ldr	r3, [r7, #12]
2001012a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2001012c:	4619      	mov	r1, r3
2001012e:	68f8      	ldr	r0, [r7, #12]
20010130:	f001 f83c 	bl	200111ac <I2C_ITError>
    if (hi2c->XferCount == 0U)
20010134:	e07d      	b.n	20010232 <I2C_Slave_ISR_IT+0x1ee>
20010136:	e07c      	b.n	20010232 <I2C_Slave_ISR_IT+0x1ee>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
20010138:	693b      	ldr	r3, [r7, #16]
2001013a:	089b      	lsrs	r3, r3, #2
2001013c:	f003 0301 	and.w	r3, r3, #1
20010140:	2b00      	cmp	r3, #0
20010142:	d030      	beq.n	200101a6 <I2C_Slave_ISR_IT+0x162>
20010144:	687b      	ldr	r3, [r7, #4]
20010146:	089b      	lsrs	r3, r3, #2
20010148:	f003 0301 	and.w	r3, r3, #1
2001014c:	2b00      	cmp	r3, #0
2001014e:	d02a      	beq.n	200101a6 <I2C_Slave_ISR_IT+0x162>
  {
    if (hi2c->XferCount > 0U)
20010150:	68fb      	ldr	r3, [r7, #12]
20010152:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20010154:	b29b      	uxth	r3, r3
20010156:	2b00      	cmp	r3, #0
20010158:	d018      	beq.n	2001018c <I2C_Slave_ISR_IT+0x148>
    {
      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2001015a:	68fb      	ldr	r3, [r7, #12]
2001015c:	681b      	ldr	r3, [r3, #0]
2001015e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20010160:	68fb      	ldr	r3, [r7, #12]
20010162:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20010164:	b2d2      	uxtb	r2, r2
20010166:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
20010168:	68fb      	ldr	r3, [r7, #12]
2001016a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2001016c:	1c5a      	adds	r2, r3, #1
2001016e:	68fb      	ldr	r3, [r7, #12]
20010170:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
20010172:	68fb      	ldr	r3, [r7, #12]
20010174:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20010176:	3b01      	subs	r3, #1
20010178:	b29a      	uxth	r2, r3
2001017a:	68fb      	ldr	r3, [r7, #12]
2001017c:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2001017e:	68fb      	ldr	r3, [r7, #12]
20010180:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20010182:	b29b      	uxth	r3, r3
20010184:	3b01      	subs	r3, #1
20010186:	b29a      	uxth	r2, r3
20010188:	68fb      	ldr	r3, [r7, #12]
2001018a:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    if ((hi2c->XferCount == 0U) && \
2001018c:	68fb      	ldr	r3, [r7, #12]
2001018e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20010190:	b29b      	uxth	r3, r3
20010192:	2b00      	cmp	r3, #0
20010194:	d14f      	bne.n	20010236 <I2C_Slave_ISR_IT+0x1f2>
20010196:	697b      	ldr	r3, [r7, #20]
20010198:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2001019c:	d04b      	beq.n	20010236 <I2C_Slave_ISR_IT+0x1f2>
        (tmpoptions != I2C_NO_OPTION_FRAME))
    {
      /* Call I2C Slave Sequential complete process */
      I2C_ITSlaveSeqCplt(hi2c);
2001019e:	68f8      	ldr	r0, [r7, #12]
200101a0:	f000 fc8f 	bl	20010ac2 <I2C_ITSlaveSeqCplt>
    if ((hi2c->XferCount == 0U) && \
200101a4:	e047      	b.n	20010236 <I2C_Slave_ISR_IT+0x1f2>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
200101a6:	693b      	ldr	r3, [r7, #16]
200101a8:	08db      	lsrs	r3, r3, #3
200101aa:	f003 0301 	and.w	r3, r3, #1
200101ae:	2b00      	cmp	r3, #0
200101b0:	d00a      	beq.n	200101c8 <I2C_Slave_ISR_IT+0x184>
200101b2:	687b      	ldr	r3, [r7, #4]
200101b4:	08db      	lsrs	r3, r3, #3
200101b6:	f003 0301 	and.w	r3, r3, #1
200101ba:	2b00      	cmp	r3, #0
200101bc:	d004      	beq.n	200101c8 <I2C_Slave_ISR_IT+0x184>
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
200101be:	6939      	ldr	r1, [r7, #16]
200101c0:	68f8      	ldr	r0, [r7, #12]
200101c2:	f000 fbbd 	bl	20010940 <I2C_ITAddrCplt>
200101c6:	e037      	b.n	20010238 <I2C_Slave_ISR_IT+0x1f4>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
200101c8:	693b      	ldr	r3, [r7, #16]
200101ca:	085b      	lsrs	r3, r3, #1
200101cc:	f003 0301 	and.w	r3, r3, #1
200101d0:	2b00      	cmp	r3, #0
200101d2:	d031      	beq.n	20010238 <I2C_Slave_ISR_IT+0x1f4>
200101d4:	687b      	ldr	r3, [r7, #4]
200101d6:	085b      	lsrs	r3, r3, #1
200101d8:	f003 0301 	and.w	r3, r3, #1
200101dc:	2b00      	cmp	r3, #0
200101de:	d02b      	beq.n	20010238 <I2C_Slave_ISR_IT+0x1f4>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Datas have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hi2c->XferCount > 0U)
200101e0:	68fb      	ldr	r3, [r7, #12]
200101e2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200101e4:	b29b      	uxth	r3, r3
200101e6:	2b00      	cmp	r3, #0
200101e8:	d018      	beq.n	2001021c <I2C_Slave_ISR_IT+0x1d8>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
200101ea:	68fb      	ldr	r3, [r7, #12]
200101ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200101ee:	781a      	ldrb	r2, [r3, #0]
200101f0:	68fb      	ldr	r3, [r7, #12]
200101f2:	681b      	ldr	r3, [r3, #0]
200101f4:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
200101f6:	68fb      	ldr	r3, [r7, #12]
200101f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200101fa:	1c5a      	adds	r2, r3, #1
200101fc:	68fb      	ldr	r3, [r7, #12]
200101fe:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
20010200:	68fb      	ldr	r3, [r7, #12]
20010202:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20010204:	b29b      	uxth	r3, r3
20010206:	3b01      	subs	r3, #1
20010208:	b29a      	uxth	r2, r3
2001020a:	68fb      	ldr	r3, [r7, #12]
2001020c:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2001020e:	68fb      	ldr	r3, [r7, #12]
20010210:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20010212:	3b01      	subs	r3, #1
20010214:	b29a      	uxth	r2, r3
20010216:	68fb      	ldr	r3, [r7, #12]
20010218:	851a      	strh	r2, [r3, #40]	; 0x28
2001021a:	e00d      	b.n	20010238 <I2C_Slave_ISR_IT+0x1f4>
    }
    else
    {
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2001021c:	697b      	ldr	r3, [r7, #20]
2001021e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20010222:	d002      	beq.n	2001022a <I2C_Slave_ISR_IT+0x1e6>
20010224:	697b      	ldr	r3, [r7, #20]
20010226:	2b00      	cmp	r3, #0
20010228:	d106      	bne.n	20010238 <I2C_Slave_ISR_IT+0x1f4>
      {
        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
2001022a:	68f8      	ldr	r0, [r7, #12]
2001022c:	f000 fc49 	bl	20010ac2 <I2C_ITSlaveSeqCplt>
20010230:	e002      	b.n	20010238 <I2C_Slave_ISR_IT+0x1f4>
    if (hi2c->XferCount == 0U)
20010232:	bf00      	nop
20010234:	e000      	b.n	20010238 <I2C_Slave_ISR_IT+0x1f4>
    if ((hi2c->XferCount == 0U) && \
20010236:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
20010238:	68fb      	ldr	r3, [r7, #12]
2001023a:	2200      	movs	r2, #0
2001023c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
20010240:	2300      	movs	r3, #0
}
20010242:	4618      	mov	r0, r3
20010244:	3718      	adds	r7, #24
20010246:	46bd      	mov	sp, r7
20010248:	bd80      	pop	{r7, pc}

2001024a <I2C_Master_ISR_DMA>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
2001024a:	b580      	push	{r7, lr}
2001024c:	b088      	sub	sp, #32
2001024e:	af02      	add	r7, sp, #8
20010250:	60f8      	str	r0, [r7, #12]
20010252:	60b9      	str	r1, [r7, #8]
20010254:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t xfermode;

  /* Process Locked */
  __HAL_LOCK(hi2c);
20010256:	68fb      	ldr	r3, [r7, #12]
20010258:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2001025c:	2b01      	cmp	r3, #1
2001025e:	d101      	bne.n	20010264 <I2C_Master_ISR_DMA+0x1a>
20010260:	2302      	movs	r3, #2
20010262:	e0e1      	b.n	20010428 <I2C_Master_ISR_DMA+0x1de>
20010264:	68fb      	ldr	r3, [r7, #12]
20010266:	2201      	movs	r2, #1
20010268:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2001026c:	68bb      	ldr	r3, [r7, #8]
2001026e:	091b      	lsrs	r3, r3, #4
20010270:	f003 0301 	and.w	r3, r3, #1
20010274:	2b00      	cmp	r3, #0
20010276:	d017      	beq.n	200102a8 <I2C_Master_ISR_DMA+0x5e>
20010278:	687b      	ldr	r3, [r7, #4]
2001027a:	091b      	lsrs	r3, r3, #4
2001027c:	f003 0301 	and.w	r3, r3, #1
20010280:	2b00      	cmp	r3, #0
20010282:	d011      	beq.n	200102a8 <I2C_Master_ISR_DMA+0x5e>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20010284:	68fb      	ldr	r3, [r7, #12]
20010286:	681b      	ldr	r3, [r3, #0]
20010288:	2210      	movs	r2, #16
2001028a:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2001028c:	68fb      	ldr	r3, [r7, #12]
2001028e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20010290:	f043 0204 	orr.w	r2, r3, #4
20010294:	68fb      	ldr	r3, [r7, #12]
20010296:	645a      	str	r2, [r3, #68]	; 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
20010298:	2120      	movs	r1, #32
2001029a:	68f8      	ldr	r0, [r7, #12]
2001029c:	f001 fd66 	bl	20011d6c <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
200102a0:	68f8      	ldr	r0, [r7, #12]
200102a2:	f001 f87a 	bl	2001139a <I2C_Flush_TXDR>
200102a6:	e0ba      	b.n	2001041e <I2C_Master_ISR_DMA+0x1d4>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
200102a8:	68bb      	ldr	r3, [r7, #8]
200102aa:	09db      	lsrs	r3, r3, #7
200102ac:	f003 0301 	and.w	r3, r3, #1
200102b0:	2b00      	cmp	r3, #0
200102b2:	d072      	beq.n	2001039a <I2C_Master_ISR_DMA+0x150>
200102b4:	687b      	ldr	r3, [r7, #4]
200102b6:	099b      	lsrs	r3, r3, #6
200102b8:	f003 0301 	and.w	r3, r3, #1
200102bc:	2b00      	cmp	r3, #0
200102be:	d06c      	beq.n	2001039a <I2C_Master_ISR_DMA+0x150>
  {
    /* Disable TC interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
200102c0:	68fb      	ldr	r3, [r7, #12]
200102c2:	681b      	ldr	r3, [r3, #0]
200102c4:	681a      	ldr	r2, [r3, #0]
200102c6:	68fb      	ldr	r3, [r7, #12]
200102c8:	681b      	ldr	r3, [r3, #0]
200102ca:	f022 0240 	bic.w	r2, r2, #64	; 0x40
200102ce:	601a      	str	r2, [r3, #0]

    if (hi2c->XferCount != 0U)
200102d0:	68fb      	ldr	r3, [r7, #12]
200102d2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200102d4:	b29b      	uxth	r3, r3
200102d6:	2b00      	cmp	r3, #0
200102d8:	d04e      	beq.n	20010378 <I2C_Master_ISR_DMA+0x12e>
    {
      /* Recover Slave address */
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
200102da:	68fb      	ldr	r3, [r7, #12]
200102dc:	681b      	ldr	r3, [r3, #0]
200102de:	685b      	ldr	r3, [r3, #4]
200102e0:	b29b      	uxth	r3, r3
200102e2:	f3c3 0309 	ubfx	r3, r3, #0, #10
200102e6:	827b      	strh	r3, [r7, #18]

      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
200102e8:	68fb      	ldr	r3, [r7, #12]
200102ea:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200102ec:	b29b      	uxth	r3, r3
200102ee:	2bff      	cmp	r3, #255	; 0xff
200102f0:	d906      	bls.n	20010300 <I2C_Master_ISR_DMA+0xb6>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
200102f2:	68fb      	ldr	r3, [r7, #12]
200102f4:	22ff      	movs	r2, #255	; 0xff
200102f6:	851a      	strh	r2, [r3, #40]	; 0x28
        xfermode = I2C_RELOAD_MODE;
200102f8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200102fc:	617b      	str	r3, [r7, #20]
200102fe:	e010      	b.n	20010322 <I2C_Master_ISR_DMA+0xd8>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
20010300:	68fb      	ldr	r3, [r7, #12]
20010302:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20010304:	b29a      	uxth	r2, r3
20010306:	68fb      	ldr	r3, [r7, #12]
20010308:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2001030a:	68fb      	ldr	r3, [r7, #12]
2001030c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001030e:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
20010312:	d003      	beq.n	2001031c <I2C_Master_ISR_DMA+0xd2>
        {
          xfermode = hi2c->XferOptions;
20010314:	68fb      	ldr	r3, [r7, #12]
20010316:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20010318:	617b      	str	r3, [r7, #20]
2001031a:	e002      	b.n	20010322 <I2C_Master_ISR_DMA+0xd8>
        }
        else
        {
          xfermode = I2C_AUTOEND_MODE;
2001031c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20010320:	617b      	str	r3, [r7, #20]
        }
      }

      /* Set the new XferSize in Nbytes register */
      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
20010322:	68fb      	ldr	r3, [r7, #12]
20010324:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20010326:	b2da      	uxtb	r2, r3
20010328:	8a79      	ldrh	r1, [r7, #18]
2001032a:	2300      	movs	r3, #0
2001032c:	9300      	str	r3, [sp, #0]
2001032e:	697b      	ldr	r3, [r7, #20]
20010330:	68f8      	ldr	r0, [r7, #12]
20010332:	f001 fca3 	bl	20011c7c <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
20010336:	68fb      	ldr	r3, [r7, #12]
20010338:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2001033a:	b29a      	uxth	r2, r3
2001033c:	68fb      	ldr	r3, [r7, #12]
2001033e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20010340:	1ad3      	subs	r3, r2, r3
20010342:	b29a      	uxth	r2, r3
20010344:	68fb      	ldr	r3, [r7, #12]
20010346:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
20010348:	68fb      	ldr	r3, [r7, #12]
2001034a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2001034e:	b2db      	uxtb	r3, r3
20010350:	2b22      	cmp	r3, #34	; 0x22
20010352:	d108      	bne.n	20010366 <I2C_Master_ISR_DMA+0x11c>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
20010354:	68fb      	ldr	r3, [r7, #12]
20010356:	681b      	ldr	r3, [r3, #0]
20010358:	681a      	ldr	r2, [r3, #0]
2001035a:	68fb      	ldr	r3, [r7, #12]
2001035c:	681b      	ldr	r3, [r3, #0]
2001035e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20010362:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
20010364:	e05b      	b.n	2001041e <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
20010366:	68fb      	ldr	r3, [r7, #12]
20010368:	681b      	ldr	r3, [r3, #0]
2001036a:	681a      	ldr	r2, [r3, #0]
2001036c:	68fb      	ldr	r3, [r7, #12]
2001036e:	681b      	ldr	r3, [r3, #0]
20010370:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
20010374:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
20010376:	e052      	b.n	2001041e <I2C_Master_ISR_DMA+0x1d4>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
20010378:	68fb      	ldr	r3, [r7, #12]
2001037a:	681b      	ldr	r3, [r3, #0]
2001037c:	685b      	ldr	r3, [r3, #4]
2001037e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20010382:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20010386:	d003      	beq.n	20010390 <I2C_Master_ISR_DMA+0x146>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
20010388:	68f8      	ldr	r0, [r7, #12]
2001038a:	f000 fb5d 	bl	20010a48 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount != 0U)
2001038e:	e046      	b.n	2001041e <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
20010390:	2140      	movs	r1, #64	; 0x40
20010392:	68f8      	ldr	r0, [r7, #12]
20010394:	f000 ff0a 	bl	200111ac <I2C_ITError>
    if (hi2c->XferCount != 0U)
20010398:	e041      	b.n	2001041e <I2C_Master_ISR_DMA+0x1d4>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2001039a:	68bb      	ldr	r3, [r7, #8]
2001039c:	099b      	lsrs	r3, r3, #6
2001039e:	f003 0301 	and.w	r3, r3, #1
200103a2:	2b00      	cmp	r3, #0
200103a4:	d029      	beq.n	200103fa <I2C_Master_ISR_DMA+0x1b0>
200103a6:	687b      	ldr	r3, [r7, #4]
200103a8:	099b      	lsrs	r3, r3, #6
200103aa:	f003 0301 	and.w	r3, r3, #1
200103ae:	2b00      	cmp	r3, #0
200103b0:	d023      	beq.n	200103fa <I2C_Master_ISR_DMA+0x1b0>
  {
    if (hi2c->XferCount == 0U)
200103b2:	68fb      	ldr	r3, [r7, #12]
200103b4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200103b6:	b29b      	uxth	r3, r3
200103b8:	2b00      	cmp	r3, #0
200103ba:	d119      	bne.n	200103f0 <I2C_Master_ISR_DMA+0x1a6>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
200103bc:	68fb      	ldr	r3, [r7, #12]
200103be:	681b      	ldr	r3, [r3, #0]
200103c0:	685b      	ldr	r3, [r3, #4]
200103c2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
200103c6:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200103ca:	d027      	beq.n	2001041c <I2C_Master_ISR_DMA+0x1d2>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
200103cc:	68fb      	ldr	r3, [r7, #12]
200103ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200103d0:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
200103d4:	d108      	bne.n	200103e8 <I2C_Master_ISR_DMA+0x19e>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
200103d6:	68fb      	ldr	r3, [r7, #12]
200103d8:	681b      	ldr	r3, [r3, #0]
200103da:	685a      	ldr	r2, [r3, #4]
200103dc:	68fb      	ldr	r3, [r7, #12]
200103de:	681b      	ldr	r3, [r3, #0]
200103e0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
200103e4:	605a      	str	r2, [r3, #4]
    if (hi2c->XferCount == 0U)
200103e6:	e019      	b.n	2001041c <I2C_Master_ISR_DMA+0x1d2>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
200103e8:	68f8      	ldr	r0, [r7, #12]
200103ea:	f000 fb2d 	bl	20010a48 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount == 0U)
200103ee:	e015      	b.n	2001041c <I2C_Master_ISR_DMA+0x1d2>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
200103f0:	2140      	movs	r1, #64	; 0x40
200103f2:	68f8      	ldr	r0, [r7, #12]
200103f4:	f000 feda 	bl	200111ac <I2C_ITError>
    if (hi2c->XferCount == 0U)
200103f8:	e010      	b.n	2001041c <I2C_Master_ISR_DMA+0x1d2>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
200103fa:	68bb      	ldr	r3, [r7, #8]
200103fc:	095b      	lsrs	r3, r3, #5
200103fe:	f003 0301 	and.w	r3, r3, #1
20010402:	2b00      	cmp	r3, #0
20010404:	d00b      	beq.n	2001041e <I2C_Master_ISR_DMA+0x1d4>
20010406:	687b      	ldr	r3, [r7, #4]
20010408:	095b      	lsrs	r3, r3, #5
2001040a:	f003 0301 	and.w	r3, r3, #1
2001040e:	2b00      	cmp	r3, #0
20010410:	d005      	beq.n	2001041e <I2C_Master_ISR_DMA+0x1d4>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
20010412:	68b9      	ldr	r1, [r7, #8]
20010414:	68f8      	ldr	r0, [r7, #12]
20010416:	f000 fbb3 	bl	20010b80 <I2C_ITMasterCplt>
2001041a:	e000      	b.n	2001041e <I2C_Master_ISR_DMA+0x1d4>
    if (hi2c->XferCount == 0U)
2001041c:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2001041e:	68fb      	ldr	r3, [r7, #12]
20010420:	2200      	movs	r2, #0
20010422:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
20010426:	2300      	movs	r3, #0
}
20010428:	4618      	mov	r0, r3
2001042a:	3718      	adds	r7, #24
2001042c:	46bd      	mov	sp, r7
2001042e:	bd80      	pop	{r7, pc}

20010430 <I2C_Slave_ISR_DMA>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
20010430:	b580      	push	{r7, lr}
20010432:	b088      	sub	sp, #32
20010434:	af00      	add	r7, sp, #0
20010436:	60f8      	str	r0, [r7, #12]
20010438:	60b9      	str	r1, [r7, #8]
2001043a:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
2001043c:	68fb      	ldr	r3, [r7, #12]
2001043e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20010440:	61bb      	str	r3, [r7, #24]
  uint32_t treatdmanack = 0U;
20010442:	2300      	movs	r3, #0
20010444:	61fb      	str	r3, [r7, #28]
  HAL_I2C_StateTypeDef tmpstate;

  /* Process locked */
  __HAL_LOCK(hi2c);
20010446:	68fb      	ldr	r3, [r7, #12]
20010448:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2001044c:	2b01      	cmp	r3, #1
2001044e:	d101      	bne.n	20010454 <I2C_Slave_ISR_DMA+0x24>
20010450:	2302      	movs	r3, #2
20010452:	e1c8      	b.n	200107e6 <I2C_Slave_ISR_DMA+0x3b6>
20010454:	68fb      	ldr	r3, [r7, #12]
20010456:	2201      	movs	r2, #1
20010458:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2001045c:	68bb      	ldr	r3, [r7, #8]
2001045e:	095b      	lsrs	r3, r3, #5
20010460:	f003 0301 	and.w	r3, r3, #1
20010464:	2b00      	cmp	r3, #0
20010466:	d009      	beq.n	2001047c <I2C_Slave_ISR_DMA+0x4c>
20010468:	687b      	ldr	r3, [r7, #4]
2001046a:	095b      	lsrs	r3, r3, #5
2001046c:	f003 0301 	and.w	r3, r3, #1
20010470:	2b00      	cmp	r3, #0
20010472:	d003      	beq.n	2001047c <I2C_Slave_ISR_DMA+0x4c>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, ITFlags);
20010474:	68b9      	ldr	r1, [r7, #8]
20010476:	68f8      	ldr	r0, [r7, #12]
20010478:	f000 fc4a 	bl	20010d10 <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2001047c:	68bb      	ldr	r3, [r7, #8]
2001047e:	091b      	lsrs	r3, r3, #4
20010480:	f003 0301 	and.w	r3, r3, #1
20010484:	2b00      	cmp	r3, #0
20010486:	f000 8199 	beq.w	200107bc <I2C_Slave_ISR_DMA+0x38c>
2001048a:	687b      	ldr	r3, [r7, #4]
2001048c:	091b      	lsrs	r3, r3, #4
2001048e:	f003 0301 	and.w	r3, r3, #1
20010492:	2b00      	cmp	r3, #0
20010494:	f000 8192 	beq.w	200107bc <I2C_Slave_ISR_DMA+0x38c>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0 */
    /* So clear Flag NACKF only */
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
20010498:	687b      	ldr	r3, [r7, #4]
2001049a:	0b9b      	lsrs	r3, r3, #14
2001049c:	f003 0301 	and.w	r3, r3, #1
200104a0:	2b00      	cmp	r3, #0
200104a2:	d106      	bne.n	200104b2 <I2C_Slave_ISR_DMA+0x82>
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
200104a4:	687b      	ldr	r3, [r7, #4]
200104a6:	0bdb      	lsrs	r3, r3, #15
200104a8:	f003 0301 	and.w	r3, r3, #1
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
200104ac:	2b00      	cmp	r3, #0
200104ae:	f000 817e 	beq.w	200107ae <I2C_Slave_ISR_DMA+0x37e>
    {
      /* Split check of hdmarx, for MISRA compliance */
      if (hi2c->hdmarx != NULL)
200104b2:	68fb      	ldr	r3, [r7, #12]
200104b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200104b6:	2b00      	cmp	r3, #0
200104b8:	d07c      	beq.n	200105b4 <I2C_Slave_ISR_DMA+0x184>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
200104ba:	687b      	ldr	r3, [r7, #4]
200104bc:	0bdb      	lsrs	r3, r3, #15
200104be:	f003 0301 	and.w	r3, r3, #1
200104c2:	2b00      	cmp	r3, #0
200104c4:	d076      	beq.n	200105b4 <I2C_Slave_ISR_DMA+0x184>
        {
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
200104c6:	68fb      	ldr	r3, [r7, #12]
200104c8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200104ca:	681b      	ldr	r3, [r3, #0]
200104cc:	4a8d      	ldr	r2, [pc, #564]	; (20010704 <I2C_Slave_ISR_DMA+0x2d4>)
200104ce:	4293      	cmp	r3, r2
200104d0:	d059      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
200104d2:	68fb      	ldr	r3, [r7, #12]
200104d4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200104d6:	681b      	ldr	r3, [r3, #0]
200104d8:	4a8b      	ldr	r2, [pc, #556]	; (20010708 <I2C_Slave_ISR_DMA+0x2d8>)
200104da:	4293      	cmp	r3, r2
200104dc:	d053      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
200104de:	68fb      	ldr	r3, [r7, #12]
200104e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200104e2:	681b      	ldr	r3, [r3, #0]
200104e4:	4a89      	ldr	r2, [pc, #548]	; (2001070c <I2C_Slave_ISR_DMA+0x2dc>)
200104e6:	4293      	cmp	r3, r2
200104e8:	d04d      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
200104ea:	68fb      	ldr	r3, [r7, #12]
200104ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200104ee:	681b      	ldr	r3, [r3, #0]
200104f0:	4a87      	ldr	r2, [pc, #540]	; (20010710 <I2C_Slave_ISR_DMA+0x2e0>)
200104f2:	4293      	cmp	r3, r2
200104f4:	d047      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
200104f6:	68fb      	ldr	r3, [r7, #12]
200104f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200104fa:	681b      	ldr	r3, [r3, #0]
200104fc:	4a85      	ldr	r2, [pc, #532]	; (20010714 <I2C_Slave_ISR_DMA+0x2e4>)
200104fe:	4293      	cmp	r3, r2
20010500:	d041      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
20010502:	68fb      	ldr	r3, [r7, #12]
20010504:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010506:	681b      	ldr	r3, [r3, #0]
20010508:	4a83      	ldr	r2, [pc, #524]	; (20010718 <I2C_Slave_ISR_DMA+0x2e8>)
2001050a:	4293      	cmp	r3, r2
2001050c:	d03b      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
2001050e:	68fb      	ldr	r3, [r7, #12]
20010510:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010512:	681b      	ldr	r3, [r3, #0]
20010514:	4a81      	ldr	r2, [pc, #516]	; (2001071c <I2C_Slave_ISR_DMA+0x2ec>)
20010516:	4293      	cmp	r3, r2
20010518:	d035      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
2001051a:	68fb      	ldr	r3, [r7, #12]
2001051c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001051e:	681b      	ldr	r3, [r3, #0]
20010520:	4a7f      	ldr	r2, [pc, #508]	; (20010720 <I2C_Slave_ISR_DMA+0x2f0>)
20010522:	4293      	cmp	r3, r2
20010524:	d02f      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
20010526:	68fb      	ldr	r3, [r7, #12]
20010528:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001052a:	681b      	ldr	r3, [r3, #0]
2001052c:	4a7d      	ldr	r2, [pc, #500]	; (20010724 <I2C_Slave_ISR_DMA+0x2f4>)
2001052e:	4293      	cmp	r3, r2
20010530:	d029      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
20010532:	68fb      	ldr	r3, [r7, #12]
20010534:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010536:	681b      	ldr	r3, [r3, #0]
20010538:	4a7b      	ldr	r2, [pc, #492]	; (20010728 <I2C_Slave_ISR_DMA+0x2f8>)
2001053a:	4293      	cmp	r3, r2
2001053c:	d023      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
2001053e:	68fb      	ldr	r3, [r7, #12]
20010540:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010542:	681b      	ldr	r3, [r3, #0]
20010544:	4a79      	ldr	r2, [pc, #484]	; (2001072c <I2C_Slave_ISR_DMA+0x2fc>)
20010546:	4293      	cmp	r3, r2
20010548:	d01d      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
2001054a:	68fb      	ldr	r3, [r7, #12]
2001054c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001054e:	681b      	ldr	r3, [r3, #0]
20010550:	4a77      	ldr	r2, [pc, #476]	; (20010730 <I2C_Slave_ISR_DMA+0x300>)
20010552:	4293      	cmp	r3, r2
20010554:	d017      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
20010556:	68fb      	ldr	r3, [r7, #12]
20010558:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001055a:	681b      	ldr	r3, [r3, #0]
2001055c:	4a75      	ldr	r2, [pc, #468]	; (20010734 <I2C_Slave_ISR_DMA+0x304>)
2001055e:	4293      	cmp	r3, r2
20010560:	d011      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
20010562:	68fb      	ldr	r3, [r7, #12]
20010564:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010566:	681b      	ldr	r3, [r3, #0]
20010568:	4a73      	ldr	r2, [pc, #460]	; (20010738 <I2C_Slave_ISR_DMA+0x308>)
2001056a:	4293      	cmp	r3, r2
2001056c:	d00b      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
2001056e:	68fb      	ldr	r3, [r7, #12]
20010570:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010572:	681b      	ldr	r3, [r3, #0]
20010574:	4a71      	ldr	r2, [pc, #452]	; (2001073c <I2C_Slave_ISR_DMA+0x30c>)
20010576:	4293      	cmp	r3, r2
20010578:	d005      	beq.n	20010586 <I2C_Slave_ISR_DMA+0x156>
2001057a:	68fb      	ldr	r3, [r7, #12]
2001057c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001057e:	681b      	ldr	r3, [r3, #0]
20010580:	4a6f      	ldr	r2, [pc, #444]	; (20010740 <I2C_Slave_ISR_DMA+0x310>)
20010582:	4293      	cmp	r3, r2
20010584:	d109      	bne.n	2001059a <I2C_Slave_ISR_DMA+0x16a>
20010586:	68fb      	ldr	r3, [r7, #12]
20010588:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001058a:	681b      	ldr	r3, [r3, #0]
2001058c:	685b      	ldr	r3, [r3, #4]
2001058e:	2b00      	cmp	r3, #0
20010590:	bf0c      	ite	eq
20010592:	2301      	moveq	r3, #1
20010594:	2300      	movne	r3, #0
20010596:	b2db      	uxtb	r3, r3
20010598:	e008      	b.n	200105ac <I2C_Slave_ISR_DMA+0x17c>
2001059a:	68fb      	ldr	r3, [r7, #12]
2001059c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001059e:	681b      	ldr	r3, [r3, #0]
200105a0:	685b      	ldr	r3, [r3, #4]
200105a2:	2b00      	cmp	r3, #0
200105a4:	bf0c      	ite	eq
200105a6:	2301      	moveq	r3, #1
200105a8:	2300      	movne	r3, #0
200105aa:	b2db      	uxtb	r3, r3
200105ac:	2b00      	cmp	r3, #0
200105ae:	d001      	beq.n	200105b4 <I2C_Slave_ISR_DMA+0x184>
          {
            treatdmanack = 1U;
200105b0:	2301      	movs	r3, #1
200105b2:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      /* Split check of hdmatx, for MISRA compliance  */
      if (hi2c->hdmatx != NULL)
200105b4:	68fb      	ldr	r3, [r7, #12]
200105b6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200105b8:	2b00      	cmp	r3, #0
200105ba:	d07c      	beq.n	200106b6 <I2C_Slave_ISR_DMA+0x286>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
200105bc:	687b      	ldr	r3, [r7, #4]
200105be:	0b9b      	lsrs	r3, r3, #14
200105c0:	f003 0301 	and.w	r3, r3, #1
200105c4:	2b00      	cmp	r3, #0
200105c6:	d076      	beq.n	200106b6 <I2C_Slave_ISR_DMA+0x286>
        {
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
200105c8:	68fb      	ldr	r3, [r7, #12]
200105ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200105cc:	681b      	ldr	r3, [r3, #0]
200105ce:	4a4d      	ldr	r2, [pc, #308]	; (20010704 <I2C_Slave_ISR_DMA+0x2d4>)
200105d0:	4293      	cmp	r3, r2
200105d2:	d059      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
200105d4:	68fb      	ldr	r3, [r7, #12]
200105d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200105d8:	681b      	ldr	r3, [r3, #0]
200105da:	4a4b      	ldr	r2, [pc, #300]	; (20010708 <I2C_Slave_ISR_DMA+0x2d8>)
200105dc:	4293      	cmp	r3, r2
200105de:	d053      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
200105e0:	68fb      	ldr	r3, [r7, #12]
200105e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200105e4:	681b      	ldr	r3, [r3, #0]
200105e6:	4a49      	ldr	r2, [pc, #292]	; (2001070c <I2C_Slave_ISR_DMA+0x2dc>)
200105e8:	4293      	cmp	r3, r2
200105ea:	d04d      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
200105ec:	68fb      	ldr	r3, [r7, #12]
200105ee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200105f0:	681b      	ldr	r3, [r3, #0]
200105f2:	4a47      	ldr	r2, [pc, #284]	; (20010710 <I2C_Slave_ISR_DMA+0x2e0>)
200105f4:	4293      	cmp	r3, r2
200105f6:	d047      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
200105f8:	68fb      	ldr	r3, [r7, #12]
200105fa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200105fc:	681b      	ldr	r3, [r3, #0]
200105fe:	4a45      	ldr	r2, [pc, #276]	; (20010714 <I2C_Slave_ISR_DMA+0x2e4>)
20010600:	4293      	cmp	r3, r2
20010602:	d041      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
20010604:	68fb      	ldr	r3, [r7, #12]
20010606:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010608:	681b      	ldr	r3, [r3, #0]
2001060a:	4a43      	ldr	r2, [pc, #268]	; (20010718 <I2C_Slave_ISR_DMA+0x2e8>)
2001060c:	4293      	cmp	r3, r2
2001060e:	d03b      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
20010610:	68fb      	ldr	r3, [r7, #12]
20010612:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010614:	681b      	ldr	r3, [r3, #0]
20010616:	4a41      	ldr	r2, [pc, #260]	; (2001071c <I2C_Slave_ISR_DMA+0x2ec>)
20010618:	4293      	cmp	r3, r2
2001061a:	d035      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
2001061c:	68fb      	ldr	r3, [r7, #12]
2001061e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010620:	681b      	ldr	r3, [r3, #0]
20010622:	4a3f      	ldr	r2, [pc, #252]	; (20010720 <I2C_Slave_ISR_DMA+0x2f0>)
20010624:	4293      	cmp	r3, r2
20010626:	d02f      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
20010628:	68fb      	ldr	r3, [r7, #12]
2001062a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001062c:	681b      	ldr	r3, [r3, #0]
2001062e:	4a3d      	ldr	r2, [pc, #244]	; (20010724 <I2C_Slave_ISR_DMA+0x2f4>)
20010630:	4293      	cmp	r3, r2
20010632:	d029      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
20010634:	68fb      	ldr	r3, [r7, #12]
20010636:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010638:	681b      	ldr	r3, [r3, #0]
2001063a:	4a3b      	ldr	r2, [pc, #236]	; (20010728 <I2C_Slave_ISR_DMA+0x2f8>)
2001063c:	4293      	cmp	r3, r2
2001063e:	d023      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
20010640:	68fb      	ldr	r3, [r7, #12]
20010642:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010644:	681b      	ldr	r3, [r3, #0]
20010646:	4a39      	ldr	r2, [pc, #228]	; (2001072c <I2C_Slave_ISR_DMA+0x2fc>)
20010648:	4293      	cmp	r3, r2
2001064a:	d01d      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
2001064c:	68fb      	ldr	r3, [r7, #12]
2001064e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010650:	681b      	ldr	r3, [r3, #0]
20010652:	4a37      	ldr	r2, [pc, #220]	; (20010730 <I2C_Slave_ISR_DMA+0x300>)
20010654:	4293      	cmp	r3, r2
20010656:	d017      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
20010658:	68fb      	ldr	r3, [r7, #12]
2001065a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001065c:	681b      	ldr	r3, [r3, #0]
2001065e:	4a35      	ldr	r2, [pc, #212]	; (20010734 <I2C_Slave_ISR_DMA+0x304>)
20010660:	4293      	cmp	r3, r2
20010662:	d011      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
20010664:	68fb      	ldr	r3, [r7, #12]
20010666:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010668:	681b      	ldr	r3, [r3, #0]
2001066a:	4a33      	ldr	r2, [pc, #204]	; (20010738 <I2C_Slave_ISR_DMA+0x308>)
2001066c:	4293      	cmp	r3, r2
2001066e:	d00b      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
20010670:	68fb      	ldr	r3, [r7, #12]
20010672:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010674:	681b      	ldr	r3, [r3, #0]
20010676:	4a31      	ldr	r2, [pc, #196]	; (2001073c <I2C_Slave_ISR_DMA+0x30c>)
20010678:	4293      	cmp	r3, r2
2001067a:	d005      	beq.n	20010688 <I2C_Slave_ISR_DMA+0x258>
2001067c:	68fb      	ldr	r3, [r7, #12]
2001067e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010680:	681b      	ldr	r3, [r3, #0]
20010682:	4a2f      	ldr	r2, [pc, #188]	; (20010740 <I2C_Slave_ISR_DMA+0x310>)
20010684:	4293      	cmp	r3, r2
20010686:	d109      	bne.n	2001069c <I2C_Slave_ISR_DMA+0x26c>
20010688:	68fb      	ldr	r3, [r7, #12]
2001068a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001068c:	681b      	ldr	r3, [r3, #0]
2001068e:	685b      	ldr	r3, [r3, #4]
20010690:	2b00      	cmp	r3, #0
20010692:	bf0c      	ite	eq
20010694:	2301      	moveq	r3, #1
20010696:	2300      	movne	r3, #0
20010698:	b2db      	uxtb	r3, r3
2001069a:	e008      	b.n	200106ae <I2C_Slave_ISR_DMA+0x27e>
2001069c:	68fb      	ldr	r3, [r7, #12]
2001069e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200106a0:	681b      	ldr	r3, [r3, #0]
200106a2:	685b      	ldr	r3, [r3, #4]
200106a4:	2b00      	cmp	r3, #0
200106a6:	bf0c      	ite	eq
200106a8:	2301      	moveq	r3, #1
200106aa:	2300      	movne	r3, #0
200106ac:	b2db      	uxtb	r3, r3
200106ae:	2b00      	cmp	r3, #0
200106b0:	d001      	beq.n	200106b6 <I2C_Slave_ISR_DMA+0x286>
          {
            treatdmanack = 1U;
200106b2:	2301      	movs	r3, #1
200106b4:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      if (treatdmanack == 1U)
200106b6:	69fb      	ldr	r3, [r7, #28]
200106b8:	2b01      	cmp	r3, #1
200106ba:	d148      	bne.n	2001074e <I2C_Slave_ISR_DMA+0x31e>
      {
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
200106bc:	68fb      	ldr	r3, [r7, #12]
200106be:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200106c2:	b2db      	uxtb	r3, r3
200106c4:	2b28      	cmp	r3, #40	; 0x28
200106c6:	d108      	bne.n	200106da <I2C_Slave_ISR_DMA+0x2aa>
200106c8:	69bb      	ldr	r3, [r7, #24]
200106ca:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200106ce:	d104      	bne.n	200106da <I2C_Slave_ISR_DMA+0x2aa>
        {
          /* Call I2C Listen complete process */
          I2C_ITListenCplt(hi2c, ITFlags);
200106d0:	68b9      	ldr	r1, [r7, #8]
200106d2:	68f8      	ldr	r0, [r7, #12]
200106d4:	f000 fd14 	bl	20011100 <I2C_ITListenCplt>
200106d8:	e068      	b.n	200107ac <I2C_Slave_ISR_DMA+0x37c>
        }
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
200106da:	68fb      	ldr	r3, [r7, #12]
200106dc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200106e0:	b2db      	uxtb	r3, r3
200106e2:	2b29      	cmp	r3, #41	; 0x29
200106e4:	d12e      	bne.n	20010744 <I2C_Slave_ISR_DMA+0x314>
200106e6:	69bb      	ldr	r3, [r7, #24]
200106e8:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
200106ec:	d02a      	beq.n	20010744 <I2C_Slave_ISR_DMA+0x314>
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
200106ee:	68fb      	ldr	r3, [r7, #12]
200106f0:	681b      	ldr	r3, [r3, #0]
200106f2:	2210      	movs	r2, #16
200106f4:	61da      	str	r2, [r3, #28]

          /* Flush TX register */
          I2C_Flush_TXDR(hi2c);
200106f6:	68f8      	ldr	r0, [r7, #12]
200106f8:	f000 fe4f 	bl	2001139a <I2C_Flush_TXDR>

          /* Last Byte is Transmitted */
          /* Call I2C Slave Sequential complete process */
          I2C_ITSlaveSeqCplt(hi2c);
200106fc:	68f8      	ldr	r0, [r7, #12]
200106fe:	f000 f9e0 	bl	20010ac2 <I2C_ITSlaveSeqCplt>
20010702:	e053      	b.n	200107ac <I2C_Slave_ISR_DMA+0x37c>
20010704:	40020010 	.word	0x40020010
20010708:	40020028 	.word	0x40020028
2001070c:	40020040 	.word	0x40020040
20010710:	40020058 	.word	0x40020058
20010714:	40020070 	.word	0x40020070
20010718:	40020088 	.word	0x40020088
2001071c:	400200a0 	.word	0x400200a0
20010720:	400200b8 	.word	0x400200b8
20010724:	40020410 	.word	0x40020410
20010728:	40020428 	.word	0x40020428
2001072c:	40020440 	.word	0x40020440
20010730:	40020458 	.word	0x40020458
20010734:	40020470 	.word	0x40020470
20010738:	40020488 	.word	0x40020488
2001073c:	400204a0 	.word	0x400204a0
20010740:	400204b8 	.word	0x400204b8
        }
        else
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20010744:	68fb      	ldr	r3, [r7, #12]
20010746:	681b      	ldr	r3, [r3, #0]
20010748:	2210      	movs	r2, #16
2001074a:	61da      	str	r2, [r3, #28]
      if (treatdmanack == 1U)
2001074c:	e034      	b.n	200107b8 <I2C_Slave_ISR_DMA+0x388>
      }
      else
      {
        /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2001074e:	68fb      	ldr	r3, [r7, #12]
20010750:	681b      	ldr	r3, [r3, #0]
20010752:	2210      	movs	r2, #16
20010754:	61da      	str	r2, [r3, #28]

        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
20010756:	68fb      	ldr	r3, [r7, #12]
20010758:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2001075a:	f043 0204 	orr.w	r2, r3, #4
2001075e:	68fb      	ldr	r3, [r7, #12]
20010760:	645a      	str	r2, [r3, #68]	; 0x44

        /* Store current hi2c->State, solve MISRA2012-Rule-13.5 */
        tmpstate = hi2c->State;
20010762:	68fb      	ldr	r3, [r7, #12]
20010764:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010768:	75fb      	strb	r3, [r7, #23]

        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
2001076a:	69bb      	ldr	r3, [r7, #24]
2001076c:	2b00      	cmp	r3, #0
2001076e:	d003      	beq.n	20010778 <I2C_Slave_ISR_DMA+0x348>
20010770:	69bb      	ldr	r3, [r7, #24]
20010772:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20010776:	d11f      	bne.n	200107b8 <I2C_Slave_ISR_DMA+0x388>
        {
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
20010778:	7dfb      	ldrb	r3, [r7, #23]
2001077a:	2b21      	cmp	r3, #33	; 0x21
2001077c:	d002      	beq.n	20010784 <I2C_Slave_ISR_DMA+0x354>
2001077e:	7dfb      	ldrb	r3, [r7, #23]
20010780:	2b29      	cmp	r3, #41	; 0x29
20010782:	d103      	bne.n	2001078c <I2C_Slave_ISR_DMA+0x35c>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
20010784:	68fb      	ldr	r3, [r7, #12]
20010786:	2221      	movs	r2, #33	; 0x21
20010788:	631a      	str	r2, [r3, #48]	; 0x30
2001078a:	e008      	b.n	2001079e <I2C_Slave_ISR_DMA+0x36e>
          }
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
2001078c:	7dfb      	ldrb	r3, [r7, #23]
2001078e:	2b22      	cmp	r3, #34	; 0x22
20010790:	d002      	beq.n	20010798 <I2C_Slave_ISR_DMA+0x368>
20010792:	7dfb      	ldrb	r3, [r7, #23]
20010794:	2b2a      	cmp	r3, #42	; 0x2a
20010796:	d102      	bne.n	2001079e <I2C_Slave_ISR_DMA+0x36e>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
20010798:	68fb      	ldr	r3, [r7, #12]
2001079a:	2222      	movs	r2, #34	; 0x22
2001079c:	631a      	str	r2, [r3, #48]	; 0x30
          {
            /* Do nothing */
          }

          /* Call the corresponding callback to inform upper layer of End of Transfer */
          I2C_ITError(hi2c, hi2c->ErrorCode);
2001079e:	68fb      	ldr	r3, [r7, #12]
200107a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200107a2:	4619      	mov	r1, r3
200107a4:	68f8      	ldr	r0, [r7, #12]
200107a6:	f000 fd01 	bl	200111ac <I2C_ITError>
      if (treatdmanack == 1U)
200107aa:	e005      	b.n	200107b8 <I2C_Slave_ISR_DMA+0x388>
200107ac:	e004      	b.n	200107b8 <I2C_Slave_ISR_DMA+0x388>
      }
    }
    else
    {
      /* Only Clear NACK Flag, no DMA treatment is pending */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
200107ae:	68fb      	ldr	r3, [r7, #12]
200107b0:	681b      	ldr	r3, [r3, #0]
200107b2:	2210      	movs	r2, #16
200107b4:	61da      	str	r2, [r3, #28]
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
200107b6:	e011      	b.n	200107dc <I2C_Slave_ISR_DMA+0x3ac>
      if (treatdmanack == 1U)
200107b8:	bf00      	nop
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
200107ba:	e00f      	b.n	200107dc <I2C_Slave_ISR_DMA+0x3ac>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
200107bc:	68bb      	ldr	r3, [r7, #8]
200107be:	08db      	lsrs	r3, r3, #3
200107c0:	f003 0301 	and.w	r3, r3, #1
200107c4:	2b00      	cmp	r3, #0
200107c6:	d009      	beq.n	200107dc <I2C_Slave_ISR_DMA+0x3ac>
200107c8:	687b      	ldr	r3, [r7, #4]
200107ca:	08db      	lsrs	r3, r3, #3
200107cc:	f003 0301 	and.w	r3, r3, #1
200107d0:	2b00      	cmp	r3, #0
200107d2:	d003      	beq.n	200107dc <I2C_Slave_ISR_DMA+0x3ac>
  {
    I2C_ITAddrCplt(hi2c, ITFlags);
200107d4:	68b9      	ldr	r1, [r7, #8]
200107d6:	68f8      	ldr	r0, [r7, #12]
200107d8:	f000 f8b2 	bl	20010940 <I2C_ITAddrCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
200107dc:	68fb      	ldr	r3, [r7, #12]
200107de:	2200      	movs	r2, #0
200107e0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
200107e4:	2300      	movs	r3, #0
}
200107e6:	4618      	mov	r0, r3
200107e8:	3720      	adds	r7, #32
200107ea:	46bd      	mov	sp, r7
200107ec:	bd80      	pop	{r7, pc}
200107ee:	bf00      	nop

200107f0 <I2C_RequestMemoryWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
200107f0:	b580      	push	{r7, lr}
200107f2:	b086      	sub	sp, #24
200107f4:	af02      	add	r7, sp, #8
200107f6:	60f8      	str	r0, [r7, #12]
200107f8:	4608      	mov	r0, r1
200107fa:	4611      	mov	r1, r2
200107fc:	461a      	mov	r2, r3
200107fe:	4603      	mov	r3, r0
20010800:	817b      	strh	r3, [r7, #10]
20010802:	460b      	mov	r3, r1
20010804:	813b      	strh	r3, [r7, #8]
20010806:	4613      	mov	r3, r2
20010808:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
2001080a:	88fb      	ldrh	r3, [r7, #6]
2001080c:	b2da      	uxtb	r2, r3
2001080e:	8979      	ldrh	r1, [r7, #10]
20010810:	4b20      	ldr	r3, [pc, #128]	; (20010894 <I2C_RequestMemoryWrite+0xa4>)
20010812:	9300      	str	r3, [sp, #0]
20010814:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20010818:	68f8      	ldr	r0, [r7, #12]
2001081a:	f001 fa2f 	bl	20011c7c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2001081e:	69fa      	ldr	r2, [r7, #28]
20010820:	69b9      	ldr	r1, [r7, #24]
20010822:	68f8      	ldr	r0, [r7, #12]
20010824:	f001 f8dc 	bl	200119e0 <I2C_WaitOnTXISFlagUntilTimeout>
20010828:	4603      	mov	r3, r0
2001082a:	2b00      	cmp	r3, #0
2001082c:	d001      	beq.n	20010832 <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
2001082e:	2301      	movs	r3, #1
20010830:	e02c      	b.n	2001088c <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
20010832:	88fb      	ldrh	r3, [r7, #6]
20010834:	2b01      	cmp	r3, #1
20010836:	d105      	bne.n	20010844 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
20010838:	893b      	ldrh	r3, [r7, #8]
2001083a:	b2da      	uxtb	r2, r3
2001083c:	68fb      	ldr	r3, [r7, #12]
2001083e:	681b      	ldr	r3, [r3, #0]
20010840:	629a      	str	r2, [r3, #40]	; 0x28
20010842:	e015      	b.n	20010870 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
20010844:	893b      	ldrh	r3, [r7, #8]
20010846:	0a1b      	lsrs	r3, r3, #8
20010848:	b29b      	uxth	r3, r3
2001084a:	b2da      	uxtb	r2, r3
2001084c:	68fb      	ldr	r3, [r7, #12]
2001084e:	681b      	ldr	r3, [r3, #0]
20010850:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
20010852:	69fa      	ldr	r2, [r7, #28]
20010854:	69b9      	ldr	r1, [r7, #24]
20010856:	68f8      	ldr	r0, [r7, #12]
20010858:	f001 f8c2 	bl	200119e0 <I2C_WaitOnTXISFlagUntilTimeout>
2001085c:	4603      	mov	r3, r0
2001085e:	2b00      	cmp	r3, #0
20010860:	d001      	beq.n	20010866 <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
20010862:	2301      	movs	r3, #1
20010864:	e012      	b.n	2001088c <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
20010866:	893b      	ldrh	r3, [r7, #8]
20010868:	b2da      	uxtb	r2, r3
2001086a:	68fb      	ldr	r3, [r7, #12]
2001086c:	681b      	ldr	r3, [r3, #0]
2001086e:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
20010870:	69fb      	ldr	r3, [r7, #28]
20010872:	9300      	str	r3, [sp, #0]
20010874:	69bb      	ldr	r3, [r7, #24]
20010876:	2200      	movs	r2, #0
20010878:	2180      	movs	r1, #128	; 0x80
2001087a:	68f8      	ldr	r0, [r7, #12]
2001087c:	f001 f870 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
20010880:	4603      	mov	r3, r0
20010882:	2b00      	cmp	r3, #0
20010884:	d001      	beq.n	2001088a <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
20010886:	2301      	movs	r3, #1
20010888:	e000      	b.n	2001088c <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
2001088a:	2300      	movs	r3, #0
}
2001088c:	4618      	mov	r0, r3
2001088e:	3710      	adds	r7, #16
20010890:	46bd      	mov	sp, r7
20010892:	bd80      	pop	{r7, pc}
20010894:	80002000 	.word	0x80002000

20010898 <I2C_RequestMemoryRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
20010898:	b580      	push	{r7, lr}
2001089a:	b086      	sub	sp, #24
2001089c:	af02      	add	r7, sp, #8
2001089e:	60f8      	str	r0, [r7, #12]
200108a0:	4608      	mov	r0, r1
200108a2:	4611      	mov	r1, r2
200108a4:	461a      	mov	r2, r3
200108a6:	4603      	mov	r3, r0
200108a8:	817b      	strh	r3, [r7, #10]
200108aa:	460b      	mov	r3, r1
200108ac:	813b      	strh	r3, [r7, #8]
200108ae:	4613      	mov	r3, r2
200108b0:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
200108b2:	88fb      	ldrh	r3, [r7, #6]
200108b4:	b2da      	uxtb	r2, r3
200108b6:	8979      	ldrh	r1, [r7, #10]
200108b8:	4b20      	ldr	r3, [pc, #128]	; (2001093c <I2C_RequestMemoryRead+0xa4>)
200108ba:	9300      	str	r3, [sp, #0]
200108bc:	2300      	movs	r3, #0
200108be:	68f8      	ldr	r0, [r7, #12]
200108c0:	f001 f9dc 	bl	20011c7c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
200108c4:	69fa      	ldr	r2, [r7, #28]
200108c6:	69b9      	ldr	r1, [r7, #24]
200108c8:	68f8      	ldr	r0, [r7, #12]
200108ca:	f001 f889 	bl	200119e0 <I2C_WaitOnTXISFlagUntilTimeout>
200108ce:	4603      	mov	r3, r0
200108d0:	2b00      	cmp	r3, #0
200108d2:	d001      	beq.n	200108d8 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
200108d4:	2301      	movs	r3, #1
200108d6:	e02c      	b.n	20010932 <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
200108d8:	88fb      	ldrh	r3, [r7, #6]
200108da:	2b01      	cmp	r3, #1
200108dc:	d105      	bne.n	200108ea <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
200108de:	893b      	ldrh	r3, [r7, #8]
200108e0:	b2da      	uxtb	r2, r3
200108e2:	68fb      	ldr	r3, [r7, #12]
200108e4:	681b      	ldr	r3, [r3, #0]
200108e6:	629a      	str	r2, [r3, #40]	; 0x28
200108e8:	e015      	b.n	20010916 <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
200108ea:	893b      	ldrh	r3, [r7, #8]
200108ec:	0a1b      	lsrs	r3, r3, #8
200108ee:	b29b      	uxth	r3, r3
200108f0:	b2da      	uxtb	r2, r3
200108f2:	68fb      	ldr	r3, [r7, #12]
200108f4:	681b      	ldr	r3, [r3, #0]
200108f6:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
200108f8:	69fa      	ldr	r2, [r7, #28]
200108fa:	69b9      	ldr	r1, [r7, #24]
200108fc:	68f8      	ldr	r0, [r7, #12]
200108fe:	f001 f86f 	bl	200119e0 <I2C_WaitOnTXISFlagUntilTimeout>
20010902:	4603      	mov	r3, r0
20010904:	2b00      	cmp	r3, #0
20010906:	d001      	beq.n	2001090c <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
20010908:	2301      	movs	r3, #1
2001090a:	e012      	b.n	20010932 <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2001090c:	893b      	ldrh	r3, [r7, #8]
2001090e:	b2da      	uxtb	r2, r3
20010910:	68fb      	ldr	r3, [r7, #12]
20010912:	681b      	ldr	r3, [r3, #0]
20010914:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
20010916:	69fb      	ldr	r3, [r7, #28]
20010918:	9300      	str	r3, [sp, #0]
2001091a:	69bb      	ldr	r3, [r7, #24]
2001091c:	2200      	movs	r2, #0
2001091e:	2140      	movs	r1, #64	; 0x40
20010920:	68f8      	ldr	r0, [r7, #12]
20010922:	f001 f81d 	bl	20011960 <I2C_WaitOnFlagUntilTimeout>
20010926:	4603      	mov	r3, r0
20010928:	2b00      	cmp	r3, #0
2001092a:	d001      	beq.n	20010930 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
2001092c:	2301      	movs	r3, #1
2001092e:	e000      	b.n	20010932 <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
20010930:	2300      	movs	r3, #0
}
20010932:	4618      	mov	r0, r3
20010934:	3710      	adds	r7, #16
20010936:	46bd      	mov	sp, r7
20010938:	bd80      	pop	{r7, pc}
2001093a:	bf00      	nop
2001093c:	80002000 	.word	0x80002000

20010940 <I2C_ITAddrCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
20010940:	b580      	push	{r7, lr}
20010942:	b084      	sub	sp, #16
20010944:	af00      	add	r7, sp, #0
20010946:	6078      	str	r0, [r7, #4]
20010948:	6039      	str	r1, [r7, #0]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(ITFlags);

  /* In case of Listen state, need to inform upper layer of address match code event */
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2001094a:	687b      	ldr	r3, [r7, #4]
2001094c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010950:	b2db      	uxtb	r3, r3
20010952:	f003 0328 	and.w	r3, r3, #40	; 0x28
20010956:	2b28      	cmp	r3, #40	; 0x28
20010958:	d16a      	bne.n	20010a30 <I2C_ITAddrCplt+0xf0>
  {
    transferdirection = I2C_GET_DIR(hi2c);
2001095a:	687b      	ldr	r3, [r7, #4]
2001095c:	681b      	ldr	r3, [r3, #0]
2001095e:	699b      	ldr	r3, [r3, #24]
20010960:	0c1b      	lsrs	r3, r3, #16
20010962:	b2db      	uxtb	r3, r3
20010964:	f003 0301 	and.w	r3, r3, #1
20010968:	73fb      	strb	r3, [r7, #15]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
2001096a:	687b      	ldr	r3, [r7, #4]
2001096c:	681b      	ldr	r3, [r3, #0]
2001096e:	699b      	ldr	r3, [r3, #24]
20010970:	0c1b      	lsrs	r3, r3, #16
20010972:	b29b      	uxth	r3, r3
20010974:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
20010978:	81bb      	strh	r3, [r7, #12]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
2001097a:	687b      	ldr	r3, [r7, #4]
2001097c:	681b      	ldr	r3, [r3, #0]
2001097e:	689b      	ldr	r3, [r3, #8]
20010980:	b29b      	uxth	r3, r3
20010982:	f3c3 0309 	ubfx	r3, r3, #0, #10
20010986:	817b      	strh	r3, [r7, #10]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
20010988:	687b      	ldr	r3, [r7, #4]
2001098a:	681b      	ldr	r3, [r3, #0]
2001098c:	68db      	ldr	r3, [r3, #12]
2001098e:	b29b      	uxth	r3, r3
20010990:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
20010994:	813b      	strh	r3, [r7, #8]

    /* If 10bits addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
20010996:	687b      	ldr	r3, [r7, #4]
20010998:	68db      	ldr	r3, [r3, #12]
2001099a:	2b02      	cmp	r3, #2
2001099c:	d138      	bne.n	20010a10 <I2C_ITAddrCplt+0xd0>
    {
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
2001099e:	897b      	ldrh	r3, [r7, #10]
200109a0:	09db      	lsrs	r3, r3, #7
200109a2:	b29a      	uxth	r2, r3
200109a4:	89bb      	ldrh	r3, [r7, #12]
200109a6:	4053      	eors	r3, r2
200109a8:	b29b      	uxth	r3, r3
200109aa:	f003 0306 	and.w	r3, r3, #6
200109ae:	2b00      	cmp	r3, #0
200109b0:	d11c      	bne.n	200109ec <I2C_ITAddrCplt+0xac>
      {
        slaveaddrcode = ownadd1code;
200109b2:	897b      	ldrh	r3, [r7, #10]
200109b4:	81bb      	strh	r3, [r7, #12]
        hi2c->AddrEventCount++;
200109b6:	687b      	ldr	r3, [r7, #4]
200109b8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200109ba:	1c5a      	adds	r2, r3, #1
200109bc:	687b      	ldr	r3, [r7, #4]
200109be:	649a      	str	r2, [r3, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
200109c0:	687b      	ldr	r3, [r7, #4]
200109c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200109c4:	2b02      	cmp	r3, #2
200109c6:	d13b      	bne.n	20010a40 <I2C_ITAddrCplt+0x100>
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;
200109c8:	687b      	ldr	r3, [r7, #4]
200109ca:	2200      	movs	r2, #0
200109cc:	649a      	str	r2, [r3, #72]	; 0x48

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
200109ce:	687b      	ldr	r3, [r7, #4]
200109d0:	681b      	ldr	r3, [r3, #0]
200109d2:	2208      	movs	r2, #8
200109d4:	61da      	str	r2, [r3, #28]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
200109d6:	687b      	ldr	r3, [r7, #4]
200109d8:	2200      	movs	r2, #0
200109da:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
#else
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
200109de:	89ba      	ldrh	r2, [r7, #12]
200109e0:	7bfb      	ldrb	r3, [r7, #15]
200109e2:	4619      	mov	r1, r3
200109e4:	6878      	ldr	r0, [r7, #4]
200109e6:	f7ff f99c 	bl	2000fd22 <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
200109ea:	e029      	b.n	20010a40 <I2C_ITAddrCplt+0x100>
        slaveaddrcode = ownadd2code;
200109ec:	893b      	ldrh	r3, [r7, #8]
200109ee:	81bb      	strh	r3, [r7, #12]
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
200109f0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
200109f4:	6878      	ldr	r0, [r7, #4]
200109f6:	f001 fa1d 	bl	20011e34 <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
200109fa:	687b      	ldr	r3, [r7, #4]
200109fc:	2200      	movs	r2, #0
200109fe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
20010a02:	89ba      	ldrh	r2, [r7, #12]
20010a04:	7bfb      	ldrb	r3, [r7, #15]
20010a06:	4619      	mov	r1, r3
20010a08:	6878      	ldr	r0, [r7, #4]
20010a0a:	f7ff f98a 	bl	2000fd22 <HAL_I2C_AddrCallback>
}
20010a0e:	e017      	b.n	20010a40 <I2C_ITAddrCplt+0x100>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
20010a10:	f44f 4100 	mov.w	r1, #32768	; 0x8000
20010a14:	6878      	ldr	r0, [r7, #4]
20010a16:	f001 fa0d 	bl	20011e34 <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
20010a1a:	687b      	ldr	r3, [r7, #4]
20010a1c:	2200      	movs	r2, #0
20010a1e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
20010a22:	89ba      	ldrh	r2, [r7, #12]
20010a24:	7bfb      	ldrb	r3, [r7, #15]
20010a26:	4619      	mov	r1, r3
20010a28:	6878      	ldr	r0, [r7, #4]
20010a2a:	f7ff f97a 	bl	2000fd22 <HAL_I2C_AddrCallback>
}
20010a2e:	e007      	b.n	20010a40 <I2C_ITAddrCplt+0x100>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
20010a30:	687b      	ldr	r3, [r7, #4]
20010a32:	681b      	ldr	r3, [r3, #0]
20010a34:	2208      	movs	r2, #8
20010a36:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
20010a38:	687b      	ldr	r3, [r7, #4]
20010a3a:	2200      	movs	r2, #0
20010a3c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
}
20010a40:	bf00      	nop
20010a42:	3710      	adds	r7, #16
20010a44:	46bd      	mov	sp, r7
20010a46:	bd80      	pop	{r7, pc}

20010a48 <I2C_ITMasterSeqCplt>:
  * @brief  I2C Master sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
{
20010a48:	b580      	push	{r7, lr}
20010a4a:	b082      	sub	sp, #8
20010a4c:	af00      	add	r7, sp, #0
20010a4e:	6078      	str	r0, [r7, #4]
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
20010a50:	687b      	ldr	r3, [r7, #4]
20010a52:	2200      	movs	r2, #0
20010a54:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* No Generate Stop, to permit restart mode */
  /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
20010a58:	687b      	ldr	r3, [r7, #4]
20010a5a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010a5e:	b2db      	uxtb	r3, r3
20010a60:	2b21      	cmp	r3, #33	; 0x21
20010a62:	d115      	bne.n	20010a90 <I2C_ITMasterSeqCplt+0x48>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
20010a64:	687b      	ldr	r3, [r7, #4]
20010a66:	2220      	movs	r2, #32
20010a68:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
20010a6c:	687b      	ldr	r3, [r7, #4]
20010a6e:	2211      	movs	r2, #17
20010a70:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
20010a72:	687b      	ldr	r3, [r7, #4]
20010a74:	2200      	movs	r2, #0
20010a76:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
20010a78:	2101      	movs	r1, #1
20010a7a:	6878      	ldr	r0, [r7, #4]
20010a7c:	f001 f9da 	bl	20011e34 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20010a80:	687b      	ldr	r3, [r7, #4]
20010a82:	2200      	movs	r2, #0
20010a84:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->MasterTxCpltCallback(hi2c);
#else
    HAL_I2C_MasterTxCpltCallback(hi2c);
20010a88:	6878      	ldr	r0, [r7, #4]
20010a8a:	f7ff f922 	bl	2000fcd2 <HAL_I2C_MasterTxCpltCallback>
    hi2c->MasterRxCpltCallback(hi2c);
#else
    HAL_I2C_MasterRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
20010a8e:	e014      	b.n	20010aba <I2C_ITMasterSeqCplt+0x72>
    hi2c->State         = HAL_I2C_STATE_READY;
20010a90:	687b      	ldr	r3, [r7, #4]
20010a92:	2220      	movs	r2, #32
20010a94:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
20010a98:	687b      	ldr	r3, [r7, #4]
20010a9a:	2212      	movs	r2, #18
20010a9c:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
20010a9e:	687b      	ldr	r3, [r7, #4]
20010aa0:	2200      	movs	r2, #0
20010aa2:	635a      	str	r2, [r3, #52]	; 0x34
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
20010aa4:	2102      	movs	r1, #2
20010aa6:	6878      	ldr	r0, [r7, #4]
20010aa8:	f001 f9c4 	bl	20011e34 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
20010aac:	687b      	ldr	r3, [r7, #4]
20010aae:	2200      	movs	r2, #0
20010ab0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
20010ab4:	6878      	ldr	r0, [r7, #4]
20010ab6:	f7ff f916 	bl	2000fce6 <HAL_I2C_MasterRxCpltCallback>
}
20010aba:	bf00      	nop
20010abc:	3708      	adds	r7, #8
20010abe:	46bd      	mov	sp, r7
20010ac0:	bd80      	pop	{r7, pc}

20010ac2 <I2C_ITSlaveSeqCplt>:
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
{
20010ac2:	b580      	push	{r7, lr}
20010ac4:	b084      	sub	sp, #16
20010ac6:	af00      	add	r7, sp, #0
20010ac8:	6078      	str	r0, [r7, #4]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
20010aca:	687b      	ldr	r3, [r7, #4]
20010acc:	681b      	ldr	r3, [r3, #0]
20010ace:	681b      	ldr	r3, [r3, #0]
20010ad0:	60fb      	str	r3, [r7, #12]

  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
20010ad2:	687b      	ldr	r3, [r7, #4]
20010ad4:	2200      	movs	r2, #0
20010ad6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
20010ada:	68fb      	ldr	r3, [r7, #12]
20010adc:	0b9b      	lsrs	r3, r3, #14
20010ade:	f003 0301 	and.w	r3, r3, #1
20010ae2:	2b00      	cmp	r3, #0
20010ae4:	d008      	beq.n	20010af8 <I2C_ITSlaveSeqCplt+0x36>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
20010ae6:	687b      	ldr	r3, [r7, #4]
20010ae8:	681b      	ldr	r3, [r3, #0]
20010aea:	681a      	ldr	r2, [r3, #0]
20010aec:	687b      	ldr	r3, [r7, #4]
20010aee:	681b      	ldr	r3, [r3, #0]
20010af0:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
20010af4:	601a      	str	r2, [r3, #0]
20010af6:	e00d      	b.n	20010b14 <I2C_ITSlaveSeqCplt+0x52>
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
20010af8:	68fb      	ldr	r3, [r7, #12]
20010afa:	0bdb      	lsrs	r3, r3, #15
20010afc:	f003 0301 	and.w	r3, r3, #1
20010b00:	2b00      	cmp	r3, #0
20010b02:	d007      	beq.n	20010b14 <I2C_ITSlaveSeqCplt+0x52>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
20010b04:	687b      	ldr	r3, [r7, #4]
20010b06:	681b      	ldr	r3, [r3, #0]
20010b08:	681a      	ldr	r2, [r3, #0]
20010b0a:	687b      	ldr	r3, [r7, #4]
20010b0c:	681b      	ldr	r3, [r3, #0]
20010b0e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20010b12:	601a      	str	r2, [r3, #0]
  else
  {
    /* Do nothing */
  }

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
20010b14:	687b      	ldr	r3, [r7, #4]
20010b16:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010b1a:	b2db      	uxtb	r3, r3
20010b1c:	2b29      	cmp	r3, #41	; 0x29
20010b1e:	d112      	bne.n	20010b46 <I2C_ITSlaveSeqCplt+0x84>
  {
    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
20010b20:	687b      	ldr	r3, [r7, #4]
20010b22:	2228      	movs	r2, #40	; 0x28
20010b24:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
20010b28:	687b      	ldr	r3, [r7, #4]
20010b2a:	2221      	movs	r2, #33	; 0x21
20010b2c:	631a      	str	r2, [r3, #48]	; 0x30

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
20010b2e:	2101      	movs	r1, #1
20010b30:	6878      	ldr	r0, [r7, #4]
20010b32:	f001 f97f 	bl	20011e34 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20010b36:	687b      	ldr	r3, [r7, #4]
20010b38:	2200      	movs	r2, #0
20010b3a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
20010b3e:	6878      	ldr	r0, [r7, #4]
20010b40:	f7ff f8db 	bl	2000fcfa <HAL_I2C_SlaveTxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
20010b44:	e017      	b.n	20010b76 <I2C_ITSlaveSeqCplt+0xb4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
20010b46:	687b      	ldr	r3, [r7, #4]
20010b48:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010b4c:	b2db      	uxtb	r3, r3
20010b4e:	2b2a      	cmp	r3, #42	; 0x2a
20010b50:	d111      	bne.n	20010b76 <I2C_ITSlaveSeqCplt+0xb4>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
20010b52:	687b      	ldr	r3, [r7, #4]
20010b54:	2228      	movs	r2, #40	; 0x28
20010b56:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
20010b5a:	687b      	ldr	r3, [r7, #4]
20010b5c:	2222      	movs	r2, #34	; 0x22
20010b5e:	631a      	str	r2, [r3, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
20010b60:	2102      	movs	r1, #2
20010b62:	6878      	ldr	r0, [r7, #4]
20010b64:	f001 f966 	bl	20011e34 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
20010b68:	687b      	ldr	r3, [r7, #4]
20010b6a:	2200      	movs	r2, #0
20010b6c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
20010b70:	6878      	ldr	r0, [r7, #4]
20010b72:	f7ff f8cc 	bl	2000fd0e <HAL_I2C_SlaveRxCpltCallback>
}
20010b76:	bf00      	nop
20010b78:	3710      	adds	r7, #16
20010b7a:	46bd      	mov	sp, r7
20010b7c:	bd80      	pop	{r7, pc}
	...

20010b80 <I2C_ITMasterCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
20010b80:	b580      	push	{r7, lr}
20010b82:	b086      	sub	sp, #24
20010b84:	af00      	add	r7, sp, #0
20010b86:	6078      	str	r0, [r7, #4]
20010b88:	6039      	str	r1, [r7, #0]
  uint32_t tmperror;
  uint32_t tmpITFlags = ITFlags;
20010b8a:	683b      	ldr	r3, [r7, #0]
20010b8c:	617b      	str	r3, [r7, #20]
  uint32_t tmp;

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
20010b8e:	687b      	ldr	r3, [r7, #4]
20010b90:	681b      	ldr	r3, [r3, #0]
20010b92:	2220      	movs	r2, #32
20010b94:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
20010b96:	687b      	ldr	r3, [r7, #4]
20010b98:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010b9c:	b2db      	uxtb	r3, r3
20010b9e:	2b21      	cmp	r3, #33	; 0x21
20010ba0:	d107      	bne.n	20010bb2 <I2C_ITMasterCplt+0x32>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
20010ba2:	2101      	movs	r1, #1
20010ba4:	6878      	ldr	r0, [r7, #4]
20010ba6:	f001 f945 	bl	20011e34 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
20010baa:	687b      	ldr	r3, [r7, #4]
20010bac:	2211      	movs	r2, #17
20010bae:	631a      	str	r2, [r3, #48]	; 0x30
20010bb0:	e00c      	b.n	20010bcc <I2C_ITMasterCplt+0x4c>
  }
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
20010bb2:	687b      	ldr	r3, [r7, #4]
20010bb4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010bb8:	b2db      	uxtb	r3, r3
20010bba:	2b22      	cmp	r3, #34	; 0x22
20010bbc:	d106      	bne.n	20010bcc <I2C_ITMasterCplt+0x4c>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
20010bbe:	2102      	movs	r1, #2
20010bc0:	6878      	ldr	r0, [r7, #4]
20010bc2:	f001 f937 	bl	20011e34 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
20010bc6:	687b      	ldr	r3, [r7, #4]
20010bc8:	2212      	movs	r2, #18
20010bca:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
20010bcc:	687b      	ldr	r3, [r7, #4]
20010bce:	681b      	ldr	r3, [r3, #0]
20010bd0:	6859      	ldr	r1, [r3, #4]
20010bd2:	687b      	ldr	r3, [r7, #4]
20010bd4:	681a      	ldr	r2, [r3, #0]
20010bd6:	4b4c      	ldr	r3, [pc, #304]	; (20010d08 <I2C_ITMasterCplt+0x188>)
20010bd8:	400b      	ands	r3, r1
20010bda:	6053      	str	r3, [r2, #4]

  /* Reset handle parameters */
  hi2c->XferISR       = NULL;
20010bdc:	687b      	ldr	r3, [r7, #4]
20010bde:	2200      	movs	r2, #0
20010be0:	635a      	str	r2, [r3, #52]	; 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
20010be2:	687b      	ldr	r3, [r7, #4]
20010be4:	4a49      	ldr	r2, [pc, #292]	; (20010d0c <I2C_ITMasterCplt+0x18c>)
20010be6:	62da      	str	r2, [r3, #44]	; 0x2c

  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
20010be8:	697b      	ldr	r3, [r7, #20]
20010bea:	091b      	lsrs	r3, r3, #4
20010bec:	f003 0301 	and.w	r3, r3, #1
20010bf0:	2b00      	cmp	r3, #0
20010bf2:	d009      	beq.n	20010c08 <I2C_ITMasterCplt+0x88>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20010bf4:	687b      	ldr	r3, [r7, #4]
20010bf6:	681b      	ldr	r3, [r3, #0]
20010bf8:	2210      	movs	r2, #16
20010bfa:	61da      	str	r2, [r3, #28]

    /* Set acknowledge error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
20010bfc:	687b      	ldr	r3, [r7, #4]
20010bfe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20010c00:	f043 0204 	orr.w	r2, r3, #4
20010c04:	687b      	ldr	r3, [r7, #4]
20010c06:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Fetch Last receive data if any */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
20010c08:	687b      	ldr	r3, [r7, #4]
20010c0a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010c0e:	b2db      	uxtb	r3, r3
20010c10:	2b60      	cmp	r3, #96	; 0x60
20010c12:	d10a      	bne.n	20010c2a <I2C_ITMasterCplt+0xaa>
20010c14:	697b      	ldr	r3, [r7, #20]
20010c16:	089b      	lsrs	r3, r3, #2
20010c18:	f003 0301 	and.w	r3, r3, #1
20010c1c:	2b00      	cmp	r3, #0
20010c1e:	d004      	beq.n	20010c2a <I2C_ITMasterCplt+0xaa>
  {
    /* Read data from RXDR */
    tmp = (uint8_t)hi2c->Instance->RXDR;
20010c20:	687b      	ldr	r3, [r7, #4]
20010c22:	681b      	ldr	r3, [r3, #0]
20010c24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20010c26:	b2db      	uxtb	r3, r3
20010c28:	613b      	str	r3, [r7, #16]

    UNUSED(tmp);
  }

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
20010c2a:	6878      	ldr	r0, [r7, #4]
20010c2c:	f000 fbb5 	bl	2001139a <I2C_Flush_TXDR>

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
20010c30:	687b      	ldr	r3, [r7, #4]
20010c32:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20010c34:	60fb      	str	r3, [r7, #12]

  /* Call the corresponding callback to inform upper layer of End of Transfer */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
20010c36:	687b      	ldr	r3, [r7, #4]
20010c38:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010c3c:	b2db      	uxtb	r3, r3
20010c3e:	2b60      	cmp	r3, #96	; 0x60
20010c40:	d002      	beq.n	20010c48 <I2C_ITMasterCplt+0xc8>
20010c42:	68fb      	ldr	r3, [r7, #12]
20010c44:	2b00      	cmp	r3, #0
20010c46:	d006      	beq.n	20010c56 <I2C_ITMasterCplt+0xd6>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
20010c48:	687b      	ldr	r3, [r7, #4]
20010c4a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20010c4c:	4619      	mov	r1, r3
20010c4e:	6878      	ldr	r0, [r7, #4]
20010c50:	f000 faac 	bl	200111ac <I2C_ITError>
  }
  else
  {
    /* Nothing to do */
  }
}
20010c54:	e054      	b.n	20010d00 <I2C_ITMasterCplt+0x180>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
20010c56:	687b      	ldr	r3, [r7, #4]
20010c58:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010c5c:	b2db      	uxtb	r3, r3
20010c5e:	2b21      	cmp	r3, #33	; 0x21
20010c60:	d124      	bne.n	20010cac <I2C_ITMasterCplt+0x12c>
    hi2c->State = HAL_I2C_STATE_READY;
20010c62:	687b      	ldr	r3, [r7, #4]
20010c64:	2220      	movs	r2, #32
20010c66:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
20010c6a:	687b      	ldr	r3, [r7, #4]
20010c6c:	2200      	movs	r2, #0
20010c6e:	631a      	str	r2, [r3, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
20010c70:	687b      	ldr	r3, [r7, #4]
20010c72:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
20010c76:	b2db      	uxtb	r3, r3
20010c78:	2b40      	cmp	r3, #64	; 0x40
20010c7a:	d10b      	bne.n	20010c94 <I2C_ITMasterCplt+0x114>
      hi2c->Mode = HAL_I2C_MODE_NONE;
20010c7c:	687b      	ldr	r3, [r7, #4]
20010c7e:	2200      	movs	r2, #0
20010c80:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
20010c84:	687b      	ldr	r3, [r7, #4]
20010c86:	2200      	movs	r2, #0
20010c88:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemTxCpltCallback(hi2c);
20010c8c:	6878      	ldr	r0, [r7, #4]
20010c8e:	f7ff f860 	bl	2000fd52 <HAL_I2C_MemTxCpltCallback>
}
20010c92:	e035      	b.n	20010d00 <I2C_ITMasterCplt+0x180>
      hi2c->Mode = HAL_I2C_MODE_NONE;
20010c94:	687b      	ldr	r3, [r7, #4]
20010c96:	2200      	movs	r2, #0
20010c98:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
20010c9c:	687b      	ldr	r3, [r7, #4]
20010c9e:	2200      	movs	r2, #0
20010ca0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterTxCpltCallback(hi2c);
20010ca4:	6878      	ldr	r0, [r7, #4]
20010ca6:	f7ff f814 	bl	2000fcd2 <HAL_I2C_MasterTxCpltCallback>
}
20010caa:	e029      	b.n	20010d00 <I2C_ITMasterCplt+0x180>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
20010cac:	687b      	ldr	r3, [r7, #4]
20010cae:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010cb2:	b2db      	uxtb	r3, r3
20010cb4:	2b22      	cmp	r3, #34	; 0x22
20010cb6:	d123      	bne.n	20010d00 <I2C_ITMasterCplt+0x180>
    hi2c->State = HAL_I2C_STATE_READY;
20010cb8:	687b      	ldr	r3, [r7, #4]
20010cba:	2220      	movs	r2, #32
20010cbc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
20010cc0:	687b      	ldr	r3, [r7, #4]
20010cc2:	2200      	movs	r2, #0
20010cc4:	631a      	str	r2, [r3, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
20010cc6:	687b      	ldr	r3, [r7, #4]
20010cc8:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
20010ccc:	b2db      	uxtb	r3, r3
20010cce:	2b40      	cmp	r3, #64	; 0x40
20010cd0:	d10b      	bne.n	20010cea <I2C_ITMasterCplt+0x16a>
      hi2c->Mode = HAL_I2C_MODE_NONE;
20010cd2:	687b      	ldr	r3, [r7, #4]
20010cd4:	2200      	movs	r2, #0
20010cd6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
20010cda:	687b      	ldr	r3, [r7, #4]
20010cdc:	2200      	movs	r2, #0
20010cde:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemRxCpltCallback(hi2c);
20010ce2:	6878      	ldr	r0, [r7, #4]
20010ce4:	f7ff f83f 	bl	2000fd66 <HAL_I2C_MemRxCpltCallback>
}
20010ce8:	e00a      	b.n	20010d00 <I2C_ITMasterCplt+0x180>
      hi2c->Mode = HAL_I2C_MODE_NONE;
20010cea:	687b      	ldr	r3, [r7, #4]
20010cec:	2200      	movs	r2, #0
20010cee:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
20010cf2:	687b      	ldr	r3, [r7, #4]
20010cf4:	2200      	movs	r2, #0
20010cf6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterRxCpltCallback(hi2c);
20010cfa:	6878      	ldr	r0, [r7, #4]
20010cfc:	f7fe fff3 	bl	2000fce6 <HAL_I2C_MasterRxCpltCallback>
}
20010d00:	bf00      	nop
20010d02:	3718      	adds	r7, #24
20010d04:	46bd      	mov	sp, r7
20010d06:	bd80      	pop	{r7, pc}
20010d08:	fe00e800 	.word	0xfe00e800
20010d0c:	ffff0000 	.word	0xffff0000

20010d10 <I2C_ITSlaveCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
20010d10:	b580      	push	{r7, lr}
20010d12:	b086      	sub	sp, #24
20010d14:	af00      	add	r7, sp, #0
20010d16:	6078      	str	r0, [r7, #4]
20010d18:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
20010d1a:	687b      	ldr	r3, [r7, #4]
20010d1c:	681b      	ldr	r3, [r3, #0]
20010d1e:	681b      	ldr	r3, [r3, #0]
20010d20:	613b      	str	r3, [r7, #16]
  uint32_t tmpITFlags = ITFlags;
20010d22:	683b      	ldr	r3, [r7, #0]
20010d24:	617b      	str	r3, [r7, #20]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
20010d26:	687b      	ldr	r3, [r7, #4]
20010d28:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20010d2c:	73fb      	strb	r3, [r7, #15]

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
20010d2e:	687b      	ldr	r3, [r7, #4]
20010d30:	681b      	ldr	r3, [r3, #0]
20010d32:	2220      	movs	r2, #32
20010d34:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
20010d36:	7bfb      	ldrb	r3, [r7, #15]
20010d38:	2b21      	cmp	r3, #33	; 0x21
20010d3a:	d002      	beq.n	20010d42 <I2C_ITSlaveCplt+0x32>
20010d3c:	7bfb      	ldrb	r3, [r7, #15]
20010d3e:	2b29      	cmp	r3, #41	; 0x29
20010d40:	d108      	bne.n	20010d54 <I2C_ITSlaveCplt+0x44>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
20010d42:	f248 0101 	movw	r1, #32769	; 0x8001
20010d46:	6878      	ldr	r0, [r7, #4]
20010d48:	f001 f874 	bl	20011e34 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
20010d4c:	687b      	ldr	r3, [r7, #4]
20010d4e:	2221      	movs	r2, #33	; 0x21
20010d50:	631a      	str	r2, [r3, #48]	; 0x30
20010d52:	e00d      	b.n	20010d70 <I2C_ITSlaveCplt+0x60>
  }
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
20010d54:	7bfb      	ldrb	r3, [r7, #15]
20010d56:	2b22      	cmp	r3, #34	; 0x22
20010d58:	d002      	beq.n	20010d60 <I2C_ITSlaveCplt+0x50>
20010d5a:	7bfb      	ldrb	r3, [r7, #15]
20010d5c:	2b2a      	cmp	r3, #42	; 0x2a
20010d5e:	d107      	bne.n	20010d70 <I2C_ITSlaveCplt+0x60>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
20010d60:	f248 0102 	movw	r1, #32770	; 0x8002
20010d64:	6878      	ldr	r0, [r7, #4]
20010d66:	f001 f865 	bl	20011e34 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
20010d6a:	687b      	ldr	r3, [r7, #4]
20010d6c:	2222      	movs	r2, #34	; 0x22
20010d6e:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
20010d70:	687b      	ldr	r3, [r7, #4]
20010d72:	681b      	ldr	r3, [r3, #0]
20010d74:	685a      	ldr	r2, [r3, #4]
20010d76:	687b      	ldr	r3, [r7, #4]
20010d78:	681b      	ldr	r3, [r3, #0]
20010d7a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20010d7e:	605a      	str	r2, [r3, #4]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
20010d80:	687b      	ldr	r3, [r7, #4]
20010d82:	681b      	ldr	r3, [r3, #0]
20010d84:	6859      	ldr	r1, [r3, #4]
20010d86:	687b      	ldr	r3, [r7, #4]
20010d88:	681a      	ldr	r2, [r3, #0]
20010d8a:	4b80      	ldr	r3, [pc, #512]	; (20010f8c <I2C_ITSlaveCplt+0x27c>)
20010d8c:	400b      	ands	r3, r1
20010d8e:	6053      	str	r3, [r2, #4]

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
20010d90:	6878      	ldr	r0, [r7, #4]
20010d92:	f000 fb02 	bl	2001139a <I2C_Flush_TXDR>

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
20010d96:	693b      	ldr	r3, [r7, #16]
20010d98:	0b9b      	lsrs	r3, r3, #14
20010d9a:	f003 0301 	and.w	r3, r3, #1
20010d9e:	2b00      	cmp	r3, #0
20010da0:	d07a      	beq.n	20010e98 <I2C_ITSlaveCplt+0x188>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
20010da2:	687b      	ldr	r3, [r7, #4]
20010da4:	681b      	ldr	r3, [r3, #0]
20010da6:	681a      	ldr	r2, [r3, #0]
20010da8:	687b      	ldr	r3, [r7, #4]
20010daa:	681b      	ldr	r3, [r3, #0]
20010dac:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
20010db0:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmatx != NULL)
20010db2:	687b      	ldr	r3, [r7, #4]
20010db4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010db6:	2b00      	cmp	r3, #0
20010db8:	f000 8111 	beq.w	20010fde <I2C_ITSlaveCplt+0x2ce>
    {
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmatx);
20010dbc:	687b      	ldr	r3, [r7, #4]
20010dbe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010dc0:	681b      	ldr	r3, [r3, #0]
20010dc2:	4a73      	ldr	r2, [pc, #460]	; (20010f90 <I2C_ITSlaveCplt+0x280>)
20010dc4:	4293      	cmp	r3, r2
20010dc6:	d059      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010dc8:	687b      	ldr	r3, [r7, #4]
20010dca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010dcc:	681b      	ldr	r3, [r3, #0]
20010dce:	4a71      	ldr	r2, [pc, #452]	; (20010f94 <I2C_ITSlaveCplt+0x284>)
20010dd0:	4293      	cmp	r3, r2
20010dd2:	d053      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010dd4:	687b      	ldr	r3, [r7, #4]
20010dd6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010dd8:	681b      	ldr	r3, [r3, #0]
20010dda:	4a6f      	ldr	r2, [pc, #444]	; (20010f98 <I2C_ITSlaveCplt+0x288>)
20010ddc:	4293      	cmp	r3, r2
20010dde:	d04d      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010de0:	687b      	ldr	r3, [r7, #4]
20010de2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010de4:	681b      	ldr	r3, [r3, #0]
20010de6:	4a6d      	ldr	r2, [pc, #436]	; (20010f9c <I2C_ITSlaveCplt+0x28c>)
20010de8:	4293      	cmp	r3, r2
20010dea:	d047      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010dec:	687b      	ldr	r3, [r7, #4]
20010dee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010df0:	681b      	ldr	r3, [r3, #0]
20010df2:	4a6b      	ldr	r2, [pc, #428]	; (20010fa0 <I2C_ITSlaveCplt+0x290>)
20010df4:	4293      	cmp	r3, r2
20010df6:	d041      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010df8:	687b      	ldr	r3, [r7, #4]
20010dfa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010dfc:	681b      	ldr	r3, [r3, #0]
20010dfe:	4a69      	ldr	r2, [pc, #420]	; (20010fa4 <I2C_ITSlaveCplt+0x294>)
20010e00:	4293      	cmp	r3, r2
20010e02:	d03b      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010e04:	687b      	ldr	r3, [r7, #4]
20010e06:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e08:	681b      	ldr	r3, [r3, #0]
20010e0a:	4a67      	ldr	r2, [pc, #412]	; (20010fa8 <I2C_ITSlaveCplt+0x298>)
20010e0c:	4293      	cmp	r3, r2
20010e0e:	d035      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010e10:	687b      	ldr	r3, [r7, #4]
20010e12:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e14:	681b      	ldr	r3, [r3, #0]
20010e16:	4a65      	ldr	r2, [pc, #404]	; (20010fac <I2C_ITSlaveCplt+0x29c>)
20010e18:	4293      	cmp	r3, r2
20010e1a:	d02f      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010e1c:	687b      	ldr	r3, [r7, #4]
20010e1e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e20:	681b      	ldr	r3, [r3, #0]
20010e22:	4a63      	ldr	r2, [pc, #396]	; (20010fb0 <I2C_ITSlaveCplt+0x2a0>)
20010e24:	4293      	cmp	r3, r2
20010e26:	d029      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010e28:	687b      	ldr	r3, [r7, #4]
20010e2a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e2c:	681b      	ldr	r3, [r3, #0]
20010e2e:	4a61      	ldr	r2, [pc, #388]	; (20010fb4 <I2C_ITSlaveCplt+0x2a4>)
20010e30:	4293      	cmp	r3, r2
20010e32:	d023      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010e34:	687b      	ldr	r3, [r7, #4]
20010e36:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e38:	681b      	ldr	r3, [r3, #0]
20010e3a:	4a5f      	ldr	r2, [pc, #380]	; (20010fb8 <I2C_ITSlaveCplt+0x2a8>)
20010e3c:	4293      	cmp	r3, r2
20010e3e:	d01d      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010e40:	687b      	ldr	r3, [r7, #4]
20010e42:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e44:	681b      	ldr	r3, [r3, #0]
20010e46:	4a5d      	ldr	r2, [pc, #372]	; (20010fbc <I2C_ITSlaveCplt+0x2ac>)
20010e48:	4293      	cmp	r3, r2
20010e4a:	d017      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010e4c:	687b      	ldr	r3, [r7, #4]
20010e4e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e50:	681b      	ldr	r3, [r3, #0]
20010e52:	4a5b      	ldr	r2, [pc, #364]	; (20010fc0 <I2C_ITSlaveCplt+0x2b0>)
20010e54:	4293      	cmp	r3, r2
20010e56:	d011      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010e58:	687b      	ldr	r3, [r7, #4]
20010e5a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e5c:	681b      	ldr	r3, [r3, #0]
20010e5e:	4a59      	ldr	r2, [pc, #356]	; (20010fc4 <I2C_ITSlaveCplt+0x2b4>)
20010e60:	4293      	cmp	r3, r2
20010e62:	d00b      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010e64:	687b      	ldr	r3, [r7, #4]
20010e66:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e68:	681b      	ldr	r3, [r3, #0]
20010e6a:	4a57      	ldr	r2, [pc, #348]	; (20010fc8 <I2C_ITSlaveCplt+0x2b8>)
20010e6c:	4293      	cmp	r3, r2
20010e6e:	d005      	beq.n	20010e7c <I2C_ITSlaveCplt+0x16c>
20010e70:	687b      	ldr	r3, [r7, #4]
20010e72:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e74:	681b      	ldr	r3, [r3, #0]
20010e76:	4a55      	ldr	r2, [pc, #340]	; (20010fcc <I2C_ITSlaveCplt+0x2bc>)
20010e78:	4293      	cmp	r3, r2
20010e7a:	d105      	bne.n	20010e88 <I2C_ITSlaveCplt+0x178>
20010e7c:	687b      	ldr	r3, [r7, #4]
20010e7e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e80:	681b      	ldr	r3, [r3, #0]
20010e82:	685b      	ldr	r3, [r3, #4]
20010e84:	b29b      	uxth	r3, r3
20010e86:	e004      	b.n	20010e92 <I2C_ITSlaveCplt+0x182>
20010e88:	687b      	ldr	r3, [r7, #4]
20010e8a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20010e8c:	681b      	ldr	r3, [r3, #0]
20010e8e:	685b      	ldr	r3, [r3, #4]
20010e90:	b29b      	uxth	r3, r3
20010e92:	687a      	ldr	r2, [r7, #4]
20010e94:	8553      	strh	r3, [r2, #42]	; 0x2a
20010e96:	e0a2      	b.n	20010fde <I2C_ITSlaveCplt+0x2ce>
    }
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
20010e98:	693b      	ldr	r3, [r7, #16]
20010e9a:	0bdb      	lsrs	r3, r3, #15
20010e9c:	f003 0301 	and.w	r3, r3, #1
20010ea0:	2b00      	cmp	r3, #0
20010ea2:	f000 809c 	beq.w	20010fde <I2C_ITSlaveCplt+0x2ce>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
20010ea6:	687b      	ldr	r3, [r7, #4]
20010ea8:	681b      	ldr	r3, [r3, #0]
20010eaa:	681a      	ldr	r2, [r3, #0]
20010eac:	687b      	ldr	r3, [r7, #4]
20010eae:	681b      	ldr	r3, [r3, #0]
20010eb0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20010eb4:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmarx != NULL)
20010eb6:	687b      	ldr	r3, [r7, #4]
20010eb8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010eba:	2b00      	cmp	r3, #0
20010ebc:	f000 808f 	beq.w	20010fde <I2C_ITSlaveCplt+0x2ce>
    {
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
20010ec0:	687b      	ldr	r3, [r7, #4]
20010ec2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010ec4:	681b      	ldr	r3, [r3, #0]
20010ec6:	4a32      	ldr	r2, [pc, #200]	; (20010f90 <I2C_ITSlaveCplt+0x280>)
20010ec8:	4293      	cmp	r3, r2
20010eca:	d059      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010ecc:	687b      	ldr	r3, [r7, #4]
20010ece:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010ed0:	681b      	ldr	r3, [r3, #0]
20010ed2:	4a30      	ldr	r2, [pc, #192]	; (20010f94 <I2C_ITSlaveCplt+0x284>)
20010ed4:	4293      	cmp	r3, r2
20010ed6:	d053      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010ed8:	687b      	ldr	r3, [r7, #4]
20010eda:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010edc:	681b      	ldr	r3, [r3, #0]
20010ede:	4a2e      	ldr	r2, [pc, #184]	; (20010f98 <I2C_ITSlaveCplt+0x288>)
20010ee0:	4293      	cmp	r3, r2
20010ee2:	d04d      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010ee4:	687b      	ldr	r3, [r7, #4]
20010ee6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010ee8:	681b      	ldr	r3, [r3, #0]
20010eea:	4a2c      	ldr	r2, [pc, #176]	; (20010f9c <I2C_ITSlaveCplt+0x28c>)
20010eec:	4293      	cmp	r3, r2
20010eee:	d047      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010ef0:	687b      	ldr	r3, [r7, #4]
20010ef2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010ef4:	681b      	ldr	r3, [r3, #0]
20010ef6:	4a2a      	ldr	r2, [pc, #168]	; (20010fa0 <I2C_ITSlaveCplt+0x290>)
20010ef8:	4293      	cmp	r3, r2
20010efa:	d041      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010efc:	687b      	ldr	r3, [r7, #4]
20010efe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f00:	681b      	ldr	r3, [r3, #0]
20010f02:	4a28      	ldr	r2, [pc, #160]	; (20010fa4 <I2C_ITSlaveCplt+0x294>)
20010f04:	4293      	cmp	r3, r2
20010f06:	d03b      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010f08:	687b      	ldr	r3, [r7, #4]
20010f0a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f0c:	681b      	ldr	r3, [r3, #0]
20010f0e:	4a26      	ldr	r2, [pc, #152]	; (20010fa8 <I2C_ITSlaveCplt+0x298>)
20010f10:	4293      	cmp	r3, r2
20010f12:	d035      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010f14:	687b      	ldr	r3, [r7, #4]
20010f16:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f18:	681b      	ldr	r3, [r3, #0]
20010f1a:	4a24      	ldr	r2, [pc, #144]	; (20010fac <I2C_ITSlaveCplt+0x29c>)
20010f1c:	4293      	cmp	r3, r2
20010f1e:	d02f      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010f20:	687b      	ldr	r3, [r7, #4]
20010f22:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f24:	681b      	ldr	r3, [r3, #0]
20010f26:	4a22      	ldr	r2, [pc, #136]	; (20010fb0 <I2C_ITSlaveCplt+0x2a0>)
20010f28:	4293      	cmp	r3, r2
20010f2a:	d029      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010f2c:	687b      	ldr	r3, [r7, #4]
20010f2e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f30:	681b      	ldr	r3, [r3, #0]
20010f32:	4a20      	ldr	r2, [pc, #128]	; (20010fb4 <I2C_ITSlaveCplt+0x2a4>)
20010f34:	4293      	cmp	r3, r2
20010f36:	d023      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010f38:	687b      	ldr	r3, [r7, #4]
20010f3a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f3c:	681b      	ldr	r3, [r3, #0]
20010f3e:	4a1e      	ldr	r2, [pc, #120]	; (20010fb8 <I2C_ITSlaveCplt+0x2a8>)
20010f40:	4293      	cmp	r3, r2
20010f42:	d01d      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010f44:	687b      	ldr	r3, [r7, #4]
20010f46:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f48:	681b      	ldr	r3, [r3, #0]
20010f4a:	4a1c      	ldr	r2, [pc, #112]	; (20010fbc <I2C_ITSlaveCplt+0x2ac>)
20010f4c:	4293      	cmp	r3, r2
20010f4e:	d017      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010f50:	687b      	ldr	r3, [r7, #4]
20010f52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f54:	681b      	ldr	r3, [r3, #0]
20010f56:	4a1a      	ldr	r2, [pc, #104]	; (20010fc0 <I2C_ITSlaveCplt+0x2b0>)
20010f58:	4293      	cmp	r3, r2
20010f5a:	d011      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010f5c:	687b      	ldr	r3, [r7, #4]
20010f5e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f60:	681b      	ldr	r3, [r3, #0]
20010f62:	4a18      	ldr	r2, [pc, #96]	; (20010fc4 <I2C_ITSlaveCplt+0x2b4>)
20010f64:	4293      	cmp	r3, r2
20010f66:	d00b      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010f68:	687b      	ldr	r3, [r7, #4]
20010f6a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f6c:	681b      	ldr	r3, [r3, #0]
20010f6e:	4a16      	ldr	r2, [pc, #88]	; (20010fc8 <I2C_ITSlaveCplt+0x2b8>)
20010f70:	4293      	cmp	r3, r2
20010f72:	d005      	beq.n	20010f80 <I2C_ITSlaveCplt+0x270>
20010f74:	687b      	ldr	r3, [r7, #4]
20010f76:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f78:	681b      	ldr	r3, [r3, #0]
20010f7a:	4a14      	ldr	r2, [pc, #80]	; (20010fcc <I2C_ITSlaveCplt+0x2bc>)
20010f7c:	4293      	cmp	r3, r2
20010f7e:	d127      	bne.n	20010fd0 <I2C_ITSlaveCplt+0x2c0>
20010f80:	687b      	ldr	r3, [r7, #4]
20010f82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010f84:	681b      	ldr	r3, [r3, #0]
20010f86:	685b      	ldr	r3, [r3, #4]
20010f88:	b29b      	uxth	r3, r3
20010f8a:	e026      	b.n	20010fda <I2C_ITSlaveCplt+0x2ca>
20010f8c:	fe00e800 	.word	0xfe00e800
20010f90:	40020010 	.word	0x40020010
20010f94:	40020028 	.word	0x40020028
20010f98:	40020040 	.word	0x40020040
20010f9c:	40020058 	.word	0x40020058
20010fa0:	40020070 	.word	0x40020070
20010fa4:	40020088 	.word	0x40020088
20010fa8:	400200a0 	.word	0x400200a0
20010fac:	400200b8 	.word	0x400200b8
20010fb0:	40020410 	.word	0x40020410
20010fb4:	40020428 	.word	0x40020428
20010fb8:	40020440 	.word	0x40020440
20010fbc:	40020458 	.word	0x40020458
20010fc0:	40020470 	.word	0x40020470
20010fc4:	40020488 	.word	0x40020488
20010fc8:	400204a0 	.word	0x400204a0
20010fcc:	400204b8 	.word	0x400204b8
20010fd0:	687b      	ldr	r3, [r7, #4]
20010fd2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20010fd4:	681b      	ldr	r3, [r3, #0]
20010fd6:	685b      	ldr	r3, [r3, #4]
20010fd8:	b29b      	uxth	r3, r3
20010fda:	687a      	ldr	r2, [r7, #4]
20010fdc:	8553      	strh	r3, [r2, #42]	; 0x2a
  {
    /* Do nothing */
  }

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
20010fde:	697b      	ldr	r3, [r7, #20]
20010fe0:	089b      	lsrs	r3, r3, #2
20010fe2:	f003 0301 	and.w	r3, r3, #1
20010fe6:	2b00      	cmp	r3, #0
20010fe8:	d020      	beq.n	2001102c <I2C_ITSlaveCplt+0x31c>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
20010fea:	697b      	ldr	r3, [r7, #20]
20010fec:	f023 0304 	bic.w	r3, r3, #4
20010ff0:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
20010ff2:	687b      	ldr	r3, [r7, #4]
20010ff4:	681b      	ldr	r3, [r3, #0]
20010ff6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20010ff8:	687b      	ldr	r3, [r7, #4]
20010ffa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20010ffc:	b2d2      	uxtb	r2, r2
20010ffe:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
20011000:	687b      	ldr	r3, [r7, #4]
20011002:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20011004:	1c5a      	adds	r2, r3, #1
20011006:	687b      	ldr	r3, [r7, #4]
20011008:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
2001100a:	687b      	ldr	r3, [r7, #4]
2001100c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2001100e:	2b00      	cmp	r3, #0
20011010:	d00c      	beq.n	2001102c <I2C_ITSlaveCplt+0x31c>
    {
      hi2c->XferSize--;
20011012:	687b      	ldr	r3, [r7, #4]
20011014:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20011016:	3b01      	subs	r3, #1
20011018:	b29a      	uxth	r2, r3
2001101a:	687b      	ldr	r3, [r7, #4]
2001101c:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2001101e:	687b      	ldr	r3, [r7, #4]
20011020:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20011022:	b29b      	uxth	r3, r3
20011024:	3b01      	subs	r3, #1
20011026:	b29a      	uxth	r2, r3
20011028:	687b      	ldr	r3, [r7, #4]
2001102a:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
2001102c:	687b      	ldr	r3, [r7, #4]
2001102e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20011030:	b29b      	uxth	r3, r3
20011032:	2b00      	cmp	r3, #0
20011034:	d005      	beq.n	20011042 <I2C_ITSlaveCplt+0x332>
  {
    /* Set ErrorCode corresponding to a Non-Acknowledge */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
20011036:	687b      	ldr	r3, [r7, #4]
20011038:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2001103a:	f043 0204 	orr.w	r2, r3, #4
2001103e:	687b      	ldr	r3, [r7, #4]
20011040:	645a      	str	r2, [r3, #68]	; 0x44
  }

  hi2c->Mode = HAL_I2C_MODE_NONE;
20011042:	687b      	ldr	r3, [r7, #4]
20011044:	2200      	movs	r2, #0
20011046:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
2001104a:	687b      	ldr	r3, [r7, #4]
2001104c:	2200      	movs	r2, #0
2001104e:	635a      	str	r2, [r3, #52]	; 0x34

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
20011050:	687b      	ldr	r3, [r7, #4]
20011052:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20011054:	2b00      	cmp	r3, #0
20011056:	d010      	beq.n	2001107a <I2C_ITSlaveCplt+0x36a>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
20011058:	687b      	ldr	r3, [r7, #4]
2001105a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2001105c:	4619      	mov	r1, r3
2001105e:	6878      	ldr	r0, [r7, #4]
20011060:	f000 f8a4 	bl	200111ac <I2C_ITError>

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
20011064:	687b      	ldr	r3, [r7, #4]
20011066:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2001106a:	b2db      	uxtb	r3, r3
2001106c:	2b28      	cmp	r3, #40	; 0x28
2001106e:	d141      	bne.n	200110f4 <I2C_ITSlaveCplt+0x3e4>
    {
      /* Call I2C Listen complete process */
      I2C_ITListenCplt(hi2c, tmpITFlags);
20011070:	6979      	ldr	r1, [r7, #20]
20011072:	6878      	ldr	r0, [r7, #4]
20011074:	f000 f844 	bl	20011100 <I2C_ITListenCplt>
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
20011078:	e03c      	b.n	200110f4 <I2C_ITSlaveCplt+0x3e4>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2001107a:	687b      	ldr	r3, [r7, #4]
2001107c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001107e:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
20011082:	d014      	beq.n	200110ae <I2C_ITSlaveCplt+0x39e>
    I2C_ITSlaveSeqCplt(hi2c);
20011084:	6878      	ldr	r0, [r7, #4]
20011086:	f7ff fd1c 	bl	20010ac2 <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2001108a:	687b      	ldr	r3, [r7, #4]
2001108c:	4a1b      	ldr	r2, [pc, #108]	; (200110fc <I2C_ITSlaveCplt+0x3ec>)
2001108e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
20011090:	687b      	ldr	r3, [r7, #4]
20011092:	2220      	movs	r2, #32
20011094:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
20011098:	687b      	ldr	r3, [r7, #4]
2001109a:	2200      	movs	r2, #0
2001109c:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2001109e:	687b      	ldr	r3, [r7, #4]
200110a0:	2200      	movs	r2, #0
200110a2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ListenCpltCallback(hi2c);
200110a6:	6878      	ldr	r0, [r7, #4]
200110a8:	f7fe fe49 	bl	2000fd3e <HAL_I2C_ListenCpltCallback>
}
200110ac:	e022      	b.n	200110f4 <I2C_ITSlaveCplt+0x3e4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
200110ae:	687b      	ldr	r3, [r7, #4]
200110b0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200110b4:	b2db      	uxtb	r3, r3
200110b6:	2b22      	cmp	r3, #34	; 0x22
200110b8:	d10e      	bne.n	200110d8 <I2C_ITSlaveCplt+0x3c8>
    hi2c->State = HAL_I2C_STATE_READY;
200110ba:	687b      	ldr	r3, [r7, #4]
200110bc:	2220      	movs	r2, #32
200110be:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
200110c2:	687b      	ldr	r3, [r7, #4]
200110c4:	2200      	movs	r2, #0
200110c6:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
200110c8:	687b      	ldr	r3, [r7, #4]
200110ca:	2200      	movs	r2, #0
200110cc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
200110d0:	6878      	ldr	r0, [r7, #4]
200110d2:	f7fe fe1c 	bl	2000fd0e <HAL_I2C_SlaveRxCpltCallback>
}
200110d6:	e00d      	b.n	200110f4 <I2C_ITSlaveCplt+0x3e4>
    hi2c->State = HAL_I2C_STATE_READY;
200110d8:	687b      	ldr	r3, [r7, #4]
200110da:	2220      	movs	r2, #32
200110dc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
200110e0:	687b      	ldr	r3, [r7, #4]
200110e2:	2200      	movs	r2, #0
200110e4:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
200110e6:	687b      	ldr	r3, [r7, #4]
200110e8:	2200      	movs	r2, #0
200110ea:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
200110ee:	6878      	ldr	r0, [r7, #4]
200110f0:	f7fe fe03 	bl	2000fcfa <HAL_I2C_SlaveTxCpltCallback>
}
200110f4:	bf00      	nop
200110f6:	3718      	adds	r7, #24
200110f8:	46bd      	mov	sp, r7
200110fa:	bd80      	pop	{r7, pc}
200110fc:	ffff0000 	.word	0xffff0000

20011100 <I2C_ITListenCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
20011100:	b580      	push	{r7, lr}
20011102:	b082      	sub	sp, #8
20011104:	af00      	add	r7, sp, #0
20011106:	6078      	str	r0, [r7, #4]
20011108:	6039      	str	r1, [r7, #0]
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2001110a:	687b      	ldr	r3, [r7, #4]
2001110c:	4a26      	ldr	r2, [pc, #152]	; (200111a8 <I2C_ITListenCplt+0xa8>)
2001110e:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
20011110:	687b      	ldr	r3, [r7, #4]
20011112:	2200      	movs	r2, #0
20011114:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
20011116:	687b      	ldr	r3, [r7, #4]
20011118:	2220      	movs	r2, #32
2001111a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
2001111e:	687b      	ldr	r3, [r7, #4]
20011120:	2200      	movs	r2, #0
20011122:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
20011126:	687b      	ldr	r3, [r7, #4]
20011128:	2200      	movs	r2, #0
2001112a:	635a      	str	r2, [r3, #52]	; 0x34

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
2001112c:	683b      	ldr	r3, [r7, #0]
2001112e:	089b      	lsrs	r3, r3, #2
20011130:	f003 0301 	and.w	r3, r3, #1
20011134:	2b00      	cmp	r3, #0
20011136:	d022      	beq.n	2001117e <I2C_ITListenCplt+0x7e>
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
20011138:	687b      	ldr	r3, [r7, #4]
2001113a:	681b      	ldr	r3, [r3, #0]
2001113c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2001113e:	687b      	ldr	r3, [r7, #4]
20011140:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20011142:	b2d2      	uxtb	r2, r2
20011144:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
20011146:	687b      	ldr	r3, [r7, #4]
20011148:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2001114a:	1c5a      	adds	r2, r3, #1
2001114c:	687b      	ldr	r3, [r7, #4]
2001114e:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
20011150:	687b      	ldr	r3, [r7, #4]
20011152:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20011154:	2b00      	cmp	r3, #0
20011156:	d012      	beq.n	2001117e <I2C_ITListenCplt+0x7e>
    {
      hi2c->XferSize--;
20011158:	687b      	ldr	r3, [r7, #4]
2001115a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2001115c:	3b01      	subs	r3, #1
2001115e:	b29a      	uxth	r2, r3
20011160:	687b      	ldr	r3, [r7, #4]
20011162:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
20011164:	687b      	ldr	r3, [r7, #4]
20011166:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20011168:	b29b      	uxth	r3, r3
2001116a:	3b01      	subs	r3, #1
2001116c:	b29a      	uxth	r2, r3
2001116e:	687b      	ldr	r3, [r7, #4]
20011170:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
20011172:	687b      	ldr	r3, [r7, #4]
20011174:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20011176:	f043 0204 	orr.w	r2, r3, #4
2001117a:	687b      	ldr	r3, [r7, #4]
2001117c:	645a      	str	r2, [r3, #68]	; 0x44
    }
  }

  /* Disable all Interrupts*/
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2001117e:	f248 0103 	movw	r1, #32771	; 0x8003
20011182:	6878      	ldr	r0, [r7, #4]
20011184:	f000 fe56 	bl	20011e34 <I2C_Disable_IRQ>

  /* Clear NACK Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20011188:	687b      	ldr	r3, [r7, #4]
2001118a:	681b      	ldr	r3, [r3, #0]
2001118c:	2210      	movs	r2, #16
2001118e:	61da      	str	r2, [r3, #28]

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
20011190:	687b      	ldr	r3, [r7, #4]
20011192:	2200      	movs	r2, #0
20011194:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
  hi2c->ListenCpltCallback(hi2c);
#else
  HAL_I2C_ListenCpltCallback(hi2c);
20011198:	6878      	ldr	r0, [r7, #4]
2001119a:	f7fe fdd0 	bl	2000fd3e <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
}
2001119e:	bf00      	nop
200111a0:	3708      	adds	r7, #8
200111a2:	46bd      	mov	sp, r7
200111a4:	bd80      	pop	{r7, pc}
200111a6:	bf00      	nop
200111a8:	ffff0000 	.word	0xffff0000

200111ac <I2C_ITError>:
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
{
200111ac:	b580      	push	{r7, lr}
200111ae:	b084      	sub	sp, #16
200111b0:	af00      	add	r7, sp, #0
200111b2:	6078      	str	r0, [r7, #4]
200111b4:	6039      	str	r1, [r7, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
200111b6:	687b      	ldr	r3, [r7, #4]
200111b8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200111bc:	73fb      	strb	r3, [r7, #15]
  uint32_t tmppreviousstate;

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
200111be:	687b      	ldr	r3, [r7, #4]
200111c0:	2200      	movs	r2, #0
200111c2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
200111c6:	687b      	ldr	r3, [r7, #4]
200111c8:	4a5d      	ldr	r2, [pc, #372]	; (20011340 <I2C_ITError+0x194>)
200111ca:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->XferCount     = 0U;
200111cc:	687b      	ldr	r3, [r7, #4]
200111ce:	2200      	movs	r2, #0
200111d0:	855a      	strh	r2, [r3, #42]	; 0x2a

  /* Set new error code */
  hi2c->ErrorCode |= ErrorCode;
200111d2:	687b      	ldr	r3, [r7, #4]
200111d4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
200111d6:	683b      	ldr	r3, [r7, #0]
200111d8:	431a      	orrs	r2, r3
200111da:	687b      	ldr	r3, [r7, #4]
200111dc:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable Interrupts */
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
200111de:	7bfb      	ldrb	r3, [r7, #15]
200111e0:	2b28      	cmp	r3, #40	; 0x28
200111e2:	d005      	beq.n	200111f0 <I2C_ITError+0x44>
200111e4:	7bfb      	ldrb	r3, [r7, #15]
200111e6:	2b29      	cmp	r3, #41	; 0x29
200111e8:	d002      	beq.n	200111f0 <I2C_ITError+0x44>
      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
200111ea:	7bfb      	ldrb	r3, [r7, #15]
200111ec:	2b2a      	cmp	r3, #42	; 0x2a
200111ee:	d10b      	bne.n	20011208 <I2C_ITError+0x5c>
      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
  {
    /* Disable all interrupts, except interrupts related to LISTEN state */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
200111f0:	2103      	movs	r1, #3
200111f2:	6878      	ldr	r0, [r7, #4]
200111f4:	f000 fe1e 	bl	20011e34 <I2C_Disable_IRQ>

    /* keep HAL_I2C_STATE_LISTEN if set */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
200111f8:	687b      	ldr	r3, [r7, #4]
200111fa:	2228      	movs	r2, #40	; 0x28
200111fc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
20011200:	687b      	ldr	r3, [r7, #4]
20011202:	4a50      	ldr	r2, [pc, #320]	; (20011344 <I2C_ITError+0x198>)
20011204:	635a      	str	r2, [r3, #52]	; 0x34
20011206:	e011      	b.n	2001122c <I2C_ITError+0x80>
  }
  else
  {
    /* Disable all interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
20011208:	f248 0103 	movw	r1, #32771	; 0x8003
2001120c:	6878      	ldr	r0, [r7, #4]
2001120e:	f000 fe11 	bl	20011e34 <I2C_Disable_IRQ>

    /* If state is an abort treatment on goind, don't change state */
    /* This change will be do later */
    if (hi2c->State != HAL_I2C_STATE_ABORT)
20011212:	687b      	ldr	r3, [r7, #4]
20011214:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20011218:	b2db      	uxtb	r3, r3
2001121a:	2b60      	cmp	r3, #96	; 0x60
2001121c:	d003      	beq.n	20011226 <I2C_ITError+0x7a>
    {
      /* Set HAL_I2C_STATE_READY */
      hi2c->State         = HAL_I2C_STATE_READY;
2001121e:	687b      	ldr	r3, [r7, #4]
20011220:	2220      	movs	r2, #32
20011222:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
    hi2c->XferISR       = NULL;
20011226:	687b      	ldr	r3, [r7, #4]
20011228:	2200      	movs	r2, #0
2001122a:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Abort DMA TX transfer if any */
  tmppreviousstate = hi2c->PreviousState;
2001122c:	687b      	ldr	r3, [r7, #4]
2001122e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20011230:	60bb      	str	r3, [r7, #8]
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
20011232:	687b      	ldr	r3, [r7, #4]
20011234:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011236:	2b00      	cmp	r3, #0
20011238:	d039      	beq.n	200112ae <I2C_ITError+0x102>
2001123a:	68bb      	ldr	r3, [r7, #8]
2001123c:	2b11      	cmp	r3, #17
2001123e:	d002      	beq.n	20011246 <I2C_ITError+0x9a>
20011240:	68bb      	ldr	r3, [r7, #8]
20011242:	2b21      	cmp	r3, #33	; 0x21
20011244:	d133      	bne.n	200112ae <I2C_ITError+0x102>
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
20011246:	687b      	ldr	r3, [r7, #4]
20011248:	681b      	ldr	r3, [r3, #0]
2001124a:	681b      	ldr	r3, [r3, #0]
2001124c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
20011250:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20011254:	d107      	bne.n	20011266 <I2C_ITError+0xba>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
20011256:	687b      	ldr	r3, [r7, #4]
20011258:	681b      	ldr	r3, [r3, #0]
2001125a:	681a      	ldr	r2, [r3, #0]
2001125c:	687b      	ldr	r3, [r7, #4]
2001125e:	681b      	ldr	r3, [r3, #0]
20011260:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
20011264:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
20011266:	687b      	ldr	r3, [r7, #4]
20011268:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001126a:	4618      	mov	r0, r3
2001126c:	f7f5 fe96 	bl	20006f9c <HAL_DMA_GetState>
20011270:	4603      	mov	r3, r0
20011272:	2b01      	cmp	r3, #1
20011274:	d017      	beq.n	200112a6 <I2C_ITError+0xfa>
    {
      /* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
20011276:	687b      	ldr	r3, [r7, #4]
20011278:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001127a:	4a33      	ldr	r2, [pc, #204]	; (20011348 <I2C_ITError+0x19c>)
2001127c:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2001127e:	687b      	ldr	r3, [r7, #4]
20011280:	2200      	movs	r2, #0
20011282:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA TX */
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
20011286:	687b      	ldr	r3, [r7, #4]
20011288:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001128a:	4618      	mov	r0, r3
2001128c:	f7f4 f8a6 	bl	200053dc <HAL_DMA_Abort_IT>
20011290:	4603      	mov	r3, r0
20011292:	2b00      	cmp	r3, #0
20011294:	d04d      	beq.n	20011332 <I2C_ITError+0x186>
      {
        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
20011296:	687b      	ldr	r3, [r7, #4]
20011298:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001129a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001129c:	687a      	ldr	r2, [r7, #4]
2001129e:	6b92      	ldr	r2, [r2, #56]	; 0x38
200112a0:	4610      	mov	r0, r2
200112a2:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
200112a4:	e045      	b.n	20011332 <I2C_ITError+0x186>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
200112a6:	6878      	ldr	r0, [r7, #4]
200112a8:	f000 f850 	bl	2001134c <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
200112ac:	e041      	b.n	20011332 <I2C_ITError+0x186>
    }
  }
  /* Abort DMA RX transfer if any */
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
200112ae:	687b      	ldr	r3, [r7, #4]
200112b0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200112b2:	2b00      	cmp	r3, #0
200112b4:	d039      	beq.n	2001132a <I2C_ITError+0x17e>
200112b6:	68bb      	ldr	r3, [r7, #8]
200112b8:	2b12      	cmp	r3, #18
200112ba:	d002      	beq.n	200112c2 <I2C_ITError+0x116>
200112bc:	68bb      	ldr	r3, [r7, #8]
200112be:	2b22      	cmp	r3, #34	; 0x22
200112c0:	d133      	bne.n	2001132a <I2C_ITError+0x17e>
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
200112c2:	687b      	ldr	r3, [r7, #4]
200112c4:	681b      	ldr	r3, [r3, #0]
200112c6:	681b      	ldr	r3, [r3, #0]
200112c8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
200112cc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
200112d0:	d107      	bne.n	200112e2 <I2C_ITError+0x136>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
200112d2:	687b      	ldr	r3, [r7, #4]
200112d4:	681b      	ldr	r3, [r3, #0]
200112d6:	681a      	ldr	r2, [r3, #0]
200112d8:	687b      	ldr	r3, [r7, #4]
200112da:	681b      	ldr	r3, [r3, #0]
200112dc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
200112e0:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
200112e2:	687b      	ldr	r3, [r7, #4]
200112e4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200112e6:	4618      	mov	r0, r3
200112e8:	f7f5 fe58 	bl	20006f9c <HAL_DMA_GetState>
200112ec:	4603      	mov	r3, r0
200112ee:	2b01      	cmp	r3, #1
200112f0:	d017      	beq.n	20011322 <I2C_ITError+0x176>
    {
      /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
200112f2:	687b      	ldr	r3, [r7, #4]
200112f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200112f6:	4a14      	ldr	r2, [pc, #80]	; (20011348 <I2C_ITError+0x19c>)
200112f8:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
200112fa:	687b      	ldr	r3, [r7, #4]
200112fc:	2200      	movs	r2, #0
200112fe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA RX */
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
20011302:	687b      	ldr	r3, [r7, #4]
20011304:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011306:	4618      	mov	r0, r3
20011308:	f7f4 f868 	bl	200053dc <HAL_DMA_Abort_IT>
2001130c:	4603      	mov	r3, r0
2001130e:	2b00      	cmp	r3, #0
20011310:	d011      	beq.n	20011336 <I2C_ITError+0x18a>
      {
        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
20011312:	687b      	ldr	r3, [r7, #4]
20011314:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011316:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20011318:	687a      	ldr	r2, [r7, #4]
2001131a:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2001131c:	4610      	mov	r0, r2
2001131e:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
20011320:	e009      	b.n	20011336 <I2C_ITError+0x18a>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
20011322:	6878      	ldr	r0, [r7, #4]
20011324:	f000 f812 	bl	2001134c <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
20011328:	e005      	b.n	20011336 <I2C_ITError+0x18a>
    }
  }
  else
  {
    I2C_TreatErrorCallback(hi2c);
2001132a:	6878      	ldr	r0, [r7, #4]
2001132c:	f000 f80e 	bl	2001134c <I2C_TreatErrorCallback>
  }
}
20011330:	e002      	b.n	20011338 <I2C_ITError+0x18c>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
20011332:	bf00      	nop
20011334:	e000      	b.n	20011338 <I2C_ITError+0x18c>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
20011336:	bf00      	nop
}
20011338:	bf00      	nop
2001133a:	3710      	adds	r7, #16
2001133c:	46bd      	mov	sp, r7
2001133e:	bd80      	pop	{r7, pc}
20011340:	ffff0000 	.word	0xffff0000
20011344:	20010045 	.word	0x20010045
20011348:	20011925 	.word	0x20011925

2001134c <I2C_TreatErrorCallback>:
  * @brief  I2C Error callback treatment.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)
{
2001134c:	b580      	push	{r7, lr}
2001134e:	b082      	sub	sp, #8
20011350:	af00      	add	r7, sp, #0
20011352:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
20011354:	687b      	ldr	r3, [r7, #4]
20011356:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2001135a:	b2db      	uxtb	r3, r3
2001135c:	2b60      	cmp	r3, #96	; 0x60
2001135e:	d10e      	bne.n	2001137e <I2C_TreatErrorCallback+0x32>
  {
    hi2c->State = HAL_I2C_STATE_READY;
20011360:	687b      	ldr	r3, [r7, #4]
20011362:	2220      	movs	r2, #32
20011364:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
20011368:	687b      	ldr	r3, [r7, #4]
2001136a:	2200      	movs	r2, #0
2001136c:	631a      	str	r2, [r3, #48]	; 0x30

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2001136e:	687b      	ldr	r3, [r7, #4]
20011370:	2200      	movs	r2, #0
20011372:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
20011376:	6878      	ldr	r0, [r7, #4]
20011378:	f7fe fd09 	bl	2000fd8e <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2001137c:	e009      	b.n	20011392 <I2C_TreatErrorCallback+0x46>
    hi2c->PreviousState = I2C_STATE_NONE;
2001137e:	687b      	ldr	r3, [r7, #4]
20011380:	2200      	movs	r2, #0
20011382:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
20011384:	687b      	ldr	r3, [r7, #4]
20011386:	2200      	movs	r2, #0
20011388:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
2001138c:	6878      	ldr	r0, [r7, #4]
2001138e:	f7fe fcf4 	bl	2000fd7a <HAL_I2C_ErrorCallback>
}
20011392:	bf00      	nop
20011394:	3708      	adds	r7, #8
20011396:	46bd      	mov	sp, r7
20011398:	bd80      	pop	{r7, pc}

2001139a <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
2001139a:	b480      	push	{r7}
2001139c:	b083      	sub	sp, #12
2001139e:	af00      	add	r7, sp, #0
200113a0:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
200113a2:	687b      	ldr	r3, [r7, #4]
200113a4:	681b      	ldr	r3, [r3, #0]
200113a6:	699b      	ldr	r3, [r3, #24]
200113a8:	f003 0302 	and.w	r3, r3, #2
200113ac:	2b02      	cmp	r3, #2
200113ae:	d103      	bne.n	200113b8 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
200113b0:	687b      	ldr	r3, [r7, #4]
200113b2:	681b      	ldr	r3, [r3, #0]
200113b4:	2200      	movs	r2, #0
200113b6:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
200113b8:	687b      	ldr	r3, [r7, #4]
200113ba:	681b      	ldr	r3, [r3, #0]
200113bc:	699b      	ldr	r3, [r3, #24]
200113be:	f003 0301 	and.w	r3, r3, #1
200113c2:	2b01      	cmp	r3, #1
200113c4:	d007      	beq.n	200113d6 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
200113c6:	687b      	ldr	r3, [r7, #4]
200113c8:	681b      	ldr	r3, [r3, #0]
200113ca:	699a      	ldr	r2, [r3, #24]
200113cc:	687b      	ldr	r3, [r7, #4]
200113ce:	681b      	ldr	r3, [r3, #0]
200113d0:	f042 0201 	orr.w	r2, r2, #1
200113d4:	619a      	str	r2, [r3, #24]
  }
}
200113d6:	bf00      	nop
200113d8:	370c      	adds	r7, #12
200113da:	46bd      	mov	sp, r7
200113dc:	f85d 7b04 	ldr.w	r7, [sp], #4
200113e0:	4770      	bx	lr

200113e2 <I2C_DMAMasterTransmitCplt>:
  * @brief  DMA I2C master transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
{
200113e2:	b580      	push	{r7, lr}
200113e4:	b084      	sub	sp, #16
200113e6:	af00      	add	r7, sp, #0
200113e8:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
200113ea:	687b      	ldr	r3, [r7, #4]
200113ec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200113ee:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
200113f0:	68fb      	ldr	r3, [r7, #12]
200113f2:	681b      	ldr	r3, [r3, #0]
200113f4:	681a      	ldr	r2, [r3, #0]
200113f6:	68fb      	ldr	r3, [r7, #12]
200113f8:	681b      	ldr	r3, [r3, #0]
200113fa:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
200113fe:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
20011400:	68fb      	ldr	r3, [r7, #12]
20011402:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20011404:	b29b      	uxth	r3, r3
20011406:	2b00      	cmp	r3, #0
20011408:	d104      	bne.n	20011414 <I2C_DMAMasterTransmitCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2001140a:	2120      	movs	r1, #32
2001140c:	68f8      	ldr	r0, [r7, #12]
2001140e:	f000 fcad 	bl	20011d6c <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
20011412:	e02d      	b.n	20011470 <I2C_DMAMasterTransmitCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
20011414:	68fb      	ldr	r3, [r7, #12]
20011416:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20011418:	68fa      	ldr	r2, [r7, #12]
2001141a:	8d12      	ldrh	r2, [r2, #40]	; 0x28
2001141c:	441a      	add	r2, r3
2001141e:	68fb      	ldr	r3, [r7, #12]
20011420:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20011422:	68fb      	ldr	r3, [r7, #12]
20011424:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20011426:	b29b      	uxth	r3, r3
20011428:	2bff      	cmp	r3, #255	; 0xff
2001142a:	d903      	bls.n	20011434 <I2C_DMAMasterTransmitCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2001142c:	68fb      	ldr	r3, [r7, #12]
2001142e:	22ff      	movs	r2, #255	; 0xff
20011430:	851a      	strh	r2, [r3, #40]	; 0x28
20011432:	e004      	b.n	2001143e <I2C_DMAMasterTransmitCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
20011434:	68fb      	ldr	r3, [r7, #12]
20011436:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20011438:	b29a      	uxth	r2, r3
2001143a:	68fb      	ldr	r3, [r7, #12]
2001143c:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
2001143e:	68fb      	ldr	r3, [r7, #12]
20011440:	6b98      	ldr	r0, [r3, #56]	; 0x38
20011442:	68fb      	ldr	r3, [r7, #12]
20011444:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20011446:	4619      	mov	r1, r3
20011448:	68fb      	ldr	r3, [r7, #12]
2001144a:	681b      	ldr	r3, [r3, #0]
2001144c:	3328      	adds	r3, #40	; 0x28
2001144e:	461a      	mov	r2, r3
20011450:	68fb      	ldr	r3, [r7, #12]
20011452:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20011454:	f7f3 fa2c 	bl	200048b0 <HAL_DMA_Start_IT>
20011458:	4603      	mov	r3, r0
2001145a:	2b00      	cmp	r3, #0
2001145c:	d004      	beq.n	20011468 <I2C_DMAMasterTransmitCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2001145e:	2110      	movs	r1, #16
20011460:	68f8      	ldr	r0, [r7, #12]
20011462:	f7ff fea3 	bl	200111ac <I2C_ITError>
}
20011466:	e003      	b.n	20011470 <I2C_DMAMasterTransmitCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
20011468:	2140      	movs	r1, #64	; 0x40
2001146a:	68f8      	ldr	r0, [r7, #12]
2001146c:	f000 fc7e 	bl	20011d6c <I2C_Enable_IRQ>
}
20011470:	bf00      	nop
20011472:	3710      	adds	r7, #16
20011474:	46bd      	mov	sp, r7
20011476:	bd80      	pop	{r7, pc}

20011478 <I2C_DMASlaveTransmitCplt>:
  * @brief  DMA I2C slave transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
{
20011478:	b580      	push	{r7, lr}
2001147a:	b084      	sub	sp, #16
2001147c:	af00      	add	r7, sp, #0
2001147e:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
20011480:	687b      	ldr	r3, [r7, #4]
20011482:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011484:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
20011486:	68fb      	ldr	r3, [r7, #12]
20011488:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001148a:	60bb      	str	r3, [r7, #8]

  if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2001148c:	68bb      	ldr	r3, [r7, #8]
2001148e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20011492:	d002      	beq.n	2001149a <I2C_DMASlaveTransmitCplt+0x22>
20011494:	68bb      	ldr	r3, [r7, #8]
20011496:	2b00      	cmp	r3, #0
20011498:	d10a      	bne.n	200114b0 <I2C_DMASlaveTransmitCplt+0x38>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2001149a:	68fb      	ldr	r3, [r7, #12]
2001149c:	681b      	ldr	r3, [r3, #0]
2001149e:	681a      	ldr	r2, [r3, #0]
200114a0:	68fb      	ldr	r3, [r7, #12]
200114a2:	681b      	ldr	r3, [r3, #0]
200114a4:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
200114a8:	601a      	str	r2, [r3, #0]

    /* Last Byte is Transmitted */
    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
200114aa:	68f8      	ldr	r0, [r7, #12]
200114ac:	f7ff fb09 	bl	20010ac2 <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
200114b0:	bf00      	nop
200114b2:	3710      	adds	r7, #16
200114b4:	46bd      	mov	sp, r7
200114b6:	bd80      	pop	{r7, pc}

200114b8 <I2C_DMAMasterReceiveCplt>:
  * @brief DMA I2C master receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
{
200114b8:	b580      	push	{r7, lr}
200114ba:	b084      	sub	sp, #16
200114bc:	af00      	add	r7, sp, #0
200114be:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
200114c0:	687b      	ldr	r3, [r7, #4]
200114c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200114c4:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
200114c6:	68fb      	ldr	r3, [r7, #12]
200114c8:	681b      	ldr	r3, [r3, #0]
200114ca:	681a      	ldr	r2, [r3, #0]
200114cc:	68fb      	ldr	r3, [r7, #12]
200114ce:	681b      	ldr	r3, [r3, #0]
200114d0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
200114d4:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
200114d6:	68fb      	ldr	r3, [r7, #12]
200114d8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200114da:	b29b      	uxth	r3, r3
200114dc:	2b00      	cmp	r3, #0
200114de:	d104      	bne.n	200114ea <I2C_DMAMasterReceiveCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
200114e0:	2120      	movs	r1, #32
200114e2:	68f8      	ldr	r0, [r7, #12]
200114e4:	f000 fc42 	bl	20011d6c <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
200114e8:	e02d      	b.n	20011546 <I2C_DMAMasterReceiveCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
200114ea:	68fb      	ldr	r3, [r7, #12]
200114ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200114ee:	68fa      	ldr	r2, [r7, #12]
200114f0:	8d12      	ldrh	r2, [r2, #40]	; 0x28
200114f2:	441a      	add	r2, r3
200114f4:	68fb      	ldr	r3, [r7, #12]
200114f6:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
200114f8:	68fb      	ldr	r3, [r7, #12]
200114fa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200114fc:	b29b      	uxth	r3, r3
200114fe:	2bff      	cmp	r3, #255	; 0xff
20011500:	d903      	bls.n	2001150a <I2C_DMAMasterReceiveCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
20011502:	68fb      	ldr	r3, [r7, #12]
20011504:	22ff      	movs	r2, #255	; 0xff
20011506:	851a      	strh	r2, [r3, #40]	; 0x28
20011508:	e004      	b.n	20011514 <I2C_DMAMasterReceiveCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
2001150a:	68fb      	ldr	r3, [r7, #12]
2001150c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2001150e:	b29a      	uxth	r2, r3
20011510:	68fb      	ldr	r3, [r7, #12]
20011512:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize) != HAL_OK)
20011514:	68fb      	ldr	r3, [r7, #12]
20011516:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
20011518:	68fb      	ldr	r3, [r7, #12]
2001151a:	681b      	ldr	r3, [r3, #0]
2001151c:	3324      	adds	r3, #36	; 0x24
2001151e:	4619      	mov	r1, r3
20011520:	68fb      	ldr	r3, [r7, #12]
20011522:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20011524:	461a      	mov	r2, r3
20011526:	68fb      	ldr	r3, [r7, #12]
20011528:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2001152a:	f7f3 f9c1 	bl	200048b0 <HAL_DMA_Start_IT>
2001152e:	4603      	mov	r3, r0
20011530:	2b00      	cmp	r3, #0
20011532:	d004      	beq.n	2001153e <I2C_DMAMasterReceiveCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
20011534:	2110      	movs	r1, #16
20011536:	68f8      	ldr	r0, [r7, #12]
20011538:	f7ff fe38 	bl	200111ac <I2C_ITError>
}
2001153c:	e003      	b.n	20011546 <I2C_DMAMasterReceiveCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
2001153e:	2140      	movs	r1, #64	; 0x40
20011540:	68f8      	ldr	r0, [r7, #12]
20011542:	f000 fc13 	bl	20011d6c <I2C_Enable_IRQ>
}
20011546:	bf00      	nop
20011548:	3710      	adds	r7, #16
2001154a:	46bd      	mov	sp, r7
2001154c:	bd80      	pop	{r7, pc}
	...

20011550 <I2C_DMASlaveReceiveCplt>:
  * @brief  DMA I2C slave receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
{
20011550:	b580      	push	{r7, lr}
20011552:	b084      	sub	sp, #16
20011554:	af00      	add	r7, sp, #0
20011556:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
20011558:	687b      	ldr	r3, [r7, #4]
2001155a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001155c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
2001155e:	68fb      	ldr	r3, [r7, #12]
20011560:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20011562:	60bb      	str	r3, [r7, #8]

  if ((__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U) && \
20011564:	68fb      	ldr	r3, [r7, #12]
20011566:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011568:	681b      	ldr	r3, [r3, #0]
2001156a:	4a42      	ldr	r2, [pc, #264]	; (20011674 <I2C_DMASlaveReceiveCplt+0x124>)
2001156c:	4293      	cmp	r3, r2
2001156e:	d059      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
20011570:	68fb      	ldr	r3, [r7, #12]
20011572:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011574:	681b      	ldr	r3, [r3, #0]
20011576:	4a40      	ldr	r2, [pc, #256]	; (20011678 <I2C_DMASlaveReceiveCplt+0x128>)
20011578:	4293      	cmp	r3, r2
2001157a:	d053      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
2001157c:	68fb      	ldr	r3, [r7, #12]
2001157e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011580:	681b      	ldr	r3, [r3, #0]
20011582:	4a3e      	ldr	r2, [pc, #248]	; (2001167c <I2C_DMASlaveReceiveCplt+0x12c>)
20011584:	4293      	cmp	r3, r2
20011586:	d04d      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
20011588:	68fb      	ldr	r3, [r7, #12]
2001158a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001158c:	681b      	ldr	r3, [r3, #0]
2001158e:	4a3c      	ldr	r2, [pc, #240]	; (20011680 <I2C_DMASlaveReceiveCplt+0x130>)
20011590:	4293      	cmp	r3, r2
20011592:	d047      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
20011594:	68fb      	ldr	r3, [r7, #12]
20011596:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011598:	681b      	ldr	r3, [r3, #0]
2001159a:	4a3a      	ldr	r2, [pc, #232]	; (20011684 <I2C_DMASlaveReceiveCplt+0x134>)
2001159c:	4293      	cmp	r3, r2
2001159e:	d041      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
200115a0:	68fb      	ldr	r3, [r7, #12]
200115a2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200115a4:	681b      	ldr	r3, [r3, #0]
200115a6:	4a38      	ldr	r2, [pc, #224]	; (20011688 <I2C_DMASlaveReceiveCplt+0x138>)
200115a8:	4293      	cmp	r3, r2
200115aa:	d03b      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
200115ac:	68fb      	ldr	r3, [r7, #12]
200115ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200115b0:	681b      	ldr	r3, [r3, #0]
200115b2:	4a36      	ldr	r2, [pc, #216]	; (2001168c <I2C_DMASlaveReceiveCplt+0x13c>)
200115b4:	4293      	cmp	r3, r2
200115b6:	d035      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
200115b8:	68fb      	ldr	r3, [r7, #12]
200115ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200115bc:	681b      	ldr	r3, [r3, #0]
200115be:	4a34      	ldr	r2, [pc, #208]	; (20011690 <I2C_DMASlaveReceiveCplt+0x140>)
200115c0:	4293      	cmp	r3, r2
200115c2:	d02f      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
200115c4:	68fb      	ldr	r3, [r7, #12]
200115c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200115c8:	681b      	ldr	r3, [r3, #0]
200115ca:	4a32      	ldr	r2, [pc, #200]	; (20011694 <I2C_DMASlaveReceiveCplt+0x144>)
200115cc:	4293      	cmp	r3, r2
200115ce:	d029      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
200115d0:	68fb      	ldr	r3, [r7, #12]
200115d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200115d4:	681b      	ldr	r3, [r3, #0]
200115d6:	4a30      	ldr	r2, [pc, #192]	; (20011698 <I2C_DMASlaveReceiveCplt+0x148>)
200115d8:	4293      	cmp	r3, r2
200115da:	d023      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
200115dc:	68fb      	ldr	r3, [r7, #12]
200115de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200115e0:	681b      	ldr	r3, [r3, #0]
200115e2:	4a2e      	ldr	r2, [pc, #184]	; (2001169c <I2C_DMASlaveReceiveCplt+0x14c>)
200115e4:	4293      	cmp	r3, r2
200115e6:	d01d      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
200115e8:	68fb      	ldr	r3, [r7, #12]
200115ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200115ec:	681b      	ldr	r3, [r3, #0]
200115ee:	4a2c      	ldr	r2, [pc, #176]	; (200116a0 <I2C_DMASlaveReceiveCplt+0x150>)
200115f0:	4293      	cmp	r3, r2
200115f2:	d017      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
200115f4:	68fb      	ldr	r3, [r7, #12]
200115f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200115f8:	681b      	ldr	r3, [r3, #0]
200115fa:	4a2a      	ldr	r2, [pc, #168]	; (200116a4 <I2C_DMASlaveReceiveCplt+0x154>)
200115fc:	4293      	cmp	r3, r2
200115fe:	d011      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
20011600:	68fb      	ldr	r3, [r7, #12]
20011602:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011604:	681b      	ldr	r3, [r3, #0]
20011606:	4a28      	ldr	r2, [pc, #160]	; (200116a8 <I2C_DMASlaveReceiveCplt+0x158>)
20011608:	4293      	cmp	r3, r2
2001160a:	d00b      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
2001160c:	68fb      	ldr	r3, [r7, #12]
2001160e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011610:	681b      	ldr	r3, [r3, #0]
20011612:	4a26      	ldr	r2, [pc, #152]	; (200116ac <I2C_DMASlaveReceiveCplt+0x15c>)
20011614:	4293      	cmp	r3, r2
20011616:	d005      	beq.n	20011624 <I2C_DMASlaveReceiveCplt+0xd4>
20011618:	68fb      	ldr	r3, [r7, #12]
2001161a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001161c:	681b      	ldr	r3, [r3, #0]
2001161e:	4a24      	ldr	r2, [pc, #144]	; (200116b0 <I2C_DMASlaveReceiveCplt+0x160>)
20011620:	4293      	cmp	r3, r2
20011622:	d109      	bne.n	20011638 <I2C_DMASlaveReceiveCplt+0xe8>
20011624:	68fb      	ldr	r3, [r7, #12]
20011626:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011628:	681b      	ldr	r3, [r3, #0]
2001162a:	685b      	ldr	r3, [r3, #4]
2001162c:	2b00      	cmp	r3, #0
2001162e:	bf0c      	ite	eq
20011630:	2301      	moveq	r3, #1
20011632:	2300      	movne	r3, #0
20011634:	b2db      	uxtb	r3, r3
20011636:	e008      	b.n	2001164a <I2C_DMASlaveReceiveCplt+0xfa>
20011638:	68fb      	ldr	r3, [r7, #12]
2001163a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001163c:	681b      	ldr	r3, [r3, #0]
2001163e:	685b      	ldr	r3, [r3, #4]
20011640:	2b00      	cmp	r3, #0
20011642:	bf0c      	ite	eq
20011644:	2301      	moveq	r3, #1
20011646:	2300      	movne	r3, #0
20011648:	b2db      	uxtb	r3, r3
2001164a:	2b00      	cmp	r3, #0
2001164c:	d00e      	beq.n	2001166c <I2C_DMASlaveReceiveCplt+0x11c>
2001164e:	68bb      	ldr	r3, [r7, #8]
20011650:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
20011654:	d00a      	beq.n	2001166c <I2C_DMASlaveReceiveCplt+0x11c>
      (tmpoptions != I2C_NO_OPTION_FRAME))
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
20011656:	68fb      	ldr	r3, [r7, #12]
20011658:	681b      	ldr	r3, [r3, #0]
2001165a:	681a      	ldr	r2, [r3, #0]
2001165c:	68fb      	ldr	r3, [r7, #12]
2001165e:	681b      	ldr	r3, [r3, #0]
20011660:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20011664:	601a      	str	r2, [r3, #0]

    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
20011666:	68f8      	ldr	r0, [r7, #12]
20011668:	f7ff fa2b 	bl	20010ac2 <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
2001166c:	bf00      	nop
2001166e:	3710      	adds	r7, #16
20011670:	46bd      	mov	sp, r7
20011672:	bd80      	pop	{r7, pc}
20011674:	40020010 	.word	0x40020010
20011678:	40020028 	.word	0x40020028
2001167c:	40020040 	.word	0x40020040
20011680:	40020058 	.word	0x40020058
20011684:	40020070 	.word	0x40020070
20011688:	40020088 	.word	0x40020088
2001168c:	400200a0 	.word	0x400200a0
20011690:	400200b8 	.word	0x400200b8
20011694:	40020410 	.word	0x40020410
20011698:	40020428 	.word	0x40020428
2001169c:	40020440 	.word	0x40020440
200116a0:	40020458 	.word	0x40020458
200116a4:	40020470 	.word	0x40020470
200116a8:	40020488 	.word	0x40020488
200116ac:	400204a0 	.word	0x400204a0
200116b0:	400204b8 	.word	0x400204b8

200116b4 <I2C_DMAError>:
  * @brief  DMA I2C communication error callback.
  * @param hdma DMA handle
  * @retval None
  */
static void I2C_DMAError(DMA_HandleTypeDef *hdma)
{
200116b4:	b580      	push	{r7, lr}
200116b6:	b084      	sub	sp, #16
200116b8:	af00      	add	r7, sp, #0
200116ba:	6078      	str	r0, [r7, #4]
  uint32_t treatdmaerror = 0U;
200116bc:	2300      	movs	r3, #0
200116be:	60fb      	str	r3, [r7, #12]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
200116c0:	687b      	ldr	r3, [r7, #4]
200116c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200116c4:	60bb      	str	r3, [r7, #8]

  if (hi2c->hdmatx != NULL)
200116c6:	68bb      	ldr	r3, [r7, #8]
200116c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200116ca:	2b00      	cmp	r3, #0
200116cc:	d076      	beq.n	200117bc <I2C_DMAError+0x108>
  {
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
200116ce:	68bb      	ldr	r3, [r7, #8]
200116d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200116d2:	681b      	ldr	r3, [r3, #0]
200116d4:	4a83      	ldr	r2, [pc, #524]	; (200118e4 <I2C_DMAError+0x230>)
200116d6:	4293      	cmp	r3, r2
200116d8:	d059      	beq.n	2001178e <I2C_DMAError+0xda>
200116da:	68bb      	ldr	r3, [r7, #8]
200116dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200116de:	681b      	ldr	r3, [r3, #0]
200116e0:	4a81      	ldr	r2, [pc, #516]	; (200118e8 <I2C_DMAError+0x234>)
200116e2:	4293      	cmp	r3, r2
200116e4:	d053      	beq.n	2001178e <I2C_DMAError+0xda>
200116e6:	68bb      	ldr	r3, [r7, #8]
200116e8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200116ea:	681b      	ldr	r3, [r3, #0]
200116ec:	4a7f      	ldr	r2, [pc, #508]	; (200118ec <I2C_DMAError+0x238>)
200116ee:	4293      	cmp	r3, r2
200116f0:	d04d      	beq.n	2001178e <I2C_DMAError+0xda>
200116f2:	68bb      	ldr	r3, [r7, #8]
200116f4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200116f6:	681b      	ldr	r3, [r3, #0]
200116f8:	4a7d      	ldr	r2, [pc, #500]	; (200118f0 <I2C_DMAError+0x23c>)
200116fa:	4293      	cmp	r3, r2
200116fc:	d047      	beq.n	2001178e <I2C_DMAError+0xda>
200116fe:	68bb      	ldr	r3, [r7, #8]
20011700:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011702:	681b      	ldr	r3, [r3, #0]
20011704:	4a7b      	ldr	r2, [pc, #492]	; (200118f4 <I2C_DMAError+0x240>)
20011706:	4293      	cmp	r3, r2
20011708:	d041      	beq.n	2001178e <I2C_DMAError+0xda>
2001170a:	68bb      	ldr	r3, [r7, #8]
2001170c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001170e:	681b      	ldr	r3, [r3, #0]
20011710:	4a79      	ldr	r2, [pc, #484]	; (200118f8 <I2C_DMAError+0x244>)
20011712:	4293      	cmp	r3, r2
20011714:	d03b      	beq.n	2001178e <I2C_DMAError+0xda>
20011716:	68bb      	ldr	r3, [r7, #8]
20011718:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001171a:	681b      	ldr	r3, [r3, #0]
2001171c:	4a77      	ldr	r2, [pc, #476]	; (200118fc <I2C_DMAError+0x248>)
2001171e:	4293      	cmp	r3, r2
20011720:	d035      	beq.n	2001178e <I2C_DMAError+0xda>
20011722:	68bb      	ldr	r3, [r7, #8]
20011724:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011726:	681b      	ldr	r3, [r3, #0]
20011728:	4a75      	ldr	r2, [pc, #468]	; (20011900 <I2C_DMAError+0x24c>)
2001172a:	4293      	cmp	r3, r2
2001172c:	d02f      	beq.n	2001178e <I2C_DMAError+0xda>
2001172e:	68bb      	ldr	r3, [r7, #8]
20011730:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011732:	681b      	ldr	r3, [r3, #0]
20011734:	4a73      	ldr	r2, [pc, #460]	; (20011904 <I2C_DMAError+0x250>)
20011736:	4293      	cmp	r3, r2
20011738:	d029      	beq.n	2001178e <I2C_DMAError+0xda>
2001173a:	68bb      	ldr	r3, [r7, #8]
2001173c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001173e:	681b      	ldr	r3, [r3, #0]
20011740:	4a71      	ldr	r2, [pc, #452]	; (20011908 <I2C_DMAError+0x254>)
20011742:	4293      	cmp	r3, r2
20011744:	d023      	beq.n	2001178e <I2C_DMAError+0xda>
20011746:	68bb      	ldr	r3, [r7, #8]
20011748:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001174a:	681b      	ldr	r3, [r3, #0]
2001174c:	4a6f      	ldr	r2, [pc, #444]	; (2001190c <I2C_DMAError+0x258>)
2001174e:	4293      	cmp	r3, r2
20011750:	d01d      	beq.n	2001178e <I2C_DMAError+0xda>
20011752:	68bb      	ldr	r3, [r7, #8]
20011754:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011756:	681b      	ldr	r3, [r3, #0]
20011758:	4a6d      	ldr	r2, [pc, #436]	; (20011910 <I2C_DMAError+0x25c>)
2001175a:	4293      	cmp	r3, r2
2001175c:	d017      	beq.n	2001178e <I2C_DMAError+0xda>
2001175e:	68bb      	ldr	r3, [r7, #8]
20011760:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011762:	681b      	ldr	r3, [r3, #0]
20011764:	4a6b      	ldr	r2, [pc, #428]	; (20011914 <I2C_DMAError+0x260>)
20011766:	4293      	cmp	r3, r2
20011768:	d011      	beq.n	2001178e <I2C_DMAError+0xda>
2001176a:	68bb      	ldr	r3, [r7, #8]
2001176c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001176e:	681b      	ldr	r3, [r3, #0]
20011770:	4a69      	ldr	r2, [pc, #420]	; (20011918 <I2C_DMAError+0x264>)
20011772:	4293      	cmp	r3, r2
20011774:	d00b      	beq.n	2001178e <I2C_DMAError+0xda>
20011776:	68bb      	ldr	r3, [r7, #8]
20011778:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001177a:	681b      	ldr	r3, [r3, #0]
2001177c:	4a67      	ldr	r2, [pc, #412]	; (2001191c <I2C_DMAError+0x268>)
2001177e:	4293      	cmp	r3, r2
20011780:	d005      	beq.n	2001178e <I2C_DMAError+0xda>
20011782:	68bb      	ldr	r3, [r7, #8]
20011784:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011786:	681b      	ldr	r3, [r3, #0]
20011788:	4a65      	ldr	r2, [pc, #404]	; (20011920 <I2C_DMAError+0x26c>)
2001178a:	4293      	cmp	r3, r2
2001178c:	d109      	bne.n	200117a2 <I2C_DMAError+0xee>
2001178e:	68bb      	ldr	r3, [r7, #8]
20011790:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011792:	681b      	ldr	r3, [r3, #0]
20011794:	685b      	ldr	r3, [r3, #4]
20011796:	2b00      	cmp	r3, #0
20011798:	bf0c      	ite	eq
2001179a:	2301      	moveq	r3, #1
2001179c:	2300      	movne	r3, #0
2001179e:	b2db      	uxtb	r3, r3
200117a0:	e008      	b.n	200117b4 <I2C_DMAError+0x100>
200117a2:	68bb      	ldr	r3, [r7, #8]
200117a4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200117a6:	681b      	ldr	r3, [r3, #0]
200117a8:	685b      	ldr	r3, [r3, #4]
200117aa:	2b00      	cmp	r3, #0
200117ac:	bf0c      	ite	eq
200117ae:	2301      	moveq	r3, #1
200117b0:	2300      	movne	r3, #0
200117b2:	b2db      	uxtb	r3, r3
200117b4:	2b00      	cmp	r3, #0
200117b6:	d001      	beq.n	200117bc <I2C_DMAError+0x108>
    {
      treatdmaerror = 1U;
200117b8:	2301      	movs	r3, #1
200117ba:	60fb      	str	r3, [r7, #12]
    }
  }

  if (hi2c->hdmarx != NULL)
200117bc:	68bb      	ldr	r3, [r7, #8]
200117be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200117c0:	2b00      	cmp	r3, #0
200117c2:	d076      	beq.n	200118b2 <I2C_DMAError+0x1fe>
  {
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
200117c4:	68bb      	ldr	r3, [r7, #8]
200117c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200117c8:	681b      	ldr	r3, [r3, #0]
200117ca:	4a46      	ldr	r2, [pc, #280]	; (200118e4 <I2C_DMAError+0x230>)
200117cc:	4293      	cmp	r3, r2
200117ce:	d059      	beq.n	20011884 <I2C_DMAError+0x1d0>
200117d0:	68bb      	ldr	r3, [r7, #8]
200117d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200117d4:	681b      	ldr	r3, [r3, #0]
200117d6:	4a44      	ldr	r2, [pc, #272]	; (200118e8 <I2C_DMAError+0x234>)
200117d8:	4293      	cmp	r3, r2
200117da:	d053      	beq.n	20011884 <I2C_DMAError+0x1d0>
200117dc:	68bb      	ldr	r3, [r7, #8]
200117de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200117e0:	681b      	ldr	r3, [r3, #0]
200117e2:	4a42      	ldr	r2, [pc, #264]	; (200118ec <I2C_DMAError+0x238>)
200117e4:	4293      	cmp	r3, r2
200117e6:	d04d      	beq.n	20011884 <I2C_DMAError+0x1d0>
200117e8:	68bb      	ldr	r3, [r7, #8]
200117ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200117ec:	681b      	ldr	r3, [r3, #0]
200117ee:	4a40      	ldr	r2, [pc, #256]	; (200118f0 <I2C_DMAError+0x23c>)
200117f0:	4293      	cmp	r3, r2
200117f2:	d047      	beq.n	20011884 <I2C_DMAError+0x1d0>
200117f4:	68bb      	ldr	r3, [r7, #8]
200117f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200117f8:	681b      	ldr	r3, [r3, #0]
200117fa:	4a3e      	ldr	r2, [pc, #248]	; (200118f4 <I2C_DMAError+0x240>)
200117fc:	4293      	cmp	r3, r2
200117fe:	d041      	beq.n	20011884 <I2C_DMAError+0x1d0>
20011800:	68bb      	ldr	r3, [r7, #8]
20011802:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011804:	681b      	ldr	r3, [r3, #0]
20011806:	4a3c      	ldr	r2, [pc, #240]	; (200118f8 <I2C_DMAError+0x244>)
20011808:	4293      	cmp	r3, r2
2001180a:	d03b      	beq.n	20011884 <I2C_DMAError+0x1d0>
2001180c:	68bb      	ldr	r3, [r7, #8]
2001180e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011810:	681b      	ldr	r3, [r3, #0]
20011812:	4a3a      	ldr	r2, [pc, #232]	; (200118fc <I2C_DMAError+0x248>)
20011814:	4293      	cmp	r3, r2
20011816:	d035      	beq.n	20011884 <I2C_DMAError+0x1d0>
20011818:	68bb      	ldr	r3, [r7, #8]
2001181a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001181c:	681b      	ldr	r3, [r3, #0]
2001181e:	4a38      	ldr	r2, [pc, #224]	; (20011900 <I2C_DMAError+0x24c>)
20011820:	4293      	cmp	r3, r2
20011822:	d02f      	beq.n	20011884 <I2C_DMAError+0x1d0>
20011824:	68bb      	ldr	r3, [r7, #8]
20011826:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011828:	681b      	ldr	r3, [r3, #0]
2001182a:	4a36      	ldr	r2, [pc, #216]	; (20011904 <I2C_DMAError+0x250>)
2001182c:	4293      	cmp	r3, r2
2001182e:	d029      	beq.n	20011884 <I2C_DMAError+0x1d0>
20011830:	68bb      	ldr	r3, [r7, #8]
20011832:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011834:	681b      	ldr	r3, [r3, #0]
20011836:	4a34      	ldr	r2, [pc, #208]	; (20011908 <I2C_DMAError+0x254>)
20011838:	4293      	cmp	r3, r2
2001183a:	d023      	beq.n	20011884 <I2C_DMAError+0x1d0>
2001183c:	68bb      	ldr	r3, [r7, #8]
2001183e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011840:	681b      	ldr	r3, [r3, #0]
20011842:	4a32      	ldr	r2, [pc, #200]	; (2001190c <I2C_DMAError+0x258>)
20011844:	4293      	cmp	r3, r2
20011846:	d01d      	beq.n	20011884 <I2C_DMAError+0x1d0>
20011848:	68bb      	ldr	r3, [r7, #8]
2001184a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001184c:	681b      	ldr	r3, [r3, #0]
2001184e:	4a30      	ldr	r2, [pc, #192]	; (20011910 <I2C_DMAError+0x25c>)
20011850:	4293      	cmp	r3, r2
20011852:	d017      	beq.n	20011884 <I2C_DMAError+0x1d0>
20011854:	68bb      	ldr	r3, [r7, #8]
20011856:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011858:	681b      	ldr	r3, [r3, #0]
2001185a:	4a2e      	ldr	r2, [pc, #184]	; (20011914 <I2C_DMAError+0x260>)
2001185c:	4293      	cmp	r3, r2
2001185e:	d011      	beq.n	20011884 <I2C_DMAError+0x1d0>
20011860:	68bb      	ldr	r3, [r7, #8]
20011862:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011864:	681b      	ldr	r3, [r3, #0]
20011866:	4a2c      	ldr	r2, [pc, #176]	; (20011918 <I2C_DMAError+0x264>)
20011868:	4293      	cmp	r3, r2
2001186a:	d00b      	beq.n	20011884 <I2C_DMAError+0x1d0>
2001186c:	68bb      	ldr	r3, [r7, #8]
2001186e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011870:	681b      	ldr	r3, [r3, #0]
20011872:	4a2a      	ldr	r2, [pc, #168]	; (2001191c <I2C_DMAError+0x268>)
20011874:	4293      	cmp	r3, r2
20011876:	d005      	beq.n	20011884 <I2C_DMAError+0x1d0>
20011878:	68bb      	ldr	r3, [r7, #8]
2001187a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001187c:	681b      	ldr	r3, [r3, #0]
2001187e:	4a28      	ldr	r2, [pc, #160]	; (20011920 <I2C_DMAError+0x26c>)
20011880:	4293      	cmp	r3, r2
20011882:	d109      	bne.n	20011898 <I2C_DMAError+0x1e4>
20011884:	68bb      	ldr	r3, [r7, #8]
20011886:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011888:	681b      	ldr	r3, [r3, #0]
2001188a:	685b      	ldr	r3, [r3, #4]
2001188c:	2b00      	cmp	r3, #0
2001188e:	bf0c      	ite	eq
20011890:	2301      	moveq	r3, #1
20011892:	2300      	movne	r3, #0
20011894:	b2db      	uxtb	r3, r3
20011896:	e008      	b.n	200118aa <I2C_DMAError+0x1f6>
20011898:	68bb      	ldr	r3, [r7, #8]
2001189a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001189c:	681b      	ldr	r3, [r3, #0]
2001189e:	685b      	ldr	r3, [r3, #4]
200118a0:	2b00      	cmp	r3, #0
200118a2:	bf0c      	ite	eq
200118a4:	2301      	moveq	r3, #1
200118a6:	2300      	movne	r3, #0
200118a8:	b2db      	uxtb	r3, r3
200118aa:	2b00      	cmp	r3, #0
200118ac:	d001      	beq.n	200118b2 <I2C_DMAError+0x1fe>
    {
      treatdmaerror = 1U;
200118ae:	2301      	movs	r3, #1
200118b0:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Check if a FIFO error is detected, if true normal use case, so no specific action to perform */
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
200118b2:	6878      	ldr	r0, [r7, #4]
200118b4:	f7f5 fb80 	bl	20006fb8 <HAL_DMA_GetError>
200118b8:	4603      	mov	r3, r0
200118ba:	2b02      	cmp	r3, #2
200118bc:	d00e      	beq.n	200118dc <I2C_DMAError+0x228>
200118be:	68fb      	ldr	r3, [r7, #12]
200118c0:	2b00      	cmp	r3, #0
200118c2:	d00b      	beq.n	200118dc <I2C_DMAError+0x228>
  {
    /* Disable Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
200118c4:	68bb      	ldr	r3, [r7, #8]
200118c6:	681b      	ldr	r3, [r3, #0]
200118c8:	685a      	ldr	r2, [r3, #4]
200118ca:	68bb      	ldr	r3, [r7, #8]
200118cc:	681b      	ldr	r3, [r3, #0]
200118ce:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
200118d2:	605a      	str	r2, [r3, #4]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
200118d4:	2110      	movs	r1, #16
200118d6:	68b8      	ldr	r0, [r7, #8]
200118d8:	f7ff fc68 	bl	200111ac <I2C_ITError>
  }
}
200118dc:	bf00      	nop
200118de:	3710      	adds	r7, #16
200118e0:	46bd      	mov	sp, r7
200118e2:	bd80      	pop	{r7, pc}
200118e4:	40020010 	.word	0x40020010
200118e8:	40020028 	.word	0x40020028
200118ec:	40020040 	.word	0x40020040
200118f0:	40020058 	.word	0x40020058
200118f4:	40020070 	.word	0x40020070
200118f8:	40020088 	.word	0x40020088
200118fc:	400200a0 	.word	0x400200a0
20011900:	400200b8 	.word	0x400200b8
20011904:	40020410 	.word	0x40020410
20011908:	40020428 	.word	0x40020428
2001190c:	40020440 	.word	0x40020440
20011910:	40020458 	.word	0x40020458
20011914:	40020470 	.word	0x40020470
20011918:	40020488 	.word	0x40020488
2001191c:	400204a0 	.word	0x400204a0
20011920:	400204b8 	.word	0x400204b8

20011924 <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
20011924:	b580      	push	{r7, lr}
20011926:	b084      	sub	sp, #16
20011928:	af00      	add	r7, sp, #0
2001192a:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2001192c:	687b      	ldr	r3, [r7, #4]
2001192e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011930:	60fb      	str	r3, [r7, #12]

  /* Reset AbortCpltCallback */
  if (hi2c->hdmatx != NULL)
20011932:	68fb      	ldr	r3, [r7, #12]
20011934:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20011936:	2b00      	cmp	r3, #0
20011938:	d003      	beq.n	20011942 <I2C_DMAAbort+0x1e>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
2001193a:	68fb      	ldr	r3, [r7, #12]
2001193c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001193e:	2200      	movs	r2, #0
20011940:	651a      	str	r2, [r3, #80]	; 0x50
  }
  if (hi2c->hdmarx != NULL)
20011942:	68fb      	ldr	r3, [r7, #12]
20011944:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20011946:	2b00      	cmp	r3, #0
20011948:	d003      	beq.n	20011952 <I2C_DMAAbort+0x2e>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
2001194a:	68fb      	ldr	r3, [r7, #12]
2001194c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001194e:	2200      	movs	r2, #0
20011950:	651a      	str	r2, [r3, #80]	; 0x50
  }

  I2C_TreatErrorCallback(hi2c);
20011952:	68f8      	ldr	r0, [r7, #12]
20011954:	f7ff fcfa 	bl	2001134c <I2C_TreatErrorCallback>
}
20011958:	bf00      	nop
2001195a:	3710      	adds	r7, #16
2001195c:	46bd      	mov	sp, r7
2001195e:	bd80      	pop	{r7, pc}

20011960 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
20011960:	b580      	push	{r7, lr}
20011962:	b084      	sub	sp, #16
20011964:	af00      	add	r7, sp, #0
20011966:	60f8      	str	r0, [r7, #12]
20011968:	60b9      	str	r1, [r7, #8]
2001196a:	603b      	str	r3, [r7, #0]
2001196c:	4613      	mov	r3, r2
2001196e:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
20011970:	e022      	b.n	200119b8 <I2C_WaitOnFlagUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
20011972:	683b      	ldr	r3, [r7, #0]
20011974:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
20011978:	d01e      	beq.n	200119b8 <I2C_WaitOnFlagUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2001197a:	f7f0 f9b7 	bl	20001cec <HAL_GetTick>
2001197e:	4602      	mov	r2, r0
20011980:	69bb      	ldr	r3, [r7, #24]
20011982:	1ad3      	subs	r3, r2, r3
20011984:	683a      	ldr	r2, [r7, #0]
20011986:	429a      	cmp	r2, r3
20011988:	d302      	bcc.n	20011990 <I2C_WaitOnFlagUntilTimeout+0x30>
2001198a:	683b      	ldr	r3, [r7, #0]
2001198c:	2b00      	cmp	r3, #0
2001198e:	d113      	bne.n	200119b8 <I2C_WaitOnFlagUntilTimeout+0x58>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
20011990:	68fb      	ldr	r3, [r7, #12]
20011992:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20011994:	f043 0220 	orr.w	r2, r3, #32
20011998:	68fb      	ldr	r3, [r7, #12]
2001199a:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2001199c:	68fb      	ldr	r3, [r7, #12]
2001199e:	2220      	movs	r2, #32
200119a0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
200119a4:	68fb      	ldr	r3, [r7, #12]
200119a6:	2200      	movs	r2, #0
200119a8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
200119ac:	68fb      	ldr	r3, [r7, #12]
200119ae:	2200      	movs	r2, #0
200119b0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
200119b4:	2301      	movs	r3, #1
200119b6:	e00f      	b.n	200119d8 <I2C_WaitOnFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
200119b8:	68fb      	ldr	r3, [r7, #12]
200119ba:	681b      	ldr	r3, [r3, #0]
200119bc:	699a      	ldr	r2, [r3, #24]
200119be:	68bb      	ldr	r3, [r7, #8]
200119c0:	4013      	ands	r3, r2
200119c2:	68ba      	ldr	r2, [r7, #8]
200119c4:	429a      	cmp	r2, r3
200119c6:	bf0c      	ite	eq
200119c8:	2301      	moveq	r3, #1
200119ca:	2300      	movne	r3, #0
200119cc:	b2db      	uxtb	r3, r3
200119ce:	461a      	mov	r2, r3
200119d0:	79fb      	ldrb	r3, [r7, #7]
200119d2:	429a      	cmp	r2, r3
200119d4:	d0cd      	beq.n	20011972 <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
200119d6:	2300      	movs	r3, #0
}
200119d8:	4618      	mov	r0, r3
200119da:	3710      	adds	r7, #16
200119dc:	46bd      	mov	sp, r7
200119de:	bd80      	pop	{r7, pc}

200119e0 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
200119e0:	b580      	push	{r7, lr}
200119e2:	b084      	sub	sp, #16
200119e4:	af00      	add	r7, sp, #0
200119e6:	60f8      	str	r0, [r7, #12]
200119e8:	60b9      	str	r1, [r7, #8]
200119ea:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
200119ec:	e02c      	b.n	20011a48 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
200119ee:	687a      	ldr	r2, [r7, #4]
200119f0:	68b9      	ldr	r1, [r7, #8]
200119f2:	68f8      	ldr	r0, [r7, #12]
200119f4:	f000 f8dc 	bl	20011bb0 <I2C_IsAcknowledgeFailed>
200119f8:	4603      	mov	r3, r0
200119fa:	2b00      	cmp	r3, #0
200119fc:	d001      	beq.n	20011a02 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
200119fe:	2301      	movs	r3, #1
20011a00:	e02a      	b.n	20011a58 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
20011a02:	68bb      	ldr	r3, [r7, #8]
20011a04:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
20011a08:	d01e      	beq.n	20011a48 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
20011a0a:	f7f0 f96f 	bl	20001cec <HAL_GetTick>
20011a0e:	4602      	mov	r2, r0
20011a10:	687b      	ldr	r3, [r7, #4]
20011a12:	1ad3      	subs	r3, r2, r3
20011a14:	68ba      	ldr	r2, [r7, #8]
20011a16:	429a      	cmp	r2, r3
20011a18:	d302      	bcc.n	20011a20 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
20011a1a:	68bb      	ldr	r3, [r7, #8]
20011a1c:	2b00      	cmp	r3, #0
20011a1e:	d113      	bne.n	20011a48 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
20011a20:	68fb      	ldr	r3, [r7, #12]
20011a22:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20011a24:	f043 0220 	orr.w	r2, r3, #32
20011a28:	68fb      	ldr	r3, [r7, #12]
20011a2a:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
20011a2c:	68fb      	ldr	r3, [r7, #12]
20011a2e:	2220      	movs	r2, #32
20011a30:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
20011a34:	68fb      	ldr	r3, [r7, #12]
20011a36:	2200      	movs	r2, #0
20011a38:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
20011a3c:	68fb      	ldr	r3, [r7, #12]
20011a3e:	2200      	movs	r2, #0
20011a40:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
20011a44:	2301      	movs	r3, #1
20011a46:	e007      	b.n	20011a58 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
20011a48:	68fb      	ldr	r3, [r7, #12]
20011a4a:	681b      	ldr	r3, [r3, #0]
20011a4c:	699b      	ldr	r3, [r3, #24]
20011a4e:	f003 0302 	and.w	r3, r3, #2
20011a52:	2b02      	cmp	r3, #2
20011a54:	d1cb      	bne.n	200119ee <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
20011a56:	2300      	movs	r3, #0
}
20011a58:	4618      	mov	r0, r3
20011a5a:	3710      	adds	r7, #16
20011a5c:	46bd      	mov	sp, r7
20011a5e:	bd80      	pop	{r7, pc}

20011a60 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
20011a60:	b580      	push	{r7, lr}
20011a62:	b084      	sub	sp, #16
20011a64:	af00      	add	r7, sp, #0
20011a66:	60f8      	str	r0, [r7, #12]
20011a68:	60b9      	str	r1, [r7, #8]
20011a6a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
20011a6c:	e028      	b.n	20011ac0 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
20011a6e:	687a      	ldr	r2, [r7, #4]
20011a70:	68b9      	ldr	r1, [r7, #8]
20011a72:	68f8      	ldr	r0, [r7, #12]
20011a74:	f000 f89c 	bl	20011bb0 <I2C_IsAcknowledgeFailed>
20011a78:	4603      	mov	r3, r0
20011a7a:	2b00      	cmp	r3, #0
20011a7c:	d001      	beq.n	20011a82 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
20011a7e:	2301      	movs	r3, #1
20011a80:	e026      	b.n	20011ad0 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
20011a82:	f7f0 f933 	bl	20001cec <HAL_GetTick>
20011a86:	4602      	mov	r2, r0
20011a88:	687b      	ldr	r3, [r7, #4]
20011a8a:	1ad3      	subs	r3, r2, r3
20011a8c:	68ba      	ldr	r2, [r7, #8]
20011a8e:	429a      	cmp	r2, r3
20011a90:	d302      	bcc.n	20011a98 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
20011a92:	68bb      	ldr	r3, [r7, #8]
20011a94:	2b00      	cmp	r3, #0
20011a96:	d113      	bne.n	20011ac0 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
20011a98:	68fb      	ldr	r3, [r7, #12]
20011a9a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20011a9c:	f043 0220 	orr.w	r2, r3, #32
20011aa0:	68fb      	ldr	r3, [r7, #12]
20011aa2:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
20011aa4:	68fb      	ldr	r3, [r7, #12]
20011aa6:	2220      	movs	r2, #32
20011aa8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
20011aac:	68fb      	ldr	r3, [r7, #12]
20011aae:	2200      	movs	r2, #0
20011ab0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20011ab4:	68fb      	ldr	r3, [r7, #12]
20011ab6:	2200      	movs	r2, #0
20011ab8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
20011abc:	2301      	movs	r3, #1
20011abe:	e007      	b.n	20011ad0 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
20011ac0:	68fb      	ldr	r3, [r7, #12]
20011ac2:	681b      	ldr	r3, [r3, #0]
20011ac4:	699b      	ldr	r3, [r3, #24]
20011ac6:	f003 0320 	and.w	r3, r3, #32
20011aca:	2b20      	cmp	r3, #32
20011acc:	d1cf      	bne.n	20011a6e <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
20011ace:	2300      	movs	r3, #0
}
20011ad0:	4618      	mov	r0, r3
20011ad2:	3710      	adds	r7, #16
20011ad4:	46bd      	mov	sp, r7
20011ad6:	bd80      	pop	{r7, pc}

20011ad8 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
20011ad8:	b580      	push	{r7, lr}
20011ada:	b084      	sub	sp, #16
20011adc:	af00      	add	r7, sp, #0
20011ade:	60f8      	str	r0, [r7, #12]
20011ae0:	60b9      	str	r1, [r7, #8]
20011ae2:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
20011ae4:	e055      	b.n	20011b92 <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
20011ae6:	687a      	ldr	r2, [r7, #4]
20011ae8:	68b9      	ldr	r1, [r7, #8]
20011aea:	68f8      	ldr	r0, [r7, #12]
20011aec:	f000 f860 	bl	20011bb0 <I2C_IsAcknowledgeFailed>
20011af0:	4603      	mov	r3, r0
20011af2:	2b00      	cmp	r3, #0
20011af4:	d001      	beq.n	20011afa <I2C_WaitOnRXNEFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
20011af6:	2301      	movs	r3, #1
20011af8:	e053      	b.n	20011ba2 <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
20011afa:	68fb      	ldr	r3, [r7, #12]
20011afc:	681b      	ldr	r3, [r3, #0]
20011afe:	699b      	ldr	r3, [r3, #24]
20011b00:	f003 0320 	and.w	r3, r3, #32
20011b04:	2b20      	cmp	r3, #32
20011b06:	d129      	bne.n	20011b5c <I2C_WaitOnRXNEFlagUntilTimeout+0x84>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
20011b08:	68fb      	ldr	r3, [r7, #12]
20011b0a:	681b      	ldr	r3, [r3, #0]
20011b0c:	699b      	ldr	r3, [r3, #24]
20011b0e:	f003 0304 	and.w	r3, r3, #4
20011b12:	2b04      	cmp	r3, #4
20011b14:	d105      	bne.n	20011b22 <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
20011b16:	68fb      	ldr	r3, [r7, #12]
20011b18:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20011b1a:	2b00      	cmp	r3, #0
20011b1c:	d001      	beq.n	20011b22 <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
      {
        /* Return HAL_OK */
        /* The Reading of data from RXDR will be done in caller function */
        return HAL_OK;
20011b1e:	2300      	movs	r3, #0
20011b20:	e03f      	b.n	20011ba2 <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
      else
      {
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
20011b22:	68fb      	ldr	r3, [r7, #12]
20011b24:	681b      	ldr	r3, [r3, #0]
20011b26:	2220      	movs	r2, #32
20011b28:	61da      	str	r2, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
20011b2a:	68fb      	ldr	r3, [r7, #12]
20011b2c:	681b      	ldr	r3, [r3, #0]
20011b2e:	6859      	ldr	r1, [r3, #4]
20011b30:	68fb      	ldr	r3, [r7, #12]
20011b32:	681a      	ldr	r2, [r3, #0]
20011b34:	4b1d      	ldr	r3, [pc, #116]	; (20011bac <I2C_WaitOnRXNEFlagUntilTimeout+0xd4>)
20011b36:	400b      	ands	r3, r1
20011b38:	6053      	str	r3, [r2, #4]

        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
20011b3a:	68fb      	ldr	r3, [r7, #12]
20011b3c:	2200      	movs	r2, #0
20011b3e:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
20011b40:	68fb      	ldr	r3, [r7, #12]
20011b42:	2220      	movs	r2, #32
20011b44:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
20011b48:	68fb      	ldr	r3, [r7, #12]
20011b4a:	2200      	movs	r2, #0
20011b4c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
20011b50:	68fb      	ldr	r3, [r7, #12]
20011b52:	2200      	movs	r2, #0
20011b54:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
20011b58:	2301      	movs	r3, #1
20011b5a:	e022      	b.n	20011ba2 <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
20011b5c:	f7f0 f8c6 	bl	20001cec <HAL_GetTick>
20011b60:	4602      	mov	r2, r0
20011b62:	687b      	ldr	r3, [r7, #4]
20011b64:	1ad3      	subs	r3, r2, r3
20011b66:	68ba      	ldr	r2, [r7, #8]
20011b68:	429a      	cmp	r2, r3
20011b6a:	d302      	bcc.n	20011b72 <I2C_WaitOnRXNEFlagUntilTimeout+0x9a>
20011b6c:	68bb      	ldr	r3, [r7, #8]
20011b6e:	2b00      	cmp	r3, #0
20011b70:	d10f      	bne.n	20011b92 <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
20011b72:	68fb      	ldr	r3, [r7, #12]
20011b74:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20011b76:	f043 0220 	orr.w	r2, r3, #32
20011b7a:	68fb      	ldr	r3, [r7, #12]
20011b7c:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
20011b7e:	68fb      	ldr	r3, [r7, #12]
20011b80:	2220      	movs	r2, #32
20011b82:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20011b86:	68fb      	ldr	r3, [r7, #12]
20011b88:	2200      	movs	r2, #0
20011b8a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
20011b8e:	2301      	movs	r3, #1
20011b90:	e007      	b.n	20011ba2 <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
20011b92:	68fb      	ldr	r3, [r7, #12]
20011b94:	681b      	ldr	r3, [r3, #0]
20011b96:	699b      	ldr	r3, [r3, #24]
20011b98:	f003 0304 	and.w	r3, r3, #4
20011b9c:	2b04      	cmp	r3, #4
20011b9e:	d1a2      	bne.n	20011ae6 <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
20011ba0:	2300      	movs	r3, #0
}
20011ba2:	4618      	mov	r0, r3
20011ba4:	3710      	adds	r7, #16
20011ba6:	46bd      	mov	sp, r7
20011ba8:	bd80      	pop	{r7, pc}
20011baa:	bf00      	nop
20011bac:	fe00e800 	.word	0xfe00e800

20011bb0 <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
20011bb0:	b580      	push	{r7, lr}
20011bb2:	b084      	sub	sp, #16
20011bb4:	af00      	add	r7, sp, #0
20011bb6:	60f8      	str	r0, [r7, #12]
20011bb8:	60b9      	str	r1, [r7, #8]
20011bba:	607a      	str	r2, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
20011bbc:	68fb      	ldr	r3, [r7, #12]
20011bbe:	681b      	ldr	r3, [r3, #0]
20011bc0:	699b      	ldr	r3, [r3, #24]
20011bc2:	f003 0310 	and.w	r3, r3, #16
20011bc6:	2b10      	cmp	r3, #16
20011bc8:	d151      	bne.n	20011c6e <I2C_IsAcknowledgeFailed+0xbe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
20011bca:	e022      	b.n	20011c12 <I2C_IsAcknowledgeFailed+0x62>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
20011bcc:	68bb      	ldr	r3, [r7, #8]
20011bce:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
20011bd2:	d01e      	beq.n	20011c12 <I2C_IsAcknowledgeFailed+0x62>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
20011bd4:	f7f0 f88a 	bl	20001cec <HAL_GetTick>
20011bd8:	4602      	mov	r2, r0
20011bda:	687b      	ldr	r3, [r7, #4]
20011bdc:	1ad3      	subs	r3, r2, r3
20011bde:	68ba      	ldr	r2, [r7, #8]
20011be0:	429a      	cmp	r2, r3
20011be2:	d302      	bcc.n	20011bea <I2C_IsAcknowledgeFailed+0x3a>
20011be4:	68bb      	ldr	r3, [r7, #8]
20011be6:	2b00      	cmp	r3, #0
20011be8:	d113      	bne.n	20011c12 <I2C_IsAcknowledgeFailed+0x62>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
20011bea:	68fb      	ldr	r3, [r7, #12]
20011bec:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20011bee:	f043 0220 	orr.w	r2, r3, #32
20011bf2:	68fb      	ldr	r3, [r7, #12]
20011bf4:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
20011bf6:	68fb      	ldr	r3, [r7, #12]
20011bf8:	2220      	movs	r2, #32
20011bfa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
20011bfe:	68fb      	ldr	r3, [r7, #12]
20011c00:	2200      	movs	r2, #0
20011c02:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
20011c06:	68fb      	ldr	r3, [r7, #12]
20011c08:	2200      	movs	r2, #0
20011c0a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          return HAL_ERROR;
20011c0e:	2301      	movs	r3, #1
20011c10:	e02e      	b.n	20011c70 <I2C_IsAcknowledgeFailed+0xc0>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
20011c12:	68fb      	ldr	r3, [r7, #12]
20011c14:	681b      	ldr	r3, [r3, #0]
20011c16:	699b      	ldr	r3, [r3, #24]
20011c18:	f003 0320 	and.w	r3, r3, #32
20011c1c:	2b20      	cmp	r3, #32
20011c1e:	d1d5      	bne.n	20011bcc <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20011c20:	68fb      	ldr	r3, [r7, #12]
20011c22:	681b      	ldr	r3, [r3, #0]
20011c24:	2210      	movs	r2, #16
20011c26:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
20011c28:	68fb      	ldr	r3, [r7, #12]
20011c2a:	681b      	ldr	r3, [r3, #0]
20011c2c:	2220      	movs	r2, #32
20011c2e:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
20011c30:	68f8      	ldr	r0, [r7, #12]
20011c32:	f7ff fbb2 	bl	2001139a <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
20011c36:	68fb      	ldr	r3, [r7, #12]
20011c38:	681b      	ldr	r3, [r3, #0]
20011c3a:	6859      	ldr	r1, [r3, #4]
20011c3c:	68fb      	ldr	r3, [r7, #12]
20011c3e:	681a      	ldr	r2, [r3, #0]
20011c40:	4b0d      	ldr	r3, [pc, #52]	; (20011c78 <I2C_IsAcknowledgeFailed+0xc8>)
20011c42:	400b      	ands	r3, r1
20011c44:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
20011c46:	68fb      	ldr	r3, [r7, #12]
20011c48:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20011c4a:	f043 0204 	orr.w	r2, r3, #4
20011c4e:	68fb      	ldr	r3, [r7, #12]
20011c50:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
20011c52:	68fb      	ldr	r3, [r7, #12]
20011c54:	2220      	movs	r2, #32
20011c56:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
20011c5a:	68fb      	ldr	r3, [r7, #12]
20011c5c:	2200      	movs	r2, #0
20011c5e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20011c62:	68fb      	ldr	r3, [r7, #12]
20011c64:	2200      	movs	r2, #0
20011c66:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
20011c6a:	2301      	movs	r3, #1
20011c6c:	e000      	b.n	20011c70 <I2C_IsAcknowledgeFailed+0xc0>
  }
  return HAL_OK;
20011c6e:	2300      	movs	r3, #0
}
20011c70:	4618      	mov	r0, r3
20011c72:	3710      	adds	r7, #16
20011c74:	46bd      	mov	sp, r7
20011c76:	bd80      	pop	{r7, pc}
20011c78:	fe00e800 	.word	0xfe00e800

20011c7c <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
20011c7c:	b580      	push	{r7, lr}
20011c7e:	b084      	sub	sp, #16
20011c80:	af00      	add	r7, sp, #0
20011c82:	60f8      	str	r0, [r7, #12]
20011c84:	607b      	str	r3, [r7, #4]
20011c86:	460b      	mov	r3, r1
20011c88:	817b      	strh	r3, [r7, #10]
20011c8a:	4613      	mov	r3, r2
20011c8c:	727b      	strb	r3, [r7, #9]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
20011c8e:	68fb      	ldr	r3, [r7, #12]
20011c90:	681b      	ldr	r3, [r3, #0]
20011c92:	4a2d      	ldr	r2, [pc, #180]	; (20011d48 <I2C_TransferConfig+0xcc>)
20011c94:	4293      	cmp	r3, r2
20011c96:	d013      	beq.n	20011cc0 <I2C_TransferConfig+0x44>
20011c98:	68fb      	ldr	r3, [r7, #12]
20011c9a:	681b      	ldr	r3, [r3, #0]
20011c9c:	4a2b      	ldr	r2, [pc, #172]	; (20011d4c <I2C_TransferConfig+0xd0>)
20011c9e:	4293      	cmp	r3, r2
20011ca0:	d00e      	beq.n	20011cc0 <I2C_TransferConfig+0x44>
20011ca2:	68fb      	ldr	r3, [r7, #12]
20011ca4:	681b      	ldr	r3, [r3, #0]
20011ca6:	4a2a      	ldr	r2, [pc, #168]	; (20011d50 <I2C_TransferConfig+0xd4>)
20011ca8:	4293      	cmp	r3, r2
20011caa:	d009      	beq.n	20011cc0 <I2C_TransferConfig+0x44>
20011cac:	68fb      	ldr	r3, [r7, #12]
20011cae:	681b      	ldr	r3, [r3, #0]
20011cb0:	4a28      	ldr	r2, [pc, #160]	; (20011d54 <I2C_TransferConfig+0xd8>)
20011cb2:	4293      	cmp	r3, r2
20011cb4:	d004      	beq.n	20011cc0 <I2C_TransferConfig+0x44>
20011cb6:	f641 1131 	movw	r1, #6449	; 0x1931
20011cba:	4827      	ldr	r0, [pc, #156]	; (20011d58 <I2C_TransferConfig+0xdc>)
20011cbc:	f7ee fe1a 	bl	200008f4 <assert_failed>
  assert_param(IS_TRANSFER_MODE(Mode));
20011cc0:	687b      	ldr	r3, [r7, #4]
20011cc2:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20011cc6:	d00b      	beq.n	20011ce0 <I2C_TransferConfig+0x64>
20011cc8:	687b      	ldr	r3, [r7, #4]
20011cca:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20011cce:	d007      	beq.n	20011ce0 <I2C_TransferConfig+0x64>
20011cd0:	687b      	ldr	r3, [r7, #4]
20011cd2:	2b00      	cmp	r3, #0
20011cd4:	d004      	beq.n	20011ce0 <I2C_TransferConfig+0x64>
20011cd6:	f641 1132 	movw	r1, #6450	; 0x1932
20011cda:	481f      	ldr	r0, [pc, #124]	; (20011d58 <I2C_TransferConfig+0xdc>)
20011cdc:	f7ee fe0a 	bl	200008f4 <assert_failed>
  assert_param(IS_TRANSFER_REQUEST(Request));
20011ce0:	69bb      	ldr	r3, [r7, #24]
20011ce2:	4a1e      	ldr	r2, [pc, #120]	; (20011d5c <I2C_TransferConfig+0xe0>)
20011ce4:	4293      	cmp	r3, r2
20011ce6:	d00f      	beq.n	20011d08 <I2C_TransferConfig+0x8c>
20011ce8:	69bb      	ldr	r3, [r7, #24]
20011cea:	4a1d      	ldr	r2, [pc, #116]	; (20011d60 <I2C_TransferConfig+0xe4>)
20011cec:	4293      	cmp	r3, r2
20011cee:	d00b      	beq.n	20011d08 <I2C_TransferConfig+0x8c>
20011cf0:	69bb      	ldr	r3, [r7, #24]
20011cf2:	4a1c      	ldr	r2, [pc, #112]	; (20011d64 <I2C_TransferConfig+0xe8>)
20011cf4:	4293      	cmp	r3, r2
20011cf6:	d007      	beq.n	20011d08 <I2C_TransferConfig+0x8c>
20011cf8:	69bb      	ldr	r3, [r7, #24]
20011cfa:	2b00      	cmp	r3, #0
20011cfc:	d004      	beq.n	20011d08 <I2C_TransferConfig+0x8c>
20011cfe:	f641 1133 	movw	r1, #6451	; 0x1933
20011d02:	4815      	ldr	r0, [pc, #84]	; (20011d58 <I2C_TransferConfig+0xdc>)
20011d04:	f7ee fdf6 	bl	200008f4 <assert_failed>

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
20011d08:	68fb      	ldr	r3, [r7, #12]
20011d0a:	681b      	ldr	r3, [r3, #0]
20011d0c:	685a      	ldr	r2, [r3, #4]
20011d0e:	69bb      	ldr	r3, [r7, #24]
20011d10:	0d5b      	lsrs	r3, r3, #21
20011d12:	f403 6180 	and.w	r1, r3, #1024	; 0x400
20011d16:	4b14      	ldr	r3, [pc, #80]	; (20011d68 <I2C_TransferConfig+0xec>)
20011d18:	430b      	orrs	r3, r1
20011d1a:	43db      	mvns	r3, r3
20011d1c:	ea02 0103 	and.w	r1, r2, r3
20011d20:	897b      	ldrh	r3, [r7, #10]
20011d22:	f3c3 0209 	ubfx	r2, r3, #0, #10
20011d26:	7a7b      	ldrb	r3, [r7, #9]
20011d28:	041b      	lsls	r3, r3, #16
20011d2a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
20011d2e:	431a      	orrs	r2, r3
20011d30:	687b      	ldr	r3, [r7, #4]
20011d32:	431a      	orrs	r2, r3
20011d34:	69bb      	ldr	r3, [r7, #24]
20011d36:	431a      	orrs	r2, r3
20011d38:	68fb      	ldr	r3, [r7, #12]
20011d3a:	681b      	ldr	r3, [r3, #0]
20011d3c:	430a      	orrs	r2, r1
20011d3e:	605a      	str	r2, [r3, #4]
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
20011d40:	bf00      	nop
20011d42:	3710      	adds	r7, #16
20011d44:	46bd      	mov	sp, r7
20011d46:	bd80      	pop	{r7, pc}
20011d48:	40005400 	.word	0x40005400
20011d4c:	40005800 	.word	0x40005800
20011d50:	40005c00 	.word	0x40005c00
20011d54:	58001c00 	.word	0x58001c00
20011d58:	2001c180 	.word	0x2001c180
20011d5c:	80004000 	.word	0x80004000
20011d60:	80002400 	.word	0x80002400
20011d64:	80002000 	.word	0x80002000
20011d68:	03ff63ff 	.word	0x03ff63ff

20011d6c <I2C_Enable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
20011d6c:	b480      	push	{r7}
20011d6e:	b085      	sub	sp, #20
20011d70:	af00      	add	r7, sp, #0
20011d72:	6078      	str	r0, [r7, #4]
20011d74:	460b      	mov	r3, r1
20011d76:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
20011d78:	2300      	movs	r3, #0
20011d7a:	60fb      	str	r3, [r7, #12]

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
20011d7c:	687b      	ldr	r3, [r7, #4]
20011d7e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20011d80:	4a2a      	ldr	r2, [pc, #168]	; (20011e2c <I2C_Enable_IRQ+0xc0>)
20011d82:	4293      	cmp	r3, r2
20011d84:	d004      	beq.n	20011d90 <I2C_Enable_IRQ+0x24>
      (hi2c->XferISR == I2C_Slave_ISR_DMA))
20011d86:	687b      	ldr	r3, [r7, #4]
20011d88:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
20011d8a:	4a29      	ldr	r2, [pc, #164]	; (20011e30 <I2C_Enable_IRQ+0xc4>)
20011d8c:	4293      	cmp	r3, r2
20011d8e:	d11d      	bne.n	20011dcc <I2C_Enable_IRQ+0x60>
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
20011d90:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
20011d94:	2b00      	cmp	r3, #0
20011d96:	da03      	bge.n	20011da0 <I2C_Enable_IRQ+0x34>
    {
      /* Enable ERR, STOP, NACK and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
20011d98:	68fb      	ldr	r3, [r7, #12]
20011d9a:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
20011d9e:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_ERROR_IT)
20011da0:	887b      	ldrh	r3, [r7, #2]
20011da2:	2b10      	cmp	r3, #16
20011da4:	d103      	bne.n	20011dae <I2C_Enable_IRQ+0x42>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
20011da6:	68fb      	ldr	r3, [r7, #12]
20011da8:	f043 0390 	orr.w	r3, r3, #144	; 0x90
20011dac:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
20011dae:	887b      	ldrh	r3, [r7, #2]
20011db0:	2b20      	cmp	r3, #32
20011db2:	d103      	bne.n	20011dbc <I2C_Enable_IRQ+0x50>
    {
      /* Enable STOP interrupts */
      tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);
20011db4:	68fb      	ldr	r3, [r7, #12]
20011db6:	f043 0360 	orr.w	r3, r3, #96	; 0x60
20011dba:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_RELOAD_IT)
20011dbc:	887b      	ldrh	r3, [r7, #2]
20011dbe:	2b40      	cmp	r3, #64	; 0x40
20011dc0:	d125      	bne.n	20011e0e <I2C_Enable_IRQ+0xa2>
    {
      /* Enable TC interrupts */
      tmpisr |= I2C_IT_TCI;
20011dc2:	68fb      	ldr	r3, [r7, #12]
20011dc4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20011dc8:	60fb      	str	r3, [r7, #12]
    if (InterruptRequest == I2C_XFER_RELOAD_IT)
20011dca:	e020      	b.n	20011e0e <I2C_Enable_IRQ+0xa2>
    }
  }
  else
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
20011dcc:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
20011dd0:	2b00      	cmp	r3, #0
20011dd2:	da03      	bge.n	20011ddc <I2C_Enable_IRQ+0x70>
    {
      /* Enable ERR, STOP, NACK, and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
20011dd4:	68fb      	ldr	r3, [r7, #12]
20011dd6:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
20011dda:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
20011ddc:	887b      	ldrh	r3, [r7, #2]
20011dde:	f003 0301 	and.w	r3, r3, #1
20011de2:	2b00      	cmp	r3, #0
20011de4:	d003      	beq.n	20011dee <I2C_Enable_IRQ+0x82>
    {
      /* Enable ERR, TC, STOP, NACK and RXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
20011de6:	68fb      	ldr	r3, [r7, #12]
20011de8:	f043 03f2 	orr.w	r3, r3, #242	; 0xf2
20011dec:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
20011dee:	887b      	ldrh	r3, [r7, #2]
20011df0:	f003 0302 	and.w	r3, r3, #2
20011df4:	2b00      	cmp	r3, #0
20011df6:	d003      	beq.n	20011e00 <I2C_Enable_IRQ+0x94>
    {
      /* Enable ERR, TC, STOP, NACK and TXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
20011df8:	68fb      	ldr	r3, [r7, #12]
20011dfa:	f043 03f4 	orr.w	r3, r3, #244	; 0xf4
20011dfe:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
20011e00:	887b      	ldrh	r3, [r7, #2]
20011e02:	2b20      	cmp	r3, #32
20011e04:	d103      	bne.n	20011e0e <I2C_Enable_IRQ+0xa2>
    {
      /* Enable STOP interrupts */
      tmpisr |= I2C_IT_STOPI;
20011e06:	68fb      	ldr	r3, [r7, #12]
20011e08:	f043 0320 	orr.w	r3, r3, #32
20011e0c:	60fb      	str	r3, [r7, #12]
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
20011e0e:	687b      	ldr	r3, [r7, #4]
20011e10:	681b      	ldr	r3, [r3, #0]
20011e12:	6819      	ldr	r1, [r3, #0]
20011e14:	687b      	ldr	r3, [r7, #4]
20011e16:	681b      	ldr	r3, [r3, #0]
20011e18:	68fa      	ldr	r2, [r7, #12]
20011e1a:	430a      	orrs	r2, r1
20011e1c:	601a      	str	r2, [r3, #0]
}
20011e1e:	bf00      	nop
20011e20:	3714      	adds	r7, #20
20011e22:	46bd      	mov	sp, r7
20011e24:	f85d 7b04 	ldr.w	r7, [sp], #4
20011e28:	4770      	bx	lr
20011e2a:	bf00      	nop
20011e2c:	2001024b 	.word	0x2001024b
20011e30:	20010431 	.word	0x20010431

20011e34 <I2C_Disable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
20011e34:	b480      	push	{r7}
20011e36:	b085      	sub	sp, #20
20011e38:	af00      	add	r7, sp, #0
20011e3a:	6078      	str	r0, [r7, #4]
20011e3c:	460b      	mov	r3, r1
20011e3e:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
20011e40:	2300      	movs	r3, #0
20011e42:	60fb      	str	r3, [r7, #12]

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
20011e44:	887b      	ldrh	r3, [r7, #2]
20011e46:	f003 0301 	and.w	r3, r3, #1
20011e4a:	2b00      	cmp	r3, #0
20011e4c:	d00f      	beq.n	20011e6e <I2C_Disable_IRQ+0x3a>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
20011e4e:	68fb      	ldr	r3, [r7, #12]
20011e50:	f043 0342 	orr.w	r3, r3, #66	; 0x42
20011e54:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
20011e56:	687b      	ldr	r3, [r7, #4]
20011e58:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20011e5c:	b2db      	uxtb	r3, r3
20011e5e:	f003 0328 	and.w	r3, r3, #40	; 0x28
20011e62:	2b28      	cmp	r3, #40	; 0x28
20011e64:	d003      	beq.n	20011e6e <I2C_Disable_IRQ+0x3a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
20011e66:	68fb      	ldr	r3, [r7, #12]
20011e68:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
20011e6c:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
20011e6e:	887b      	ldrh	r3, [r7, #2]
20011e70:	f003 0302 	and.w	r3, r3, #2
20011e74:	2b00      	cmp	r3, #0
20011e76:	d00f      	beq.n	20011e98 <I2C_Disable_IRQ+0x64>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
20011e78:	68fb      	ldr	r3, [r7, #12]
20011e7a:	f043 0344 	orr.w	r3, r3, #68	; 0x44
20011e7e:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
20011e80:	687b      	ldr	r3, [r7, #4]
20011e82:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20011e86:	b2db      	uxtb	r3, r3
20011e88:	f003 0328 	and.w	r3, r3, #40	; 0x28
20011e8c:	2b28      	cmp	r3, #40	; 0x28
20011e8e:	d003      	beq.n	20011e98 <I2C_Disable_IRQ+0x64>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
20011e90:	68fb      	ldr	r3, [r7, #12]
20011e92:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
20011e96:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
20011e98:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
20011e9c:	2b00      	cmp	r3, #0
20011e9e:	da03      	bge.n	20011ea8 <I2C_Disable_IRQ+0x74>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
20011ea0:	68fb      	ldr	r3, [r7, #12]
20011ea2:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
20011ea6:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_ERROR_IT)
20011ea8:	887b      	ldrh	r3, [r7, #2]
20011eaa:	2b10      	cmp	r3, #16
20011eac:	d103      	bne.n	20011eb6 <I2C_Disable_IRQ+0x82>
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
20011eae:	68fb      	ldr	r3, [r7, #12]
20011eb0:	f043 0390 	orr.w	r3, r3, #144	; 0x90
20011eb4:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_CPLT_IT)
20011eb6:	887b      	ldrh	r3, [r7, #2]
20011eb8:	2b20      	cmp	r3, #32
20011eba:	d103      	bne.n	20011ec4 <I2C_Disable_IRQ+0x90>
  {
    /* Enable STOP interrupts */
    tmpisr |= I2C_IT_STOPI;
20011ebc:	68fb      	ldr	r3, [r7, #12]
20011ebe:	f043 0320 	orr.w	r3, r3, #32
20011ec2:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_RELOAD_IT)
20011ec4:	887b      	ldrh	r3, [r7, #2]
20011ec6:	2b40      	cmp	r3, #64	; 0x40
20011ec8:	d103      	bne.n	20011ed2 <I2C_Disable_IRQ+0x9e>
  {
    /* Enable TC interrupts */
    tmpisr |= I2C_IT_TCI;
20011eca:	68fb      	ldr	r3, [r7, #12]
20011ecc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20011ed0:	60fb      	str	r3, [r7, #12]
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
20011ed2:	687b      	ldr	r3, [r7, #4]
20011ed4:	681b      	ldr	r3, [r3, #0]
20011ed6:	6819      	ldr	r1, [r3, #0]
20011ed8:	68fb      	ldr	r3, [r7, #12]
20011eda:	43da      	mvns	r2, r3
20011edc:	687b      	ldr	r3, [r7, #4]
20011ede:	681b      	ldr	r3, [r3, #0]
20011ee0:	400a      	ands	r2, r1
20011ee2:	601a      	str	r2, [r3, #0]
}
20011ee4:	bf00      	nop
20011ee6:	3714      	adds	r7, #20
20011ee8:	46bd      	mov	sp, r7
20011eea:	f85d 7b04 	ldr.w	r7, [sp], #4
20011eee:	4770      	bx	lr

20011ef0 <I2C_ConvertOtherXferOptions>:
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functionnal XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
20011ef0:	b480      	push	{r7}
20011ef2:	b083      	sub	sp, #12
20011ef4:	af00      	add	r7, sp, #0
20011ef6:	6078      	str	r0, [r7, #4]
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
20011ef8:	687b      	ldr	r3, [r7, #4]
20011efa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20011efc:	2baa      	cmp	r3, #170	; 0xaa
20011efe:	d103      	bne.n	20011f08 <I2C_ConvertOtherXferOptions+0x18>
  {
    hi2c->XferOptions = I2C_FIRST_FRAME;
20011f00:	687b      	ldr	r3, [r7, #4]
20011f02:	2200      	movs	r2, #0
20011f04:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  else
  {
    /* Nothing to do */
  }
}
20011f06:	e008      	b.n	20011f1a <I2C_ConvertOtherXferOptions+0x2a>
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
20011f08:	687b      	ldr	r3, [r7, #4]
20011f0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20011f0c:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
20011f10:	d103      	bne.n	20011f1a <I2C_ConvertOtherXferOptions+0x2a>
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
20011f12:	687b      	ldr	r3, [r7, #4]
20011f14:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
20011f18:	62da      	str	r2, [r3, #44]	; 0x2c
}
20011f1a:	bf00      	nop
20011f1c:	370c      	adds	r7, #12
20011f1e:	46bd      	mov	sp, r7
20011f20:	f85d 7b04 	ldr.w	r7, [sp], #4
20011f24:	4770      	bx	lr
	...

20011f28 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
20011f28:	b580      	push	{r7, lr}
20011f2a:	b082      	sub	sp, #8
20011f2c:	af00      	add	r7, sp, #0
20011f2e:	6078      	str	r0, [r7, #4]
20011f30:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
20011f32:	687b      	ldr	r3, [r7, #4]
20011f34:	681b      	ldr	r3, [r3, #0]
20011f36:	4a32      	ldr	r2, [pc, #200]	; (20012000 <HAL_I2CEx_ConfigAnalogFilter+0xd8>)
20011f38:	4293      	cmp	r3, r2
20011f3a:	d012      	beq.n	20011f62 <HAL_I2CEx_ConfigAnalogFilter+0x3a>
20011f3c:	687b      	ldr	r3, [r7, #4]
20011f3e:	681b      	ldr	r3, [r3, #0]
20011f40:	4a30      	ldr	r2, [pc, #192]	; (20012004 <HAL_I2CEx_ConfigAnalogFilter+0xdc>)
20011f42:	4293      	cmp	r3, r2
20011f44:	d00d      	beq.n	20011f62 <HAL_I2CEx_ConfigAnalogFilter+0x3a>
20011f46:	687b      	ldr	r3, [r7, #4]
20011f48:	681b      	ldr	r3, [r3, #0]
20011f4a:	4a2f      	ldr	r2, [pc, #188]	; (20012008 <HAL_I2CEx_ConfigAnalogFilter+0xe0>)
20011f4c:	4293      	cmp	r3, r2
20011f4e:	d008      	beq.n	20011f62 <HAL_I2CEx_ConfigAnalogFilter+0x3a>
20011f50:	687b      	ldr	r3, [r7, #4]
20011f52:	681b      	ldr	r3, [r3, #0]
20011f54:	4a2d      	ldr	r2, [pc, #180]	; (2001200c <HAL_I2CEx_ConfigAnalogFilter+0xe4>)
20011f56:	4293      	cmp	r3, r2
20011f58:	d003      	beq.n	20011f62 <HAL_I2CEx_ConfigAnalogFilter+0x3a>
20011f5a:	2164      	movs	r1, #100	; 0x64
20011f5c:	482c      	ldr	r0, [pc, #176]	; (20012010 <HAL_I2CEx_ConfigAnalogFilter+0xe8>)
20011f5e:	f7ee fcc9 	bl	200008f4 <assert_failed>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
20011f62:	683b      	ldr	r3, [r7, #0]
20011f64:	2b00      	cmp	r3, #0
20011f66:	d007      	beq.n	20011f78 <HAL_I2CEx_ConfigAnalogFilter+0x50>
20011f68:	683b      	ldr	r3, [r7, #0]
20011f6a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20011f6e:	d003      	beq.n	20011f78 <HAL_I2CEx_ConfigAnalogFilter+0x50>
20011f70:	2165      	movs	r1, #101	; 0x65
20011f72:	4827      	ldr	r0, [pc, #156]	; (20012010 <HAL_I2CEx_ConfigAnalogFilter+0xe8>)
20011f74:	f7ee fcbe 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
20011f78:	687b      	ldr	r3, [r7, #4]
20011f7a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20011f7e:	b2db      	uxtb	r3, r3
20011f80:	2b20      	cmp	r3, #32
20011f82:	d138      	bne.n	20011ff6 <HAL_I2CEx_ConfigAnalogFilter+0xce>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
20011f84:	687b      	ldr	r3, [r7, #4]
20011f86:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20011f8a:	2b01      	cmp	r3, #1
20011f8c:	d101      	bne.n	20011f92 <HAL_I2CEx_ConfigAnalogFilter+0x6a>
20011f8e:	2302      	movs	r3, #2
20011f90:	e032      	b.n	20011ff8 <HAL_I2CEx_ConfigAnalogFilter+0xd0>
20011f92:	687b      	ldr	r3, [r7, #4]
20011f94:	2201      	movs	r2, #1
20011f96:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
20011f9a:	687b      	ldr	r3, [r7, #4]
20011f9c:	2224      	movs	r2, #36	; 0x24
20011f9e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
20011fa2:	687b      	ldr	r3, [r7, #4]
20011fa4:	681b      	ldr	r3, [r3, #0]
20011fa6:	681a      	ldr	r2, [r3, #0]
20011fa8:	687b      	ldr	r3, [r7, #4]
20011faa:	681b      	ldr	r3, [r3, #0]
20011fac:	f022 0201 	bic.w	r2, r2, #1
20011fb0:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
20011fb2:	687b      	ldr	r3, [r7, #4]
20011fb4:	681b      	ldr	r3, [r3, #0]
20011fb6:	681a      	ldr	r2, [r3, #0]
20011fb8:	687b      	ldr	r3, [r7, #4]
20011fba:	681b      	ldr	r3, [r3, #0]
20011fbc:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
20011fc0:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
20011fc2:	687b      	ldr	r3, [r7, #4]
20011fc4:	681b      	ldr	r3, [r3, #0]
20011fc6:	6819      	ldr	r1, [r3, #0]
20011fc8:	687b      	ldr	r3, [r7, #4]
20011fca:	681b      	ldr	r3, [r3, #0]
20011fcc:	683a      	ldr	r2, [r7, #0]
20011fce:	430a      	orrs	r2, r1
20011fd0:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
20011fd2:	687b      	ldr	r3, [r7, #4]
20011fd4:	681b      	ldr	r3, [r3, #0]
20011fd6:	681a      	ldr	r2, [r3, #0]
20011fd8:	687b      	ldr	r3, [r7, #4]
20011fda:	681b      	ldr	r3, [r3, #0]
20011fdc:	f042 0201 	orr.w	r2, r2, #1
20011fe0:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
20011fe2:	687b      	ldr	r3, [r7, #4]
20011fe4:	2220      	movs	r2, #32
20011fe6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20011fea:	687b      	ldr	r3, [r7, #4]
20011fec:	2200      	movs	r2, #0
20011fee:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
20011ff2:	2300      	movs	r3, #0
20011ff4:	e000      	b.n	20011ff8 <HAL_I2CEx_ConfigAnalogFilter+0xd0>
  }
  else
  {
    return HAL_BUSY;
20011ff6:	2302      	movs	r3, #2
  }
}
20011ff8:	4618      	mov	r0, r3
20011ffa:	3708      	adds	r7, #8
20011ffc:	46bd      	mov	sp, r7
20011ffe:	bd80      	pop	{r7, pc}
20012000:	40005400 	.word	0x40005400
20012004:	40005800 	.word	0x40005800
20012008:	40005c00 	.word	0x40005c00
2001200c:	58001c00 	.word	0x58001c00
20012010:	2001c1b8 	.word	0x2001c1b8

20012014 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
20012014:	b580      	push	{r7, lr}
20012016:	b084      	sub	sp, #16
20012018:	af00      	add	r7, sp, #0
2001201a:	6078      	str	r0, [r7, #4]
2001201c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
2001201e:	687b      	ldr	r3, [r7, #4]
20012020:	681b      	ldr	r3, [r3, #0]
20012022:	4a31      	ldr	r2, [pc, #196]	; (200120e8 <HAL_I2CEx_ConfigDigitalFilter+0xd4>)
20012024:	4293      	cmp	r3, r2
20012026:	d012      	beq.n	2001204e <HAL_I2CEx_ConfigDigitalFilter+0x3a>
20012028:	687b      	ldr	r3, [r7, #4]
2001202a:	681b      	ldr	r3, [r3, #0]
2001202c:	4a2f      	ldr	r2, [pc, #188]	; (200120ec <HAL_I2CEx_ConfigDigitalFilter+0xd8>)
2001202e:	4293      	cmp	r3, r2
20012030:	d00d      	beq.n	2001204e <HAL_I2CEx_ConfigDigitalFilter+0x3a>
20012032:	687b      	ldr	r3, [r7, #4]
20012034:	681b      	ldr	r3, [r3, #0]
20012036:	4a2e      	ldr	r2, [pc, #184]	; (200120f0 <HAL_I2CEx_ConfigDigitalFilter+0xdc>)
20012038:	4293      	cmp	r3, r2
2001203a:	d008      	beq.n	2001204e <HAL_I2CEx_ConfigDigitalFilter+0x3a>
2001203c:	687b      	ldr	r3, [r7, #4]
2001203e:	681b      	ldr	r3, [r3, #0]
20012040:	4a2c      	ldr	r2, [pc, #176]	; (200120f4 <HAL_I2CEx_ConfigDigitalFilter+0xe0>)
20012042:	4293      	cmp	r3, r2
20012044:	d003      	beq.n	2001204e <HAL_I2CEx_ConfigDigitalFilter+0x3a>
20012046:	2192      	movs	r1, #146	; 0x92
20012048:	482b      	ldr	r0, [pc, #172]	; (200120f8 <HAL_I2CEx_ConfigDigitalFilter+0xe4>)
2001204a:	f7ee fc53 	bl	200008f4 <assert_failed>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
2001204e:	683b      	ldr	r3, [r7, #0]
20012050:	2b0f      	cmp	r3, #15
20012052:	d903      	bls.n	2001205c <HAL_I2CEx_ConfigDigitalFilter+0x48>
20012054:	2193      	movs	r1, #147	; 0x93
20012056:	4828      	ldr	r0, [pc, #160]	; (200120f8 <HAL_I2CEx_ConfigDigitalFilter+0xe4>)
20012058:	f7ee fc4c 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
2001205c:	687b      	ldr	r3, [r7, #4]
2001205e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20012062:	b2db      	uxtb	r3, r3
20012064:	2b20      	cmp	r3, #32
20012066:	d139      	bne.n	200120dc <HAL_I2CEx_ConfigDigitalFilter+0xc8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
20012068:	687b      	ldr	r3, [r7, #4]
2001206a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2001206e:	2b01      	cmp	r3, #1
20012070:	d101      	bne.n	20012076 <HAL_I2CEx_ConfigDigitalFilter+0x62>
20012072:	2302      	movs	r3, #2
20012074:	e033      	b.n	200120de <HAL_I2CEx_ConfigDigitalFilter+0xca>
20012076:	687b      	ldr	r3, [r7, #4]
20012078:	2201      	movs	r2, #1
2001207a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2001207e:	687b      	ldr	r3, [r7, #4]
20012080:	2224      	movs	r2, #36	; 0x24
20012082:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
20012086:	687b      	ldr	r3, [r7, #4]
20012088:	681b      	ldr	r3, [r3, #0]
2001208a:	681a      	ldr	r2, [r3, #0]
2001208c:	687b      	ldr	r3, [r7, #4]
2001208e:	681b      	ldr	r3, [r3, #0]
20012090:	f022 0201 	bic.w	r2, r2, #1
20012094:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
20012096:	687b      	ldr	r3, [r7, #4]
20012098:	681b      	ldr	r3, [r3, #0]
2001209a:	681b      	ldr	r3, [r3, #0]
2001209c:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
2001209e:	68fb      	ldr	r3, [r7, #12]
200120a0:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
200120a4:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
200120a6:	683b      	ldr	r3, [r7, #0]
200120a8:	021b      	lsls	r3, r3, #8
200120aa:	68fa      	ldr	r2, [r7, #12]
200120ac:	4313      	orrs	r3, r2
200120ae:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
200120b0:	687b      	ldr	r3, [r7, #4]
200120b2:	681b      	ldr	r3, [r3, #0]
200120b4:	68fa      	ldr	r2, [r7, #12]
200120b6:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
200120b8:	687b      	ldr	r3, [r7, #4]
200120ba:	681b      	ldr	r3, [r3, #0]
200120bc:	681a      	ldr	r2, [r3, #0]
200120be:	687b      	ldr	r3, [r7, #4]
200120c0:	681b      	ldr	r3, [r3, #0]
200120c2:	f042 0201 	orr.w	r2, r2, #1
200120c6:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
200120c8:	687b      	ldr	r3, [r7, #4]
200120ca:	2220      	movs	r2, #32
200120cc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
200120d0:	687b      	ldr	r3, [r7, #4]
200120d2:	2200      	movs	r2, #0
200120d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
200120d8:	2300      	movs	r3, #0
200120da:	e000      	b.n	200120de <HAL_I2CEx_ConfigDigitalFilter+0xca>
  }
  else
  {
    return HAL_BUSY;
200120dc:	2302      	movs	r3, #2
  }
}
200120de:	4618      	mov	r0, r3
200120e0:	3710      	adds	r7, #16
200120e2:	46bd      	mov	sp, r7
200120e4:	bd80      	pop	{r7, pc}
200120e6:	bf00      	nop
200120e8:	40005400 	.word	0x40005400
200120ec:	40005800 	.word	0x40005800
200120f0:	40005c00 	.word	0x40005c00
200120f4:	58001c00 	.word	0x58001c00
200120f8:	2001c1b8 	.word	0x2001c1b8

200120fc <HAL_I2CEx_EnableWakeUp>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_EnableWakeUp(I2C_HandleTypeDef *hi2c)
{
200120fc:	b580      	push	{r7, lr}
200120fe:	b082      	sub	sp, #8
20012100:	af00      	add	r7, sp, #0
20012102:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));
20012104:	687b      	ldr	r3, [r7, #4]
20012106:	681b      	ldr	r3, [r3, #0]
20012108:	4a28      	ldr	r2, [pc, #160]	; (200121ac <HAL_I2CEx_EnableWakeUp+0xb0>)
2001210a:	4293      	cmp	r3, r2
2001210c:	d012      	beq.n	20012134 <HAL_I2CEx_EnableWakeUp+0x38>
2001210e:	687b      	ldr	r3, [r7, #4]
20012110:	681b      	ldr	r3, [r3, #0]
20012112:	4a27      	ldr	r2, [pc, #156]	; (200121b0 <HAL_I2CEx_EnableWakeUp+0xb4>)
20012114:	4293      	cmp	r3, r2
20012116:	d00d      	beq.n	20012134 <HAL_I2CEx_EnableWakeUp+0x38>
20012118:	687b      	ldr	r3, [r7, #4]
2001211a:	681b      	ldr	r3, [r3, #0]
2001211c:	4a25      	ldr	r2, [pc, #148]	; (200121b4 <HAL_I2CEx_EnableWakeUp+0xb8>)
2001211e:	4293      	cmp	r3, r2
20012120:	d008      	beq.n	20012134 <HAL_I2CEx_EnableWakeUp+0x38>
20012122:	687b      	ldr	r3, [r7, #4]
20012124:	681b      	ldr	r3, [r3, #0]
20012126:	4a24      	ldr	r2, [pc, #144]	; (200121b8 <HAL_I2CEx_EnableWakeUp+0xbc>)
20012128:	4293      	cmp	r3, r2
2001212a:	d003      	beq.n	20012134 <HAL_I2CEx_EnableWakeUp+0x38>
2001212c:	21c3      	movs	r1, #195	; 0xc3
2001212e:	4823      	ldr	r0, [pc, #140]	; (200121bc <HAL_I2CEx_EnableWakeUp+0xc0>)
20012130:	f7ee fbe0 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
20012134:	687b      	ldr	r3, [r7, #4]
20012136:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2001213a:	b2db      	uxtb	r3, r3
2001213c:	2b20      	cmp	r3, #32
2001213e:	d130      	bne.n	200121a2 <HAL_I2CEx_EnableWakeUp+0xa6>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
20012140:	687b      	ldr	r3, [r7, #4]
20012142:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20012146:	2b01      	cmp	r3, #1
20012148:	d101      	bne.n	2001214e <HAL_I2CEx_EnableWakeUp+0x52>
2001214a:	2302      	movs	r3, #2
2001214c:	e02a      	b.n	200121a4 <HAL_I2CEx_EnableWakeUp+0xa8>
2001214e:	687b      	ldr	r3, [r7, #4]
20012150:	2201      	movs	r2, #1
20012152:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
20012156:	687b      	ldr	r3, [r7, #4]
20012158:	2224      	movs	r2, #36	; 0x24
2001215a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2001215e:	687b      	ldr	r3, [r7, #4]
20012160:	681b      	ldr	r3, [r3, #0]
20012162:	681a      	ldr	r2, [r3, #0]
20012164:	687b      	ldr	r3, [r7, #4]
20012166:	681b      	ldr	r3, [r3, #0]
20012168:	f022 0201 	bic.w	r2, r2, #1
2001216c:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 |= I2C_CR1_WUPEN;
2001216e:	687b      	ldr	r3, [r7, #4]
20012170:	681b      	ldr	r3, [r3, #0]
20012172:	681a      	ldr	r2, [r3, #0]
20012174:	687b      	ldr	r3, [r7, #4]
20012176:	681b      	ldr	r3, [r3, #0]
20012178:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
2001217c:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2001217e:	687b      	ldr	r3, [r7, #4]
20012180:	681b      	ldr	r3, [r3, #0]
20012182:	681a      	ldr	r2, [r3, #0]
20012184:	687b      	ldr	r3, [r7, #4]
20012186:	681b      	ldr	r3, [r3, #0]
20012188:	f042 0201 	orr.w	r2, r2, #1
2001218c:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2001218e:	687b      	ldr	r3, [r7, #4]
20012190:	2220      	movs	r2, #32
20012192:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20012196:	687b      	ldr	r3, [r7, #4]
20012198:	2200      	movs	r2, #0
2001219a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2001219e:	2300      	movs	r3, #0
200121a0:	e000      	b.n	200121a4 <HAL_I2CEx_EnableWakeUp+0xa8>
  }
  else
  {
    return HAL_BUSY;
200121a2:	2302      	movs	r3, #2
  }
}
200121a4:	4618      	mov	r0, r3
200121a6:	3708      	adds	r7, #8
200121a8:	46bd      	mov	sp, r7
200121aa:	bd80      	pop	{r7, pc}
200121ac:	40005400 	.word	0x40005400
200121b0:	40005800 	.word	0x40005800
200121b4:	40005c00 	.word	0x40005c00
200121b8:	58001c00 	.word	0x58001c00
200121bc:	2001c1b8 	.word	0x2001c1b8

200121c0 <HAL_I2CEx_DisableWakeUp>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_DisableWakeUp(I2C_HandleTypeDef *hi2c)
{
200121c0:	b580      	push	{r7, lr}
200121c2:	b082      	sub	sp, #8
200121c4:	af00      	add	r7, sp, #0
200121c6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));
200121c8:	687b      	ldr	r3, [r7, #4]
200121ca:	681b      	ldr	r3, [r3, #0]
200121cc:	4a28      	ldr	r2, [pc, #160]	; (20012270 <HAL_I2CEx_DisableWakeUp+0xb0>)
200121ce:	4293      	cmp	r3, r2
200121d0:	d012      	beq.n	200121f8 <HAL_I2CEx_DisableWakeUp+0x38>
200121d2:	687b      	ldr	r3, [r7, #4]
200121d4:	681b      	ldr	r3, [r3, #0]
200121d6:	4a27      	ldr	r2, [pc, #156]	; (20012274 <HAL_I2CEx_DisableWakeUp+0xb4>)
200121d8:	4293      	cmp	r3, r2
200121da:	d00d      	beq.n	200121f8 <HAL_I2CEx_DisableWakeUp+0x38>
200121dc:	687b      	ldr	r3, [r7, #4]
200121de:	681b      	ldr	r3, [r3, #0]
200121e0:	4a25      	ldr	r2, [pc, #148]	; (20012278 <HAL_I2CEx_DisableWakeUp+0xb8>)
200121e2:	4293      	cmp	r3, r2
200121e4:	d008      	beq.n	200121f8 <HAL_I2CEx_DisableWakeUp+0x38>
200121e6:	687b      	ldr	r3, [r7, #4]
200121e8:	681b      	ldr	r3, [r3, #0]
200121ea:	4a24      	ldr	r2, [pc, #144]	; (2001227c <HAL_I2CEx_DisableWakeUp+0xbc>)
200121ec:	4293      	cmp	r3, r2
200121ee:	d003      	beq.n	200121f8 <HAL_I2CEx_DisableWakeUp+0x38>
200121f0:	21ea      	movs	r1, #234	; 0xea
200121f2:	4823      	ldr	r0, [pc, #140]	; (20012280 <HAL_I2CEx_DisableWakeUp+0xc0>)
200121f4:	f7ee fb7e 	bl	200008f4 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
200121f8:	687b      	ldr	r3, [r7, #4]
200121fa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200121fe:	b2db      	uxtb	r3, r3
20012200:	2b20      	cmp	r3, #32
20012202:	d130      	bne.n	20012266 <HAL_I2CEx_DisableWakeUp+0xa6>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
20012204:	687b      	ldr	r3, [r7, #4]
20012206:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2001220a:	2b01      	cmp	r3, #1
2001220c:	d101      	bne.n	20012212 <HAL_I2CEx_DisableWakeUp+0x52>
2001220e:	2302      	movs	r3, #2
20012210:	e02a      	b.n	20012268 <HAL_I2CEx_DisableWakeUp+0xa8>
20012212:	687b      	ldr	r3, [r7, #4]
20012214:	2201      	movs	r2, #1
20012216:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2001221a:	687b      	ldr	r3, [r7, #4]
2001221c:	2224      	movs	r2, #36	; 0x24
2001221e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
20012222:	687b      	ldr	r3, [r7, #4]
20012224:	681b      	ldr	r3, [r3, #0]
20012226:	681a      	ldr	r2, [r3, #0]
20012228:	687b      	ldr	r3, [r7, #4]
2001222a:	681b      	ldr	r3, [r3, #0]
2001222c:	f022 0201 	bic.w	r2, r2, #1
20012230:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 &= ~(I2C_CR1_WUPEN);
20012232:	687b      	ldr	r3, [r7, #4]
20012234:	681b      	ldr	r3, [r3, #0]
20012236:	681a      	ldr	r2, [r3, #0]
20012238:	687b      	ldr	r3, [r7, #4]
2001223a:	681b      	ldr	r3, [r3, #0]
2001223c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
20012240:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
20012242:	687b      	ldr	r3, [r7, #4]
20012244:	681b      	ldr	r3, [r3, #0]
20012246:	681a      	ldr	r2, [r3, #0]
20012248:	687b      	ldr	r3, [r7, #4]
2001224a:	681b      	ldr	r3, [r3, #0]
2001224c:	f042 0201 	orr.w	r2, r2, #1
20012250:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
20012252:	687b      	ldr	r3, [r7, #4]
20012254:	2220      	movs	r2, #32
20012256:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2001225a:	687b      	ldr	r3, [r7, #4]
2001225c:	2200      	movs	r2, #0
2001225e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
20012262:	2300      	movs	r3, #0
20012264:	e000      	b.n	20012268 <HAL_I2CEx_DisableWakeUp+0xa8>
  }
  else
  {
    return HAL_BUSY;
20012266:	2302      	movs	r3, #2
  }
}
20012268:	4618      	mov	r0, r3
2001226a:	3708      	adds	r7, #8
2001226c:	46bd      	mov	sp, r7
2001226e:	bd80      	pop	{r7, pc}
20012270:	40005400 	.word	0x40005400
20012274:	40005800 	.word	0x40005800
20012278:	40005c00 	.word	0x40005c00
2001227c:	58001c00 	.word	0x58001c00
20012280:	2001c1b8 	.word	0x2001c1b8

20012284 <HAL_I2CEx_EnableFastModePlus>:
  * @note  For all I2C4 pins fast mode plus driving capability can be enabled
  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.
  * @retval None
  */
void HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus)
{
20012284:	b580      	push	{r7, lr}
20012286:	b084      	sub	sp, #16
20012288:	af00      	add	r7, sp, #0
2001228a:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));
2001228c:	687b      	ldr	r3, [r7, #4]
2001228e:	f003 0310 	and.w	r3, r3, #16
20012292:	2b00      	cmp	r3, #0
20012294:	d127      	bne.n	200122e6 <HAL_I2CEx_EnableFastModePlus+0x62>
20012296:	687b      	ldr	r3, [r7, #4]
20012298:	f003 0320 	and.w	r3, r3, #32
2001229c:	2b00      	cmp	r3, #0
2001229e:	d122      	bne.n	200122e6 <HAL_I2CEx_EnableFastModePlus+0x62>
200122a0:	687b      	ldr	r3, [r7, #4]
200122a2:	f003 0340 	and.w	r3, r3, #64	; 0x40
200122a6:	2b00      	cmp	r3, #0
200122a8:	d11d      	bne.n	200122e6 <HAL_I2CEx_EnableFastModePlus+0x62>
200122aa:	687b      	ldr	r3, [r7, #4]
200122ac:	f003 0380 	and.w	r3, r3, #128	; 0x80
200122b0:	2b00      	cmp	r3, #0
200122b2:	d118      	bne.n	200122e6 <HAL_I2CEx_EnableFastModePlus+0x62>
200122b4:	687b      	ldr	r3, [r7, #4]
200122b6:	f003 0301 	and.w	r3, r3, #1
200122ba:	2b00      	cmp	r3, #0
200122bc:	d113      	bne.n	200122e6 <HAL_I2CEx_EnableFastModePlus+0x62>
200122be:	687b      	ldr	r3, [r7, #4]
200122c0:	f003 0302 	and.w	r3, r3, #2
200122c4:	2b00      	cmp	r3, #0
200122c6:	d10e      	bne.n	200122e6 <HAL_I2CEx_EnableFastModePlus+0x62>
200122c8:	687b      	ldr	r3, [r7, #4]
200122ca:	f003 0304 	and.w	r3, r3, #4
200122ce:	2b00      	cmp	r3, #0
200122d0:	d109      	bne.n	200122e6 <HAL_I2CEx_EnableFastModePlus+0x62>
200122d2:	687b      	ldr	r3, [r7, #4]
200122d4:	f003 0308 	and.w	r3, r3, #8
200122d8:	2b00      	cmp	r3, #0
200122da:	d104      	bne.n	200122e6 <HAL_I2CEx_EnableFastModePlus+0x62>
200122dc:	f44f 718e 	mov.w	r1, #284	; 0x11c
200122e0:	480d      	ldr	r0, [pc, #52]	; (20012318 <HAL_I2CEx_EnableFastModePlus+0x94>)
200122e2:	f7ee fb07 	bl	200008f4 <assert_failed>

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
200122e6:	4b0d      	ldr	r3, [pc, #52]	; (2001231c <HAL_I2CEx_EnableFastModePlus+0x98>)
200122e8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
200122ec:	4a0b      	ldr	r2, [pc, #44]	; (2001231c <HAL_I2CEx_EnableFastModePlus+0x98>)
200122ee:	f043 0302 	orr.w	r3, r3, #2
200122f2:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
200122f6:	4b09      	ldr	r3, [pc, #36]	; (2001231c <HAL_I2CEx_EnableFastModePlus+0x98>)
200122f8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
200122fc:	f003 0302 	and.w	r3, r3, #2
20012300:	60fb      	str	r3, [r7, #12]
20012302:	68fb      	ldr	r3, [r7, #12]

  /* Enable fast mode plus driving capability for selected pin */
  SET_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
20012304:	4b06      	ldr	r3, [pc, #24]	; (20012320 <HAL_I2CEx_EnableFastModePlus+0x9c>)
20012306:	685a      	ldr	r2, [r3, #4]
20012308:	4905      	ldr	r1, [pc, #20]	; (20012320 <HAL_I2CEx_EnableFastModePlus+0x9c>)
2001230a:	687b      	ldr	r3, [r7, #4]
2001230c:	4313      	orrs	r3, r2
2001230e:	604b      	str	r3, [r1, #4]
}
20012310:	bf00      	nop
20012312:	3710      	adds	r7, #16
20012314:	46bd      	mov	sp, r7
20012316:	bd80      	pop	{r7, pc}
20012318:	2001c1b8 	.word	0x2001c1b8
2001231c:	58024400 	.word	0x58024400
20012320:	58000400 	.word	0x58000400

20012324 <HAL_I2CEx_DisableFastModePlus>:
  * @note  For all I2C4 pins fast mode plus driving capability can be disabled
  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.
  * @retval None
  */
void HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus)
{
20012324:	b580      	push	{r7, lr}
20012326:	b084      	sub	sp, #16
20012328:	af00      	add	r7, sp, #0
2001232a:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));
2001232c:	687b      	ldr	r3, [r7, #4]
2001232e:	f003 0310 	and.w	r3, r3, #16
20012332:	2b00      	cmp	r3, #0
20012334:	d127      	bne.n	20012386 <HAL_I2CEx_DisableFastModePlus+0x62>
20012336:	687b      	ldr	r3, [r7, #4]
20012338:	f003 0320 	and.w	r3, r3, #32
2001233c:	2b00      	cmp	r3, #0
2001233e:	d122      	bne.n	20012386 <HAL_I2CEx_DisableFastModePlus+0x62>
20012340:	687b      	ldr	r3, [r7, #4]
20012342:	f003 0340 	and.w	r3, r3, #64	; 0x40
20012346:	2b00      	cmp	r3, #0
20012348:	d11d      	bne.n	20012386 <HAL_I2CEx_DisableFastModePlus+0x62>
2001234a:	687b      	ldr	r3, [r7, #4]
2001234c:	f003 0380 	and.w	r3, r3, #128	; 0x80
20012350:	2b00      	cmp	r3, #0
20012352:	d118      	bne.n	20012386 <HAL_I2CEx_DisableFastModePlus+0x62>
20012354:	687b      	ldr	r3, [r7, #4]
20012356:	f003 0301 	and.w	r3, r3, #1
2001235a:	2b00      	cmp	r3, #0
2001235c:	d113      	bne.n	20012386 <HAL_I2CEx_DisableFastModePlus+0x62>
2001235e:	687b      	ldr	r3, [r7, #4]
20012360:	f003 0302 	and.w	r3, r3, #2
20012364:	2b00      	cmp	r3, #0
20012366:	d10e      	bne.n	20012386 <HAL_I2CEx_DisableFastModePlus+0x62>
20012368:	687b      	ldr	r3, [r7, #4]
2001236a:	f003 0304 	and.w	r3, r3, #4
2001236e:	2b00      	cmp	r3, #0
20012370:	d109      	bne.n	20012386 <HAL_I2CEx_DisableFastModePlus+0x62>
20012372:	687b      	ldr	r3, [r7, #4]
20012374:	f003 0308 	and.w	r3, r3, #8
20012378:	2b00      	cmp	r3, #0
2001237a:	d104      	bne.n	20012386 <HAL_I2CEx_DisableFastModePlus+0x62>
2001237c:	f240 1139 	movw	r1, #313	; 0x139
20012380:	480e      	ldr	r0, [pc, #56]	; (200123bc <HAL_I2CEx_DisableFastModePlus+0x98>)
20012382:	f7ee fab7 	bl	200008f4 <assert_failed>

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
20012386:	4b0e      	ldr	r3, [pc, #56]	; (200123c0 <HAL_I2CEx_DisableFastModePlus+0x9c>)
20012388:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2001238c:	4a0c      	ldr	r2, [pc, #48]	; (200123c0 <HAL_I2CEx_DisableFastModePlus+0x9c>)
2001238e:	f043 0302 	orr.w	r3, r3, #2
20012392:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
20012396:	4b0a      	ldr	r3, [pc, #40]	; (200123c0 <HAL_I2CEx_DisableFastModePlus+0x9c>)
20012398:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2001239c:	f003 0302 	and.w	r3, r3, #2
200123a0:	60fb      	str	r3, [r7, #12]
200123a2:	68fb      	ldr	r3, [r7, #12]

  /* Disable fast mode plus driving capability for selected pin */
  CLEAR_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
200123a4:	4b07      	ldr	r3, [pc, #28]	; (200123c4 <HAL_I2CEx_DisableFastModePlus+0xa0>)
200123a6:	685a      	ldr	r2, [r3, #4]
200123a8:	687b      	ldr	r3, [r7, #4]
200123aa:	43db      	mvns	r3, r3
200123ac:	4905      	ldr	r1, [pc, #20]	; (200123c4 <HAL_I2CEx_DisableFastModePlus+0xa0>)
200123ae:	4013      	ands	r3, r2
200123b0:	604b      	str	r3, [r1, #4]
}
200123b2:	bf00      	nop
200123b4:	3710      	adds	r7, #16
200123b6:	46bd      	mov	sp, r7
200123b8:	bd80      	pop	{r7, pc}
200123ba:	bf00      	nop
200123bc:	2001c1b8 	.word	0x2001c1b8
200123c0:	58024400 	.word	0x58024400
200123c4:	58000400 	.word	0x58000400

200123c8 <HAL_MDMA_Init>:
  * @param  hmdma: Pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
200123c8:	b580      	push	{r7, lr}
200123ca:	b084      	sub	sp, #16
200123cc:	af00      	add	r7, sp, #0
200123ce:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
200123d0:	f7ef fc8c 	bl	20001cec <HAL_GetTick>
200123d4:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
200123d6:	687b      	ldr	r3, [r7, #4]
200123d8:	2b00      	cmp	r3, #0
200123da:	d101      	bne.n	200123e0 <HAL_MDMA_Init+0x18>
  {
    return HAL_ERROR;
200123dc:	2301      	movs	r3, #1
200123de:	e224      	b.n	2001282a <HAL_MDMA_Init+0x462>
  }

  /* Check the parameters */
  assert_param(IS_MDMA_STREAM_ALL_INSTANCE(hmdma->Instance));
200123e0:	687b      	ldr	r3, [r7, #4]
200123e2:	681b      	ldr	r3, [r3, #0]
200123e4:	4a97      	ldr	r2, [pc, #604]	; (20012644 <HAL_MDMA_Init+0x27c>)
200123e6:	4293      	cmp	r3, r2
200123e8:	d04e      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
200123ea:	687b      	ldr	r3, [r7, #4]
200123ec:	681b      	ldr	r3, [r3, #0]
200123ee:	4a96      	ldr	r2, [pc, #600]	; (20012648 <HAL_MDMA_Init+0x280>)
200123f0:	4293      	cmp	r3, r2
200123f2:	d049      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
200123f4:	687b      	ldr	r3, [r7, #4]
200123f6:	681b      	ldr	r3, [r3, #0]
200123f8:	4a94      	ldr	r2, [pc, #592]	; (2001264c <HAL_MDMA_Init+0x284>)
200123fa:	4293      	cmp	r3, r2
200123fc:	d044      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
200123fe:	687b      	ldr	r3, [r7, #4]
20012400:	681b      	ldr	r3, [r3, #0]
20012402:	4a93      	ldr	r2, [pc, #588]	; (20012650 <HAL_MDMA_Init+0x288>)
20012404:	4293      	cmp	r3, r2
20012406:	d03f      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
20012408:	687b      	ldr	r3, [r7, #4]
2001240a:	681b      	ldr	r3, [r3, #0]
2001240c:	4a91      	ldr	r2, [pc, #580]	; (20012654 <HAL_MDMA_Init+0x28c>)
2001240e:	4293      	cmp	r3, r2
20012410:	d03a      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
20012412:	687b      	ldr	r3, [r7, #4]
20012414:	681b      	ldr	r3, [r3, #0]
20012416:	4a90      	ldr	r2, [pc, #576]	; (20012658 <HAL_MDMA_Init+0x290>)
20012418:	4293      	cmp	r3, r2
2001241a:	d035      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
2001241c:	687b      	ldr	r3, [r7, #4]
2001241e:	681b      	ldr	r3, [r3, #0]
20012420:	4a8e      	ldr	r2, [pc, #568]	; (2001265c <HAL_MDMA_Init+0x294>)
20012422:	4293      	cmp	r3, r2
20012424:	d030      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
20012426:	687b      	ldr	r3, [r7, #4]
20012428:	681b      	ldr	r3, [r3, #0]
2001242a:	4a8d      	ldr	r2, [pc, #564]	; (20012660 <HAL_MDMA_Init+0x298>)
2001242c:	4293      	cmp	r3, r2
2001242e:	d02b      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
20012430:	687b      	ldr	r3, [r7, #4]
20012432:	681b      	ldr	r3, [r3, #0]
20012434:	4a8b      	ldr	r2, [pc, #556]	; (20012664 <HAL_MDMA_Init+0x29c>)
20012436:	4293      	cmp	r3, r2
20012438:	d026      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
2001243a:	687b      	ldr	r3, [r7, #4]
2001243c:	681b      	ldr	r3, [r3, #0]
2001243e:	4a8a      	ldr	r2, [pc, #552]	; (20012668 <HAL_MDMA_Init+0x2a0>)
20012440:	4293      	cmp	r3, r2
20012442:	d021      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
20012444:	687b      	ldr	r3, [r7, #4]
20012446:	681b      	ldr	r3, [r3, #0]
20012448:	4a88      	ldr	r2, [pc, #544]	; (2001266c <HAL_MDMA_Init+0x2a4>)
2001244a:	4293      	cmp	r3, r2
2001244c:	d01c      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
2001244e:	687b      	ldr	r3, [r7, #4]
20012450:	681b      	ldr	r3, [r3, #0]
20012452:	4a87      	ldr	r2, [pc, #540]	; (20012670 <HAL_MDMA_Init+0x2a8>)
20012454:	4293      	cmp	r3, r2
20012456:	d017      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
20012458:	687b      	ldr	r3, [r7, #4]
2001245a:	681b      	ldr	r3, [r3, #0]
2001245c:	4a85      	ldr	r2, [pc, #532]	; (20012674 <HAL_MDMA_Init+0x2ac>)
2001245e:	4293      	cmp	r3, r2
20012460:	d012      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
20012462:	687b      	ldr	r3, [r7, #4]
20012464:	681b      	ldr	r3, [r3, #0]
20012466:	4a84      	ldr	r2, [pc, #528]	; (20012678 <HAL_MDMA_Init+0x2b0>)
20012468:	4293      	cmp	r3, r2
2001246a:	d00d      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
2001246c:	687b      	ldr	r3, [r7, #4]
2001246e:	681b      	ldr	r3, [r3, #0]
20012470:	4a82      	ldr	r2, [pc, #520]	; (2001267c <HAL_MDMA_Init+0x2b4>)
20012472:	4293      	cmp	r3, r2
20012474:	d008      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
20012476:	687b      	ldr	r3, [r7, #4]
20012478:	681b      	ldr	r3, [r3, #0]
2001247a:	4a81      	ldr	r2, [pc, #516]	; (20012680 <HAL_MDMA_Init+0x2b8>)
2001247c:	4293      	cmp	r3, r2
2001247e:	d003      	beq.n	20012488 <HAL_MDMA_Init+0xc0>
20012480:	21e6      	movs	r1, #230	; 0xe6
20012482:	4880      	ldr	r0, [pc, #512]	; (20012684 <HAL_MDMA_Init+0x2bc>)
20012484:	f7ee fa36 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_PRIORITY(hmdma->Init.Priority));
20012488:	687b      	ldr	r3, [r7, #4]
2001248a:	68db      	ldr	r3, [r3, #12]
2001248c:	2b00      	cmp	r3, #0
2001248e:	d00f      	beq.n	200124b0 <HAL_MDMA_Init+0xe8>
20012490:	687b      	ldr	r3, [r7, #4]
20012492:	68db      	ldr	r3, [r3, #12]
20012494:	2b40      	cmp	r3, #64	; 0x40
20012496:	d00b      	beq.n	200124b0 <HAL_MDMA_Init+0xe8>
20012498:	687b      	ldr	r3, [r7, #4]
2001249a:	68db      	ldr	r3, [r3, #12]
2001249c:	2b80      	cmp	r3, #128	; 0x80
2001249e:	d007      	beq.n	200124b0 <HAL_MDMA_Init+0xe8>
200124a0:	687b      	ldr	r3, [r7, #4]
200124a2:	68db      	ldr	r3, [r3, #12]
200124a4:	2bc0      	cmp	r3, #192	; 0xc0
200124a6:	d003      	beq.n	200124b0 <HAL_MDMA_Init+0xe8>
200124a8:	21e7      	movs	r1, #231	; 0xe7
200124aa:	4876      	ldr	r0, [pc, #472]	; (20012684 <HAL_MDMA_Init+0x2bc>)
200124ac:	f7ee fa22 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_ENDIANNESS_MODE(hmdma->Init.Endianness));
200124b0:	687b      	ldr	r3, [r7, #4]
200124b2:	691b      	ldr	r3, [r3, #16]
200124b4:	2b00      	cmp	r3, #0
200124b6:	d012      	beq.n	200124de <HAL_MDMA_Init+0x116>
200124b8:	687b      	ldr	r3, [r7, #4]
200124ba:	691b      	ldr	r3, [r3, #16]
200124bc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
200124c0:	d00d      	beq.n	200124de <HAL_MDMA_Init+0x116>
200124c2:	687b      	ldr	r3, [r7, #4]
200124c4:	691b      	ldr	r3, [r3, #16]
200124c6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
200124ca:	d008      	beq.n	200124de <HAL_MDMA_Init+0x116>
200124cc:	687b      	ldr	r3, [r7, #4]
200124ce:	691b      	ldr	r3, [r3, #16]
200124d0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
200124d4:	d003      	beq.n	200124de <HAL_MDMA_Init+0x116>
200124d6:	21e8      	movs	r1, #232	; 0xe8
200124d8:	486a      	ldr	r0, [pc, #424]	; (20012684 <HAL_MDMA_Init+0x2bc>)
200124da:	f7ee fa0b 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_REQUEST(hmdma->Init.Request));
200124de:	687b      	ldr	r3, [r7, #4]
200124e0:	685b      	ldr	r3, [r3, #4]
200124e2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
200124e6:	d007      	beq.n	200124f8 <HAL_MDMA_Init+0x130>
200124e8:	687b      	ldr	r3, [r7, #4]
200124ea:	685b      	ldr	r3, [r3, #4]
200124ec:	2b1f      	cmp	r3, #31
200124ee:	d903      	bls.n	200124f8 <HAL_MDMA_Init+0x130>
200124f0:	21e9      	movs	r1, #233	; 0xe9
200124f2:	4864      	ldr	r0, [pc, #400]	; (20012684 <HAL_MDMA_Init+0x2bc>)
200124f4:	f7ee f9fe 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_SOURCE_INC(hmdma->Init.SourceInc));
200124f8:	687b      	ldr	r3, [r7, #4]
200124fa:	695b      	ldr	r3, [r3, #20]
200124fc:	2b00      	cmp	r3, #0
200124fe:	d02e      	beq.n	2001255e <HAL_MDMA_Init+0x196>
20012500:	687b      	ldr	r3, [r7, #4]
20012502:	695b      	ldr	r3, [r3, #20]
20012504:	2b02      	cmp	r3, #2
20012506:	d02a      	beq.n	2001255e <HAL_MDMA_Init+0x196>
20012508:	687b      	ldr	r3, [r7, #4]
2001250a:	695b      	ldr	r3, [r3, #20]
2001250c:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
20012510:	d025      	beq.n	2001255e <HAL_MDMA_Init+0x196>
20012512:	687b      	ldr	r3, [r7, #4]
20012514:	695b      	ldr	r3, [r3, #20]
20012516:	f240 2202 	movw	r2, #514	; 0x202
2001251a:	4293      	cmp	r3, r2
2001251c:	d01f      	beq.n	2001255e <HAL_MDMA_Init+0x196>
2001251e:	687b      	ldr	r3, [r7, #4]
20012520:	695b      	ldr	r3, [r3, #20]
20012522:	f240 3202 	movw	r2, #770	; 0x302
20012526:	4293      	cmp	r3, r2
20012528:	d019      	beq.n	2001255e <HAL_MDMA_Init+0x196>
2001252a:	687b      	ldr	r3, [r7, #4]
2001252c:	695b      	ldr	r3, [r3, #20]
2001252e:	2b03      	cmp	r3, #3
20012530:	d015      	beq.n	2001255e <HAL_MDMA_Init+0x196>
20012532:	687b      	ldr	r3, [r7, #4]
20012534:	695b      	ldr	r3, [r3, #20]
20012536:	f240 1203 	movw	r2, #259	; 0x103
2001253a:	4293      	cmp	r3, r2
2001253c:	d00f      	beq.n	2001255e <HAL_MDMA_Init+0x196>
2001253e:	687b      	ldr	r3, [r7, #4]
20012540:	695b      	ldr	r3, [r3, #20]
20012542:	f240 2203 	movw	r2, #515	; 0x203
20012546:	4293      	cmp	r3, r2
20012548:	d009      	beq.n	2001255e <HAL_MDMA_Init+0x196>
2001254a:	687b      	ldr	r3, [r7, #4]
2001254c:	695b      	ldr	r3, [r3, #20]
2001254e:	f240 3203 	movw	r2, #771	; 0x303
20012552:	4293      	cmp	r3, r2
20012554:	d003      	beq.n	2001255e <HAL_MDMA_Init+0x196>
20012556:	21ea      	movs	r1, #234	; 0xea
20012558:	484a      	ldr	r0, [pc, #296]	; (20012684 <HAL_MDMA_Init+0x2bc>)
2001255a:	f7ee f9cb 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_DESTINATION_INC(hmdma->Init.DestinationInc));
2001255e:	687b      	ldr	r3, [r7, #4]
20012560:	699b      	ldr	r3, [r3, #24]
20012562:	2b00      	cmp	r3, #0
20012564:	d02e      	beq.n	200125c4 <HAL_MDMA_Init+0x1fc>
20012566:	687b      	ldr	r3, [r7, #4]
20012568:	699b      	ldr	r3, [r3, #24]
2001256a:	2b08      	cmp	r3, #8
2001256c:	d02a      	beq.n	200125c4 <HAL_MDMA_Init+0x1fc>
2001256e:	687b      	ldr	r3, [r7, #4]
20012570:	699b      	ldr	r3, [r3, #24]
20012572:	f5b3 6f81 	cmp.w	r3, #1032	; 0x408
20012576:	d025      	beq.n	200125c4 <HAL_MDMA_Init+0x1fc>
20012578:	687b      	ldr	r3, [r7, #4]
2001257a:	699b      	ldr	r3, [r3, #24]
2001257c:	f640 0208 	movw	r2, #2056	; 0x808
20012580:	4293      	cmp	r3, r2
20012582:	d01f      	beq.n	200125c4 <HAL_MDMA_Init+0x1fc>
20012584:	687b      	ldr	r3, [r7, #4]
20012586:	699b      	ldr	r3, [r3, #24]
20012588:	f640 4208 	movw	r2, #3080	; 0xc08
2001258c:	4293      	cmp	r3, r2
2001258e:	d019      	beq.n	200125c4 <HAL_MDMA_Init+0x1fc>
20012590:	687b      	ldr	r3, [r7, #4]
20012592:	699b      	ldr	r3, [r3, #24]
20012594:	2b0c      	cmp	r3, #12
20012596:	d015      	beq.n	200125c4 <HAL_MDMA_Init+0x1fc>
20012598:	687b      	ldr	r3, [r7, #4]
2001259a:	699b      	ldr	r3, [r3, #24]
2001259c:	f240 420c 	movw	r2, #1036	; 0x40c
200125a0:	4293      	cmp	r3, r2
200125a2:	d00f      	beq.n	200125c4 <HAL_MDMA_Init+0x1fc>
200125a4:	687b      	ldr	r3, [r7, #4]
200125a6:	699b      	ldr	r3, [r3, #24]
200125a8:	f640 020c 	movw	r2, #2060	; 0x80c
200125ac:	4293      	cmp	r3, r2
200125ae:	d009      	beq.n	200125c4 <HAL_MDMA_Init+0x1fc>
200125b0:	687b      	ldr	r3, [r7, #4]
200125b2:	699b      	ldr	r3, [r3, #24]
200125b4:	f640 420c 	movw	r2, #3084	; 0xc0c
200125b8:	4293      	cmp	r3, r2
200125ba:	d003      	beq.n	200125c4 <HAL_MDMA_Init+0x1fc>
200125bc:	21eb      	movs	r1, #235	; 0xeb
200125be:	4831      	ldr	r0, [pc, #196]	; (20012684 <HAL_MDMA_Init+0x2bc>)
200125c0:	f7ee f998 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_SOURCE_DATASIZE(hmdma->Init.SourceDataSize));
200125c4:	687b      	ldr	r3, [r7, #4]
200125c6:	69db      	ldr	r3, [r3, #28]
200125c8:	2b00      	cmp	r3, #0
200125ca:	d00f      	beq.n	200125ec <HAL_MDMA_Init+0x224>
200125cc:	687b      	ldr	r3, [r7, #4]
200125ce:	69db      	ldr	r3, [r3, #28]
200125d0:	2b10      	cmp	r3, #16
200125d2:	d00b      	beq.n	200125ec <HAL_MDMA_Init+0x224>
200125d4:	687b      	ldr	r3, [r7, #4]
200125d6:	69db      	ldr	r3, [r3, #28]
200125d8:	2b20      	cmp	r3, #32
200125da:	d007      	beq.n	200125ec <HAL_MDMA_Init+0x224>
200125dc:	687b      	ldr	r3, [r7, #4]
200125de:	69db      	ldr	r3, [r3, #28]
200125e0:	2b30      	cmp	r3, #48	; 0x30
200125e2:	d003      	beq.n	200125ec <HAL_MDMA_Init+0x224>
200125e4:	21ec      	movs	r1, #236	; 0xec
200125e6:	4827      	ldr	r0, [pc, #156]	; (20012684 <HAL_MDMA_Init+0x2bc>)
200125e8:	f7ee f984 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_DESTINATION_DATASIZE(hmdma->Init.DestDataSize));
200125ec:	687b      	ldr	r3, [r7, #4]
200125ee:	6a1b      	ldr	r3, [r3, #32]
200125f0:	2b00      	cmp	r3, #0
200125f2:	d00f      	beq.n	20012614 <HAL_MDMA_Init+0x24c>
200125f4:	687b      	ldr	r3, [r7, #4]
200125f6:	6a1b      	ldr	r3, [r3, #32]
200125f8:	2b40      	cmp	r3, #64	; 0x40
200125fa:	d00b      	beq.n	20012614 <HAL_MDMA_Init+0x24c>
200125fc:	687b      	ldr	r3, [r7, #4]
200125fe:	6a1b      	ldr	r3, [r3, #32]
20012600:	2b80      	cmp	r3, #128	; 0x80
20012602:	d007      	beq.n	20012614 <HAL_MDMA_Init+0x24c>
20012604:	687b      	ldr	r3, [r7, #4]
20012606:	6a1b      	ldr	r3, [r3, #32]
20012608:	2bc0      	cmp	r3, #192	; 0xc0
2001260a:	d003      	beq.n	20012614 <HAL_MDMA_Init+0x24c>
2001260c:	21ed      	movs	r1, #237	; 0xed
2001260e:	481d      	ldr	r0, [pc, #116]	; (20012684 <HAL_MDMA_Init+0x2bc>)
20012610:	f7ee f970 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_DATA_ALIGNMENT(hmdma->Init.DataAlignment));
20012614:	687b      	ldr	r3, [r7, #4]
20012616:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20012618:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2001261c:	d034      	beq.n	20012688 <HAL_MDMA_Init+0x2c0>
2001261e:	687b      	ldr	r3, [r7, #4]
20012620:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20012622:	2b00      	cmp	r3, #0
20012624:	d030      	beq.n	20012688 <HAL_MDMA_Init+0x2c0>
20012626:	687b      	ldr	r3, [r7, #4]
20012628:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2001262a:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
2001262e:	d02b      	beq.n	20012688 <HAL_MDMA_Init+0x2c0>
20012630:	687b      	ldr	r3, [r7, #4]
20012632:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20012634:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
20012638:	d026      	beq.n	20012688 <HAL_MDMA_Init+0x2c0>
2001263a:	21ee      	movs	r1, #238	; 0xee
2001263c:	4811      	ldr	r0, [pc, #68]	; (20012684 <HAL_MDMA_Init+0x2bc>)
2001263e:	f7ee f959 	bl	200008f4 <assert_failed>
20012642:	e021      	b.n	20012688 <HAL_MDMA_Init+0x2c0>
20012644:	52000040 	.word	0x52000040
20012648:	52000080 	.word	0x52000080
2001264c:	520000c0 	.word	0x520000c0
20012650:	52000100 	.word	0x52000100
20012654:	52000140 	.word	0x52000140
20012658:	52000180 	.word	0x52000180
2001265c:	520001c0 	.word	0x520001c0
20012660:	52000200 	.word	0x52000200
20012664:	52000240 	.word	0x52000240
20012668:	52000280 	.word	0x52000280
2001266c:	520002c0 	.word	0x520002c0
20012670:	52000300 	.word	0x52000300
20012674:	52000340 	.word	0x52000340
20012678:	52000380 	.word	0x52000380
2001267c:	520003c0 	.word	0x520003c0
20012680:	52000400 	.word	0x52000400
20012684:	2001c1f4 	.word	0x2001c1f4
  assert_param(IS_MDMA_SOURCE_BURST(hmdma->Init.SourceBurst));
20012688:	687b      	ldr	r3, [r7, #4]
2001268a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001268c:	2b00      	cmp	r3, #0
2001268e:	d026      	beq.n	200126de <HAL_MDMA_Init+0x316>
20012690:	687b      	ldr	r3, [r7, #4]
20012692:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20012694:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20012698:	d021      	beq.n	200126de <HAL_MDMA_Init+0x316>
2001269a:	687b      	ldr	r3, [r7, #4]
2001269c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001269e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
200126a2:	d01c      	beq.n	200126de <HAL_MDMA_Init+0x316>
200126a4:	687b      	ldr	r3, [r7, #4]
200126a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200126a8:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
200126ac:	d017      	beq.n	200126de <HAL_MDMA_Init+0x316>
200126ae:	687b      	ldr	r3, [r7, #4]
200126b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200126b2:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
200126b6:	d012      	beq.n	200126de <HAL_MDMA_Init+0x316>
200126b8:	687b      	ldr	r3, [r7, #4]
200126ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200126bc:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
200126c0:	d00d      	beq.n	200126de <HAL_MDMA_Init+0x316>
200126c2:	687b      	ldr	r3, [r7, #4]
200126c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200126c6:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
200126ca:	d008      	beq.n	200126de <HAL_MDMA_Init+0x316>
200126cc:	687b      	ldr	r3, [r7, #4]
200126ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200126d0:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
200126d4:	d003      	beq.n	200126de <HAL_MDMA_Init+0x316>
200126d6:	21ef      	movs	r1, #239	; 0xef
200126d8:	4856      	ldr	r0, [pc, #344]	; (20012834 <HAL_MDMA_Init+0x46c>)
200126da:	f7ee f90b 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_DESTINATION_BURST(hmdma->Init.DestBurst));
200126de:	687b      	ldr	r3, [r7, #4]
200126e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200126e2:	2b00      	cmp	r3, #0
200126e4:	d026      	beq.n	20012734 <HAL_MDMA_Init+0x36c>
200126e6:	687b      	ldr	r3, [r7, #4]
200126e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200126ea:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
200126ee:	d021      	beq.n	20012734 <HAL_MDMA_Init+0x36c>
200126f0:	687b      	ldr	r3, [r7, #4]
200126f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200126f4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
200126f8:	d01c      	beq.n	20012734 <HAL_MDMA_Init+0x36c>
200126fa:	687b      	ldr	r3, [r7, #4]
200126fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200126fe:	f5b3 3fc0 	cmp.w	r3, #98304	; 0x18000
20012702:	d017      	beq.n	20012734 <HAL_MDMA_Init+0x36c>
20012704:	687b      	ldr	r3, [r7, #4]
20012706:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20012708:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2001270c:	d012      	beq.n	20012734 <HAL_MDMA_Init+0x36c>
2001270e:	687b      	ldr	r3, [r7, #4]
20012710:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20012712:	f5b3 3f20 	cmp.w	r3, #163840	; 0x28000
20012716:	d00d      	beq.n	20012734 <HAL_MDMA_Init+0x36c>
20012718:	687b      	ldr	r3, [r7, #4]
2001271a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001271c:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
20012720:	d008      	beq.n	20012734 <HAL_MDMA_Init+0x36c>
20012722:	687b      	ldr	r3, [r7, #4]
20012724:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20012726:	f5b3 3f60 	cmp.w	r3, #229376	; 0x38000
2001272a:	d003      	beq.n	20012734 <HAL_MDMA_Init+0x36c>
2001272c:	21f0      	movs	r1, #240	; 0xf0
2001272e:	4841      	ldr	r0, [pc, #260]	; (20012834 <HAL_MDMA_Init+0x46c>)
20012730:	f7ee f8e0 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_BUFFER_TRANSFER_LENGTH(hmdma->Init.BufferTransferLength));
20012734:	687b      	ldr	r3, [r7, #4]
20012736:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012738:	2b00      	cmp	r3, #0
2001273a:	d003      	beq.n	20012744 <HAL_MDMA_Init+0x37c>
2001273c:	687b      	ldr	r3, [r7, #4]
2001273e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012740:	2bfe      	cmp	r3, #254	; 0xfe
20012742:	d903      	bls.n	2001274c <HAL_MDMA_Init+0x384>
20012744:	21f1      	movs	r1, #241	; 0xf1
20012746:	483b      	ldr	r0, [pc, #236]	; (20012834 <HAL_MDMA_Init+0x46c>)
20012748:	f7ee f8d4 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_TRANSFER_TRIGGER_MODE(hmdma->Init.TransferTriggerMode));
2001274c:	687b      	ldr	r3, [r7, #4]
2001274e:	689b      	ldr	r3, [r3, #8]
20012750:	2b00      	cmp	r3, #0
20012752:	d012      	beq.n	2001277a <HAL_MDMA_Init+0x3b2>
20012754:	687b      	ldr	r3, [r7, #4]
20012756:	689b      	ldr	r3, [r3, #8]
20012758:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001275c:	d00d      	beq.n	2001277a <HAL_MDMA_Init+0x3b2>
2001275e:	687b      	ldr	r3, [r7, #4]
20012760:	689b      	ldr	r3, [r3, #8]
20012762:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20012766:	d008      	beq.n	2001277a <HAL_MDMA_Init+0x3b2>
20012768:	687b      	ldr	r3, [r7, #4]
2001276a:	689b      	ldr	r3, [r3, #8]
2001276c:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
20012770:	d003      	beq.n	2001277a <HAL_MDMA_Init+0x3b2>
20012772:	21f2      	movs	r1, #242	; 0xf2
20012774:	482f      	ldr	r0, [pc, #188]	; (20012834 <HAL_MDMA_Init+0x46c>)
20012776:	f7ee f8bd 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.SourceBlockAddressOffset));
2001277a:	687b      	ldr	r3, [r7, #4]
2001277c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2001277e:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
20012782:	dd04      	ble.n	2001278e <HAL_MDMA_Init+0x3c6>
20012784:	687b      	ldr	r3, [r7, #4]
20012786:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20012788:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2001278c:	db03      	blt.n	20012796 <HAL_MDMA_Init+0x3ce>
2001278e:	21f3      	movs	r1, #243	; 0xf3
20012790:	4828      	ldr	r0, [pc, #160]	; (20012834 <HAL_MDMA_Init+0x46c>)
20012792:	f7ee f8af 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.DestBlockAddressOffset));
20012796:	687b      	ldr	r3, [r7, #4]
20012798:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001279a:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2001279e:	dd04      	ble.n	200127aa <HAL_MDMA_Init+0x3e2>
200127a0:	687b      	ldr	r3, [r7, #4]
200127a2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200127a4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
200127a8:	db03      	blt.n	200127b2 <HAL_MDMA_Init+0x3ea>
200127aa:	21f4      	movs	r1, #244	; 0xf4
200127ac:	4821      	ldr	r0, [pc, #132]	; (20012834 <HAL_MDMA_Init+0x46c>)
200127ae:	f7ee f8a1 	bl	200008f4 <assert_failed>


  /* Allocate lock resource */
  __HAL_UNLOCK(hmdma);
200127b2:	687b      	ldr	r3, [r7, #4]
200127b4:	2200      	movs	r2, #0
200127b6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change MDMA peripheral state */
  hmdma->State = HAL_MDMA_STATE_BUSY;
200127ba:	687b      	ldr	r3, [r7, #4]
200127bc:	2202      	movs	r2, #2
200127be:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the MDMA channel */
  __HAL_MDMA_DISABLE(hmdma);
200127c2:	687b      	ldr	r3, [r7, #4]
200127c4:	681b      	ldr	r3, [r3, #0]
200127c6:	68da      	ldr	r2, [r3, #12]
200127c8:	687b      	ldr	r3, [r7, #4]
200127ca:	681b      	ldr	r3, [r3, #0]
200127cc:	f022 0201 	bic.w	r2, r2, #1
200127d0:	60da      	str	r2, [r3, #12]

  /* Check if the MDMA channel is effectively disabled */
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
200127d2:	e00f      	b.n	200127f4 <HAL_MDMA_Init+0x42c>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
200127d4:	f7ef fa8a 	bl	20001cec <HAL_GetTick>
200127d8:	4602      	mov	r2, r0
200127da:	68fb      	ldr	r3, [r7, #12]
200127dc:	1ad3      	subs	r3, r2, r3
200127de:	2b05      	cmp	r3, #5
200127e0:	d908      	bls.n	200127f4 <HAL_MDMA_Init+0x42c>
    {
      /* Update error code */
      hmdma->ErrorCode = HAL_MDMA_ERROR_TIMEOUT;
200127e2:	687b      	ldr	r3, [r7, #4]
200127e4:	2240      	movs	r2, #64	; 0x40
200127e6:	669a      	str	r2, [r3, #104]	; 0x68

      /* Change the MDMA state */
      hmdma->State = HAL_MDMA_STATE_ERROR;
200127e8:	687b      	ldr	r3, [r7, #4]
200127ea:	2203      	movs	r2, #3
200127ec:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      return HAL_ERROR;
200127f0:	2301      	movs	r3, #1
200127f2:	e01a      	b.n	2001282a <HAL_MDMA_Init+0x462>
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
200127f4:	687b      	ldr	r3, [r7, #4]
200127f6:	681b      	ldr	r3, [r3, #0]
200127f8:	68db      	ldr	r3, [r3, #12]
200127fa:	f003 0301 	and.w	r3, r3, #1
200127fe:	2b00      	cmp	r3, #0
20012800:	d1e8      	bne.n	200127d4 <HAL_MDMA_Init+0x40c>
    }
  }

  /* Initialize the MDMA channel registers */
  MDMA_Init(hmdma);
20012802:	6878      	ldr	r0, [r7, #4]
20012804:	f001 fa88 	bl	20013d18 <MDMA_Init>

  /* Reset the MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
20012808:	687b      	ldr	r3, [r7, #4]
2001280a:	2200      	movs	r2, #0
2001280c:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
2001280e:	687b      	ldr	r3, [r7, #4]
20012810:	2200      	movs	r2, #0
20012812:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
20012814:	687b      	ldr	r3, [r7, #4]
20012816:	2200      	movs	r2, #0
20012818:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2001281a:	687b      	ldr	r3, [r7, #4]
2001281c:	2200      	movs	r2, #0
2001281e:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_READY;
20012820:	687b      	ldr	r3, [r7, #4]
20012822:	2201      	movs	r2, #1
20012824:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
20012828:	2300      	movs	r3, #0
}
2001282a:	4618      	mov	r0, r3
2001282c:	3710      	adds	r7, #16
2001282e:	46bd      	mov	sp, r7
20012830:	bd80      	pop	{r7, pc}
20012832:	bf00      	nop
20012834:	2001c1f4 	.word	0x2001c1f4

20012838 <HAL_MDMA_DeInit>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_DeInit(MDMA_HandleTypeDef *hmdma)
{
20012838:	b480      	push	{r7}
2001283a:	b083      	sub	sp, #12
2001283c:	af00      	add	r7, sp, #0
2001283e:	6078      	str	r0, [r7, #4]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
20012840:	687b      	ldr	r3, [r7, #4]
20012842:	2b00      	cmp	r3, #0
20012844:	d101      	bne.n	2001284a <HAL_MDMA_DeInit+0x12>
  {
    return HAL_ERROR;
20012846:	2301      	movs	r3, #1
20012848:	e048      	b.n	200128dc <HAL_MDMA_DeInit+0xa4>
  }

  /* Disable the selected MDMA Channelx */
  __HAL_MDMA_DISABLE(hmdma);
2001284a:	687b      	ldr	r3, [r7, #4]
2001284c:	681b      	ldr	r3, [r3, #0]
2001284e:	68da      	ldr	r2, [r3, #12]
20012850:	687b      	ldr	r3, [r7, #4]
20012852:	681b      	ldr	r3, [r3, #0]
20012854:	f022 0201 	bic.w	r2, r2, #1
20012858:	60da      	str	r2, [r3, #12]

  /* Reset MDMA Channel control register */
  hmdma->Instance->CCR  = 0;
2001285a:	687b      	ldr	r3, [r7, #4]
2001285c:	681b      	ldr	r3, [r3, #0]
2001285e:	2200      	movs	r2, #0
20012860:	60da      	str	r2, [r3, #12]
  hmdma->Instance->CTCR = 0;
20012862:	687b      	ldr	r3, [r7, #4]
20012864:	681b      	ldr	r3, [r3, #0]
20012866:	2200      	movs	r2, #0
20012868:	611a      	str	r2, [r3, #16]
  hmdma->Instance->CBNDTR = 0;
2001286a:	687b      	ldr	r3, [r7, #4]
2001286c:	681b      	ldr	r3, [r3, #0]
2001286e:	2200      	movs	r2, #0
20012870:	615a      	str	r2, [r3, #20]
  hmdma->Instance->CSAR = 0;
20012872:	687b      	ldr	r3, [r7, #4]
20012874:	681b      	ldr	r3, [r3, #0]
20012876:	2200      	movs	r2, #0
20012878:	619a      	str	r2, [r3, #24]
  hmdma->Instance->CDAR = 0;
2001287a:	687b      	ldr	r3, [r7, #4]
2001287c:	681b      	ldr	r3, [r3, #0]
2001287e:	2200      	movs	r2, #0
20012880:	61da      	str	r2, [r3, #28]
  hmdma->Instance->CBRUR = 0;
20012882:	687b      	ldr	r3, [r7, #4]
20012884:	681b      	ldr	r3, [r3, #0]
20012886:	2200      	movs	r2, #0
20012888:	621a      	str	r2, [r3, #32]
  hmdma->Instance->CLAR = 0;
2001288a:	687b      	ldr	r3, [r7, #4]
2001288c:	681b      	ldr	r3, [r3, #0]
2001288e:	2200      	movs	r2, #0
20012890:	625a      	str	r2, [r3, #36]	; 0x24
  hmdma->Instance->CTBR = 0;
20012892:	687b      	ldr	r3, [r7, #4]
20012894:	681b      	ldr	r3, [r3, #0]
20012896:	2200      	movs	r2, #0
20012898:	629a      	str	r2, [r3, #40]	; 0x28
  hmdma->Instance->CMAR = 0;
2001289a:	687b      	ldr	r3, [r7, #4]
2001289c:	681b      	ldr	r3, [r3, #0]
2001289e:	2200      	movs	r2, #0
200128a0:	631a      	str	r2, [r3, #48]	; 0x30
  hmdma->Instance->CMDR = 0;
200128a2:	687b      	ldr	r3, [r7, #4]
200128a4:	681b      	ldr	r3, [r3, #0]
200128a6:	2200      	movs	r2, #0
200128a8:	635a      	str	r2, [r3, #52]	; 0x34

  /* Clear all flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma,(MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC));
200128aa:	687b      	ldr	r3, [r7, #4]
200128ac:	681b      	ldr	r3, [r3, #0]
200128ae:	221f      	movs	r2, #31
200128b0:	605a      	str	r2, [r3, #4]

  /* Reset the  MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
200128b2:	687b      	ldr	r3, [r7, #4]
200128b4:	2200      	movs	r2, #0
200128b6:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
200128b8:	687b      	ldr	r3, [r7, #4]
200128ba:	2200      	movs	r2, #0
200128bc:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
200128be:	687b      	ldr	r3, [r7, #4]
200128c0:	2200      	movs	r2, #0
200128c2:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
200128c4:	687b      	ldr	r3, [r7, #4]
200128c6:	2200      	movs	r2, #0
200128c8:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_RESET;
200128ca:	687b      	ldr	r3, [r7, #4]
200128cc:	2200      	movs	r2, #0
200128ce:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
200128d2:	687b      	ldr	r3, [r7, #4]
200128d4:	2200      	movs	r2, #0
200128d6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
200128da:	2300      	movs	r3, #0
}
200128dc:	4618      	mov	r0, r3
200128de:	370c      	adds	r7, #12
200128e0:	46bd      	mov	sp, r7
200128e2:	f85d 7b04 	ldr.w	r7, [sp], #4
200128e6:	4770      	bx	lr

200128e8 <HAL_MDMA_ConfigPostRequestMask>:
  * @param  MaskData:    specifies the value to be written to MaskAddress after a request is served.
  *                      MaskAddress and MaskData could be used to automatically clear a peripheral flag when the request is served.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_ConfigPostRequestMask(MDMA_HandleTypeDef *hmdma, uint32_t MaskAddress, uint32_t MaskData)
{
200128e8:	b480      	push	{r7}
200128ea:	b087      	sub	sp, #28
200128ec:	af00      	add	r7, sp, #0
200128ee:	60f8      	str	r0, [r7, #12]
200128f0:	60b9      	str	r1, [r7, #8]
200128f2:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
200128f4:	2300      	movs	r3, #0
200128f6:	75fb      	strb	r3, [r7, #23]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
200128f8:	68fb      	ldr	r3, [r7, #12]
200128fa:	2b00      	cmp	r3, #0
200128fc:	d101      	bne.n	20012902 <HAL_MDMA_ConfigPostRequestMask+0x1a>
  {
    return HAL_ERROR;
200128fe:	2301      	movs	r3, #1
20012900:	e03e      	b.n	20012980 <HAL_MDMA_ConfigPostRequestMask+0x98>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
20012902:	68fb      	ldr	r3, [r7, #12]
20012904:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
20012908:	2b01      	cmp	r3, #1
2001290a:	d101      	bne.n	20012910 <HAL_MDMA_ConfigPostRequestMask+0x28>
2001290c:	2302      	movs	r3, #2
2001290e:	e037      	b.n	20012980 <HAL_MDMA_ConfigPostRequestMask+0x98>
20012910:	68fb      	ldr	r3, [r7, #12]
20012912:	2201      	movs	r2, #1
20012914:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
20012918:	68fb      	ldr	r3, [r7, #12]
2001291a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2001291e:	b2db      	uxtb	r3, r3
20012920:	2b01      	cmp	r3, #1
20012922:	d126      	bne.n	20012972 <HAL_MDMA_ConfigPostRequestMask+0x8a>
  {
    /* if HW request set Post Request MaskAddress and MaskData,  */
    if((hmdma->Instance->CTCR & MDMA_CTCR_SWRM) == 0U)
20012924:	68fb      	ldr	r3, [r7, #12]
20012926:	681b      	ldr	r3, [r3, #0]
20012928:	691b      	ldr	r3, [r3, #16]
2001292a:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2001292e:	2b00      	cmp	r3, #0
20012930:	d11c      	bne.n	2001296c <HAL_MDMA_ConfigPostRequestMask+0x84>
    {
      /* Set the HW request clear Mask and Data */
      hmdma->Instance->CMAR = MaskAddress;
20012932:	68fb      	ldr	r3, [r7, #12]
20012934:	681b      	ldr	r3, [r3, #0]
20012936:	68ba      	ldr	r2, [r7, #8]
20012938:	631a      	str	r2, [r3, #48]	; 0x30
      hmdma->Instance->CMDR = MaskData;
2001293a:	68fb      	ldr	r3, [r7, #12]
2001293c:	681b      	ldr	r3, [r3, #0]
2001293e:	687a      	ldr	r2, [r7, #4]
20012940:	635a      	str	r2, [r3, #52]	; 0x34
      -If the request is done by SW : BWM could be set to 1 or 0.
      -If the request is done by a peripheral :
         If mask address not set (0) => BWM must be set to 0
         If mask address set (different than 0) => BWM could be set to 1 or 0
      */
      if(MaskAddress == 0U)
20012942:	68bb      	ldr	r3, [r7, #8]
20012944:	2b00      	cmp	r3, #0
20012946:	d108      	bne.n	2001295a <HAL_MDMA_ConfigPostRequestMask+0x72>
      {
        hmdma->Instance->CTCR &=  ~MDMA_CTCR_BWM;
20012948:	68fb      	ldr	r3, [r7, #12]
2001294a:	681b      	ldr	r3, [r3, #0]
2001294c:	691a      	ldr	r2, [r3, #16]
2001294e:	68fb      	ldr	r3, [r7, #12]
20012950:	681b      	ldr	r3, [r3, #0]
20012952:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
20012956:	611a      	str	r2, [r3, #16]
20012958:	e00d      	b.n	20012976 <HAL_MDMA_ConfigPostRequestMask+0x8e>
      }
      else
      {
        hmdma->Instance->CTCR |=  MDMA_CTCR_BWM;
2001295a:	68fb      	ldr	r3, [r7, #12]
2001295c:	681b      	ldr	r3, [r3, #0]
2001295e:	691a      	ldr	r2, [r3, #16]
20012960:	68fb      	ldr	r3, [r7, #12]
20012962:	681b      	ldr	r3, [r3, #0]
20012964:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
20012968:	611a      	str	r2, [r3, #16]
2001296a:	e004      	b.n	20012976 <HAL_MDMA_ConfigPostRequestMask+0x8e>
      }
    }
    else
    {
      /* Return error status */
      status =  HAL_ERROR;
2001296c:	2301      	movs	r3, #1
2001296e:	75fb      	strb	r3, [r7, #23]
20012970:	e001      	b.n	20012976 <HAL_MDMA_ConfigPostRequestMask+0x8e>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
20012972:	2301      	movs	r3, #1
20012974:	75fb      	strb	r3, [r7, #23]
  }
  /* Release Lock */
  __HAL_UNLOCK(hmdma);
20012976:	68fb      	ldr	r3, [r7, #12]
20012978:	2200      	movs	r2, #0
2001297a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2001297e:	7dfb      	ldrb	r3, [r7, #23]
}
20012980:	4618      	mov	r0, r3
20012982:	371c      	adds	r7, #28
20012984:	46bd      	mov	sp, r7
20012986:	f85d 7b04 	ldr.w	r7, [sp], #4
2001298a:	4770      	bx	lr

2001298c <HAL_MDMA_RegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  * @param  pCallback:            pointer to callbacsk function.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_RegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID, void (* pCallback)(MDMA_HandleTypeDef *_hmdma))
{
2001298c:	b480      	push	{r7}
2001298e:	b087      	sub	sp, #28
20012990:	af00      	add	r7, sp, #0
20012992:	60f8      	str	r0, [r7, #12]
20012994:	460b      	mov	r3, r1
20012996:	607a      	str	r2, [r7, #4]
20012998:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
2001299a:	2300      	movs	r3, #0
2001299c:	75fb      	strb	r3, [r7, #23]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2001299e:	68fb      	ldr	r3, [r7, #12]
200129a0:	2b00      	cmp	r3, #0
200129a2:	d101      	bne.n	200129a8 <HAL_MDMA_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
200129a4:	2301      	movs	r3, #1
200129a6:	e044      	b.n	20012a32 <HAL_MDMA_RegisterCallback+0xa6>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
200129a8:	68fb      	ldr	r3, [r7, #12]
200129aa:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
200129ae:	2b01      	cmp	r3, #1
200129b0:	d101      	bne.n	200129b6 <HAL_MDMA_RegisterCallback+0x2a>
200129b2:	2302      	movs	r3, #2
200129b4:	e03d      	b.n	20012a32 <HAL_MDMA_RegisterCallback+0xa6>
200129b6:	68fb      	ldr	r3, [r7, #12]
200129b8:	2201      	movs	r2, #1
200129ba:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
200129be:	68fb      	ldr	r3, [r7, #12]
200129c0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
200129c4:	b2db      	uxtb	r3, r3
200129c6:	2b01      	cmp	r3, #1
200129c8:	d12a      	bne.n	20012a20 <HAL_MDMA_RegisterCallback+0x94>
  {
    switch (CallbackID)
200129ca:	7afb      	ldrb	r3, [r7, #11]
200129cc:	2b05      	cmp	r3, #5
200129ce:	d82a      	bhi.n	20012a26 <HAL_MDMA_RegisterCallback+0x9a>
200129d0:	a201      	add	r2, pc, #4	; (adr r2, 200129d8 <HAL_MDMA_RegisterCallback+0x4c>)
200129d2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200129d6:	bf00      	nop
200129d8:	200129f1 	.word	0x200129f1
200129dc:	200129f9 	.word	0x200129f9
200129e0:	20012a01 	.word	0x20012a01
200129e4:	20012a09 	.word	0x20012a09
200129e8:	20012a11 	.word	0x20012a11
200129ec:	20012a19 	.word	0x20012a19
    {
    case  HAL_MDMA_XFER_CPLT_CB_ID:
      hmdma->XferCpltCallback = pCallback;
200129f0:	68fb      	ldr	r3, [r7, #12]
200129f2:	687a      	ldr	r2, [r7, #4]
200129f4:	645a      	str	r2, [r3, #68]	; 0x44
      break;
200129f6:	e017      	b.n	20012a28 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:
      hmdma->XferBufferCpltCallback = pCallback;
200129f8:	68fb      	ldr	r3, [r7, #12]
200129fa:	687a      	ldr	r2, [r7, #4]
200129fc:	649a      	str	r2, [r3, #72]	; 0x48
      break;
200129fe:	e013      	b.n	20012a28 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:
      hmdma->XferBlockCpltCallback = pCallback;
20012a00:	68fb      	ldr	r3, [r7, #12]
20012a02:	687a      	ldr	r2, [r7, #4]
20012a04:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
20012a06:	e00f      	b.n	20012a28 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:
      hmdma->XferRepeatBlockCpltCallback = pCallback;
20012a08:	68fb      	ldr	r3, [r7, #12]
20012a0a:	687a      	ldr	r2, [r7, #4]
20012a0c:	651a      	str	r2, [r3, #80]	; 0x50
      break;
20012a0e:	e00b      	b.n	20012a28 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_ERROR_CB_ID:
      hmdma->XferErrorCallback = pCallback;
20012a10:	68fb      	ldr	r3, [r7, #12]
20012a12:	687a      	ldr	r2, [r7, #4]
20012a14:	655a      	str	r2, [r3, #84]	; 0x54
      break;
20012a16:	e007      	b.n	20012a28 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_ABORT_CB_ID:
      hmdma->XferAbortCallback = pCallback;
20012a18:	68fb      	ldr	r3, [r7, #12]
20012a1a:	687a      	ldr	r2, [r7, #4]
20012a1c:	659a      	str	r2, [r3, #88]	; 0x58
      break;
20012a1e:	e003      	b.n	20012a28 <HAL_MDMA_RegisterCallback+0x9c>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
20012a20:	2301      	movs	r3, #1
20012a22:	75fb      	strb	r3, [r7, #23]
20012a24:	e000      	b.n	20012a28 <HAL_MDMA_RegisterCallback+0x9c>
      break;
20012a26:	bf00      	nop
  }

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
20012a28:	68fb      	ldr	r3, [r7, #12]
20012a2a:	2200      	movs	r2, #0
20012a2c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
20012a30:	7dfb      	ldrb	r3, [r7, #23]
}
20012a32:	4618      	mov	r0, r3
20012a34:	371c      	adds	r7, #28
20012a36:	46bd      	mov	sp, r7
20012a38:	f85d 7b04 	ldr.w	r7, [sp], #4
20012a3c:	4770      	bx	lr
20012a3e:	bf00      	nop

20012a40 <HAL_MDMA_UnRegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  *                               a HAL_MDMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_UnRegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID)
{
20012a40:	b480      	push	{r7}
20012a42:	b085      	sub	sp, #20
20012a44:	af00      	add	r7, sp, #0
20012a46:	6078      	str	r0, [r7, #4]
20012a48:	460b      	mov	r3, r1
20012a4a:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
20012a4c:	2300      	movs	r3, #0
20012a4e:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
20012a50:	687b      	ldr	r3, [r7, #4]
20012a52:	2b00      	cmp	r3, #0
20012a54:	d101      	bne.n	20012a5a <HAL_MDMA_UnRegisterCallback+0x1a>
  {
    return HAL_ERROR;
20012a56:	2301      	movs	r3, #1
20012a58:	e05a      	b.n	20012b10 <HAL_MDMA_UnRegisterCallback+0xd0>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
20012a5a:	687b      	ldr	r3, [r7, #4]
20012a5c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
20012a60:	2b01      	cmp	r3, #1
20012a62:	d101      	bne.n	20012a68 <HAL_MDMA_UnRegisterCallback+0x28>
20012a64:	2302      	movs	r3, #2
20012a66:	e053      	b.n	20012b10 <HAL_MDMA_UnRegisterCallback+0xd0>
20012a68:	687b      	ldr	r3, [r7, #4]
20012a6a:	2201      	movs	r2, #1
20012a6c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
20012a70:	687b      	ldr	r3, [r7, #4]
20012a72:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
20012a76:	b2db      	uxtb	r3, r3
20012a78:	2b01      	cmp	r3, #1
20012a7a:	d142      	bne.n	20012b02 <HAL_MDMA_UnRegisterCallback+0xc2>
  {
    switch (CallbackID)
20012a7c:	78fb      	ldrb	r3, [r7, #3]
20012a7e:	2b06      	cmp	r3, #6
20012a80:	d83b      	bhi.n	20012afa <HAL_MDMA_UnRegisterCallback+0xba>
20012a82:	a201      	add	r2, pc, #4	; (adr r2, 20012a88 <HAL_MDMA_UnRegisterCallback+0x48>)
20012a84:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20012a88:	20012aa5 	.word	0x20012aa5
20012a8c:	20012aad 	.word	0x20012aad
20012a90:	20012ab5 	.word	0x20012ab5
20012a94:	20012abd 	.word	0x20012abd
20012a98:	20012ac5 	.word	0x20012ac5
20012a9c:	20012acd 	.word	0x20012acd
20012aa0:	20012ad5 	.word	0x20012ad5
    {
    case  HAL_MDMA_XFER_CPLT_CB_ID:
      hmdma->XferCpltCallback = NULL;
20012aa4:	687b      	ldr	r3, [r7, #4]
20012aa6:	2200      	movs	r2, #0
20012aa8:	645a      	str	r2, [r3, #68]	; 0x44
      break;
20012aaa:	e02c      	b.n	20012b06 <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:
      hmdma->XferBufferCpltCallback = NULL;
20012aac:	687b      	ldr	r3, [r7, #4]
20012aae:	2200      	movs	r2, #0
20012ab0:	649a      	str	r2, [r3, #72]	; 0x48
      break;
20012ab2:	e028      	b.n	20012b06 <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:
      hmdma->XferBlockCpltCallback = NULL;
20012ab4:	687b      	ldr	r3, [r7, #4]
20012ab6:	2200      	movs	r2, #0
20012ab8:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
20012aba:	e024      	b.n	20012b06 <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:
      hmdma->XferRepeatBlockCpltCallback = NULL;
20012abc:	687b      	ldr	r3, [r7, #4]
20012abe:	2200      	movs	r2, #0
20012ac0:	651a      	str	r2, [r3, #80]	; 0x50
      break;
20012ac2:	e020      	b.n	20012b06 <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_ERROR_CB_ID:
      hmdma->XferErrorCallback = NULL;
20012ac4:	687b      	ldr	r3, [r7, #4]
20012ac6:	2200      	movs	r2, #0
20012ac8:	655a      	str	r2, [r3, #84]	; 0x54
      break;
20012aca:	e01c      	b.n	20012b06 <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_ABORT_CB_ID:
      hmdma->XferAbortCallback = NULL;
20012acc:	687b      	ldr	r3, [r7, #4]
20012ace:	2200      	movs	r2, #0
20012ad0:	659a      	str	r2, [r3, #88]	; 0x58
      break;
20012ad2:	e018      	b.n	20012b06 <HAL_MDMA_UnRegisterCallback+0xc6>

    case   HAL_MDMA_XFER_ALL_CB_ID:
      hmdma->XferCpltCallback = NULL;
20012ad4:	687b      	ldr	r3, [r7, #4]
20012ad6:	2200      	movs	r2, #0
20012ad8:	645a      	str	r2, [r3, #68]	; 0x44
      hmdma->XferBufferCpltCallback = NULL;
20012ada:	687b      	ldr	r3, [r7, #4]
20012adc:	2200      	movs	r2, #0
20012ade:	649a      	str	r2, [r3, #72]	; 0x48
      hmdma->XferBlockCpltCallback = NULL;
20012ae0:	687b      	ldr	r3, [r7, #4]
20012ae2:	2200      	movs	r2, #0
20012ae4:	64da      	str	r2, [r3, #76]	; 0x4c
      hmdma->XferRepeatBlockCpltCallback = NULL;
20012ae6:	687b      	ldr	r3, [r7, #4]
20012ae8:	2200      	movs	r2, #0
20012aea:	651a      	str	r2, [r3, #80]	; 0x50
      hmdma->XferErrorCallback = NULL;
20012aec:	687b      	ldr	r3, [r7, #4]
20012aee:	2200      	movs	r2, #0
20012af0:	655a      	str	r2, [r3, #84]	; 0x54
      hmdma->XferAbortCallback = NULL;
20012af2:	687b      	ldr	r3, [r7, #4]
20012af4:	2200      	movs	r2, #0
20012af6:	659a      	str	r2, [r3, #88]	; 0x58
      break;
20012af8:	e005      	b.n	20012b06 <HAL_MDMA_UnRegisterCallback+0xc6>

    default:
      status = HAL_ERROR;
20012afa:	2301      	movs	r3, #1
20012afc:	73fb      	strb	r3, [r7, #15]
      break;
20012afe:	bf00      	nop
20012b00:	e001      	b.n	20012b06 <HAL_MDMA_UnRegisterCallback+0xc6>
    }
  }
  else
  {
    status = HAL_ERROR;
20012b02:	2301      	movs	r3, #1
20012b04:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
20012b06:	687b      	ldr	r3, [r7, #4]
20012b08:	2200      	movs	r2, #0
20012b0a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
20012b0e:	7bfb      	ldrb	r3, [r7, #15]
}
20012b10:	4618      	mov	r0, r3
20012b12:	3714      	adds	r7, #20
20012b14:	46bd      	mov	sp, r7
20012b16:	f85d 7b04 	ldr.w	r7, [sp], #4
20012b1a:	4770      	bx	lr

20012b1c <HAL_MDMA_LinkedList_CreateNode>:
  * @param  pNodeConfig: Pointer to a MDMA_LinkNodeConfTypeDef structure that contains
  *               the configuration information for the specified MDMA Linked List Node.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_CreateNode(MDMA_LinkNodeTypeDef *pNode, MDMA_LinkNodeConfTypeDef *pNodeConfig)
{
20012b1c:	b580      	push	{r7, lr}
20012b1e:	b084      	sub	sp, #16
20012b20:	af00      	add	r7, sp, #0
20012b22:	6078      	str	r0, [r7, #4]
20012b24:	6039      	str	r1, [r7, #0]
  uint32_t addressMask;
  uint32_t blockoffset;

  /* Check the MDMA peripheral state */
  if((pNode == NULL) || (pNodeConfig == NULL))
20012b26:	687b      	ldr	r3, [r7, #4]
20012b28:	2b00      	cmp	r3, #0
20012b2a:	d002      	beq.n	20012b32 <HAL_MDMA_LinkedList_CreateNode+0x16>
20012b2c:	683b      	ldr	r3, [r7, #0]
20012b2e:	2b00      	cmp	r3, #0
20012b30:	d101      	bne.n	20012b36 <HAL_MDMA_LinkedList_CreateNode+0x1a>
  {
    return HAL_ERROR;
20012b32:	2301      	movs	r3, #1
20012b34:	e267      	b.n	20013006 <HAL_MDMA_LinkedList_CreateNode+0x4ea>
  }

  /* Check the parameters */
  assert_param(IS_MDMA_PRIORITY(pNodeConfig->Init.Priority));
20012b36:	683b      	ldr	r3, [r7, #0]
20012b38:	689b      	ldr	r3, [r3, #8]
20012b3a:	2b00      	cmp	r3, #0
20012b3c:	d010      	beq.n	20012b60 <HAL_MDMA_LinkedList_CreateNode+0x44>
20012b3e:	683b      	ldr	r3, [r7, #0]
20012b40:	689b      	ldr	r3, [r3, #8]
20012b42:	2b40      	cmp	r3, #64	; 0x40
20012b44:	d00c      	beq.n	20012b60 <HAL_MDMA_LinkedList_CreateNode+0x44>
20012b46:	683b      	ldr	r3, [r7, #0]
20012b48:	689b      	ldr	r3, [r3, #8]
20012b4a:	2b80      	cmp	r3, #128	; 0x80
20012b4c:	d008      	beq.n	20012b60 <HAL_MDMA_LinkedList_CreateNode+0x44>
20012b4e:	683b      	ldr	r3, [r7, #0]
20012b50:	689b      	ldr	r3, [r3, #8]
20012b52:	2bc0      	cmp	r3, #192	; 0xc0
20012b54:	d004      	beq.n	20012b60 <HAL_MDMA_LinkedList_CreateNode+0x44>
20012b56:	f240 2145 	movw	r1, #581	; 0x245
20012b5a:	489c      	ldr	r0, [pc, #624]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012b5c:	f7ed feca 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_ENDIANNESS_MODE(pNodeConfig->Init.Endianness));
20012b60:	683b      	ldr	r3, [r7, #0]
20012b62:	68db      	ldr	r3, [r3, #12]
20012b64:	2b00      	cmp	r3, #0
20012b66:	d013      	beq.n	20012b90 <HAL_MDMA_LinkedList_CreateNode+0x74>
20012b68:	683b      	ldr	r3, [r7, #0]
20012b6a:	68db      	ldr	r3, [r3, #12]
20012b6c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20012b70:	d00e      	beq.n	20012b90 <HAL_MDMA_LinkedList_CreateNode+0x74>
20012b72:	683b      	ldr	r3, [r7, #0]
20012b74:	68db      	ldr	r3, [r3, #12]
20012b76:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20012b7a:	d009      	beq.n	20012b90 <HAL_MDMA_LinkedList_CreateNode+0x74>
20012b7c:	683b      	ldr	r3, [r7, #0]
20012b7e:	68db      	ldr	r3, [r3, #12]
20012b80:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20012b84:	d004      	beq.n	20012b90 <HAL_MDMA_LinkedList_CreateNode+0x74>
20012b86:	f240 2146 	movw	r1, #582	; 0x246
20012b8a:	4890      	ldr	r0, [pc, #576]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012b8c:	f7ed feb2 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_REQUEST(pNodeConfig->Init.Request));
20012b90:	683b      	ldr	r3, [r7, #0]
20012b92:	681b      	ldr	r3, [r3, #0]
20012b94:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20012b98:	d008      	beq.n	20012bac <HAL_MDMA_LinkedList_CreateNode+0x90>
20012b9a:	683b      	ldr	r3, [r7, #0]
20012b9c:	681b      	ldr	r3, [r3, #0]
20012b9e:	2b1f      	cmp	r3, #31
20012ba0:	d904      	bls.n	20012bac <HAL_MDMA_LinkedList_CreateNode+0x90>
20012ba2:	f240 2147 	movw	r1, #583	; 0x247
20012ba6:	4889      	ldr	r0, [pc, #548]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012ba8:	f7ed fea4 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_SOURCE_INC(pNodeConfig->Init.SourceInc));
20012bac:	683b      	ldr	r3, [r7, #0]
20012bae:	691b      	ldr	r3, [r3, #16]
20012bb0:	2b00      	cmp	r3, #0
20012bb2:	d02f      	beq.n	20012c14 <HAL_MDMA_LinkedList_CreateNode+0xf8>
20012bb4:	683b      	ldr	r3, [r7, #0]
20012bb6:	691b      	ldr	r3, [r3, #16]
20012bb8:	2b02      	cmp	r3, #2
20012bba:	d02b      	beq.n	20012c14 <HAL_MDMA_LinkedList_CreateNode+0xf8>
20012bbc:	683b      	ldr	r3, [r7, #0]
20012bbe:	691b      	ldr	r3, [r3, #16]
20012bc0:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
20012bc4:	d026      	beq.n	20012c14 <HAL_MDMA_LinkedList_CreateNode+0xf8>
20012bc6:	683b      	ldr	r3, [r7, #0]
20012bc8:	691b      	ldr	r3, [r3, #16]
20012bca:	f240 2202 	movw	r2, #514	; 0x202
20012bce:	4293      	cmp	r3, r2
20012bd0:	d020      	beq.n	20012c14 <HAL_MDMA_LinkedList_CreateNode+0xf8>
20012bd2:	683b      	ldr	r3, [r7, #0]
20012bd4:	691b      	ldr	r3, [r3, #16]
20012bd6:	f240 3202 	movw	r2, #770	; 0x302
20012bda:	4293      	cmp	r3, r2
20012bdc:	d01a      	beq.n	20012c14 <HAL_MDMA_LinkedList_CreateNode+0xf8>
20012bde:	683b      	ldr	r3, [r7, #0]
20012be0:	691b      	ldr	r3, [r3, #16]
20012be2:	2b03      	cmp	r3, #3
20012be4:	d016      	beq.n	20012c14 <HAL_MDMA_LinkedList_CreateNode+0xf8>
20012be6:	683b      	ldr	r3, [r7, #0]
20012be8:	691b      	ldr	r3, [r3, #16]
20012bea:	f240 1203 	movw	r2, #259	; 0x103
20012bee:	4293      	cmp	r3, r2
20012bf0:	d010      	beq.n	20012c14 <HAL_MDMA_LinkedList_CreateNode+0xf8>
20012bf2:	683b      	ldr	r3, [r7, #0]
20012bf4:	691b      	ldr	r3, [r3, #16]
20012bf6:	f240 2203 	movw	r2, #515	; 0x203
20012bfa:	4293      	cmp	r3, r2
20012bfc:	d00a      	beq.n	20012c14 <HAL_MDMA_LinkedList_CreateNode+0xf8>
20012bfe:	683b      	ldr	r3, [r7, #0]
20012c00:	691b      	ldr	r3, [r3, #16]
20012c02:	f240 3203 	movw	r2, #771	; 0x303
20012c06:	4293      	cmp	r3, r2
20012c08:	d004      	beq.n	20012c14 <HAL_MDMA_LinkedList_CreateNode+0xf8>
20012c0a:	f44f 7112 	mov.w	r1, #584	; 0x248
20012c0e:	486f      	ldr	r0, [pc, #444]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012c10:	f7ed fe70 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_DESTINATION_INC(pNodeConfig->Init.DestinationInc));
20012c14:	683b      	ldr	r3, [r7, #0]
20012c16:	695b      	ldr	r3, [r3, #20]
20012c18:	2b00      	cmp	r3, #0
20012c1a:	d02f      	beq.n	20012c7c <HAL_MDMA_LinkedList_CreateNode+0x160>
20012c1c:	683b      	ldr	r3, [r7, #0]
20012c1e:	695b      	ldr	r3, [r3, #20]
20012c20:	2b08      	cmp	r3, #8
20012c22:	d02b      	beq.n	20012c7c <HAL_MDMA_LinkedList_CreateNode+0x160>
20012c24:	683b      	ldr	r3, [r7, #0]
20012c26:	695b      	ldr	r3, [r3, #20]
20012c28:	f5b3 6f81 	cmp.w	r3, #1032	; 0x408
20012c2c:	d026      	beq.n	20012c7c <HAL_MDMA_LinkedList_CreateNode+0x160>
20012c2e:	683b      	ldr	r3, [r7, #0]
20012c30:	695b      	ldr	r3, [r3, #20]
20012c32:	f640 0208 	movw	r2, #2056	; 0x808
20012c36:	4293      	cmp	r3, r2
20012c38:	d020      	beq.n	20012c7c <HAL_MDMA_LinkedList_CreateNode+0x160>
20012c3a:	683b      	ldr	r3, [r7, #0]
20012c3c:	695b      	ldr	r3, [r3, #20]
20012c3e:	f640 4208 	movw	r2, #3080	; 0xc08
20012c42:	4293      	cmp	r3, r2
20012c44:	d01a      	beq.n	20012c7c <HAL_MDMA_LinkedList_CreateNode+0x160>
20012c46:	683b      	ldr	r3, [r7, #0]
20012c48:	695b      	ldr	r3, [r3, #20]
20012c4a:	2b0c      	cmp	r3, #12
20012c4c:	d016      	beq.n	20012c7c <HAL_MDMA_LinkedList_CreateNode+0x160>
20012c4e:	683b      	ldr	r3, [r7, #0]
20012c50:	695b      	ldr	r3, [r3, #20]
20012c52:	f240 420c 	movw	r2, #1036	; 0x40c
20012c56:	4293      	cmp	r3, r2
20012c58:	d010      	beq.n	20012c7c <HAL_MDMA_LinkedList_CreateNode+0x160>
20012c5a:	683b      	ldr	r3, [r7, #0]
20012c5c:	695b      	ldr	r3, [r3, #20]
20012c5e:	f640 020c 	movw	r2, #2060	; 0x80c
20012c62:	4293      	cmp	r3, r2
20012c64:	d00a      	beq.n	20012c7c <HAL_MDMA_LinkedList_CreateNode+0x160>
20012c66:	683b      	ldr	r3, [r7, #0]
20012c68:	695b      	ldr	r3, [r3, #20]
20012c6a:	f640 420c 	movw	r2, #3084	; 0xc0c
20012c6e:	4293      	cmp	r3, r2
20012c70:	d004      	beq.n	20012c7c <HAL_MDMA_LinkedList_CreateNode+0x160>
20012c72:	f240 2149 	movw	r1, #585	; 0x249
20012c76:	4855      	ldr	r0, [pc, #340]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012c78:	f7ed fe3c 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_SOURCE_DATASIZE(pNodeConfig->Init.SourceDataSize));
20012c7c:	683b      	ldr	r3, [r7, #0]
20012c7e:	699b      	ldr	r3, [r3, #24]
20012c80:	2b00      	cmp	r3, #0
20012c82:	d010      	beq.n	20012ca6 <HAL_MDMA_LinkedList_CreateNode+0x18a>
20012c84:	683b      	ldr	r3, [r7, #0]
20012c86:	699b      	ldr	r3, [r3, #24]
20012c88:	2b10      	cmp	r3, #16
20012c8a:	d00c      	beq.n	20012ca6 <HAL_MDMA_LinkedList_CreateNode+0x18a>
20012c8c:	683b      	ldr	r3, [r7, #0]
20012c8e:	699b      	ldr	r3, [r3, #24]
20012c90:	2b20      	cmp	r3, #32
20012c92:	d008      	beq.n	20012ca6 <HAL_MDMA_LinkedList_CreateNode+0x18a>
20012c94:	683b      	ldr	r3, [r7, #0]
20012c96:	699b      	ldr	r3, [r3, #24]
20012c98:	2b30      	cmp	r3, #48	; 0x30
20012c9a:	d004      	beq.n	20012ca6 <HAL_MDMA_LinkedList_CreateNode+0x18a>
20012c9c:	f240 214a 	movw	r1, #586	; 0x24a
20012ca0:	484a      	ldr	r0, [pc, #296]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012ca2:	f7ed fe27 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_DESTINATION_DATASIZE(pNodeConfig->Init.DestDataSize));
20012ca6:	683b      	ldr	r3, [r7, #0]
20012ca8:	69db      	ldr	r3, [r3, #28]
20012caa:	2b00      	cmp	r3, #0
20012cac:	d010      	beq.n	20012cd0 <HAL_MDMA_LinkedList_CreateNode+0x1b4>
20012cae:	683b      	ldr	r3, [r7, #0]
20012cb0:	69db      	ldr	r3, [r3, #28]
20012cb2:	2b40      	cmp	r3, #64	; 0x40
20012cb4:	d00c      	beq.n	20012cd0 <HAL_MDMA_LinkedList_CreateNode+0x1b4>
20012cb6:	683b      	ldr	r3, [r7, #0]
20012cb8:	69db      	ldr	r3, [r3, #28]
20012cba:	2b80      	cmp	r3, #128	; 0x80
20012cbc:	d008      	beq.n	20012cd0 <HAL_MDMA_LinkedList_CreateNode+0x1b4>
20012cbe:	683b      	ldr	r3, [r7, #0]
20012cc0:	69db      	ldr	r3, [r3, #28]
20012cc2:	2bc0      	cmp	r3, #192	; 0xc0
20012cc4:	d004      	beq.n	20012cd0 <HAL_MDMA_LinkedList_CreateNode+0x1b4>
20012cc6:	f240 214b 	movw	r1, #587	; 0x24b
20012cca:	4840      	ldr	r0, [pc, #256]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012ccc:	f7ed fe12 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_DATA_ALIGNMENT(pNodeConfig->Init.DataAlignment));
20012cd0:	683b      	ldr	r3, [r7, #0]
20012cd2:	6a1b      	ldr	r3, [r3, #32]
20012cd4:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20012cd8:	d012      	beq.n	20012d00 <HAL_MDMA_LinkedList_CreateNode+0x1e4>
20012cda:	683b      	ldr	r3, [r7, #0]
20012cdc:	6a1b      	ldr	r3, [r3, #32]
20012cde:	2b00      	cmp	r3, #0
20012ce0:	d00e      	beq.n	20012d00 <HAL_MDMA_LinkedList_CreateNode+0x1e4>
20012ce2:	683b      	ldr	r3, [r7, #0]
20012ce4:	6a1b      	ldr	r3, [r3, #32]
20012ce6:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
20012cea:	d009      	beq.n	20012d00 <HAL_MDMA_LinkedList_CreateNode+0x1e4>
20012cec:	683b      	ldr	r3, [r7, #0]
20012cee:	6a1b      	ldr	r3, [r3, #32]
20012cf0:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
20012cf4:	d004      	beq.n	20012d00 <HAL_MDMA_LinkedList_CreateNode+0x1e4>
20012cf6:	f44f 7113 	mov.w	r1, #588	; 0x24c
20012cfa:	4834      	ldr	r0, [pc, #208]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012cfc:	f7ed fdfa 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_SOURCE_BURST(pNodeConfig->Init.SourceBurst));
20012d00:	683b      	ldr	r3, [r7, #0]
20012d02:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012d04:	2b00      	cmp	r3, #0
20012d06:	d027      	beq.n	20012d58 <HAL_MDMA_LinkedList_CreateNode+0x23c>
20012d08:	683b      	ldr	r3, [r7, #0]
20012d0a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012d0c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20012d10:	d022      	beq.n	20012d58 <HAL_MDMA_LinkedList_CreateNode+0x23c>
20012d12:	683b      	ldr	r3, [r7, #0]
20012d14:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012d16:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20012d1a:	d01d      	beq.n	20012d58 <HAL_MDMA_LinkedList_CreateNode+0x23c>
20012d1c:	683b      	ldr	r3, [r7, #0]
20012d1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012d20:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
20012d24:	d018      	beq.n	20012d58 <HAL_MDMA_LinkedList_CreateNode+0x23c>
20012d26:	683b      	ldr	r3, [r7, #0]
20012d28:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012d2a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20012d2e:	d013      	beq.n	20012d58 <HAL_MDMA_LinkedList_CreateNode+0x23c>
20012d30:	683b      	ldr	r3, [r7, #0]
20012d32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012d34:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
20012d38:	d00e      	beq.n	20012d58 <HAL_MDMA_LinkedList_CreateNode+0x23c>
20012d3a:	683b      	ldr	r3, [r7, #0]
20012d3c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012d3e:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
20012d42:	d009      	beq.n	20012d58 <HAL_MDMA_LinkedList_CreateNode+0x23c>
20012d44:	683b      	ldr	r3, [r7, #0]
20012d46:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012d48:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
20012d4c:	d004      	beq.n	20012d58 <HAL_MDMA_LinkedList_CreateNode+0x23c>
20012d4e:	f240 214d 	movw	r1, #589	; 0x24d
20012d52:	481e      	ldr	r0, [pc, #120]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012d54:	f7ed fdce 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_DESTINATION_BURST(pNodeConfig->Init.DestBurst));
20012d58:	683b      	ldr	r3, [r7, #0]
20012d5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20012d5c:	2b00      	cmp	r3, #0
20012d5e:	d027      	beq.n	20012db0 <HAL_MDMA_LinkedList_CreateNode+0x294>
20012d60:	683b      	ldr	r3, [r7, #0]
20012d62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20012d64:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20012d68:	d022      	beq.n	20012db0 <HAL_MDMA_LinkedList_CreateNode+0x294>
20012d6a:	683b      	ldr	r3, [r7, #0]
20012d6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20012d6e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20012d72:	d01d      	beq.n	20012db0 <HAL_MDMA_LinkedList_CreateNode+0x294>
20012d74:	683b      	ldr	r3, [r7, #0]
20012d76:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20012d78:	f5b3 3fc0 	cmp.w	r3, #98304	; 0x18000
20012d7c:	d018      	beq.n	20012db0 <HAL_MDMA_LinkedList_CreateNode+0x294>
20012d7e:	683b      	ldr	r3, [r7, #0]
20012d80:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20012d82:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20012d86:	d013      	beq.n	20012db0 <HAL_MDMA_LinkedList_CreateNode+0x294>
20012d88:	683b      	ldr	r3, [r7, #0]
20012d8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20012d8c:	f5b3 3f20 	cmp.w	r3, #163840	; 0x28000
20012d90:	d00e      	beq.n	20012db0 <HAL_MDMA_LinkedList_CreateNode+0x294>
20012d92:	683b      	ldr	r3, [r7, #0]
20012d94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20012d96:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
20012d9a:	d009      	beq.n	20012db0 <HAL_MDMA_LinkedList_CreateNode+0x294>
20012d9c:	683b      	ldr	r3, [r7, #0]
20012d9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20012da0:	f5b3 3f60 	cmp.w	r3, #229376	; 0x38000
20012da4:	d004      	beq.n	20012db0 <HAL_MDMA_LinkedList_CreateNode+0x294>
20012da6:	f240 214e 	movw	r1, #590	; 0x24e
20012daa:	4808      	ldr	r0, [pc, #32]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012dac:	f7ed fda2 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_BUFFER_TRANSFER_LENGTH(pNodeConfig->Init.BufferTransferLength));
20012db0:	683b      	ldr	r3, [r7, #0]
20012db2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20012db4:	2b00      	cmp	r3, #0
20012db6:	d003      	beq.n	20012dc0 <HAL_MDMA_LinkedList_CreateNode+0x2a4>
20012db8:	683b      	ldr	r3, [r7, #0]
20012dba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20012dbc:	2bfe      	cmp	r3, #254	; 0xfe
20012dbe:	d907      	bls.n	20012dd0 <HAL_MDMA_LinkedList_CreateNode+0x2b4>
20012dc0:	f240 214f 	movw	r1, #591	; 0x24f
20012dc4:	4801      	ldr	r0, [pc, #4]	; (20012dcc <HAL_MDMA_LinkedList_CreateNode+0x2b0>)
20012dc6:	f7ed fd95 	bl	200008f4 <assert_failed>
20012dca:	e001      	b.n	20012dd0 <HAL_MDMA_LinkedList_CreateNode+0x2b4>
20012dcc:	2001c1f4 	.word	0x2001c1f4
  assert_param(IS_MDMA_TRANSFER_TRIGGER_MODE(pNodeConfig->Init.TransferTriggerMode));
20012dd0:	683b      	ldr	r3, [r7, #0]
20012dd2:	685b      	ldr	r3, [r3, #4]
20012dd4:	2b00      	cmp	r3, #0
20012dd6:	d013      	beq.n	20012e00 <HAL_MDMA_LinkedList_CreateNode+0x2e4>
20012dd8:	683b      	ldr	r3, [r7, #0]
20012dda:	685b      	ldr	r3, [r3, #4]
20012ddc:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
20012de0:	d00e      	beq.n	20012e00 <HAL_MDMA_LinkedList_CreateNode+0x2e4>
20012de2:	683b      	ldr	r3, [r7, #0]
20012de4:	685b      	ldr	r3, [r3, #4]
20012de6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20012dea:	d009      	beq.n	20012e00 <HAL_MDMA_LinkedList_CreateNode+0x2e4>
20012dec:	683b      	ldr	r3, [r7, #0]
20012dee:	685b      	ldr	r3, [r3, #4]
20012df0:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
20012df4:	d004      	beq.n	20012e00 <HAL_MDMA_LinkedList_CreateNode+0x2e4>
20012df6:	f44f 7114 	mov.w	r1, #592	; 0x250
20012dfa:	4885      	ldr	r0, [pc, #532]	; (20013010 <HAL_MDMA_LinkedList_CreateNode+0x4f4>)
20012dfc:	f7ed fd7a 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(pNodeConfig->Init.SourceBlockAddressOffset));
20012e00:	683b      	ldr	r3, [r7, #0]
20012e02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20012e04:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
20012e08:	dd04      	ble.n	20012e14 <HAL_MDMA_LinkedList_CreateNode+0x2f8>
20012e0a:	683b      	ldr	r3, [r7, #0]
20012e0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20012e0e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20012e12:	db04      	blt.n	20012e1e <HAL_MDMA_LinkedList_CreateNode+0x302>
20012e14:	f240 2151 	movw	r1, #593	; 0x251
20012e18:	487d      	ldr	r0, [pc, #500]	; (20013010 <HAL_MDMA_LinkedList_CreateNode+0x4f4>)
20012e1a:	f7ed fd6b 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(pNodeConfig->Init.DestBlockAddressOffset));
20012e1e:	683b      	ldr	r3, [r7, #0]
20012e20:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20012e22:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
20012e26:	dd04      	ble.n	20012e32 <HAL_MDMA_LinkedList_CreateNode+0x316>
20012e28:	683b      	ldr	r3, [r7, #0]
20012e2a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20012e2c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20012e30:	db04      	blt.n	20012e3c <HAL_MDMA_LinkedList_CreateNode+0x320>
20012e32:	f240 2152 	movw	r1, #594	; 0x252
20012e36:	4876      	ldr	r0, [pc, #472]	; (20013010 <HAL_MDMA_LinkedList_CreateNode+0x4f4>)
20012e38:	f7ed fd5c 	bl	200008f4 <assert_failed>

  assert_param(IS_MDMA_TRANSFER_LENGTH(pNodeConfig->BlockDataLength));
20012e3c:	683b      	ldr	r3, [r7, #0]
20012e3e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20012e40:	2b00      	cmp	r3, #0
20012e42:	d004      	beq.n	20012e4e <HAL_MDMA_LinkedList_CreateNode+0x332>
20012e44:	683b      	ldr	r3, [r7, #0]
20012e46:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20012e48:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20012e4c:	d904      	bls.n	20012e58 <HAL_MDMA_LinkedList_CreateNode+0x33c>
20012e4e:	f44f 7115 	mov.w	r1, #596	; 0x254
20012e52:	486f      	ldr	r0, [pc, #444]	; (20013010 <HAL_MDMA_LinkedList_CreateNode+0x4f4>)
20012e54:	f7ed fd4e 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_BLOCK_COUNT(pNodeConfig->BlockCount));
20012e58:	683b      	ldr	r3, [r7, #0]
20012e5a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20012e5c:	2b00      	cmp	r3, #0
20012e5e:	d004      	beq.n	20012e6a <HAL_MDMA_LinkedList_CreateNode+0x34e>
20012e60:	683b      	ldr	r3, [r7, #0]
20012e62:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20012e64:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20012e68:	d904      	bls.n	20012e74 <HAL_MDMA_LinkedList_CreateNode+0x358>
20012e6a:	f240 2155 	movw	r1, #597	; 0x255
20012e6e:	4868      	ldr	r0, [pc, #416]	; (20013010 <HAL_MDMA_LinkedList_CreateNode+0x4f4>)
20012e70:	f7ed fd40 	bl	200008f4 <assert_failed>


  /* Configure next Link node Address Register to zero */
  pNode->CLAR =  0;
20012e74:	687b      	ldr	r3, [r7, #4]
20012e76:	2200      	movs	r2, #0
20012e78:	615a      	str	r2, [r3, #20]

  /* Configure the Link Node registers*/
  pNode->CTBR   = 0;
20012e7a:	687b      	ldr	r3, [r7, #4]
20012e7c:	2200      	movs	r2, #0
20012e7e:	619a      	str	r2, [r3, #24]
  pNode->CMAR   = 0;
20012e80:	687b      	ldr	r3, [r7, #4]
20012e82:	2200      	movs	r2, #0
20012e84:	621a      	str	r2, [r3, #32]
  pNode->CMDR   = 0;
20012e86:	687b      	ldr	r3, [r7, #4]
20012e88:	2200      	movs	r2, #0
20012e8a:	625a      	str	r2, [r3, #36]	; 0x24
  pNode->Reserved = 0;
20012e8c:	687b      	ldr	r3, [r7, #4]
20012e8e:	2200      	movs	r2, #0
20012e90:	61da      	str	r2, [r3, #28]

  /* Write new CTCR Register value */
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
20012e92:	683b      	ldr	r3, [r7, #0]
20012e94:	691a      	ldr	r2, [r3, #16]
20012e96:	683b      	ldr	r3, [r7, #0]
20012e98:	695b      	ldr	r3, [r3, #20]
20012e9a:	431a      	orrs	r2, r3
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
20012e9c:	683b      	ldr	r3, [r7, #0]
20012e9e:	699b      	ldr	r3, [r3, #24]
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
20012ea0:	431a      	orrs	r2, r3
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
20012ea2:	683b      	ldr	r3, [r7, #0]
20012ea4:	69db      	ldr	r3, [r3, #28]
20012ea6:	431a      	orrs	r2, r3
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
20012ea8:	683b      	ldr	r3, [r7, #0]
20012eaa:	6a1b      	ldr	r3, [r3, #32]
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
20012eac:	431a      	orrs	r2, r3
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
20012eae:	683b      	ldr	r3, [r7, #0]
20012eb0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20012eb2:	431a      	orrs	r2, r3
        pNodeConfig->Init.DestBurst                                             | \
20012eb4:	683b      	ldr	r3, [r7, #0]
20012eb6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
20012eb8:	431a      	orrs	r2, r3
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
20012eba:	683b      	ldr	r3, [r7, #0]
20012ebc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20012ebe:	3b01      	subs	r3, #1
20012ec0:	049b      	lsls	r3, r3, #18
        pNodeConfig->Init.DestBurst                                             | \
20012ec2:	431a      	orrs	r2, r3
            pNodeConfig->Init.TransferTriggerMode;
20012ec4:	683b      	ldr	r3, [r7, #0]
20012ec6:	685b      	ldr	r3, [r3, #4]
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
20012ec8:	431a      	orrs	r2, r3
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
20012eca:	687b      	ldr	r3, [r7, #4]
20012ecc:	601a      	str	r2, [r3, #0]

  /* If SW request set the CTCR register to SW Request Mode*/
  if(pNodeConfig->Init.Request == MDMA_REQUEST_SW)
20012ece:	683b      	ldr	r3, [r7, #0]
20012ed0:	681b      	ldr	r3, [r3, #0]
20012ed2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20012ed6:	d105      	bne.n	20012ee4 <HAL_MDMA_LinkedList_CreateNode+0x3c8>
  {
    pNode->CTCR |= MDMA_CTCR_SWRM;
20012ed8:	687b      	ldr	r3, [r7, #4]
20012eda:	681b      	ldr	r3, [r3, #0]
20012edc:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
20012ee0:	687b      	ldr	r3, [r7, #4]
20012ee2:	601a      	str	r2, [r3, #0]
  -If the request is done by SW : BWM could be set to 1 or 0.
  -If the request is done by a peripheral :
     If mask address not set (0) => BWM must be set to 0
     If mask address set (different than 0) => BWM could be set to 1 or 0
  */
  if((pNodeConfig->Init.Request == MDMA_REQUEST_SW) || (pNodeConfig->PostRequestMaskAddress != 0U))
20012ee4:	683b      	ldr	r3, [r7, #0]
20012ee6:	681b      	ldr	r3, [r3, #0]
20012ee8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20012eec:	d003      	beq.n	20012ef6 <HAL_MDMA_LinkedList_CreateNode+0x3da>
20012eee:	683b      	ldr	r3, [r7, #0]
20012ef0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20012ef2:	2b00      	cmp	r3, #0
20012ef4:	d005      	beq.n	20012f02 <HAL_MDMA_LinkedList_CreateNode+0x3e6>
  {
    pNode->CTCR |=  MDMA_CTCR_BWM;
20012ef6:	687b      	ldr	r3, [r7, #4]
20012ef8:	681b      	ldr	r3, [r3, #0]
20012efa:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
20012efe:	687b      	ldr	r3, [r7, #4]
20012f00:	601a      	str	r2, [r3, #0]
  }

  /* Set the new CBNDTR Register value */
  pNode->CBNDTR = ((pNodeConfig->BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC;
20012f02:	683b      	ldr	r3, [r7, #0]
20012f04:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20012f06:	3b01      	subs	r3, #1
20012f08:	051a      	lsls	r2, r3, #20
20012f0a:	687b      	ldr	r3, [r7, #4]
20012f0c:	605a      	str	r2, [r3, #4]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(pNodeConfig->Init.SourceBlockAddressOffset < 0)
20012f0e:	683b      	ldr	r3, [r7, #0]
20012f10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20012f12:	2b00      	cmp	r3, #0
20012f14:	da0e      	bge.n	20012f34 <HAL_MDMA_LinkedList_CreateNode+0x418>
  {
    pNode->CBNDTR |= MDMA_CBNDTR_BRSUM;
20012f16:	687b      	ldr	r3, [r7, #4]
20012f18:	685b      	ldr	r3, [r3, #4]
20012f1a:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
20012f1e:	687b      	ldr	r3, [r7, #4]
20012f20:	605a      	str	r2, [r3, #4]
    /*write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- pNodeConfig->Init.SourceBlockAddressOffset);
20012f22:	683b      	ldr	r3, [r7, #0]
20012f24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20012f26:	425b      	negs	r3, r3
20012f28:	60fb      	str	r3, [r7, #12]
    pNode->CBRUR = blockoffset & 0x0000FFFFU;
20012f2a:	68fb      	ldr	r3, [r7, #12]
20012f2c:	b29a      	uxth	r2, r3
20012f2e:	687b      	ldr	r3, [r7, #4]
20012f30:	611a      	str	r2, [r3, #16]
20012f32:	e004      	b.n	20012f3e <HAL_MDMA_LinkedList_CreateNode+0x422>
  }
  else
  {
    /*write new CBRUR Register value : source repeat block offset */
    pNode->CBRUR = (((uint32_t) pNodeConfig->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
20012f34:	683b      	ldr	r3, [r7, #0]
20012f36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20012f38:	b29a      	uxth	r2, r3
20012f3a:	687b      	ldr	r3, [r7, #4]
20012f3c:	611a      	str	r2, [r3, #16]
  }

  /* if block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(pNodeConfig->Init.DestBlockAddressOffset < 0)
20012f3e:	683b      	ldr	r3, [r7, #0]
20012f40:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20012f42:	2b00      	cmp	r3, #0
20012f44:	da11      	bge.n	20012f6a <HAL_MDMA_LinkedList_CreateNode+0x44e>
  {
    pNode->CBNDTR |= MDMA_CBNDTR_BRDUM;
20012f46:	687b      	ldr	r3, [r7, #4]
20012f48:	685b      	ldr	r3, [r3, #4]
20012f4a:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
20012f4e:	687b      	ldr	r3, [r7, #4]
20012f50:	605a      	str	r2, [r3, #4]
    /*write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- pNodeConfig->Init.DestBlockAddressOffset);
20012f52:	683b      	ldr	r3, [r7, #0]
20012f54:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20012f56:	425b      	negs	r3, r3
20012f58:	60fb      	str	r3, [r7, #12]
    pNode->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
20012f5a:	687b      	ldr	r3, [r7, #4]
20012f5c:	691a      	ldr	r2, [r3, #16]
20012f5e:	68fb      	ldr	r3, [r7, #12]
20012f60:	041b      	lsls	r3, r3, #16
20012f62:	431a      	orrs	r2, r3
20012f64:	687b      	ldr	r3, [r7, #4]
20012f66:	611a      	str	r2, [r3, #16]
20012f68:	e007      	b.n	20012f7a <HAL_MDMA_LinkedList_CreateNode+0x45e>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    pNode->CBRUR |= ((((uint32_t)pNodeConfig->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
20012f6a:	687b      	ldr	r3, [r7, #4]
20012f6c:	691a      	ldr	r2, [r3, #16]
20012f6e:	683b      	ldr	r3, [r7, #0]
20012f70:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20012f72:	041b      	lsls	r3, r3, #16
20012f74:	431a      	orrs	r2, r3
20012f76:	687b      	ldr	r3, [r7, #4]
20012f78:	611a      	str	r2, [r3, #16]
  }

  /* Configure MDMA Link Node data length */
  pNode->CBNDTR |=  pNodeConfig->BlockDataLength;
20012f7a:	687b      	ldr	r3, [r7, #4]
20012f7c:	685a      	ldr	r2, [r3, #4]
20012f7e:	683b      	ldr	r3, [r7, #0]
20012f80:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20012f82:	431a      	orrs	r2, r3
20012f84:	687b      	ldr	r3, [r7, #4]
20012f86:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Link Node destination address */
  pNode->CDAR = pNodeConfig->DstAddress;
20012f88:	683b      	ldr	r3, [r7, #0]
20012f8a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
20012f8c:	687b      	ldr	r3, [r7, #4]
20012f8e:	60da      	str	r2, [r3, #12]

  /* Configure MDMA Link Node Source address */
  pNode->CSAR = pNodeConfig->SrcAddress;
20012f90:	683b      	ldr	r3, [r7, #0]
20012f92:	6b9a      	ldr	r2, [r3, #56]	; 0x38
20012f94:	687b      	ldr	r3, [r7, #4]
20012f96:	609a      	str	r2, [r3, #8]

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData,  */
  if(pNodeConfig->Init.Request != MDMA_REQUEST_SW)
20012f98:	683b      	ldr	r3, [r7, #0]
20012f9a:	681b      	ldr	r3, [r3, #0]
20012f9c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20012fa0:	d00c      	beq.n	20012fbc <HAL_MDMA_LinkedList_CreateNode+0x4a0>
  {
    /* Set the HW request in CTBR register  */
    pNode->CTBR = pNodeConfig->Init.Request & MDMA_CTBR_TSEL;
20012fa2:	683b      	ldr	r3, [r7, #0]
20012fa4:	681b      	ldr	r3, [r3, #0]
20012fa6:	b2da      	uxtb	r2, r3
20012fa8:	687b      	ldr	r3, [r7, #4]
20012faa:	619a      	str	r2, [r3, #24]
    /* Set the HW request clear Mask and Data */
    pNode->CMAR = pNodeConfig->PostRequestMaskAddress;
20012fac:	683b      	ldr	r3, [r7, #0]
20012fae:	6c9a      	ldr	r2, [r3, #72]	; 0x48
20012fb0:	687b      	ldr	r3, [r7, #4]
20012fb2:	621a      	str	r2, [r3, #32]
    pNode->CMDR = pNodeConfig->PostRequestMaskData;
20012fb4:	683b      	ldr	r3, [r7, #0]
20012fb6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
20012fb8:	687b      	ldr	r3, [r7, #4]
20012fba:	625a      	str	r2, [r3, #36]	; 0x24
  }

  addressMask = pNodeConfig->SrcAddress & 0xFF000000U;
20012fbc:	683b      	ldr	r3, [r7, #0]
20012fbe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20012fc0:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
20012fc4:	60bb      	str	r3, [r7, #8]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
20012fc6:	68bb      	ldr	r3, [r7, #8]
20012fc8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20012fcc:	d002      	beq.n	20012fd4 <HAL_MDMA_LinkedList_CreateNode+0x4b8>
20012fce:	68bb      	ldr	r3, [r7, #8]
20012fd0:	2b00      	cmp	r3, #0
20012fd2:	d105      	bne.n	20012fe0 <HAL_MDMA_LinkedList_CreateNode+0x4c4>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    pNode->CTBR |= MDMA_CTBR_SBUS;
20012fd4:	687b      	ldr	r3, [r7, #4]
20012fd6:	699b      	ldr	r3, [r3, #24]
20012fd8:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
20012fdc:	687b      	ldr	r3, [r7, #4]
20012fde:	619a      	str	r2, [r3, #24]
  }

  addressMask = pNodeConfig->DstAddress & 0xFF000000U;
20012fe0:	683b      	ldr	r3, [r7, #0]
20012fe2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20012fe4:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
20012fe8:	60bb      	str	r3, [r7, #8]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
20012fea:	68bb      	ldr	r3, [r7, #8]
20012fec:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20012ff0:	d002      	beq.n	20012ff8 <HAL_MDMA_LinkedList_CreateNode+0x4dc>
20012ff2:	68bb      	ldr	r3, [r7, #8]
20012ff4:	2b00      	cmp	r3, #0
20012ff6:	d105      	bne.n	20013004 <HAL_MDMA_LinkedList_CreateNode+0x4e8>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    pNode->CTBR |= MDMA_CTBR_DBUS;
20012ff8:	687b      	ldr	r3, [r7, #4]
20012ffa:	699b      	ldr	r3, [r3, #24]
20012ffc:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
20013000:	687b      	ldr	r3, [r7, #4]
20013002:	619a      	str	r2, [r3, #24]
  }

  return HAL_OK;
20013004:	2300      	movs	r3, #0
}
20013006:	4618      	mov	r0, r3
20013008:	3710      	adds	r7, #16
2001300a:	46bd      	mov	sp, r7
2001300c:	bd80      	pop	{r7, pc}
2001300e:	bf00      	nop
20013010:	2001c1f4 	.word	0x2001c1f4

20013014 <HAL_MDMA_LinkedList_AddNode>:
  *                    at the end of the list
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_AddNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNewNode, MDMA_LinkNodeTypeDef *pPrevNode)
{
20013014:	b480      	push	{r7}
20013016:	b089      	sub	sp, #36	; 0x24
20013018:	af00      	add	r7, sp, #0
2001301a:	60f8      	str	r0, [r7, #12]
2001301c:	60b9      	str	r1, [r7, #8]
2001301e:	607a      	str	r2, [r7, #4]
  MDMA_LinkNodeTypeDef *pNode;
  uint32_t counter = 0, nodeInserted = 0;
20013020:	2300      	movs	r3, #0
20013022:	61bb      	str	r3, [r7, #24]
20013024:	2300      	movs	r3, #0
20013026:	617b      	str	r3, [r7, #20]
  HAL_StatusTypeDef hal_status = HAL_OK;
20013028:	2300      	movs	r3, #0
2001302a:	74fb      	strb	r3, [r7, #19]

  /* Check the MDMA peripheral handle */
  if((hmdma == NULL) || (pNewNode == NULL))
2001302c:	68fb      	ldr	r3, [r7, #12]
2001302e:	2b00      	cmp	r3, #0
20013030:	d002      	beq.n	20013038 <HAL_MDMA_LinkedList_AddNode+0x24>
20013032:	68bb      	ldr	r3, [r7, #8]
20013034:	2b00      	cmp	r3, #0
20013036:	d101      	bne.n	2001303c <HAL_MDMA_LinkedList_AddNode+0x28>
  {
    return HAL_ERROR;
20013038:	2301      	movs	r3, #1
2001303a:	e0a9      	b.n	20013190 <HAL_MDMA_LinkedList_AddNode+0x17c>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2001303c:	68fb      	ldr	r3, [r7, #12]
2001303e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
20013042:	2b01      	cmp	r3, #1
20013044:	d101      	bne.n	2001304a <HAL_MDMA_LinkedList_AddNode+0x36>
20013046:	2302      	movs	r3, #2
20013048:	e0a2      	b.n	20013190 <HAL_MDMA_LinkedList_AddNode+0x17c>
2001304a:	68fb      	ldr	r3, [r7, #12]
2001304c:	2201      	movs	r2, #1
2001304e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
20013052:	68fb      	ldr	r3, [r7, #12]
20013054:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
20013058:	b2db      	uxtb	r3, r3
2001305a:	2b01      	cmp	r3, #1
2001305c:	f040 8093 	bne.w	20013186 <HAL_MDMA_LinkedList_AddNode+0x172>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
20013060:	68fb      	ldr	r3, [r7, #12]
20013062:	2202      	movs	r2, #2
20013064:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Check if this is the first node (after the Inititlization node) */
    if((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U)
20013068:	68fb      	ldr	r3, [r7, #12]
2001306a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2001306c:	2b00      	cmp	r3, #0
2001306e:	d116      	bne.n	2001309e <HAL_MDMA_LinkedList_AddNode+0x8a>
    {
      if(pPrevNode == NULL)
20013070:	687b      	ldr	r3, [r7, #4]
20013072:	2b00      	cmp	r3, #0
20013074:	d110      	bne.n	20013098 <HAL_MDMA_LinkedList_AddNode+0x84>
      {
        /* if this is the first node after the initialization
        connect this node to the node 0 by updating
        the MDMA channel CLAR register to this node address */
        hmdma->Instance->CLAR = (uint32_t)pNewNode;
20013076:	68fb      	ldr	r3, [r7, #12]
20013078:	681b      	ldr	r3, [r3, #0]
2001307a:	68ba      	ldr	r2, [r7, #8]
2001307c:	625a      	str	r2, [r3, #36]	; 0x24
        /* Set the MDMA handle First linked List node*/
        hmdma->FirstLinkedListNodeAddress = pNewNode;
2001307e:	68fb      	ldr	r3, [r7, #12]
20013080:	68ba      	ldr	r2, [r7, #8]
20013082:	65da      	str	r2, [r3, #92]	; 0x5c

        /*reset New node link */
        pNewNode->CLAR = 0;
20013084:	68bb      	ldr	r3, [r7, #8]
20013086:	2200      	movs	r2, #0
20013088:	615a      	str	r2, [r3, #20]

        /* Update the Handle last node address */
        hmdma->LastLinkedListNodeAddress = pNewNode;
2001308a:	68fb      	ldr	r3, [r7, #12]
2001308c:	68ba      	ldr	r2, [r7, #8]
2001308e:	661a      	str	r2, [r3, #96]	; 0x60

        hmdma->LinkedListNodeCounter = 1;
20013090:	68fb      	ldr	r3, [r7, #12]
20013092:	2201      	movs	r2, #1
20013094:	665a      	str	r2, [r3, #100]	; 0x64
20013096:	e06c      	b.n	20013172 <HAL_MDMA_LinkedList_AddNode+0x15e>
      }
      else
      {
        hal_status = HAL_ERROR;
20013098:	2301      	movs	r3, #1
2001309a:	74fb      	strb	r3, [r7, #19]
2001309c:	e069      	b.n	20013172 <HAL_MDMA_LinkedList_AddNode+0x15e>
      }
    }
    else if(hmdma->FirstLinkedListNodeAddress != pNewNode)
2001309e:	68fb      	ldr	r3, [r7, #12]
200130a0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200130a2:	68ba      	ldr	r2, [r7, #8]
200130a4:	429a      	cmp	r2, r3
200130a6:	d062      	beq.n	2001316e <HAL_MDMA_LinkedList_AddNode+0x15a>
    {
      /* Check if the node to insert already exists*/
      pNode = hmdma->FirstLinkedListNodeAddress;
200130a8:	68fb      	ldr	r3, [r7, #12]
200130aa:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200130ac:	61fb      	str	r3, [r7, #28]
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
200130ae:	e00c      	b.n	200130ca <HAL_MDMA_LinkedList_AddNode+0xb6>
      {
        if(pNode->CLAR == (uint32_t)pNewNode)
200130b0:	69fb      	ldr	r3, [r7, #28]
200130b2:	695a      	ldr	r2, [r3, #20]
200130b4:	68bb      	ldr	r3, [r7, #8]
200130b6:	429a      	cmp	r2, r3
200130b8:	d101      	bne.n	200130be <HAL_MDMA_LinkedList_AddNode+0xaa>
        {
          hal_status = HAL_ERROR; /* error this node already exist in the linked list and it is not first node */
200130ba:	2301      	movs	r3, #1
200130bc:	74fb      	strb	r3, [r7, #19]
        }
        pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
200130be:	69fb      	ldr	r3, [r7, #28]
200130c0:	695b      	ldr	r3, [r3, #20]
200130c2:	61fb      	str	r3, [r7, #28]
        counter++;
200130c4:	69bb      	ldr	r3, [r7, #24]
200130c6:	3301      	adds	r3, #1
200130c8:	61bb      	str	r3, [r7, #24]
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
200130ca:	68fb      	ldr	r3, [r7, #12]
200130cc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
200130ce:	69ba      	ldr	r2, [r7, #24]
200130d0:	429a      	cmp	r2, r3
200130d2:	d202      	bcs.n	200130da <HAL_MDMA_LinkedList_AddNode+0xc6>
200130d4:	7cfb      	ldrb	r3, [r7, #19]
200130d6:	2b00      	cmp	r3, #0
200130d8:	d0ea      	beq.n	200130b0 <HAL_MDMA_LinkedList_AddNode+0x9c>
      }

      if(hal_status == HAL_OK)
200130da:	7cfb      	ldrb	r3, [r7, #19]
200130dc:	2b00      	cmp	r3, #0
200130de:	d148      	bne.n	20013172 <HAL_MDMA_LinkedList_AddNode+0x15e>
      {
        /* Check if the previous node is the last one in the current list or zero */
        if((pPrevNode == hmdma->LastLinkedListNodeAddress) || (pPrevNode == NULL))
200130e0:	68fb      	ldr	r3, [r7, #12]
200130e2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200130e4:	687a      	ldr	r2, [r7, #4]
200130e6:	429a      	cmp	r2, r3
200130e8:	d002      	beq.n	200130f0 <HAL_MDMA_LinkedList_AddNode+0xdc>
200130ea:	687b      	ldr	r3, [r7, #4]
200130ec:	2b00      	cmp	r3, #0
200130ee:	d111      	bne.n	20013114 <HAL_MDMA_LinkedList_AddNode+0x100>
        {
          /* insert the new node at the end of the list */
          pNewNode->CLAR = hmdma->LastLinkedListNodeAddress->CLAR;
200130f0:	68fb      	ldr	r3, [r7, #12]
200130f2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200130f4:	695a      	ldr	r2, [r3, #20]
200130f6:	68bb      	ldr	r3, [r7, #8]
200130f8:	615a      	str	r2, [r3, #20]
          hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)pNewNode;
200130fa:	68fb      	ldr	r3, [r7, #12]
200130fc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200130fe:	68ba      	ldr	r2, [r7, #8]
20013100:	615a      	str	r2, [r3, #20]
          /* Update the Handle last node address */
          hmdma->LastLinkedListNodeAddress = pNewNode;
20013102:	68fb      	ldr	r3, [r7, #12]
20013104:	68ba      	ldr	r2, [r7, #8]
20013106:	661a      	str	r2, [r3, #96]	; 0x60
          /* Increment the linked list node counter */
          hmdma->LinkedListNodeCounter++;
20013108:	68fb      	ldr	r3, [r7, #12]
2001310a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2001310c:	1c5a      	adds	r2, r3, #1
2001310e:	68fb      	ldr	r3, [r7, #12]
20013110:	665a      	str	r2, [r3, #100]	; 0x64
20013112:	e02e      	b.n	20013172 <HAL_MDMA_LinkedList_AddNode+0x15e>
        }
        else
        {
          /*insert the new node after the pPreviousNode node */
          pNode = hmdma->FirstLinkedListNodeAddress;
20013114:	68fb      	ldr	r3, [r7, #12]
20013116:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20013118:	61fb      	str	r3, [r7, #28]
          counter = 0;
2001311a:	2300      	movs	r3, #0
2001311c:	61bb      	str	r3, [r7, #24]
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
2001311e:	e018      	b.n	20013152 <HAL_MDMA_LinkedList_AddNode+0x13e>
          {
            counter++;
20013120:	69bb      	ldr	r3, [r7, #24]
20013122:	3301      	adds	r3, #1
20013124:	61bb      	str	r3, [r7, #24]
            if(pNode == pPrevNode)
20013126:	69fa      	ldr	r2, [r7, #28]
20013128:	687b      	ldr	r3, [r7, #4]
2001312a:	429a      	cmp	r2, r3
2001312c:	d10e      	bne.n	2001314c <HAL_MDMA_LinkedList_AddNode+0x138>
            {
              /*Insert the new node after the previous one */
              pNewNode->CLAR = pNode->CLAR;
2001312e:	69fb      	ldr	r3, [r7, #28]
20013130:	695a      	ldr	r2, [r3, #20]
20013132:	68bb      	ldr	r3, [r7, #8]
20013134:	615a      	str	r2, [r3, #20]
              pNode->CLAR = (uint32_t)pNewNode;
20013136:	68ba      	ldr	r2, [r7, #8]
20013138:	69fb      	ldr	r3, [r7, #28]
2001313a:	615a      	str	r2, [r3, #20]
              /* Increment the linked list node counter */
              hmdma->LinkedListNodeCounter++;
2001313c:	68fb      	ldr	r3, [r7, #12]
2001313e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20013140:	1c5a      	adds	r2, r3, #1
20013142:	68fb      	ldr	r3, [r7, #12]
20013144:	665a      	str	r2, [r3, #100]	; 0x64
              nodeInserted = 1;
20013146:	2301      	movs	r3, #1
20013148:	617b      	str	r3, [r7, #20]
2001314a:	e002      	b.n	20013152 <HAL_MDMA_LinkedList_AddNode+0x13e>
            }
            else
            {
              pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
2001314c:	69fb      	ldr	r3, [r7, #28]
2001314e:	695b      	ldr	r3, [r3, #20]
20013150:	61fb      	str	r3, [r7, #28]
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
20013152:	68fb      	ldr	r3, [r7, #12]
20013154:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20013156:	69ba      	ldr	r2, [r7, #24]
20013158:	429a      	cmp	r2, r3
2001315a:	d202      	bcs.n	20013162 <HAL_MDMA_LinkedList_AddNode+0x14e>
2001315c:	697b      	ldr	r3, [r7, #20]
2001315e:	2b00      	cmp	r3, #0
20013160:	d0de      	beq.n	20013120 <HAL_MDMA_LinkedList_AddNode+0x10c>
            }
          }

          if(nodeInserted == 0U)
20013162:	697b      	ldr	r3, [r7, #20]
20013164:	2b00      	cmp	r3, #0
20013166:	d104      	bne.n	20013172 <HAL_MDMA_LinkedList_AddNode+0x15e>
          {
            hal_status = HAL_ERROR;
20013168:	2301      	movs	r3, #1
2001316a:	74fb      	strb	r3, [r7, #19]
2001316c:	e001      	b.n	20013172 <HAL_MDMA_LinkedList_AddNode+0x15e>
        }
      }
    }
    else
    {
      hal_status = HAL_ERROR;
2001316e:	2301      	movs	r3, #1
20013170:	74fb      	strb	r3, [r7, #19]
    }

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
20013172:	68fb      	ldr	r3, [r7, #12]
20013174:	2200      	movs	r2, #0
20013176:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
2001317a:	68fb      	ldr	r3, [r7, #12]
2001317c:	2201      	movs	r2, #1
2001317e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return hal_status;
20013182:	7cfb      	ldrb	r3, [r7, #19]
20013184:	e004      	b.n	20013190 <HAL_MDMA_LinkedList_AddNode+0x17c>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
20013186:	68fb      	ldr	r3, [r7, #12]
20013188:	2200      	movs	r2, #0
2001318a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2001318e:	2302      	movs	r3, #2
  }
}
20013190:	4618      	mov	r0, r3
20013192:	3724      	adds	r7, #36	; 0x24
20013194:	46bd      	mov	sp, r7
20013196:	f85d 7b04 	ldr.w	r7, [sp], #4
2001319a:	4770      	bx	lr

2001319c <HAL_MDMA_LinkedList_RemoveNode>:
  *                 to be removed from the list.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_RemoveNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNode)
{
2001319c:	b480      	push	{r7}
2001319e:	b087      	sub	sp, #28
200131a0:	af00      	add	r7, sp, #0
200131a2:	6078      	str	r0, [r7, #4]
200131a4:	6039      	str	r1, [r7, #0]
  MDMA_LinkNodeTypeDef *ptmpNode;
  uint32_t counter = 0, nodeDeleted = 0;
200131a6:	2300      	movs	r3, #0
200131a8:	613b      	str	r3, [r7, #16]
200131aa:	2300      	movs	r3, #0
200131ac:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef hal_status = HAL_OK;
200131ae:	2300      	movs	r3, #0
200131b0:	72fb      	strb	r3, [r7, #11]

  /* Check the MDMA peripheral handle */
  if((hmdma == NULL) || (pNode == NULL))
200131b2:	687b      	ldr	r3, [r7, #4]
200131b4:	2b00      	cmp	r3, #0
200131b6:	d002      	beq.n	200131be <HAL_MDMA_LinkedList_RemoveNode+0x22>
200131b8:	683b      	ldr	r3, [r7, #0]
200131ba:	2b00      	cmp	r3, #0
200131bc:	d101      	bne.n	200131c2 <HAL_MDMA_LinkedList_RemoveNode+0x26>
  {
    return HAL_ERROR;
200131be:	2301      	movs	r3, #1
200131c0:	e099      	b.n	200132f6 <HAL_MDMA_LinkedList_RemoveNode+0x15a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
200131c2:	687b      	ldr	r3, [r7, #4]
200131c4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
200131c8:	2b01      	cmp	r3, #1
200131ca:	d101      	bne.n	200131d0 <HAL_MDMA_LinkedList_RemoveNode+0x34>
200131cc:	2302      	movs	r3, #2
200131ce:	e092      	b.n	200132f6 <HAL_MDMA_LinkedList_RemoveNode+0x15a>
200131d0:	687b      	ldr	r3, [r7, #4]
200131d2:	2201      	movs	r2, #1
200131d4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
200131d8:	687b      	ldr	r3, [r7, #4]
200131da:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
200131de:	b2db      	uxtb	r3, r3
200131e0:	2b01      	cmp	r3, #1
200131e2:	f040 8083 	bne.w	200132ec <HAL_MDMA_LinkedList_RemoveNode+0x150>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
200131e6:	687b      	ldr	r3, [r7, #4]
200131e8:	2202      	movs	r2, #2
200131ea:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
200131ee:	687b      	ldr	r3, [r7, #4]
200131f0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200131f2:	2b00      	cmp	r3, #0
200131f4:	d007      	beq.n	20013206 <HAL_MDMA_LinkedList_RemoveNode+0x6a>
200131f6:	687b      	ldr	r3, [r7, #4]
200131f8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200131fa:	2b00      	cmp	r3, #0
200131fc:	d003      	beq.n	20013206 <HAL_MDMA_LinkedList_RemoveNode+0x6a>
200131fe:	687b      	ldr	r3, [r7, #4]
20013200:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20013202:	2b00      	cmp	r3, #0
20013204:	d102      	bne.n	2001320c <HAL_MDMA_LinkedList_RemoveNode+0x70>
    {
      hal_status = HAL_ERROR;
20013206:	2301      	movs	r3, #1
20013208:	72fb      	strb	r3, [r7, #11]
2001320a:	e065      	b.n	200132d8 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
    }
    else if(hmdma->FirstLinkedListNodeAddress == pNode) /* Deleting first node */
2001320c:	687b      	ldr	r3, [r7, #4]
2001320e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20013210:	683a      	ldr	r2, [r7, #0]
20013212:	429a      	cmp	r2, r3
20013214:	d130      	bne.n	20013278 <HAL_MDMA_LinkedList_RemoveNode+0xdc>
    {
      /* Delete 1st node */
      if(hmdma->LastLinkedListNodeAddress == pNode)
20013216:	687b      	ldr	r3, [r7, #4]
20013218:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2001321a:	683a      	ldr	r2, [r7, #0]
2001321c:	429a      	cmp	r2, r3
2001321e:	d10d      	bne.n	2001323c <HAL_MDMA_LinkedList_RemoveNode+0xa0>
      {
        /*if the last node is at the same time the first one (1 single node after the init node 0)
        then update the last node too */

        hmdma->FirstLinkedListNodeAddress = 0;
20013220:	687b      	ldr	r3, [r7, #4]
20013222:	2200      	movs	r2, #0
20013224:	65da      	str	r2, [r3, #92]	; 0x5c
        hmdma->LastLinkedListNodeAddress  = 0;
20013226:	687b      	ldr	r3, [r7, #4]
20013228:	2200      	movs	r2, #0
2001322a:	661a      	str	r2, [r3, #96]	; 0x60
        hmdma->LinkedListNodeCounter = 0;
2001322c:	687b      	ldr	r3, [r7, #4]
2001322e:	2200      	movs	r2, #0
20013230:	665a      	str	r2, [r3, #100]	; 0x64

        hmdma->Instance->CLAR = 0;
20013232:	687b      	ldr	r3, [r7, #4]
20013234:	681b      	ldr	r3, [r3, #0]
20013236:	2200      	movs	r2, #0
20013238:	625a      	str	r2, [r3, #36]	; 0x24
2001323a:	e04d      	b.n	200132d8 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      }
      else
      {
        if((uint32_t)hmdma->FirstLinkedListNodeAddress == hmdma->LastLinkedListNodeAddress->CLAR)
2001323c:	687b      	ldr	r3, [r7, #4]
2001323e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20013240:	461a      	mov	r2, r3
20013242:	687b      	ldr	r3, [r7, #4]
20013244:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20013246:	695b      	ldr	r3, [r3, #20]
20013248:	429a      	cmp	r2, r3
2001324a:	d104      	bne.n	20013256 <HAL_MDMA_LinkedList_RemoveNode+0xba>
        {
          /* if last node is looping to first (circular list) one update the last node connection */
          hmdma->LastLinkedListNodeAddress->CLAR = pNode->CLAR;
2001324c:	687b      	ldr	r3, [r7, #4]
2001324e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20013250:	683a      	ldr	r2, [r7, #0]
20013252:	6952      	ldr	r2, [r2, #20]
20013254:	615a      	str	r2, [r3, #20]
        }

        /* if deleting the first node after the initialization
        connect the next node to the node 0 by updating
        the MDMA channel CLAR register to this node address */
        hmdma->Instance->CLAR = pNode->CLAR;
20013256:	687b      	ldr	r3, [r7, #4]
20013258:	681b      	ldr	r3, [r3, #0]
2001325a:	683a      	ldr	r2, [r7, #0]
2001325c:	6952      	ldr	r2, [r2, #20]
2001325e:	625a      	str	r2, [r3, #36]	; 0x24
        hmdma->FirstLinkedListNodeAddress = (MDMA_LinkNodeTypeDef *)hmdma->Instance->CLAR;
20013260:	687b      	ldr	r3, [r7, #4]
20013262:	681b      	ldr	r3, [r3, #0]
20013264:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20013266:	461a      	mov	r2, r3
20013268:	687b      	ldr	r3, [r7, #4]
2001326a:	65da      	str	r2, [r3, #92]	; 0x5c
        /* Update the Handle node counter */
        hmdma->LinkedListNodeCounter--;
2001326c:	687b      	ldr	r3, [r7, #4]
2001326e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20013270:	1e5a      	subs	r2, r3, #1
20013272:	687b      	ldr	r3, [r7, #4]
20013274:	665a      	str	r2, [r3, #100]	; 0x64
20013276:	e02f      	b.n	200132d8 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      }
    }
    else /* Deleting any other node */
    {
      /*Deleted node is not the first one : find it  */
      ptmpNode = hmdma->FirstLinkedListNodeAddress;
20013278:	687b      	ldr	r3, [r7, #4]
2001327a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2001327c:	617b      	str	r3, [r7, #20]
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
2001327e:	e01e      	b.n	200132be <HAL_MDMA_LinkedList_RemoveNode+0x122>
      {
        counter++;
20013280:	693b      	ldr	r3, [r7, #16]
20013282:	3301      	adds	r3, #1
20013284:	613b      	str	r3, [r7, #16]
        if(ptmpNode->CLAR == ((uint32_t)pNode))
20013286:	697b      	ldr	r3, [r7, #20]
20013288:	695a      	ldr	r2, [r3, #20]
2001328a:	683b      	ldr	r3, [r7, #0]
2001328c:	429a      	cmp	r2, r3
2001328e:	d113      	bne.n	200132b8 <HAL_MDMA_LinkedList_RemoveNode+0x11c>
        {
          /* if deleting the last node */
          if(pNode == hmdma->LastLinkedListNodeAddress)
20013290:	687b      	ldr	r3, [r7, #4]
20013292:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20013294:	683a      	ldr	r2, [r7, #0]
20013296:	429a      	cmp	r2, r3
20013298:	d102      	bne.n	200132a0 <HAL_MDMA_LinkedList_RemoveNode+0x104>
          {
            /*Update the linked list last node address in the handle*/
            hmdma->LastLinkedListNodeAddress = ptmpNode;
2001329a:	687b      	ldr	r3, [r7, #4]
2001329c:	697a      	ldr	r2, [r7, #20]
2001329e:	661a      	str	r2, [r3, #96]	; 0x60
          }
          /* update the next node link after deleting pMDMA_LinkedListNode */
          ptmpNode->CLAR = pNode->CLAR;
200132a0:	683b      	ldr	r3, [r7, #0]
200132a2:	695a      	ldr	r2, [r3, #20]
200132a4:	697b      	ldr	r3, [r7, #20]
200132a6:	615a      	str	r2, [r3, #20]
          nodeDeleted = 1;
200132a8:	2301      	movs	r3, #1
200132aa:	60fb      	str	r3, [r7, #12]
          /* Update the Handle node counter */
          hmdma->LinkedListNodeCounter--;
200132ac:	687b      	ldr	r3, [r7, #4]
200132ae:	6e5b      	ldr	r3, [r3, #100]	; 0x64
200132b0:	1e5a      	subs	r2, r3, #1
200132b2:	687b      	ldr	r3, [r7, #4]
200132b4:	665a      	str	r2, [r3, #100]	; 0x64
200132b6:	e002      	b.n	200132be <HAL_MDMA_LinkedList_RemoveNode+0x122>
        }
        else
        {
          ptmpNode = (MDMA_LinkNodeTypeDef *)ptmpNode->CLAR;
200132b8:	697b      	ldr	r3, [r7, #20]
200132ba:	695b      	ldr	r3, [r3, #20]
200132bc:	617b      	str	r3, [r7, #20]
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
200132be:	687b      	ldr	r3, [r7, #4]
200132c0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
200132c2:	693a      	ldr	r2, [r7, #16]
200132c4:	429a      	cmp	r2, r3
200132c6:	d202      	bcs.n	200132ce <HAL_MDMA_LinkedList_RemoveNode+0x132>
200132c8:	68fb      	ldr	r3, [r7, #12]
200132ca:	2b00      	cmp	r3, #0
200132cc:	d0d8      	beq.n	20013280 <HAL_MDMA_LinkedList_RemoveNode+0xe4>
        }
      }

      if(nodeDeleted == 0U)
200132ce:	68fb      	ldr	r3, [r7, #12]
200132d0:	2b00      	cmp	r3, #0
200132d2:	d101      	bne.n	200132d8 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      {
        /* last node reashed without finding the node to delete : return error */
        hal_status = HAL_ERROR;
200132d4:	2301      	movs	r3, #1
200132d6:	72fb      	strb	r3, [r7, #11]
      }
    }

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
200132d8:	687b      	ldr	r3, [r7, #4]
200132da:	2200      	movs	r2, #0
200132dc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
200132e0:	687b      	ldr	r3, [r7, #4]
200132e2:	2201      	movs	r2, #1
200132e4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return hal_status;
200132e8:	7afb      	ldrb	r3, [r7, #11]
200132ea:	e004      	b.n	200132f6 <HAL_MDMA_LinkedList_RemoveNode+0x15a>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
200132ec:	687b      	ldr	r3, [r7, #4]
200132ee:	2200      	movs	r2, #0
200132f0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
200132f4:	2302      	movs	r3, #2
  }
}
200132f6:	4618      	mov	r0, r3
200132f8:	371c      	adds	r7, #28
200132fa:	46bd      	mov	sp, r7
200132fc:	f85d 7b04 	ldr.w	r7, [sp], #4
20013300:	4770      	bx	lr

20013302 <HAL_MDMA_LinkedList_EnableCircularMode>:
  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_EnableCircularMode(MDMA_HandleTypeDef *hmdma)
{
20013302:	b480      	push	{r7}
20013304:	b085      	sub	sp, #20
20013306:	af00      	add	r7, sp, #0
20013308:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
2001330a:	2300      	movs	r3, #0
2001330c:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2001330e:	687b      	ldr	r3, [r7, #4]
20013310:	2b00      	cmp	r3, #0
20013312:	d101      	bne.n	20013318 <HAL_MDMA_LinkedList_EnableCircularMode+0x16>
  {
    return HAL_ERROR;
20013314:	2301      	movs	r3, #1
20013316:	e031      	b.n	2001337c <HAL_MDMA_LinkedList_EnableCircularMode+0x7a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
20013318:	687b      	ldr	r3, [r7, #4]
2001331a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2001331e:	2b01      	cmp	r3, #1
20013320:	d101      	bne.n	20013326 <HAL_MDMA_LinkedList_EnableCircularMode+0x24>
20013322:	2302      	movs	r3, #2
20013324:	e02a      	b.n	2001337c <HAL_MDMA_LinkedList_EnableCircularMode+0x7a>
20013326:	687b      	ldr	r3, [r7, #4]
20013328:	2201      	movs	r2, #1
2001332a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2001332e:	687b      	ldr	r3, [r7, #4]
20013330:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
20013334:	b2db      	uxtb	r3, r3
20013336:	2b01      	cmp	r3, #1
20013338:	d117      	bne.n	2001336a <HAL_MDMA_LinkedList_EnableCircularMode+0x68>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2001333a:	687b      	ldr	r3, [r7, #4]
2001333c:	2202      	movs	r2, #2
2001333e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
20013342:	687b      	ldr	r3, [r7, #4]
20013344:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20013346:	2b00      	cmp	r3, #0
20013348:	d007      	beq.n	2001335a <HAL_MDMA_LinkedList_EnableCircularMode+0x58>
2001334a:	687b      	ldr	r3, [r7, #4]
2001334c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2001334e:	2b00      	cmp	r3, #0
20013350:	d003      	beq.n	2001335a <HAL_MDMA_LinkedList_EnableCircularMode+0x58>
20013352:	687b      	ldr	r3, [r7, #4]
20013354:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20013356:	2b00      	cmp	r3, #0
20013358:	d102      	bne.n	20013360 <HAL_MDMA_LinkedList_EnableCircularMode+0x5e>
    {
      hal_status = HAL_ERROR;
2001335a:	2301      	movs	r3, #1
2001335c:	73fb      	strb	r3, [r7, #15]
2001335e:	e004      	b.n	2001336a <HAL_MDMA_LinkedList_EnableCircularMode+0x68>
    }
    else
    {
      /* to enable circular mode Last Node should be connected to first node */
      hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
20013360:	687b      	ldr	r3, [r7, #4]
20013362:	6dda      	ldr	r2, [r3, #92]	; 0x5c
20013364:	687b      	ldr	r3, [r7, #4]
20013366:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20013368:	615a      	str	r2, [r3, #20]
    }

  }
  /* Process unlocked */
  __HAL_UNLOCK(hmdma);
2001336a:	687b      	ldr	r3, [r7, #4]
2001336c:	2200      	movs	r2, #0
2001336e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  hmdma->State = HAL_MDMA_STATE_READY;
20013372:	687b      	ldr	r3, [r7, #4]
20013374:	2201      	movs	r2, #1
20013376:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return hal_status;
2001337a:	7bfb      	ldrb	r3, [r7, #15]
}
2001337c:	4618      	mov	r0, r3
2001337e:	3714      	adds	r7, #20
20013380:	46bd      	mov	sp, r7
20013382:	f85d 7b04 	ldr.w	r7, [sp], #4
20013386:	4770      	bx	lr

20013388 <HAL_MDMA_LinkedList_DisableCircularMode>:
  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_DisableCircularMode(MDMA_HandleTypeDef *hmdma)
{
20013388:	b480      	push	{r7}
2001338a:	b085      	sub	sp, #20
2001338c:	af00      	add	r7, sp, #0
2001338e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
20013390:	2300      	movs	r3, #0
20013392:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
20013394:	687b      	ldr	r3, [r7, #4]
20013396:	2b00      	cmp	r3, #0
20013398:	d101      	bne.n	2001339e <HAL_MDMA_LinkedList_DisableCircularMode+0x16>
  {
    return HAL_ERROR;
2001339a:	2301      	movs	r3, #1
2001339c:	e030      	b.n	20013400 <HAL_MDMA_LinkedList_DisableCircularMode+0x78>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2001339e:	687b      	ldr	r3, [r7, #4]
200133a0:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
200133a4:	2b01      	cmp	r3, #1
200133a6:	d101      	bne.n	200133ac <HAL_MDMA_LinkedList_DisableCircularMode+0x24>
200133a8:	2302      	movs	r3, #2
200133aa:	e029      	b.n	20013400 <HAL_MDMA_LinkedList_DisableCircularMode+0x78>
200133ac:	687b      	ldr	r3, [r7, #4]
200133ae:	2201      	movs	r2, #1
200133b0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
200133b4:	687b      	ldr	r3, [r7, #4]
200133b6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
200133ba:	b2db      	uxtb	r3, r3
200133bc:	2b01      	cmp	r3, #1
200133be:	d116      	bne.n	200133ee <HAL_MDMA_LinkedList_DisableCircularMode+0x66>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
200133c0:	687b      	ldr	r3, [r7, #4]
200133c2:	2202      	movs	r2, #2
200133c4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
200133c8:	687b      	ldr	r3, [r7, #4]
200133ca:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200133cc:	2b00      	cmp	r3, #0
200133ce:	d007      	beq.n	200133e0 <HAL_MDMA_LinkedList_DisableCircularMode+0x58>
200133d0:	687b      	ldr	r3, [r7, #4]
200133d2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200133d4:	2b00      	cmp	r3, #0
200133d6:	d003      	beq.n	200133e0 <HAL_MDMA_LinkedList_DisableCircularMode+0x58>
200133d8:	687b      	ldr	r3, [r7, #4]
200133da:	6e5b      	ldr	r3, [r3, #100]	; 0x64
200133dc:	2b00      	cmp	r3, #0
200133de:	d102      	bne.n	200133e6 <HAL_MDMA_LinkedList_DisableCircularMode+0x5e>
    {
      hal_status = HAL_ERROR;
200133e0:	2301      	movs	r3, #1
200133e2:	73fb      	strb	r3, [r7, #15]
200133e4:	e003      	b.n	200133ee <HAL_MDMA_LinkedList_DisableCircularMode+0x66>
    }
    else
    {
      /* to disable circular mode Last Node should be connected to NULL */
      hmdma->LastLinkedListNodeAddress->CLAR = 0;
200133e6:	687b      	ldr	r3, [r7, #4]
200133e8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200133ea:	2200      	movs	r2, #0
200133ec:	615a      	str	r2, [r3, #20]
    }

  }
  /* Process unlocked */
  __HAL_UNLOCK(hmdma);
200133ee:	687b      	ldr	r3, [r7, #4]
200133f0:	2200      	movs	r2, #0
200133f2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  hmdma->State = HAL_MDMA_STATE_READY;
200133f6:	687b      	ldr	r3, [r7, #4]
200133f8:	2201      	movs	r2, #1
200133fa:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return hal_status;
200133fe:	7bfb      	ldrb	r3, [r7, #15]
}
20013400:	4618      	mov	r0, r3
20013402:	3714      	adds	r7, #20
20013404:	46bd      	mov	sp, r7
20013406:	f85d 7b04 	ldr.w	r7, [sp], #4
2001340a:	4770      	bx	lr

2001340c <HAL_MDMA_Start>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
2001340c:	b580      	push	{r7, lr}
2001340e:	b086      	sub	sp, #24
20013410:	af02      	add	r7, sp, #8
20013412:	60f8      	str	r0, [r7, #12]
20013414:	60b9      	str	r1, [r7, #8]
20013416:	607a      	str	r2, [r7, #4]
20013418:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
2001341a:	683b      	ldr	r3, [r7, #0]
2001341c:	2b00      	cmp	r3, #0
2001341e:	d003      	beq.n	20013428 <HAL_MDMA_Start+0x1c>
20013420:	683b      	ldr	r3, [r7, #0]
20013422:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20013426:	d904      	bls.n	20013432 <HAL_MDMA_Start+0x26>
20013428:	f240 4134 	movw	r1, #1076	; 0x434
2001342c:	482e      	ldr	r0, [pc, #184]	; (200134e8 <HAL_MDMA_Start+0xdc>)
2001342e:	f7ed fa61 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));
20013432:	69bb      	ldr	r3, [r7, #24]
20013434:	2b00      	cmp	r3, #0
20013436:	d003      	beq.n	20013440 <HAL_MDMA_Start+0x34>
20013438:	69bb      	ldr	r3, [r7, #24]
2001343a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2001343e:	d904      	bls.n	2001344a <HAL_MDMA_Start+0x3e>
20013440:	f240 4135 	movw	r1, #1077	; 0x435
20013444:	4828      	ldr	r0, [pc, #160]	; (200134e8 <HAL_MDMA_Start+0xdc>)
20013446:	f7ed fa55 	bl	200008f4 <assert_failed>

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2001344a:	68fb      	ldr	r3, [r7, #12]
2001344c:	2b00      	cmp	r3, #0
2001344e:	d101      	bne.n	20013454 <HAL_MDMA_Start+0x48>
  {
    return HAL_ERROR;
20013450:	2301      	movs	r3, #1
20013452:	e044      	b.n	200134de <HAL_MDMA_Start+0xd2>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
20013454:	68fb      	ldr	r3, [r7, #12]
20013456:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2001345a:	2b01      	cmp	r3, #1
2001345c:	d101      	bne.n	20013462 <HAL_MDMA_Start+0x56>
2001345e:	2302      	movs	r3, #2
20013460:	e03d      	b.n	200134de <HAL_MDMA_Start+0xd2>
20013462:	68fb      	ldr	r3, [r7, #12]
20013464:	2201      	movs	r2, #1
20013466:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2001346a:	68fb      	ldr	r3, [r7, #12]
2001346c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
20013470:	b2db      	uxtb	r3, r3
20013472:	2b01      	cmp	r3, #1
20013474:	d12c      	bne.n	200134d0 <HAL_MDMA_Start+0xc4>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
20013476:	68fb      	ldr	r3, [r7, #12]
20013478:	2202      	movs	r2, #2
2001347a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2001347e:	68fb      	ldr	r3, [r7, #12]
20013480:	2200      	movs	r2, #0
20013482:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
20013484:	68fb      	ldr	r3, [r7, #12]
20013486:	681b      	ldr	r3, [r3, #0]
20013488:	68da      	ldr	r2, [r3, #12]
2001348a:	68fb      	ldr	r3, [r7, #12]
2001348c:	681b      	ldr	r3, [r3, #0]
2001348e:	f022 0201 	bic.w	r2, r2, #1
20013492:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
20013494:	69bb      	ldr	r3, [r7, #24]
20013496:	9300      	str	r3, [sp, #0]
20013498:	683b      	ldr	r3, [r7, #0]
2001349a:	687a      	ldr	r2, [r7, #4]
2001349c:	68b9      	ldr	r1, [r7, #8]
2001349e:	68f8      	ldr	r0, [r7, #12]
200134a0:	f000 fbca 	bl	20013c38 <MDMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
200134a4:	68fb      	ldr	r3, [r7, #12]
200134a6:	681b      	ldr	r3, [r3, #0]
200134a8:	68da      	ldr	r2, [r3, #12]
200134aa:	68fb      	ldr	r3, [r7, #12]
200134ac:	681b      	ldr	r3, [r3, #0]
200134ae:	f042 0201 	orr.w	r2, r2, #1
200134b2:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
200134b4:	68fb      	ldr	r3, [r7, #12]
200134b6:	685b      	ldr	r3, [r3, #4]
200134b8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
200134bc:	d10e      	bne.n	200134dc <HAL_MDMA_Start+0xd0>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
200134be:	68fb      	ldr	r3, [r7, #12]
200134c0:	681b      	ldr	r3, [r3, #0]
200134c2:	68da      	ldr	r2, [r3, #12]
200134c4:	68fb      	ldr	r3, [r7, #12]
200134c6:	681b      	ldr	r3, [r3, #0]
200134c8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
200134cc:	60da      	str	r2, [r3, #12]
200134ce:	e005      	b.n	200134dc <HAL_MDMA_Start+0xd0>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
200134d0:	68fb      	ldr	r3, [r7, #12]
200134d2:	2200      	movs	r2, #0
200134d4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
200134d8:	2302      	movs	r3, #2
200134da:	e000      	b.n	200134de <HAL_MDMA_Start+0xd2>
  }

  return HAL_OK;
200134dc:	2300      	movs	r3, #0
}
200134de:	4618      	mov	r0, r3
200134e0:	3710      	adds	r7, #16
200134e2:	46bd      	mov	sp, r7
200134e4:	bd80      	pop	{r7, pc}
200134e6:	bf00      	nop
200134e8:	2001c1f4 	.word	0x2001c1f4

200134ec <HAL_MDMA_Start_IT>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start_IT(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
200134ec:	b580      	push	{r7, lr}
200134ee:	b086      	sub	sp, #24
200134f0:	af02      	add	r7, sp, #8
200134f2:	60f8      	str	r0, [r7, #12]
200134f4:	60b9      	str	r1, [r7, #8]
200134f6:	607a      	str	r2, [r7, #4]
200134f8:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
200134fa:	683b      	ldr	r3, [r7, #0]
200134fc:	2b00      	cmp	r3, #0
200134fe:	d003      	beq.n	20013508 <HAL_MDMA_Start_IT+0x1c>
20013500:	683b      	ldr	r3, [r7, #0]
20013502:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20013506:	d904      	bls.n	20013512 <HAL_MDMA_Start_IT+0x26>
20013508:	f44f 618e 	mov.w	r1, #1136	; 0x470
2001350c:	4844      	ldr	r0, [pc, #272]	; (20013620 <HAL_MDMA_Start_IT+0x134>)
2001350e:	f7ed f9f1 	bl	200008f4 <assert_failed>
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));
20013512:	69bb      	ldr	r3, [r7, #24]
20013514:	2b00      	cmp	r3, #0
20013516:	d003      	beq.n	20013520 <HAL_MDMA_Start_IT+0x34>
20013518:	69bb      	ldr	r3, [r7, #24]
2001351a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2001351e:	d904      	bls.n	2001352a <HAL_MDMA_Start_IT+0x3e>
20013520:	f240 4171 	movw	r1, #1137	; 0x471
20013524:	483e      	ldr	r0, [pc, #248]	; (20013620 <HAL_MDMA_Start_IT+0x134>)
20013526:	f7ed f9e5 	bl	200008f4 <assert_failed>

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2001352a:	68fb      	ldr	r3, [r7, #12]
2001352c:	2b00      	cmp	r3, #0
2001352e:	d101      	bne.n	20013534 <HAL_MDMA_Start_IT+0x48>
  {
    return HAL_ERROR;
20013530:	2301      	movs	r3, #1
20013532:	e070      	b.n	20013616 <HAL_MDMA_Start_IT+0x12a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
20013534:	68fb      	ldr	r3, [r7, #12]
20013536:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2001353a:	2b01      	cmp	r3, #1
2001353c:	d101      	bne.n	20013542 <HAL_MDMA_Start_IT+0x56>
2001353e:	2302      	movs	r3, #2
20013540:	e069      	b.n	20013616 <HAL_MDMA_Start_IT+0x12a>
20013542:	68fb      	ldr	r3, [r7, #12]
20013544:	2201      	movs	r2, #1
20013546:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2001354a:	68fb      	ldr	r3, [r7, #12]
2001354c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
20013550:	b2db      	uxtb	r3, r3
20013552:	2b01      	cmp	r3, #1
20013554:	d158      	bne.n	20013608 <HAL_MDMA_Start_IT+0x11c>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
20013556:	68fb      	ldr	r3, [r7, #12]
20013558:	2202      	movs	r2, #2
2001355a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2001355e:	68fb      	ldr	r3, [r7, #12]
20013560:	2200      	movs	r2, #0
20013562:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
20013564:	68fb      	ldr	r3, [r7, #12]
20013566:	681b      	ldr	r3, [r3, #0]
20013568:	68da      	ldr	r2, [r3, #12]
2001356a:	68fb      	ldr	r3, [r7, #12]
2001356c:	681b      	ldr	r3, [r3, #0]
2001356e:	f022 0201 	bic.w	r2, r2, #1
20013572:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
20013574:	69bb      	ldr	r3, [r7, #24]
20013576:	9300      	str	r3, [sp, #0]
20013578:	683b      	ldr	r3, [r7, #0]
2001357a:	687a      	ldr	r2, [r7, #4]
2001357c:	68b9      	ldr	r1, [r7, #8]
2001357e:	68f8      	ldr	r0, [r7, #12]
20013580:	f000 fb5a 	bl	20013c38 <MDMA_SetConfig>

    /* Enable Common interrupts i.e Transfer Error IT and Channel Transfer Complete IT*/
    __HAL_MDMA_ENABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC));
20013584:	68fb      	ldr	r3, [r7, #12]
20013586:	681b      	ldr	r3, [r3, #0]
20013588:	68da      	ldr	r2, [r3, #12]
2001358a:	68fb      	ldr	r3, [r7, #12]
2001358c:	681b      	ldr	r3, [r3, #0]
2001358e:	f042 0206 	orr.w	r2, r2, #6
20013592:	60da      	str	r2, [r3, #12]

    if(hmdma->XferBlockCpltCallback != NULL)
20013594:	68fb      	ldr	r3, [r7, #12]
20013596:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20013598:	2b00      	cmp	r3, #0
2001359a:	d007      	beq.n	200135ac <HAL_MDMA_Start_IT+0xc0>
    {
      /* if Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BT);
2001359c:	68fb      	ldr	r3, [r7, #12]
2001359e:	681b      	ldr	r3, [r3, #0]
200135a0:	68da      	ldr	r2, [r3, #12]
200135a2:	68fb      	ldr	r3, [r7, #12]
200135a4:	681b      	ldr	r3, [r3, #0]
200135a6:	f042 0210 	orr.w	r2, r2, #16
200135aa:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferRepeatBlockCpltCallback != NULL)
200135ac:	68fb      	ldr	r3, [r7, #12]
200135ae:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200135b0:	2b00      	cmp	r3, #0
200135b2:	d007      	beq.n	200135c4 <HAL_MDMA_Start_IT+0xd8>
    {
      /* if Repeated Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BRT);
200135b4:	68fb      	ldr	r3, [r7, #12]
200135b6:	681b      	ldr	r3, [r3, #0]
200135b8:	68da      	ldr	r2, [r3, #12]
200135ba:	68fb      	ldr	r3, [r7, #12]
200135bc:	681b      	ldr	r3, [r3, #0]
200135be:	f042 0208 	orr.w	r2, r2, #8
200135c2:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferBufferCpltCallback != NULL)
200135c4:	68fb      	ldr	r3, [r7, #12]
200135c6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200135c8:	2b00      	cmp	r3, #0
200135ca:	d007      	beq.n	200135dc <HAL_MDMA_Start_IT+0xf0>
    {
      /* if buffer transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BFTC);
200135cc:	68fb      	ldr	r3, [r7, #12]
200135ce:	681b      	ldr	r3, [r3, #0]
200135d0:	68da      	ldr	r2, [r3, #12]
200135d2:	68fb      	ldr	r3, [r7, #12]
200135d4:	681b      	ldr	r3, [r3, #0]
200135d6:	f042 0220 	orr.w	r2, r2, #32
200135da:	60da      	str	r2, [r3, #12]
    }

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
200135dc:	68fb      	ldr	r3, [r7, #12]
200135de:	681b      	ldr	r3, [r3, #0]
200135e0:	68da      	ldr	r2, [r3, #12]
200135e2:	68fb      	ldr	r3, [r7, #12]
200135e4:	681b      	ldr	r3, [r3, #0]
200135e6:	f042 0201 	orr.w	r2, r2, #1
200135ea:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
200135ec:	68fb      	ldr	r3, [r7, #12]
200135ee:	685b      	ldr	r3, [r3, #4]
200135f0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
200135f4:	d10e      	bne.n	20013614 <HAL_MDMA_Start_IT+0x128>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
200135f6:	68fb      	ldr	r3, [r7, #12]
200135f8:	681b      	ldr	r3, [r3, #0]
200135fa:	68da      	ldr	r2, [r3, #12]
200135fc:	68fb      	ldr	r3, [r7, #12]
200135fe:	681b      	ldr	r3, [r3, #0]
20013600:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20013604:	60da      	str	r2, [r3, #12]
20013606:	e005      	b.n	20013614 <HAL_MDMA_Start_IT+0x128>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
20013608:	68fb      	ldr	r3, [r7, #12]
2001360a:	2200      	movs	r2, #0
2001360c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
20013610:	2302      	movs	r3, #2
20013612:	e000      	b.n	20013616 <HAL_MDMA_Start_IT+0x12a>
  }

  return HAL_OK;
20013614:	2300      	movs	r3, #0
}
20013616:	4618      	mov	r0, r3
20013618:	3710      	adds	r7, #16
2001361a:	46bd      	mov	sp, r7
2001361c:	bd80      	pop	{r7, pc}
2001361e:	bf00      	nop
20013620:	2001c1f4 	.word	0x2001c1f4

20013624 <HAL_MDMA_Abort>:
  *        and the Channel will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Abort(MDMA_HandleTypeDef *hmdma)
{
20013624:	b580      	push	{r7, lr}
20013626:	b084      	sub	sp, #16
20013628:	af00      	add	r7, sp, #0
2001362a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart =  HAL_GetTick();
2001362c:	f7ee fb5e 	bl	20001cec <HAL_GetTick>
20013630:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
20013632:	687b      	ldr	r3, [r7, #4]
20013634:	2b00      	cmp	r3, #0
20013636:	d101      	bne.n	2001363c <HAL_MDMA_Abort+0x18>
  {
    return HAL_ERROR;
20013638:	2301      	movs	r3, #1
2001363a:	e04a      	b.n	200136d2 <HAL_MDMA_Abort+0xae>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
2001363c:	687b      	ldr	r3, [r7, #4]
2001363e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
20013642:	b2db      	uxtb	r3, r3
20013644:	2b02      	cmp	r3, #2
20013646:	d008      	beq.n	2001365a <HAL_MDMA_Abort+0x36>
  {
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
20013648:	687b      	ldr	r3, [r7, #4]
2001364a:	2280      	movs	r2, #128	; 0x80
2001364c:	669a      	str	r2, [r3, #104]	; 0x68

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2001364e:	687b      	ldr	r3, [r7, #4]
20013650:	2200      	movs	r2, #0
20013652:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return HAL_ERROR;
20013656:	2301      	movs	r3, #1
20013658:	e03b      	b.n	200136d2 <HAL_MDMA_Abort+0xae>
  }
  else
  {
    /* Disable all the transfer interrupts */
    __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
2001365a:	687b      	ldr	r3, [r7, #4]
2001365c:	681b      	ldr	r3, [r3, #0]
2001365e:	68da      	ldr	r2, [r3, #12]
20013660:	687b      	ldr	r3, [r7, #4]
20013662:	681b      	ldr	r3, [r3, #0]
20013664:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
20013668:	60da      	str	r2, [r3, #12]

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
2001366a:	687b      	ldr	r3, [r7, #4]
2001366c:	681b      	ldr	r3, [r3, #0]
2001366e:	68da      	ldr	r2, [r3, #12]
20013670:	687b      	ldr	r3, [r7, #4]
20013672:	681b      	ldr	r3, [r3, #0]
20013674:	f022 0201 	bic.w	r2, r2, #1
20013678:	60da      	str	r2, [r3, #12]

    /* Check if the MDMA Channel is effectively disabled */
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2001367a:	e016      	b.n	200136aa <HAL_MDMA_Abort+0x86>
    {
      /* Check for the Timeout */
      if( (HAL_GetTick()  - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
2001367c:	f7ee fb36 	bl	20001cec <HAL_GetTick>
20013680:	4602      	mov	r2, r0
20013682:	68fb      	ldr	r3, [r7, #12]
20013684:	1ad3      	subs	r3, r2, r3
20013686:	2b05      	cmp	r3, #5
20013688:	d90f      	bls.n	200136aa <HAL_MDMA_Abort+0x86>
      {
        /* Update error code */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
2001368a:	687b      	ldr	r3, [r7, #4]
2001368c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2001368e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
20013692:	687b      	ldr	r3, [r7, #4]
20013694:	669a      	str	r2, [r3, #104]	; 0x68

        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
20013696:	687b      	ldr	r3, [r7, #4]
20013698:	2200      	movs	r2, #0
2001369a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the MDMA state */
        hmdma->State = HAL_MDMA_STATE_ERROR;
2001369e:	687b      	ldr	r3, [r7, #4]
200136a0:	2203      	movs	r2, #3
200136a2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        return HAL_ERROR;
200136a6:	2301      	movs	r3, #1
200136a8:	e013      	b.n	200136d2 <HAL_MDMA_Abort+0xae>
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
200136aa:	687b      	ldr	r3, [r7, #4]
200136ac:	681b      	ldr	r3, [r3, #0]
200136ae:	68db      	ldr	r3, [r3, #12]
200136b0:	f003 0301 	and.w	r3, r3, #1
200136b4:	2b00      	cmp	r3, #0
200136b6:	d1e1      	bne.n	2001367c <HAL_MDMA_Abort+0x58>
      }
    }

    /* Clear all interrupt flags */
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BT | MDMA_FLAG_BRT | MDMA_FLAG_BFTC));
200136b8:	687b      	ldr	r3, [r7, #4]
200136ba:	681b      	ldr	r3, [r3, #0]
200136bc:	221f      	movs	r2, #31
200136be:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
200136c0:	687b      	ldr	r3, [r7, #4]
200136c2:	2200      	movs	r2, #0
200136c4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Change the MDMA state*/
    hmdma->State = HAL_MDMA_STATE_READY;
200136c8:	687b      	ldr	r3, [r7, #4]
200136ca:	2201      	movs	r2, #1
200136cc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }

  return HAL_OK;
200136d0:	2300      	movs	r3, #0
}
200136d2:	4618      	mov	r0, r3
200136d4:	3710      	adds	r7, #16
200136d6:	46bd      	mov	sp, r7
200136d8:	bd80      	pop	{r7, pc}

200136da <HAL_MDMA_Abort_IT>:
  * @param  hmdma  : pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Abort_IT(MDMA_HandleTypeDef *hmdma)
{
200136da:	b480      	push	{r7}
200136dc:	b083      	sub	sp, #12
200136de:	af00      	add	r7, sp, #0
200136e0:	6078      	str	r0, [r7, #4]
  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
200136e2:	687b      	ldr	r3, [r7, #4]
200136e4:	2b00      	cmp	r3, #0
200136e6:	d101      	bne.n	200136ec <HAL_MDMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
200136e8:	2301      	movs	r3, #1
200136ea:	e017      	b.n	2001371c <HAL_MDMA_Abort_IT+0x42>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
200136ec:	687b      	ldr	r3, [r7, #4]
200136ee:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
200136f2:	b2db      	uxtb	r3, r3
200136f4:	2b02      	cmp	r3, #2
200136f6:	d004      	beq.n	20013702 <HAL_MDMA_Abort_IT+0x28>
  {
    /* No transfer ongoing */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
200136f8:	687b      	ldr	r3, [r7, #4]
200136fa:	2280      	movs	r2, #128	; 0x80
200136fc:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
200136fe:	2301      	movs	r3, #1
20013700:	e00c      	b.n	2001371c <HAL_MDMA_Abort_IT+0x42>
  }
  else
  {
    /* Set Abort State  */
    hmdma->State = HAL_MDMA_STATE_ABORT;
20013702:	687b      	ldr	r3, [r7, #4]
20013704:	2204      	movs	r2, #4
20013706:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the stream */
    __HAL_MDMA_DISABLE(hmdma);
2001370a:	687b      	ldr	r3, [r7, #4]
2001370c:	681b      	ldr	r3, [r3, #0]
2001370e:	68da      	ldr	r2, [r3, #12]
20013710:	687b      	ldr	r3, [r7, #4]
20013712:	681b      	ldr	r3, [r3, #0]
20013714:	f022 0201 	bic.w	r2, r2, #1
20013718:	60da      	str	r2, [r3, #12]
  }

  return HAL_OK;
2001371a:	2300      	movs	r3, #0
}
2001371c:	4618      	mov	r0, r3
2001371e:	370c      	adds	r7, #12
20013720:	46bd      	mov	sp, r7
20013722:	f85d 7b04 	ldr.w	r7, [sp], #4
20013726:	4770      	bx	lr

20013728 <HAL_MDMA_PollForTransfer>:
  * @param  CompleteLevel: Specifies the MDMA level complete.
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_PollForTransfer(MDMA_HandleTypeDef *hmdma, HAL_MDMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
20013728:	b580      	push	{r7, lr}
2001372a:	b088      	sub	sp, #32
2001372c:	af00      	add	r7, sp, #0
2001372e:	60f8      	str	r0, [r7, #12]
20013730:	460b      	mov	r3, r1
20013732:	607a      	str	r2, [r7, #4]
20013734:	72fb      	strb	r3, [r7, #11]
  uint32_t levelFlag, errorFlag;
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_MDMA_LEVEL_COMPLETE(CompleteLevel));
20013736:	7afb      	ldrb	r3, [r7, #11]
20013738:	2b00      	cmp	r3, #0
2001373a:	d00d      	beq.n	20013758 <HAL_MDMA_PollForTransfer+0x30>
2001373c:	7afb      	ldrb	r3, [r7, #11]
2001373e:	2b01      	cmp	r3, #1
20013740:	d00a      	beq.n	20013758 <HAL_MDMA_PollForTransfer+0x30>
20013742:	7afb      	ldrb	r3, [r7, #11]
20013744:	2b02      	cmp	r3, #2
20013746:	d007      	beq.n	20013758 <HAL_MDMA_PollForTransfer+0x30>
20013748:	7afb      	ldrb	r3, [r7, #11]
2001374a:	2b03      	cmp	r3, #3
2001374c:	d004      	beq.n	20013758 <HAL_MDMA_PollForTransfer+0x30>
2001374e:	f240 512a 	movw	r1, #1322	; 0x52a
20013752:	4863      	ldr	r0, [pc, #396]	; (200138e0 <HAL_MDMA_PollForTransfer+0x1b8>)
20013754:	f7ed f8ce 	bl	200008f4 <assert_failed>

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
20013758:	68fb      	ldr	r3, [r7, #12]
2001375a:	2b00      	cmp	r3, #0
2001375c:	d101      	bne.n	20013762 <HAL_MDMA_PollForTransfer+0x3a>
  {
    return HAL_ERROR;
2001375e:	2301      	movs	r3, #1
20013760:	e0b9      	b.n	200138d6 <HAL_MDMA_PollForTransfer+0x1ae>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
20013762:	68fb      	ldr	r3, [r7, #12]
20013764:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
20013768:	b2db      	uxtb	r3, r3
2001376a:	2b02      	cmp	r3, #2
2001376c:	d004      	beq.n	20013778 <HAL_MDMA_PollForTransfer+0x50>
  {
    /* No transfer ongoing */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
2001376e:	68fb      	ldr	r3, [r7, #12]
20013770:	2280      	movs	r2, #128	; 0x80
20013772:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
20013774:	2301      	movs	r3, #1
20013776:	e0ae      	b.n	200138d6 <HAL_MDMA_PollForTransfer+0x1ae>
  }

  /* Get the level transfer complete flag */
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
20013778:	7afb      	ldrb	r3, [r7, #11]
2001377a:	2b00      	cmp	r3, #0
2001377c:	d00b      	beq.n	20013796 <HAL_MDMA_PollForTransfer+0x6e>
               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \
2001377e:	7afb      	ldrb	r3, [r7, #11]
20013780:	2b01      	cmp	r3, #1
20013782:	d006      	beq.n	20013792 <HAL_MDMA_PollForTransfer+0x6a>
               (CompleteLevel == HAL_MDMA_BLOCK_TRANSFER) ? MDMA_FLAG_BT   : \
20013784:	7afb      	ldrb	r3, [r7, #11]
20013786:	2b02      	cmp	r3, #2
20013788:	d101      	bne.n	2001378e <HAL_MDMA_PollForTransfer+0x66>
2001378a:	2308      	movs	r3, #8
2001378c:	e004      	b.n	20013798 <HAL_MDMA_PollForTransfer+0x70>
2001378e:	2304      	movs	r3, #4
20013790:	e002      	b.n	20013798 <HAL_MDMA_PollForTransfer+0x70>
               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \
20013792:	2310      	movs	r3, #16
20013794:	e000      	b.n	20013798 <HAL_MDMA_PollForTransfer+0x70>
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
20013796:	2302      	movs	r3, #2
20013798:	61fb      	str	r3, [r7, #28]
               MDMA_FLAG_BRT);


  /* Get timeout */
  tickstart = HAL_GetTick();
2001379a:	f7ee faa7 	bl	20001cec <HAL_GetTick>
2001379e:	61b8      	str	r0, [r7, #24]

  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
200137a0:	e067      	b.n	20013872 <HAL_MDMA_PollForTransfer+0x14a>
  {
    if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
200137a2:	68fb      	ldr	r3, [r7, #12]
200137a4:	681b      	ldr	r3, [r3, #0]
200137a6:	681b      	ldr	r3, [r3, #0]
200137a8:	f003 0301 	and.w	r3, r3, #1
200137ac:	2b00      	cmp	r3, #0
200137ae:	d046      	beq.n	2001383e <HAL_MDMA_PollForTransfer+0x116>
    {
      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
200137b0:	68fb      	ldr	r3, [r7, #12]
200137b2:	681b      	ldr	r3, [r3, #0]
200137b4:	689b      	ldr	r3, [r3, #8]
200137b6:	617b      	str	r3, [r7, #20]

      if((errorFlag & MDMA_CESR_TED) == 0U)
200137b8:	697b      	ldr	r3, [r7, #20]
200137ba:	f003 0380 	and.w	r3, r3, #128	; 0x80
200137be:	2b00      	cmp	r3, #0
200137c0:	d106      	bne.n	200137d0 <HAL_MDMA_PollForTransfer+0xa8>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
200137c2:	68fb      	ldr	r3, [r7, #12]
200137c4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
200137c6:	f043 0201 	orr.w	r2, r3, #1
200137ca:	68fb      	ldr	r3, [r7, #12]
200137cc:	669a      	str	r2, [r3, #104]	; 0x68
200137ce:	e005      	b.n	200137dc <HAL_MDMA_PollForTransfer+0xb4>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
200137d0:	68fb      	ldr	r3, [r7, #12]
200137d2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
200137d4:	f043 0202 	orr.w	r2, r3, #2
200137d8:	68fb      	ldr	r3, [r7, #12]
200137da:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
200137dc:	697b      	ldr	r3, [r7, #20]
200137de:	f403 7300 	and.w	r3, r3, #512	; 0x200
200137e2:	2b00      	cmp	r3, #0
200137e4:	d005      	beq.n	200137f2 <HAL_MDMA_PollForTransfer+0xca>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
200137e6:	68fb      	ldr	r3, [r7, #12]
200137e8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
200137ea:	f043 0204 	orr.w	r2, r3, #4
200137ee:	68fb      	ldr	r3, [r7, #12]
200137f0:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
200137f2:	697b      	ldr	r3, [r7, #20]
200137f4:	f403 7380 	and.w	r3, r3, #256	; 0x100
200137f8:	2b00      	cmp	r3, #0
200137fa:	d005      	beq.n	20013808 <HAL_MDMA_PollForTransfer+0xe0>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
200137fc:	68fb      	ldr	r3, [r7, #12]
200137fe:	6e9b      	ldr	r3, [r3, #104]	; 0x68
20013800:	f043 0208 	orr.w	r2, r3, #8
20013804:	68fb      	ldr	r3, [r7, #12]
20013806:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
20013808:	697b      	ldr	r3, [r7, #20]
2001380a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2001380e:	2b00      	cmp	r3, #0
20013810:	d005      	beq.n	2001381e <HAL_MDMA_PollForTransfer+0xf6>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
20013812:	68fb      	ldr	r3, [r7, #12]
20013814:	6e9b      	ldr	r3, [r3, #104]	; 0x68
20013816:	f043 0210 	orr.w	r2, r3, #16
2001381a:	68fb      	ldr	r3, [r7, #12]
2001381c:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
2001381e:	697b      	ldr	r3, [r7, #20]
20013820:	f403 6300 	and.w	r3, r3, #2048	; 0x800
20013824:	2b00      	cmp	r3, #0
20013826:	d005      	beq.n	20013834 <HAL_MDMA_PollForTransfer+0x10c>
      {
        /* Update error code : Block Size error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
20013828:	68fb      	ldr	r3, [r7, #12]
2001382a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2001382c:	f043 0220 	orr.w	r2, r3, #32
20013830:	68fb      	ldr	r3, [r7, #12]
20013832:	669a      	str	r2, [r3, #104]	; 0x68
      }

      (void) HAL_MDMA_Abort(hmdma); /* if error then abort the current transfer */
20013834:	68f8      	ldr	r0, [r7, #12]
20013836:	f7ff fef5 	bl	20013624 <HAL_MDMA_Abort>
          - Clear all transfer flags
          - Unlock
          - Set the State
      */

      return HAL_ERROR;
2001383a:	2301      	movs	r3, #1
2001383c:	e04b      	b.n	200138d6 <HAL_MDMA_PollForTransfer+0x1ae>

    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
2001383e:	687b      	ldr	r3, [r7, #4]
20013840:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
20013844:	d015      	beq.n	20013872 <HAL_MDMA_PollForTransfer+0x14a>
    {
      if(((HAL_GetTick() - tickstart ) > Timeout) || (Timeout == 0U))
20013846:	f7ee fa51 	bl	20001cec <HAL_GetTick>
2001384a:	4602      	mov	r2, r0
2001384c:	69bb      	ldr	r3, [r7, #24]
2001384e:	1ad3      	subs	r3, r2, r3
20013850:	687a      	ldr	r2, [r7, #4]
20013852:	429a      	cmp	r2, r3
20013854:	d302      	bcc.n	2001385c <HAL_MDMA_PollForTransfer+0x134>
20013856:	687b      	ldr	r3, [r7, #4]
20013858:	2b00      	cmp	r3, #0
2001385a:	d10a      	bne.n	20013872 <HAL_MDMA_PollForTransfer+0x14a>
      {
        /* Update error code */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
2001385c:	68fb      	ldr	r3, [r7, #12]
2001385e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
20013860:	f043 0240 	orr.w	r2, r3, #64	; 0x40
20013864:	68fb      	ldr	r3, [r7, #12]
20013866:	669a      	str	r2, [r3, #104]	; 0x68

        (void) HAL_MDMA_Abort(hmdma); /* if timeout then abort the current transfer */
20013868:	68f8      	ldr	r0, [r7, #12]
2001386a:	f7ff fedb 	bl	20013624 <HAL_MDMA_Abort>
            - Clear all transfer flags
            - Unlock
            - Set the State
        */

        return HAL_ERROR;
2001386e:	2301      	movs	r3, #1
20013870:	e031      	b.n	200138d6 <HAL_MDMA_PollForTransfer+0x1ae>
  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
20013872:	68fb      	ldr	r3, [r7, #12]
20013874:	681b      	ldr	r3, [r3, #0]
20013876:	681a      	ldr	r2, [r3, #0]
20013878:	69fb      	ldr	r3, [r7, #28]
2001387a:	4013      	ands	r3, r2
2001387c:	2b00      	cmp	r3, #0
2001387e:	d090      	beq.n	200137a2 <HAL_MDMA_PollForTransfer+0x7a>
      }
    }
  }

  /* Clear the transfer level flag */
  if(CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)
20013880:	7afb      	ldrb	r3, [r7, #11]
20013882:	2b01      	cmp	r3, #1
20013884:	d104      	bne.n	20013890 <HAL_MDMA_PollForTransfer+0x168>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
20013886:	68fb      	ldr	r3, [r7, #12]
20013888:	681b      	ldr	r3, [r3, #0]
2001388a:	2210      	movs	r2, #16
2001388c:	605a      	str	r2, [r3, #4]
2001388e:	e021      	b.n	200138d4 <HAL_MDMA_PollForTransfer+0x1ac>

  }
  else if(CompleteLevel == HAL_MDMA_BLOCK_TRANSFER)
20013890:	7afb      	ldrb	r3, [r7, #11]
20013892:	2b02      	cmp	r3, #2
20013894:	d104      	bne.n	200138a0 <HAL_MDMA_PollForTransfer+0x178>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT));
20013896:	68fb      	ldr	r3, [r7, #12]
20013898:	681b      	ldr	r3, [r3, #0]
2001389a:	2218      	movs	r2, #24
2001389c:	605a      	str	r2, [r3, #4]
2001389e:	e019      	b.n	200138d4 <HAL_MDMA_PollForTransfer+0x1ac>

  }
  else if(CompleteLevel == HAL_MDMA_REPEAT_BLOCK_TRANSFER)
200138a0:	7afb      	ldrb	r3, [r7, #11]
200138a2:	2b03      	cmp	r3, #3
200138a4:	d104      	bne.n	200138b0 <HAL_MDMA_PollForTransfer+0x188>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT | MDMA_FLAG_BRT));
200138a6:	68fb      	ldr	r3, [r7, #12]
200138a8:	681b      	ldr	r3, [r3, #0]
200138aa:	221c      	movs	r2, #28
200138ac:	605a      	str	r2, [r3, #4]
200138ae:	e011      	b.n	200138d4 <HAL_MDMA_PollForTransfer+0x1ac>
  }
  else if(CompleteLevel == HAL_MDMA_FULL_TRANSFER)
200138b0:	7afb      	ldrb	r3, [r7, #11]
200138b2:	2b00      	cmp	r3, #0
200138b4:	d10c      	bne.n	200138d0 <HAL_MDMA_PollForTransfer+0x1a8>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC | MDMA_FLAG_CTC));
200138b6:	68fb      	ldr	r3, [r7, #12]
200138b8:	681b      	ldr	r3, [r3, #0]
200138ba:	221e      	movs	r2, #30
200138bc:	605a      	str	r2, [r3, #4]

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
200138be:	68fb      	ldr	r3, [r7, #12]
200138c0:	2200      	movs	r2, #0
200138c2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
200138c6:	68fb      	ldr	r3, [r7, #12]
200138c8:	2201      	movs	r2, #1
200138ca:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
200138ce:	e001      	b.n	200138d4 <HAL_MDMA_PollForTransfer+0x1ac>
  }
  else
  {
    return HAL_ERROR;
200138d0:	2301      	movs	r3, #1
200138d2:	e000      	b.n	200138d6 <HAL_MDMA_PollForTransfer+0x1ae>
  }

  return HAL_OK;
200138d4:	2300      	movs	r3, #0
}
200138d6:	4618      	mov	r0, r3
200138d8:	3720      	adds	r7, #32
200138da:	46bd      	mov	sp, r7
200138dc:	bd80      	pop	{r7, pc}
200138de:	bf00      	nop
200138e0:	2001c1f4 	.word	0x2001c1f4

200138e4 <HAL_MDMA_GenerateSWRequest>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_GenerateSWRequest(MDMA_HandleTypeDef *hmdma)
{
200138e4:	b480      	push	{r7}
200138e6:	b085      	sub	sp, #20
200138e8:	af00      	add	r7, sp, #0
200138ea:	6078      	str	r0, [r7, #4]
  uint32_t request_mode;

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
200138ec:	687b      	ldr	r3, [r7, #4]
200138ee:	2b00      	cmp	r3, #0
200138f0:	d101      	bne.n	200138f6 <HAL_MDMA_GenerateSWRequest+0x12>
  {
    return HAL_ERROR;
200138f2:	2301      	movs	r3, #1
200138f4:	e02a      	b.n	2001394c <HAL_MDMA_GenerateSWRequest+0x68>
  }

  /* Get the softawre request mode */
  request_mode = hmdma->Instance->CTCR & MDMA_CTCR_SWRM;
200138f6:	687b      	ldr	r3, [r7, #4]
200138f8:	681b      	ldr	r3, [r3, #0]
200138fa:	691b      	ldr	r3, [r3, #16]
200138fc:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
20013900:	60fb      	str	r3, [r7, #12]

  if((hmdma->Instance->CCR &  MDMA_CCR_EN) == 0U)
20013902:	687b      	ldr	r3, [r7, #4]
20013904:	681b      	ldr	r3, [r3, #0]
20013906:	68db      	ldr	r3, [r3, #12]
20013908:	f003 0301 	and.w	r3, r3, #1
2001390c:	2b00      	cmp	r3, #0
2001390e:	d104      	bne.n	2001391a <HAL_MDMA_GenerateSWRequest+0x36>
  {
    /* if no Transfer on going (MDMA enable bit not set) retrun error */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
20013910:	687b      	ldr	r3, [r7, #4]
20013912:	2280      	movs	r2, #128	; 0x80
20013914:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
20013916:	2301      	movs	r3, #1
20013918:	e018      	b.n	2001394c <HAL_MDMA_GenerateSWRequest+0x68>
  }
  else if(((hmdma->Instance->CISR &  MDMA_CISR_CRQA) != 0U) || (request_mode == 0U))
2001391a:	687b      	ldr	r3, [r7, #4]
2001391c:	681b      	ldr	r3, [r3, #0]
2001391e:	681b      	ldr	r3, [r3, #0]
20013920:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20013924:	2b00      	cmp	r3, #0
20013926:	d102      	bne.n	2001392e <HAL_MDMA_GenerateSWRequest+0x4a>
20013928:	68fb      	ldr	r3, [r7, #12]
2001392a:	2b00      	cmp	r3, #0
2001392c:	d105      	bne.n	2001393a <HAL_MDMA_GenerateSWRequest+0x56>
  {
    /* if an MDMA ongoing request has not yet end or if request mode is not SW request retrun error */
    hmdma->ErrorCode = HAL_MDMA_ERROR_BUSY;
2001392e:	687b      	ldr	r3, [r7, #4]
20013930:	f44f 7280 	mov.w	r2, #256	; 0x100
20013934:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
20013936:	2301      	movs	r3, #1
20013938:	e008      	b.n	2001394c <HAL_MDMA_GenerateSWRequest+0x68>
  }
  else
  {
    /* Set the SW request bit to activate the request on the Channel */
    hmdma->Instance->CCR |= MDMA_CCR_SWRQ;
2001393a:	687b      	ldr	r3, [r7, #4]
2001393c:	681b      	ldr	r3, [r3, #0]
2001393e:	68da      	ldr	r2, [r3, #12]
20013940:	687b      	ldr	r3, [r7, #4]
20013942:	681b      	ldr	r3, [r3, #0]
20013944:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20013948:	60da      	str	r2, [r3, #12]

    return HAL_OK;
2001394a:	2300      	movs	r3, #0
  }
}
2001394c:	4618      	mov	r0, r3
2001394e:	3714      	adds	r7, #20
20013950:	46bd      	mov	sp, r7
20013952:	f85d 7b04 	ldr.w	r7, [sp], #4
20013956:	4770      	bx	lr

20013958 <HAL_MDMA_IRQHandler>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval None
  */
void HAL_MDMA_IRQHandler(MDMA_HandleTypeDef *hmdma)
{
20013958:	b580      	push	{r7, lr}
2001395a:	b086      	sub	sp, #24
2001395c:	af00      	add	r7, sp, #0
2001395e:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0;
20013960:	2300      	movs	r3, #0
20013962:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
20013964:	4b9a      	ldr	r3, [pc, #616]	; (20013bd0 <HAL_MDMA_IRQHandler+0x278>)
20013966:	681b      	ldr	r3, [r3, #0]
20013968:	4a9a      	ldr	r2, [pc, #616]	; (20013bd4 <HAL_MDMA_IRQHandler+0x27c>)
2001396a:	fba2 2303 	umull	r2, r3, r2, r3
2001396e:	0a9b      	lsrs	r3, r3, #10
20013970:	617b      	str	r3, [r7, #20]

  uint32_t generalIntFlag, errorFlag;

  /* General Interrupt Flag management ****************************************/
  generalIntFlag =  1UL << ((((uint32_t)hmdma->Instance - (uint32_t)(MDMA_Channel0))/HAL_MDMA_CHANNEL_SIZE) & 0x1FU);
20013972:	687b      	ldr	r3, [r7, #4]
20013974:	681b      	ldr	r3, [r3, #0]
20013976:	461a      	mov	r2, r3
20013978:	4b97      	ldr	r3, [pc, #604]	; (20013bd8 <HAL_MDMA_IRQHandler+0x280>)
2001397a:	4413      	add	r3, r2
2001397c:	099b      	lsrs	r3, r3, #6
2001397e:	f003 031f 	and.w	r3, r3, #31
20013982:	2201      	movs	r2, #1
20013984:	fa02 f303 	lsl.w	r3, r2, r3
20013988:	613b      	str	r3, [r7, #16]
  if((MDMA->GISR0 & generalIntFlag) == 0U)
2001398a:	f04f 43a4 	mov.w	r3, #1375731712	; 0x52000000
2001398e:	681a      	ldr	r2, [r3, #0]
20013990:	693b      	ldr	r3, [r7, #16]
20013992:	4013      	ands	r3, r2
20013994:	2b00      	cmp	r3, #0
20013996:	f000 812e 	beq.w	20013bf6 <HAL_MDMA_IRQHandler+0x29e>
  {
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
  }

  /* Transfer Error Interrupt management ***************************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
2001399a:	687b      	ldr	r3, [r7, #4]
2001399c:	681b      	ldr	r3, [r3, #0]
2001399e:	681b      	ldr	r3, [r3, #0]
200139a0:	f003 0301 	and.w	r3, r3, #1
200139a4:	2b00      	cmp	r3, #0
200139a6:	d054      	beq.n	20013a52 <HAL_MDMA_IRQHandler+0xfa>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_TE) != 0U)
200139a8:	687b      	ldr	r3, [r7, #4]
200139aa:	681b      	ldr	r3, [r3, #0]
200139ac:	68db      	ldr	r3, [r3, #12]
200139ae:	f003 0302 	and.w	r3, r3, #2
200139b2:	2b00      	cmp	r3, #0
200139b4:	d04d      	beq.n	20013a52 <HAL_MDMA_IRQHandler+0xfa>
    {
      /* Disable the transfer error interrupt */
      __HAL_MDMA_DISABLE_IT(hmdma, MDMA_IT_TE);
200139b6:	687b      	ldr	r3, [r7, #4]
200139b8:	681b      	ldr	r3, [r3, #0]
200139ba:	68da      	ldr	r2, [r3, #12]
200139bc:	687b      	ldr	r3, [r7, #4]
200139be:	681b      	ldr	r3, [r3, #0]
200139c0:	f022 0202 	bic.w	r2, r2, #2
200139c4:	60da      	str	r2, [r3, #12]

      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
200139c6:	687b      	ldr	r3, [r7, #4]
200139c8:	681b      	ldr	r3, [r3, #0]
200139ca:	689b      	ldr	r3, [r3, #8]
200139cc:	60fb      	str	r3, [r7, #12]

      if((errorFlag & MDMA_CESR_TED) == 0U)
200139ce:	68fb      	ldr	r3, [r7, #12]
200139d0:	f003 0380 	and.w	r3, r3, #128	; 0x80
200139d4:	2b00      	cmp	r3, #0
200139d6:	d106      	bne.n	200139e6 <HAL_MDMA_IRQHandler+0x8e>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
200139d8:	687b      	ldr	r3, [r7, #4]
200139da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
200139dc:	f043 0201 	orr.w	r2, r3, #1
200139e0:	687b      	ldr	r3, [r7, #4]
200139e2:	669a      	str	r2, [r3, #104]	; 0x68
200139e4:	e005      	b.n	200139f2 <HAL_MDMA_IRQHandler+0x9a>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
200139e6:	687b      	ldr	r3, [r7, #4]
200139e8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
200139ea:	f043 0202 	orr.w	r2, r3, #2
200139ee:	687b      	ldr	r3, [r7, #4]
200139f0:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
200139f2:	68fb      	ldr	r3, [r7, #12]
200139f4:	f403 7300 	and.w	r3, r3, #512	; 0x200
200139f8:	2b00      	cmp	r3, #0
200139fa:	d005      	beq.n	20013a08 <HAL_MDMA_IRQHandler+0xb0>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
200139fc:	687b      	ldr	r3, [r7, #4]
200139fe:	6e9b      	ldr	r3, [r3, #104]	; 0x68
20013a00:	f043 0204 	orr.w	r2, r3, #4
20013a04:	687b      	ldr	r3, [r7, #4]
20013a06:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
20013a08:	68fb      	ldr	r3, [r7, #12]
20013a0a:	f403 7380 	and.w	r3, r3, #256	; 0x100
20013a0e:	2b00      	cmp	r3, #0
20013a10:	d005      	beq.n	20013a1e <HAL_MDMA_IRQHandler+0xc6>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
20013a12:	687b      	ldr	r3, [r7, #4]
20013a14:	6e9b      	ldr	r3, [r3, #104]	; 0x68
20013a16:	f043 0208 	orr.w	r2, r3, #8
20013a1a:	687b      	ldr	r3, [r7, #4]
20013a1c:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
20013a1e:	68fb      	ldr	r3, [r7, #12]
20013a20:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20013a24:	2b00      	cmp	r3, #0
20013a26:	d005      	beq.n	20013a34 <HAL_MDMA_IRQHandler+0xdc>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
20013a28:	687b      	ldr	r3, [r7, #4]
20013a2a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
20013a2c:	f043 0210 	orr.w	r2, r3, #16
20013a30:	687b      	ldr	r3, [r7, #4]
20013a32:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
20013a34:	68fb      	ldr	r3, [r7, #12]
20013a36:	f403 6300 	and.w	r3, r3, #2048	; 0x800
20013a3a:	2b00      	cmp	r3, #0
20013a3c:	d005      	beq.n	20013a4a <HAL_MDMA_IRQHandler+0xf2>
      {
        /* Update error code : Block Size error error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
20013a3e:	687b      	ldr	r3, [r7, #4]
20013a40:	6e9b      	ldr	r3, [r3, #104]	; 0x68
20013a42:	f043 0220 	orr.w	r2, r3, #32
20013a46:	687b      	ldr	r3, [r7, #4]
20013a48:	669a      	str	r2, [r3, #104]	; 0x68
      }

      /* Clear the transfer error flags */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE);
20013a4a:	687b      	ldr	r3, [r7, #4]
20013a4c:	681b      	ldr	r3, [r3, #0]
20013a4e:	2201      	movs	r2, #1
20013a50:	605a      	str	r2, [r3, #4]
    }
  }

  /* Buffer Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BFTC) != 0U))
20013a52:	687b      	ldr	r3, [r7, #4]
20013a54:	681b      	ldr	r3, [r3, #0]
20013a56:	681b      	ldr	r3, [r3, #0]
20013a58:	f003 0310 	and.w	r3, r3, #16
20013a5c:	2b00      	cmp	r3, #0
20013a5e:	d012      	beq.n	20013a86 <HAL_MDMA_IRQHandler+0x12e>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BFTC) != 0U)
20013a60:	687b      	ldr	r3, [r7, #4]
20013a62:	681b      	ldr	r3, [r3, #0]
20013a64:	68db      	ldr	r3, [r3, #12]
20013a66:	f003 0320 	and.w	r3, r3, #32
20013a6a:	2b00      	cmp	r3, #0
20013a6c:	d00b      	beq.n	20013a86 <HAL_MDMA_IRQHandler+0x12e>
    {
      /* Clear the buffer transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
20013a6e:	687b      	ldr	r3, [r7, #4]
20013a70:	681b      	ldr	r3, [r3, #0]
20013a72:	2210      	movs	r2, #16
20013a74:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBufferCpltCallback != NULL)
20013a76:	687b      	ldr	r3, [r7, #4]
20013a78:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20013a7a:	2b00      	cmp	r3, #0
20013a7c:	d003      	beq.n	20013a86 <HAL_MDMA_IRQHandler+0x12e>
      {
        /* Buffer transfer callback */
        hmdma->XferBufferCpltCallback(hmdma);
20013a7e:	687b      	ldr	r3, [r7, #4]
20013a80:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20013a82:	6878      	ldr	r0, [r7, #4]
20013a84:	4798      	blx	r3
      }
    }
  }

  /* Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BT) != 0U))
20013a86:	687b      	ldr	r3, [r7, #4]
20013a88:	681b      	ldr	r3, [r3, #0]
20013a8a:	681b      	ldr	r3, [r3, #0]
20013a8c:	f003 0308 	and.w	r3, r3, #8
20013a90:	2b00      	cmp	r3, #0
20013a92:	d012      	beq.n	20013aba <HAL_MDMA_IRQHandler+0x162>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BT) != 0U)
20013a94:	687b      	ldr	r3, [r7, #4]
20013a96:	681b      	ldr	r3, [r3, #0]
20013a98:	68db      	ldr	r3, [r3, #12]
20013a9a:	f003 0310 	and.w	r3, r3, #16
20013a9e:	2b00      	cmp	r3, #0
20013aa0:	d00b      	beq.n	20013aba <HAL_MDMA_IRQHandler+0x162>
    {
      /* Clear the block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BT);
20013aa2:	687b      	ldr	r3, [r7, #4]
20013aa4:	681b      	ldr	r3, [r3, #0]
20013aa6:	2208      	movs	r2, #8
20013aa8:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBlockCpltCallback != NULL)
20013aaa:	687b      	ldr	r3, [r7, #4]
20013aac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20013aae:	2b00      	cmp	r3, #0
20013ab0:	d003      	beq.n	20013aba <HAL_MDMA_IRQHandler+0x162>
      {
        /* Block transfer callback */
        hmdma->XferBlockCpltCallback(hmdma);
20013ab2:	687b      	ldr	r3, [r7, #4]
20013ab4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20013ab6:	6878      	ldr	r0, [r7, #4]
20013ab8:	4798      	blx	r3
      }
    }
  }

  /* Repeated Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BRT) != 0U))
20013aba:	687b      	ldr	r3, [r7, #4]
20013abc:	681b      	ldr	r3, [r3, #0]
20013abe:	681b      	ldr	r3, [r3, #0]
20013ac0:	f003 0304 	and.w	r3, r3, #4
20013ac4:	2b00      	cmp	r3, #0
20013ac6:	d012      	beq.n	20013aee <HAL_MDMA_IRQHandler+0x196>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BRT) != 0U)
20013ac8:	687b      	ldr	r3, [r7, #4]
20013aca:	681b      	ldr	r3, [r3, #0]
20013acc:	68db      	ldr	r3, [r3, #12]
20013ace:	f003 0308 	and.w	r3, r3, #8
20013ad2:	2b00      	cmp	r3, #0
20013ad4:	d00b      	beq.n	20013aee <HAL_MDMA_IRQHandler+0x196>
    {
      /* Clear the repeat block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BRT);
20013ad6:	687b      	ldr	r3, [r7, #4]
20013ad8:	681b      	ldr	r3, [r3, #0]
20013ada:	2204      	movs	r2, #4
20013adc:	605a      	str	r2, [r3, #4]

      if(hmdma->XferRepeatBlockCpltCallback != NULL)
20013ade:	687b      	ldr	r3, [r7, #4]
20013ae0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20013ae2:	2b00      	cmp	r3, #0
20013ae4:	d003      	beq.n	20013aee <HAL_MDMA_IRQHandler+0x196>
      {
        /* Repeated Block transfer callback */
        hmdma->XferRepeatBlockCpltCallback(hmdma);
20013ae6:	687b      	ldr	r3, [r7, #4]
20013ae8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20013aea:	6878      	ldr	r0, [r7, #4]
20013aec:	4798      	blx	r3
      }
    }
  }

  /* Channel Transfer Complete Interrupt management ***********************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_CTC) != 0U))
20013aee:	687b      	ldr	r3, [r7, #4]
20013af0:	681b      	ldr	r3, [r3, #0]
20013af2:	681b      	ldr	r3, [r3, #0]
20013af4:	f003 0302 	and.w	r3, r3, #2
20013af8:	2b00      	cmp	r3, #0
20013afa:	d039      	beq.n	20013b70 <HAL_MDMA_IRQHandler+0x218>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_CTC) != 0U)
20013afc:	687b      	ldr	r3, [r7, #4]
20013afe:	681b      	ldr	r3, [r3, #0]
20013b00:	68db      	ldr	r3, [r3, #12]
20013b02:	f003 0304 	and.w	r3, r3, #4
20013b06:	2b00      	cmp	r3, #0
20013b08:	d032      	beq.n	20013b70 <HAL_MDMA_IRQHandler+0x218>
    {
      /* Disable all the transfer interrupts */
      __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
20013b0a:	687b      	ldr	r3, [r7, #4]
20013b0c:	681b      	ldr	r3, [r3, #0]
20013b0e:	68da      	ldr	r2, [r3, #12]
20013b10:	687b      	ldr	r3, [r7, #4]
20013b12:	681b      	ldr	r3, [r3, #0]
20013b14:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
20013b18:	60da      	str	r2, [r3, #12]

      if(HAL_MDMA_STATE_ABORT == hmdma->State)
20013b1a:	687b      	ldr	r3, [r7, #4]
20013b1c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
20013b20:	b2db      	uxtb	r3, r3
20013b22:	2b04      	cmp	r3, #4
20013b24:	d110      	bne.n	20013b48 <HAL_MDMA_IRQHandler+0x1f0>
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
20013b26:	687b      	ldr	r3, [r7, #4]
20013b28:	2200      	movs	r2, #0
20013b2a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the DMA state */
        hmdma->State = HAL_MDMA_STATE_READY;
20013b2e:	687b      	ldr	r3, [r7, #4]
20013b30:	2201      	movs	r2, #1
20013b32:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        if(hmdma->XferAbortCallback != NULL)
20013b36:	687b      	ldr	r3, [r7, #4]
20013b38:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20013b3a:	2b00      	cmp	r3, #0
20013b3c:	d05d      	beq.n	20013bfa <HAL_MDMA_IRQHandler+0x2a2>
        {
          hmdma->XferAbortCallback(hmdma);
20013b3e:	687b      	ldr	r3, [r7, #4]
20013b40:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20013b42:	6878      	ldr	r0, [r7, #4]
20013b44:	4798      	blx	r3
        }
        return;
20013b46:	e058      	b.n	20013bfa <HAL_MDMA_IRQHandler+0x2a2>
      }

      /* Clear the Channel Transfer Complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_CTC);
20013b48:	687b      	ldr	r3, [r7, #4]
20013b4a:	681b      	ldr	r3, [r3, #0]
20013b4c:	2202      	movs	r2, #2
20013b4e:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hmdma);
20013b50:	687b      	ldr	r3, [r7, #4]
20013b52:	2200      	movs	r2, #0
20013b54:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

      /* Change MDMA peripheral state */
      hmdma->State = HAL_MDMA_STATE_READY;
20013b58:	687b      	ldr	r3, [r7, #4]
20013b5a:	2201      	movs	r2, #1
20013b5c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      if(hmdma->XferCpltCallback != NULL)
20013b60:	687b      	ldr	r3, [r7, #4]
20013b62:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20013b64:	2b00      	cmp	r3, #0
20013b66:	d003      	beq.n	20013b70 <HAL_MDMA_IRQHandler+0x218>
      {
        /* Channel Transfer Complete callback */
        hmdma->XferCpltCallback(hmdma);
20013b68:	687b      	ldr	r3, [r7, #4]
20013b6a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20013b6c:	6878      	ldr	r0, [r7, #4]
20013b6e:	4798      	blx	r3
      }
    }
  }

  /* manage error case */
  if(hmdma->ErrorCode != HAL_MDMA_ERROR_NONE)
20013b70:	687b      	ldr	r3, [r7, #4]
20013b72:	6e9b      	ldr	r3, [r3, #104]	; 0x68
20013b74:	2b00      	cmp	r3, #0
20013b76:	d041      	beq.n	20013bfc <HAL_MDMA_IRQHandler+0x2a4>
  {
    hmdma->State = HAL_MDMA_STATE_ABORT;
20013b78:	687b      	ldr	r3, [r7, #4]
20013b7a:	2204      	movs	r2, #4
20013b7c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
20013b80:	687b      	ldr	r3, [r7, #4]
20013b82:	681b      	ldr	r3, [r3, #0]
20013b84:	68da      	ldr	r2, [r3, #12]
20013b86:	687b      	ldr	r3, [r7, #4]
20013b88:	681b      	ldr	r3, [r3, #0]
20013b8a:	f022 0201 	bic.w	r2, r2, #1
20013b8e:	60da      	str	r2, [r3, #12]

    do
    {
      if (++count > timeout)
20013b90:	68bb      	ldr	r3, [r7, #8]
20013b92:	3301      	adds	r3, #1
20013b94:	60bb      	str	r3, [r7, #8]
20013b96:	697a      	ldr	r2, [r7, #20]
20013b98:	429a      	cmp	r2, r3
20013b9a:	d307      	bcc.n	20013bac <HAL_MDMA_IRQHandler+0x254>
      {
        break;
      }
    }
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U);
20013b9c:	687b      	ldr	r3, [r7, #4]
20013b9e:	681b      	ldr	r3, [r3, #0]
20013ba0:	68db      	ldr	r3, [r3, #12]
20013ba2:	f003 0301 	and.w	r3, r3, #1
20013ba6:	2b00      	cmp	r3, #0
20013ba8:	d1f2      	bne.n	20013b90 <HAL_MDMA_IRQHandler+0x238>
20013baa:	e000      	b.n	20013bae <HAL_MDMA_IRQHandler+0x256>
        break;
20013bac:	bf00      	nop

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
20013bae:	687b      	ldr	r3, [r7, #4]
20013bb0:	2200      	movs	r2, #0
20013bb2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    if((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
20013bb6:	687b      	ldr	r3, [r7, #4]
20013bb8:	681b      	ldr	r3, [r3, #0]
20013bba:	68db      	ldr	r3, [r3, #12]
20013bbc:	f003 0301 	and.w	r3, r3, #1
20013bc0:	2b00      	cmp	r3, #0
20013bc2:	d00b      	beq.n	20013bdc <HAL_MDMA_IRQHandler+0x284>
    {
      /* Change the MDMA state to error if MDMA disable fails */
      hmdma->State = HAL_MDMA_STATE_ERROR;
20013bc4:	687b      	ldr	r3, [r7, #4]
20013bc6:	2203      	movs	r2, #3
20013bc8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
20013bcc:	e00a      	b.n	20013be4 <HAL_MDMA_IRQHandler+0x28c>
20013bce:	bf00      	nop
20013bd0:	2001c978 	.word	0x2001c978
20013bd4:	1b4e81b5 	.word	0x1b4e81b5
20013bd8:	adffffc0 	.word	0xadffffc0
    }
    else
    {
      /* Change the MDMA state to Ready if MDMA disable success */
      hmdma->State = HAL_MDMA_STATE_READY;
20013bdc:	687b      	ldr	r3, [r7, #4]
20013bde:	2201      	movs	r2, #1
20013be0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }


    if (hmdma->XferErrorCallback != NULL)
20013be4:	687b      	ldr	r3, [r7, #4]
20013be6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20013be8:	2b00      	cmp	r3, #0
20013bea:	d007      	beq.n	20013bfc <HAL_MDMA_IRQHandler+0x2a4>
    {
      /* Transfer error callback */
      hmdma->XferErrorCallback(hmdma);
20013bec:	687b      	ldr	r3, [r7, #4]
20013bee:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20013bf0:	6878      	ldr	r0, [r7, #4]
20013bf2:	4798      	blx	r3
20013bf4:	e002      	b.n	20013bfc <HAL_MDMA_IRQHandler+0x2a4>
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
20013bf6:	bf00      	nop
20013bf8:	e000      	b.n	20013bfc <HAL_MDMA_IRQHandler+0x2a4>
        return;
20013bfa:	bf00      	nop
    }
  }
}
20013bfc:	3718      	adds	r7, #24
20013bfe:	46bd      	mov	sp, r7
20013c00:	bd80      	pop	{r7, pc}
20013c02:	bf00      	nop

20013c04 <HAL_MDMA_GetState>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL state
  */
HAL_MDMA_StateTypeDef HAL_MDMA_GetState(MDMA_HandleTypeDef *hmdma)
{
20013c04:	b480      	push	{r7}
20013c06:	b083      	sub	sp, #12
20013c08:	af00      	add	r7, sp, #0
20013c0a:	6078      	str	r0, [r7, #4]
  return hmdma->State;
20013c0c:	687b      	ldr	r3, [r7, #4]
20013c0e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
20013c12:	b2db      	uxtb	r3, r3
}
20013c14:	4618      	mov	r0, r3
20013c16:	370c      	adds	r7, #12
20013c18:	46bd      	mov	sp, r7
20013c1a:	f85d 7b04 	ldr.w	r7, [sp], #4
20013c1e:	4770      	bx	lr

20013c20 <HAL_MDMA_GetError>:
  * @param  hmdma : pointer to a MDMA_HandleTypeDef structure that contains
  *              the configuration information for the specified MDMA Channel.
  * @retval MDMA Error Code
  */
uint32_t HAL_MDMA_GetError(MDMA_HandleTypeDef *hmdma)
{
20013c20:	b480      	push	{r7}
20013c22:	b083      	sub	sp, #12
20013c24:	af00      	add	r7, sp, #0
20013c26:	6078      	str	r0, [r7, #4]
  return hmdma->ErrorCode;
20013c28:	687b      	ldr	r3, [r7, #4]
20013c2a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
}
20013c2c:	4618      	mov	r0, r3
20013c2e:	370c      	adds	r7, #12
20013c30:	46bd      	mov	sp, r7
20013c32:	f85d 7b04 	ldr.w	r7, [sp], #4
20013c36:	4770      	bx	lr

20013c38 <MDMA_SetConfig>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount: The number of blocks to be transfered
  * @retval HAL status
  */
static void MDMA_SetConfig(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
20013c38:	b480      	push	{r7}
20013c3a:	b087      	sub	sp, #28
20013c3c:	af00      	add	r7, sp, #0
20013c3e:	60f8      	str	r0, [r7, #12]
20013c40:	60b9      	str	r1, [r7, #8]
20013c42:	607a      	str	r2, [r7, #4]
20013c44:	603b      	str	r3, [r7, #0]
  uint32_t addressMask;

  /* Configure the MDMA Channel data length */
  MODIFY_REG(hmdma->Instance->CBNDTR ,MDMA_CBNDTR_BNDT, (BlockDataLength & MDMA_CBNDTR_BNDT));
20013c46:	68fb      	ldr	r3, [r7, #12]
20013c48:	681b      	ldr	r3, [r3, #0]
20013c4a:	695a      	ldr	r2, [r3, #20]
20013c4c:	4b31      	ldr	r3, [pc, #196]	; (20013d14 <MDMA_SetConfig+0xdc>)
20013c4e:	4013      	ands	r3, r2
20013c50:	683a      	ldr	r2, [r7, #0]
20013c52:	f3c2 0110 	ubfx	r1, r2, #0, #17
20013c56:	68fa      	ldr	r2, [r7, #12]
20013c58:	6812      	ldr	r2, [r2, #0]
20013c5a:	430b      	orrs	r3, r1
20013c5c:	6153      	str	r3, [r2, #20]

  /* Configure the MDMA block repeat count */
  MODIFY_REG(hmdma->Instance->CBNDTR , MDMA_CBNDTR_BRC , ((BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC);
20013c5e:	68fb      	ldr	r3, [r7, #12]
20013c60:	681b      	ldr	r3, [r3, #0]
20013c62:	695b      	ldr	r3, [r3, #20]
20013c64:	f3c3 0113 	ubfx	r1, r3, #0, #20
20013c68:	6a3b      	ldr	r3, [r7, #32]
20013c6a:	3b01      	subs	r3, #1
20013c6c:	051a      	lsls	r2, r3, #20
20013c6e:	68fb      	ldr	r3, [r7, #12]
20013c70:	681b      	ldr	r3, [r3, #0]
20013c72:	430a      	orrs	r2, r1
20013c74:	615a      	str	r2, [r3, #20]

  /* Clear all interrupt flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_CISR_BRTIF | MDMA_CISR_BTIF | MDMA_CISR_TCIF);
20013c76:	68fb      	ldr	r3, [r7, #12]
20013c78:	681b      	ldr	r3, [r3, #0]
20013c7a:	221f      	movs	r2, #31
20013c7c:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Channel destination address */
  hmdma->Instance->CDAR = DstAddress;
20013c7e:	68fb      	ldr	r3, [r7, #12]
20013c80:	681b      	ldr	r3, [r3, #0]
20013c82:	687a      	ldr	r2, [r7, #4]
20013c84:	61da      	str	r2, [r3, #28]

  /* Configure MDMA Channel Source address */
  hmdma->Instance->CSAR = SrcAddress;
20013c86:	68fb      	ldr	r3, [r7, #12]
20013c88:	681b      	ldr	r3, [r3, #0]
20013c8a:	68ba      	ldr	r2, [r7, #8]
20013c8c:	619a      	str	r2, [r3, #24]

  addressMask = SrcAddress & 0xFF000000U;
20013c8e:	68bb      	ldr	r3, [r7, #8]
20013c90:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
20013c94:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
20013c96:	697b      	ldr	r3, [r7, #20]
20013c98:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20013c9c:	d002      	beq.n	20013ca4 <MDMA_SetConfig+0x6c>
20013c9e:	697b      	ldr	r3, [r7, #20]
20013ca0:	2b00      	cmp	r3, #0
20013ca2:	d108      	bne.n	20013cb6 <MDMA_SetConfig+0x7e>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_SBUS;
20013ca4:	68fb      	ldr	r3, [r7, #12]
20013ca6:	681b      	ldr	r3, [r3, #0]
20013ca8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20013caa:	68fb      	ldr	r3, [r7, #12]
20013cac:	681b      	ldr	r3, [r3, #0]
20013cae:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20013cb2:	629a      	str	r2, [r3, #40]	; 0x28
20013cb4:	e007      	b.n	20013cc6 <MDMA_SetConfig+0x8e>
  }
  else
  {
    /*The AXI bus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_SBUS);
20013cb6:	68fb      	ldr	r3, [r7, #12]
20013cb8:	681b      	ldr	r3, [r3, #0]
20013cba:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20013cbc:	68fb      	ldr	r3, [r7, #12]
20013cbe:	681b      	ldr	r3, [r3, #0]
20013cc0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
20013cc4:	629a      	str	r2, [r3, #40]	; 0x28
  }

  addressMask = DstAddress & 0xFF000000U;
20013cc6:	687b      	ldr	r3, [r7, #4]
20013cc8:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
20013ccc:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
20013cce:	697b      	ldr	r3, [r7, #20]
20013cd0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20013cd4:	d002      	beq.n	20013cdc <MDMA_SetConfig+0xa4>
20013cd6:	697b      	ldr	r3, [r7, #20]
20013cd8:	2b00      	cmp	r3, #0
20013cda:	d108      	bne.n	20013cee <MDMA_SetConfig+0xb6>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_DBUS;
20013cdc:	68fb      	ldr	r3, [r7, #12]
20013cde:	681b      	ldr	r3, [r3, #0]
20013ce0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20013ce2:	68fb      	ldr	r3, [r7, #12]
20013ce4:	681b      	ldr	r3, [r3, #0]
20013ce6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
20013cea:	629a      	str	r2, [r3, #40]	; 0x28
20013cec:	e007      	b.n	20013cfe <MDMA_SetConfig+0xc6>
  }
  else
  {
    /*The AXI bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_DBUS);
20013cee:	68fb      	ldr	r3, [r7, #12]
20013cf0:	681b      	ldr	r3, [r3, #0]
20013cf2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20013cf4:	68fb      	ldr	r3, [r7, #12]
20013cf6:	681b      	ldr	r3, [r3, #0]
20013cf8:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
20013cfc:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Set the linked list register to the first node of the list */
  hmdma->Instance->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
20013cfe:	68fb      	ldr	r3, [r7, #12]
20013d00:	6dda      	ldr	r2, [r3, #92]	; 0x5c
20013d02:	68fb      	ldr	r3, [r7, #12]
20013d04:	681b      	ldr	r3, [r3, #0]
20013d06:	625a      	str	r2, [r3, #36]	; 0x24
}
20013d08:	bf00      	nop
20013d0a:	371c      	adds	r7, #28
20013d0c:	46bd      	mov	sp, r7
20013d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
20013d12:	4770      	bx	lr
20013d14:	fffe0000 	.word	0xfffe0000

20013d18 <MDMA_Init>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Channel.
  * @retval None
  */
static void MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
20013d18:	b480      	push	{r7}
20013d1a:	b085      	sub	sp, #20
20013d1c:	af00      	add	r7, sp, #0
20013d1e:	6078      	str	r0, [r7, #4]
  uint32_t blockoffset;

  /* Prepare the MDMA Channel configuration */
  hmdma->Instance->CCR = hmdma->Init.Priority  | hmdma->Init.Endianness;
20013d20:	687b      	ldr	r3, [r7, #4]
20013d22:	68d9      	ldr	r1, [r3, #12]
20013d24:	687b      	ldr	r3, [r7, #4]
20013d26:	691a      	ldr	r2, [r3, #16]
20013d28:	687b      	ldr	r3, [r7, #4]
20013d2a:	681b      	ldr	r3, [r3, #0]
20013d2c:	430a      	orrs	r2, r1
20013d2e:	60da      	str	r2, [r3, #12]

  /* Write new CTCR Register value */
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
20013d30:	687b      	ldr	r3, [r7, #4]
20013d32:	695a      	ldr	r2, [r3, #20]
20013d34:	687b      	ldr	r3, [r7, #4]
20013d36:	699b      	ldr	r3, [r3, #24]
20013d38:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
20013d3a:	687b      	ldr	r3, [r7, #4]
20013d3c:	69db      	ldr	r3, [r3, #28]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
20013d3e:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
20013d40:	687b      	ldr	r3, [r7, #4]
20013d42:	6a1b      	ldr	r3, [r3, #32]
20013d44:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
20013d46:	687b      	ldr	r3, [r7, #4]
20013d48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
20013d4a:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
20013d4c:	687b      	ldr	r3, [r7, #4]
20013d4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20013d50:	431a      	orrs	r2, r3
                           hmdma->Init.DestBurst                                   | \
20013d52:	687b      	ldr	r3, [r7, #4]
20013d54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
20013d56:	431a      	orrs	r2, r3
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
20013d58:	687b      	ldr	r3, [r7, #4]
20013d5a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20013d5c:	3b01      	subs	r3, #1
20013d5e:	049b      	lsls	r3, r3, #18
                           hmdma->Init.DestBurst                                   | \
20013d60:	ea42 0103 	orr.w	r1, r2, r3
                           hmdma->Init.TransferTriggerMode;
20013d64:	687b      	ldr	r3, [r7, #4]
20013d66:	689a      	ldr	r2, [r3, #8]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
20013d68:	687b      	ldr	r3, [r7, #4]
20013d6a:	681b      	ldr	r3, [r3, #0]
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
20013d6c:	430a      	orrs	r2, r1
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
20013d6e:	611a      	str	r2, [r3, #16]

  /* If SW request set the CTCR register to SW Request Mode */
  if(hmdma->Init.Request == MDMA_REQUEST_SW)
20013d70:	687b      	ldr	r3, [r7, #4]
20013d72:	685b      	ldr	r3, [r3, #4]
20013d74:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20013d78:	d107      	bne.n	20013d8a <MDMA_Init+0x72>
    -If the request is done by SW : BWM could be set to 1 or 0.
    -If the request is done by a peripheral :
    If mask address not set (0) => BWM must be set to 0
    If mask address set (different than 0) => BWM could be set to 1 or 0
    */
    hmdma->Instance->CTCR |= (MDMA_CTCR_SWRM | MDMA_CTCR_BWM);
20013d7a:	687b      	ldr	r3, [r7, #4]
20013d7c:	681b      	ldr	r3, [r3, #0]
20013d7e:	691a      	ldr	r2, [r3, #16]
20013d80:	687b      	ldr	r3, [r7, #4]
20013d82:	681b      	ldr	r3, [r3, #0]
20013d84:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
20013d88:	611a      	str	r2, [r3, #16]
  }

  /* Reset CBNDTR Register */
  hmdma->Instance->CBNDTR = 0;
20013d8a:	687b      	ldr	r3, [r7, #4]
20013d8c:	681b      	ldr	r3, [r3, #0]
20013d8e:	2200      	movs	r2, #0
20013d90:	615a      	str	r2, [r3, #20]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(hmdma->Init.SourceBlockAddressOffset < 0)
20013d92:	687b      	ldr	r3, [r7, #4]
20013d94:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20013d96:	2b00      	cmp	r3, #0
20013d98:	da11      	bge.n	20013dbe <MDMA_Init+0xa6>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRSUM;
20013d9a:	687b      	ldr	r3, [r7, #4]
20013d9c:	681b      	ldr	r3, [r3, #0]
20013d9e:	695a      	ldr	r2, [r3, #20]
20013da0:	687b      	ldr	r3, [r7, #4]
20013da2:	681b      	ldr	r3, [r3, #0]
20013da4:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
20013da8:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.SourceBlockAddressOffset);
20013daa:	687b      	ldr	r3, [r7, #4]
20013dac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20013dae:	425b      	negs	r3, r3
20013db0:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR = (blockoffset & 0x0000FFFFU);
20013db2:	687b      	ldr	r3, [r7, #4]
20013db4:	681b      	ldr	r3, [r3, #0]
20013db6:	68fa      	ldr	r2, [r7, #12]
20013db8:	b292      	uxth	r2, r2
20013dba:	621a      	str	r2, [r3, #32]
20013dbc:	e006      	b.n	20013dcc <MDMA_Init+0xb4>
  }
  else
  {
    /* Write new CBRUR Register value : source repeat block offset */
    hmdma->Instance->CBRUR = (((uint32_t)hmdma->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
20013dbe:	687b      	ldr	r3, [r7, #4]
20013dc0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20013dc2:	461a      	mov	r2, r3
20013dc4:	687b      	ldr	r3, [r7, #4]
20013dc6:	681b      	ldr	r3, [r3, #0]
20013dc8:	b292      	uxth	r2, r2
20013dca:	621a      	str	r2, [r3, #32]
  }

  /* If block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(hmdma->Init.DestBlockAddressOffset < 0)
20013dcc:	687b      	ldr	r3, [r7, #4]
20013dce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20013dd0:	2b00      	cmp	r3, #0
20013dd2:	da15      	bge.n	20013e00 <MDMA_Init+0xe8>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRDUM;
20013dd4:	687b      	ldr	r3, [r7, #4]
20013dd6:	681b      	ldr	r3, [r3, #0]
20013dd8:	695a      	ldr	r2, [r3, #20]
20013dda:	687b      	ldr	r3, [r7, #4]
20013ddc:	681b      	ldr	r3, [r3, #0]
20013dde:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
20013de2:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.DestBlockAddressOffset);
20013de4:	687b      	ldr	r3, [r7, #4]
20013de6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20013de8:	425b      	negs	r3, r3
20013dea:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
20013dec:	687b      	ldr	r3, [r7, #4]
20013dee:	681b      	ldr	r3, [r3, #0]
20013df0:	6a19      	ldr	r1, [r3, #32]
20013df2:	68fb      	ldr	r3, [r7, #12]
20013df4:	041a      	lsls	r2, r3, #16
20013df6:	687b      	ldr	r3, [r7, #4]
20013df8:	681b      	ldr	r3, [r3, #0]
20013dfa:	430a      	orrs	r2, r1
20013dfc:	621a      	str	r2, [r3, #32]
20013dfe:	e009      	b.n	20013e14 <MDMA_Init+0xfc>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    hmdma->Instance->CBRUR |= ((((uint32_t)hmdma->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
20013e00:	687b      	ldr	r3, [r7, #4]
20013e02:	681b      	ldr	r3, [r3, #0]
20013e04:	6a19      	ldr	r1, [r3, #32]
20013e06:	687b      	ldr	r3, [r7, #4]
20013e08:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20013e0a:	041a      	lsls	r2, r3, #16
20013e0c:	687b      	ldr	r3, [r7, #4]
20013e0e:	681b      	ldr	r3, [r3, #0]
20013e10:	430a      	orrs	r2, r1
20013e12:	621a      	str	r2, [r3, #32]
  }

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData, */
  if(hmdma->Init.Request != MDMA_REQUEST_SW)
20013e14:	687b      	ldr	r3, [r7, #4]
20013e16:	685b      	ldr	r3, [r3, #4]
20013e18:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20013e1c:	d006      	beq.n	20013e2c <MDMA_Init+0x114>
  {
    /* Set the HW request in CTRB register  */
    hmdma->Instance->CTBR = hmdma->Init.Request & MDMA_CTBR_TSEL;
20013e1e:	687b      	ldr	r3, [r7, #4]
20013e20:	685a      	ldr	r2, [r3, #4]
20013e22:	687b      	ldr	r3, [r7, #4]
20013e24:	681b      	ldr	r3, [r3, #0]
20013e26:	b2d2      	uxtb	r2, r2
20013e28:	629a      	str	r2, [r3, #40]	; 0x28
20013e2a:	e003      	b.n	20013e34 <MDMA_Init+0x11c>
  }
  else /* SW request : reset the CTBR register */
  {
    hmdma->Instance->CTBR = 0;
20013e2c:	687b      	ldr	r3, [r7, #4]
20013e2e:	681b      	ldr	r3, [r3, #0]
20013e30:	2200      	movs	r2, #0
20013e32:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Write Link Address Register */
  hmdma->Instance->CLAR =  0;
20013e34:	687b      	ldr	r3, [r7, #4]
20013e36:	681b      	ldr	r3, [r3, #0]
20013e38:	2200      	movs	r2, #0
20013e3a:	625a      	str	r2, [r3, #36]	; 0x24
}
20013e3c:	bf00      	nop
20013e3e:	3714      	adds	r7, #20
20013e40:	46bd      	mov	sp, r7
20013e42:	f85d 7b04 	ldr.w	r7, [sp], #4
20013e46:	4770      	bx	lr

20013e48 <HAL_PWR_DeInit>:
  *         The prototype is kept just to maintain compatibility with other
  *         products.
  * @retval None.
  */
void HAL_PWR_DeInit (void)
{
20013e48:	b480      	push	{r7}
20013e4a:	af00      	add	r7, sp, #0
}
20013e4c:	bf00      	nop
20013e4e:	46bd      	mov	sp, r7
20013e50:	f85d 7b04 	ldr.w	r7, [sp], #4
20013e54:	4770      	bx	lr
	...

20013e58 <HAL_PWR_EnableBkUpAccess>:
  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None.
  */
void HAL_PWR_EnableBkUpAccess (void)
{
20013e58:	b480      	push	{r7}
20013e5a:	af00      	add	r7, sp, #0
  /* Enable access to RTC and backup registers */
  SET_BIT (PWR->CR1, PWR_CR1_DBP);
20013e5c:	4b05      	ldr	r3, [pc, #20]	; (20013e74 <HAL_PWR_EnableBkUpAccess+0x1c>)
20013e5e:	681b      	ldr	r3, [r3, #0]
20013e60:	4a04      	ldr	r2, [pc, #16]	; (20013e74 <HAL_PWR_EnableBkUpAccess+0x1c>)
20013e62:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20013e66:	6013      	str	r3, [r2, #0]
}
20013e68:	bf00      	nop
20013e6a:	46bd      	mov	sp, r7
20013e6c:	f85d 7b04 	ldr.w	r7, [sp], #4
20013e70:	4770      	bx	lr
20013e72:	bf00      	nop
20013e74:	58024800 	.word	0x58024800

20013e78 <HAL_PWR_DisableBkUpAccess>:
  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None.
  */
void HAL_PWR_DisableBkUpAccess (void)
{
20013e78:	b480      	push	{r7}
20013e7a:	af00      	add	r7, sp, #0
  /* Disable access to RTC and backup registers */
  CLEAR_BIT (PWR->CR1, PWR_CR1_DBP);
20013e7c:	4b05      	ldr	r3, [pc, #20]	; (20013e94 <HAL_PWR_DisableBkUpAccess+0x1c>)
20013e7e:	681b      	ldr	r3, [r3, #0]
20013e80:	4a04      	ldr	r2, [pc, #16]	; (20013e94 <HAL_PWR_DisableBkUpAccess+0x1c>)
20013e82:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20013e86:	6013      	str	r3, [r2, #0]
}
20013e88:	bf00      	nop
20013e8a:	46bd      	mov	sp, r7
20013e8c:	f85d 7b04 	ldr.w	r7, [sp], #4
20013e90:	4770      	bx	lr
20013e92:	bf00      	nop
20013e94:	58024800 	.word	0x58024800

20013e98 <HAL_PWR_ConfigPVD>:
  *         driver. All combination are allowed: wake up only Cortex-M7, wake up
  *         only Cortex-M4 or wake up Cortex-M7 and Cortex-M4.
  * @retval None.
  */
void HAL_PWR_ConfigPVD (PWR_PVDTypeDef *sConfigPVD)
{
20013e98:	b580      	push	{r7, lr}
20013e9a:	b082      	sub	sp, #8
20013e9c:	af00      	add	r7, sp, #0
20013e9e:	6078      	str	r0, [r7, #4]
  /* Check the PVD configuration parameter */
  if (sConfigPVD == NULL)
20013ea0:	687b      	ldr	r3, [r7, #4]
20013ea2:	2b00      	cmp	r3, #0
20013ea4:	f000 80b6 	beq.w	20014014 <HAL_PWR_ConfigPVD+0x17c>
  {
    return;
  }

  /* Check the parameters */
  assert_param (IS_PWR_PVD_LEVEL (sConfigPVD->PVDLevel));
20013ea8:	687b      	ldr	r3, [r7, #4]
20013eaa:	681b      	ldr	r3, [r3, #0]
20013eac:	2b00      	cmp	r3, #0
20013eae:	d020      	beq.n	20013ef2 <HAL_PWR_ConfigPVD+0x5a>
20013eb0:	687b      	ldr	r3, [r7, #4]
20013eb2:	681b      	ldr	r3, [r3, #0]
20013eb4:	2b20      	cmp	r3, #32
20013eb6:	d01c      	beq.n	20013ef2 <HAL_PWR_ConfigPVD+0x5a>
20013eb8:	687b      	ldr	r3, [r7, #4]
20013eba:	681b      	ldr	r3, [r3, #0]
20013ebc:	2b40      	cmp	r3, #64	; 0x40
20013ebe:	d018      	beq.n	20013ef2 <HAL_PWR_ConfigPVD+0x5a>
20013ec0:	687b      	ldr	r3, [r7, #4]
20013ec2:	681b      	ldr	r3, [r3, #0]
20013ec4:	2b60      	cmp	r3, #96	; 0x60
20013ec6:	d014      	beq.n	20013ef2 <HAL_PWR_ConfigPVD+0x5a>
20013ec8:	687b      	ldr	r3, [r7, #4]
20013eca:	681b      	ldr	r3, [r3, #0]
20013ecc:	2b80      	cmp	r3, #128	; 0x80
20013ece:	d010      	beq.n	20013ef2 <HAL_PWR_ConfigPVD+0x5a>
20013ed0:	687b      	ldr	r3, [r7, #4]
20013ed2:	681b      	ldr	r3, [r3, #0]
20013ed4:	2ba0      	cmp	r3, #160	; 0xa0
20013ed6:	d00c      	beq.n	20013ef2 <HAL_PWR_ConfigPVD+0x5a>
20013ed8:	687b      	ldr	r3, [r7, #4]
20013eda:	681b      	ldr	r3, [r3, #0]
20013edc:	2bc0      	cmp	r3, #192	; 0xc0
20013ede:	d008      	beq.n	20013ef2 <HAL_PWR_ConfigPVD+0x5a>
20013ee0:	687b      	ldr	r3, [r7, #4]
20013ee2:	681b      	ldr	r3, [r3, #0]
20013ee4:	2be0      	cmp	r3, #224	; 0xe0
20013ee6:	d004      	beq.n	20013ef2 <HAL_PWR_ConfigPVD+0x5a>
20013ee8:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
20013eec:	484b      	ldr	r0, [pc, #300]	; (2001401c <HAL_PWR_ConfigPVD+0x184>)
20013eee:	f7ec fd01 	bl	200008f4 <assert_failed>
  assert_param (IS_PWR_PVD_MODE (sConfigPVD->Mode));
20013ef2:	687b      	ldr	r3, [r7, #4]
20013ef4:	685b      	ldr	r3, [r3, #4]
20013ef6:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
20013efa:	d021      	beq.n	20013f40 <HAL_PWR_ConfigPVD+0xa8>
20013efc:	687b      	ldr	r3, [r7, #4]
20013efe:	685b      	ldr	r3, [r3, #4]
20013f00:	4a47      	ldr	r2, [pc, #284]	; (20014020 <HAL_PWR_ConfigPVD+0x188>)
20013f02:	4293      	cmp	r3, r2
20013f04:	d01c      	beq.n	20013f40 <HAL_PWR_ConfigPVD+0xa8>
20013f06:	687b      	ldr	r3, [r7, #4]
20013f08:	685b      	ldr	r3, [r3, #4]
20013f0a:	4a46      	ldr	r2, [pc, #280]	; (20014024 <HAL_PWR_ConfigPVD+0x18c>)
20013f0c:	4293      	cmp	r3, r2
20013f0e:	d017      	beq.n	20013f40 <HAL_PWR_ConfigPVD+0xa8>
20013f10:	687b      	ldr	r3, [r7, #4]
20013f12:	685b      	ldr	r3, [r3, #4]
20013f14:	4a44      	ldr	r2, [pc, #272]	; (20014028 <HAL_PWR_ConfigPVD+0x190>)
20013f16:	4293      	cmp	r3, r2
20013f18:	d012      	beq.n	20013f40 <HAL_PWR_ConfigPVD+0xa8>
20013f1a:	687b      	ldr	r3, [r7, #4]
20013f1c:	685b      	ldr	r3, [r3, #4]
20013f1e:	f1b3 1f02 	cmp.w	r3, #131074	; 0x20002
20013f22:	d00d      	beq.n	20013f40 <HAL_PWR_ConfigPVD+0xa8>
20013f24:	687b      	ldr	r3, [r7, #4]
20013f26:	685b      	ldr	r3, [r3, #4]
20013f28:	4a40      	ldr	r2, [pc, #256]	; (2001402c <HAL_PWR_ConfigPVD+0x194>)
20013f2a:	4293      	cmp	r3, r2
20013f2c:	d008      	beq.n	20013f40 <HAL_PWR_ConfigPVD+0xa8>
20013f2e:	687b      	ldr	r3, [r7, #4]
20013f30:	685b      	ldr	r3, [r3, #4]
20013f32:	2b00      	cmp	r3, #0
20013f34:	d004      	beq.n	20013f40 <HAL_PWR_ConfigPVD+0xa8>
20013f36:	f240 11ab 	movw	r1, #427	; 0x1ab
20013f3a:	4838      	ldr	r0, [pc, #224]	; (2001401c <HAL_PWR_ConfigPVD+0x184>)
20013f3c:	f7ec fcda 	bl	200008f4 <assert_failed>

  /* Set PLS[7:5] bits according to PVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);
20013f40:	4b3b      	ldr	r3, [pc, #236]	; (20014030 <HAL_PWR_ConfigPVD+0x198>)
20013f42:	681b      	ldr	r3, [r3, #0]
20013f44:	f023 02e0 	bic.w	r2, r3, #224	; 0xe0
20013f48:	687b      	ldr	r3, [r7, #4]
20013f4a:	681b      	ldr	r3, [r3, #0]
20013f4c:	4938      	ldr	r1, [pc, #224]	; (20014030 <HAL_PWR_ConfigPVD+0x198>)
20013f4e:	4313      	orrs	r3, r2
20013f50:	600b      	str	r3, [r1, #0]

  /* Clear previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT ();
20013f52:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20013f56:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
20013f5a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20013f5e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20013f62:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __HAL_PWR_PVD_EXTI_DISABLE_IT ();
20013f66:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20013f6a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
20013f6e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20013f72:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20013f76:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE ();
20013f7a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20013f7e:	681b      	ldr	r3, [r3, #0]
20013f80:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20013f84:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20013f88:	6013      	str	r3, [r2, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE ();
20013f8a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20013f8e:	685b      	ldr	r3, [r3, #4]
20013f90:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20013f94:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20013f98:	6053      	str	r3, [r2, #4]

#if !defined (DUAL_CORE)
  /* Interrupt mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
20013f9a:	687b      	ldr	r3, [r7, #4]
20013f9c:	685b      	ldr	r3, [r3, #4]
20013f9e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20013fa2:	2b00      	cmp	r3, #0
20013fa4:	d009      	beq.n	20013fba <HAL_PWR_ConfigPVD+0x122>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT ();
20013fa6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20013faa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
20013fae:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20013fb2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20013fb6:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }

  /* Event mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
20013fba:	687b      	ldr	r3, [r7, #4]
20013fbc:	685b      	ldr	r3, [r3, #4]
20013fbe:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20013fc2:	2b00      	cmp	r3, #0
20013fc4:	d009      	beq.n	20013fda <HAL_PWR_ConfigPVD+0x142>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT ();
20013fc6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20013fca:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
20013fce:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20013fd2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20013fd6:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
20013fda:	687b      	ldr	r3, [r7, #4]
20013fdc:	685b      	ldr	r3, [r3, #4]
20013fde:	f003 0301 	and.w	r3, r3, #1
20013fe2:	2b00      	cmp	r3, #0
20013fe4:	d007      	beq.n	20013ff6 <HAL_PWR_ConfigPVD+0x15e>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE ();
20013fe6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20013fea:	681b      	ldr	r3, [r3, #0]
20013fec:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20013ff0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20013ff4:	6013      	str	r3, [r2, #0]
  }

  /* Falling edge configuration */
  if ((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
20013ff6:	687b      	ldr	r3, [r7, #4]
20013ff8:	685b      	ldr	r3, [r3, #4]
20013ffa:	f003 0302 	and.w	r3, r3, #2
20013ffe:	2b00      	cmp	r3, #0
20014000:	d009      	beq.n	20014016 <HAL_PWR_ConfigPVD+0x17e>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE ();
20014002:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20014006:	685b      	ldr	r3, [r3, #4]
20014008:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2001400c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20014010:	6053      	str	r3, [r2, #4]
20014012:	e000      	b.n	20014016 <HAL_PWR_ConfigPVD+0x17e>
    return;
20014014:	bf00      	nop
  }
}
20014016:	3708      	adds	r7, #8
20014018:	46bd      	mov	sp, r7
2001401a:	bd80      	pop	{r7, pc}
2001401c:	2001c230 	.word	0x2001c230
20014020:	00010002 	.word	0x00010002
20014024:	00010003 	.word	0x00010003
20014028:	00020001 	.word	0x00020001
2001402c:	00020003 	.word	0x00020003
20014030:	58024800 	.word	0x58024800

20014034 <HAL_PWR_EnablePVD>:
/**
  * @brief Enable the Programmable Voltage Detector (PVD).
  * @retval None.
  */
void HAL_PWR_EnablePVD (void)
{
20014034:	b480      	push	{r7}
20014036:	af00      	add	r7, sp, #0
  /* Enable the power voltage detector */
  SET_BIT (PWR->CR1, PWR_CR1_PVDEN);
20014038:	4b05      	ldr	r3, [pc, #20]	; (20014050 <HAL_PWR_EnablePVD+0x1c>)
2001403a:	681b      	ldr	r3, [r3, #0]
2001403c:	4a04      	ldr	r2, [pc, #16]	; (20014050 <HAL_PWR_EnablePVD+0x1c>)
2001403e:	f043 0310 	orr.w	r3, r3, #16
20014042:	6013      	str	r3, [r2, #0]
}
20014044:	bf00      	nop
20014046:	46bd      	mov	sp, r7
20014048:	f85d 7b04 	ldr.w	r7, [sp], #4
2001404c:	4770      	bx	lr
2001404e:	bf00      	nop
20014050:	58024800 	.word	0x58024800

20014054 <HAL_PWR_DisablePVD>:
/**
  * @brief Disable the Programmable Voltage Detector (PVD).
  * @retval None.
  */
void HAL_PWR_DisablePVD (void)
{
20014054:	b480      	push	{r7}
20014056:	af00      	add	r7, sp, #0
  /* Disable the power voltage detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_PVDEN);
20014058:	4b05      	ldr	r3, [pc, #20]	; (20014070 <HAL_PWR_DisablePVD+0x1c>)
2001405a:	681b      	ldr	r3, [r3, #0]
2001405c:	4a04      	ldr	r2, [pc, #16]	; (20014070 <HAL_PWR_DisablePVD+0x1c>)
2001405e:	f023 0310 	bic.w	r3, r3, #16
20014062:	6013      	str	r3, [r2, #0]
}
20014064:	bf00      	nop
20014066:	46bd      	mov	sp, r7
20014068:	f85d 7b04 	ldr.w	r7, [sp], #4
2001406c:	4770      	bx	lr
2001406e:	bf00      	nop
20014070:	58024800 	.word	0x58024800

20014074 <HAL_PWR_EnableWakeUpPin>:
  *                 PWR_WAKEUP_PIN6_HIGH, PWR_WAKEUP_PIN6_LOW.
  * @note   PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.
  * @retval None.
  */
void HAL_PWR_EnableWakeUpPin (uint32_t WakeUpPinPolarity)
{
20014074:	b580      	push	{r7, lr}
20014076:	b082      	sub	sp, #8
20014078:	af00      	add	r7, sp, #0
2001407a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPinPolarity));
2001407c:	687b      	ldr	r3, [r7, #4]
2001407e:	2b01      	cmp	r3, #1
20014080:	d043      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
20014082:	687b      	ldr	r3, [r7, #4]
20014084:	2b02      	cmp	r3, #2
20014086:	d040      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
20014088:	687b      	ldr	r3, [r7, #4]
2001408a:	2b04      	cmp	r3, #4
2001408c:	d03d      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
2001408e:	687b      	ldr	r3, [r7, #4]
20014090:	2b08      	cmp	r3, #8
20014092:	d03a      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
20014094:	687b      	ldr	r3, [r7, #4]
20014096:	2b10      	cmp	r3, #16
20014098:	d037      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
2001409a:	687b      	ldr	r3, [r7, #4]
2001409c:	2b20      	cmp	r3, #32
2001409e:	d034      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140a0:	687b      	ldr	r3, [r7, #4]
200140a2:	2b01      	cmp	r3, #1
200140a4:	d031      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140a6:	687b      	ldr	r3, [r7, #4]
200140a8:	2b02      	cmp	r3, #2
200140aa:	d02e      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140ac:	687b      	ldr	r3, [r7, #4]
200140ae:	2b04      	cmp	r3, #4
200140b0:	d02b      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140b2:	687b      	ldr	r3, [r7, #4]
200140b4:	2b08      	cmp	r3, #8
200140b6:	d028      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140b8:	687b      	ldr	r3, [r7, #4]
200140ba:	2b10      	cmp	r3, #16
200140bc:	d025      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140be:	687b      	ldr	r3, [r7, #4]
200140c0:	2b20      	cmp	r3, #32
200140c2:	d022      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140c4:	687b      	ldr	r3, [r7, #4]
200140c6:	f240 1201 	movw	r2, #257	; 0x101
200140ca:	4293      	cmp	r3, r2
200140cc:	d01d      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140ce:	687b      	ldr	r3, [r7, #4]
200140d0:	f240 2202 	movw	r2, #514	; 0x202
200140d4:	4293      	cmp	r3, r2
200140d6:	d018      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140d8:	687b      	ldr	r3, [r7, #4]
200140da:	f240 4204 	movw	r2, #1028	; 0x404
200140de:	4293      	cmp	r3, r2
200140e0:	d013      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140e2:	687b      	ldr	r3, [r7, #4]
200140e4:	f640 0208 	movw	r2, #2056	; 0x808
200140e8:	4293      	cmp	r3, r2
200140ea:	d00e      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140ec:	687b      	ldr	r3, [r7, #4]
200140ee:	f241 0210 	movw	r2, #4112	; 0x1010
200140f2:	4293      	cmp	r3, r2
200140f4:	d009      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
200140f6:	687b      	ldr	r3, [r7, #4]
200140f8:	f242 0220 	movw	r2, #8224	; 0x2020
200140fc:	4293      	cmp	r3, r2
200140fe:	d004      	beq.n	2001410a <HAL_PWR_EnableWakeUpPin+0x96>
20014100:	f240 11fd 	movw	r1, #509	; 0x1fd
20014104:	4807      	ldr	r0, [pc, #28]	; (20014124 <HAL_PWR_EnableWakeUpPin+0xb0>)
20014106:	f7ec fbf5 	bl	200008f4 <assert_failed>

  /*
     Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge).
  */
  MODIFY_REG (PWR->WKUPEPR, PWR_EWUP_MASK, WakeUpPinPolarity);
2001410a:	4b07      	ldr	r3, [pc, #28]	; (20014128 <HAL_PWR_EnableWakeUpPin+0xb4>)
2001410c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2001410e:	4b07      	ldr	r3, [pc, #28]	; (2001412c <HAL_PWR_EnableWakeUpPin+0xb8>)
20014110:	4013      	ands	r3, r2
20014112:	4905      	ldr	r1, [pc, #20]	; (20014128 <HAL_PWR_EnableWakeUpPin+0xb4>)
20014114:	687a      	ldr	r2, [r7, #4]
20014116:	4313      	orrs	r3, r2
20014118:	628b      	str	r3, [r1, #40]	; 0x28
}
2001411a:	bf00      	nop
2001411c:	3708      	adds	r7, #8
2001411e:	46bd      	mov	sp, r7
20014120:	bd80      	pop	{r7, pc}
20014122:	bf00      	nop
20014124:	2001c230 	.word	0x2001c230
20014128:	58024800 	.word	0x58024800
2001412c:	f000c0c0 	.word	0xf000c0c0

20014130 <HAL_PWR_DisableWakeUpPin>:
  *                 PWR_WAKEUP_PIN5_HIGH, PWR_WAKEUP_PIN5_LOW,
  *                 PWR_WAKEUP_PIN6_HIGH, PWR_WAKEUP_PIN6_LOW.
  * @retval None.
  */
void HAL_PWR_DisableWakeUpPin (uint32_t WakeUpPinx)
{
20014130:	b580      	push	{r7, lr}
20014132:	b082      	sub	sp, #8
20014134:	af00      	add	r7, sp, #0
20014136:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPinx));
20014138:	687b      	ldr	r3, [r7, #4]
2001413a:	2b01      	cmp	r3, #1
2001413c:	d043      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
2001413e:	687b      	ldr	r3, [r7, #4]
20014140:	2b02      	cmp	r3, #2
20014142:	d040      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
20014144:	687b      	ldr	r3, [r7, #4]
20014146:	2b04      	cmp	r3, #4
20014148:	d03d      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
2001414a:	687b      	ldr	r3, [r7, #4]
2001414c:	2b08      	cmp	r3, #8
2001414e:	d03a      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
20014150:	687b      	ldr	r3, [r7, #4]
20014152:	2b10      	cmp	r3, #16
20014154:	d037      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
20014156:	687b      	ldr	r3, [r7, #4]
20014158:	2b20      	cmp	r3, #32
2001415a:	d034      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
2001415c:	687b      	ldr	r3, [r7, #4]
2001415e:	2b01      	cmp	r3, #1
20014160:	d031      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
20014162:	687b      	ldr	r3, [r7, #4]
20014164:	2b02      	cmp	r3, #2
20014166:	d02e      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
20014168:	687b      	ldr	r3, [r7, #4]
2001416a:	2b04      	cmp	r3, #4
2001416c:	d02b      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
2001416e:	687b      	ldr	r3, [r7, #4]
20014170:	2b08      	cmp	r3, #8
20014172:	d028      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
20014174:	687b      	ldr	r3, [r7, #4]
20014176:	2b10      	cmp	r3, #16
20014178:	d025      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
2001417a:	687b      	ldr	r3, [r7, #4]
2001417c:	2b20      	cmp	r3, #32
2001417e:	d022      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
20014180:	687b      	ldr	r3, [r7, #4]
20014182:	f240 1201 	movw	r2, #257	; 0x101
20014186:	4293      	cmp	r3, r2
20014188:	d01d      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
2001418a:	687b      	ldr	r3, [r7, #4]
2001418c:	f240 2202 	movw	r2, #514	; 0x202
20014190:	4293      	cmp	r3, r2
20014192:	d018      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
20014194:	687b      	ldr	r3, [r7, #4]
20014196:	f240 4204 	movw	r2, #1028	; 0x404
2001419a:	4293      	cmp	r3, r2
2001419c:	d013      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
2001419e:	687b      	ldr	r3, [r7, #4]
200141a0:	f640 0208 	movw	r2, #2056	; 0x808
200141a4:	4293      	cmp	r3, r2
200141a6:	d00e      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
200141a8:	687b      	ldr	r3, [r7, #4]
200141aa:	f241 0210 	movw	r2, #4112	; 0x1010
200141ae:	4293      	cmp	r3, r2
200141b0:	d009      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
200141b2:	687b      	ldr	r3, [r7, #4]
200141b4:	f242 0220 	movw	r2, #8224	; 0x2020
200141b8:	4293      	cmp	r3, r2
200141ba:	d004      	beq.n	200141c6 <HAL_PWR_DisableWakeUpPin+0x96>
200141bc:	f240 2117 	movw	r1, #535	; 0x217
200141c0:	4807      	ldr	r0, [pc, #28]	; (200141e0 <HAL_PWR_DisableWakeUpPin+0xb0>)
200141c2:	f7ec fb97 	bl	200008f4 <assert_failed>

  /* Disable the wake up pin selected */
  CLEAR_BIT (PWR->WKUPEPR, (PWR_WKUPEPR_WKUPEN & WakeUpPinx));
200141c6:	4b07      	ldr	r3, [pc, #28]	; (200141e4 <HAL_PWR_DisableWakeUpPin+0xb4>)
200141c8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
200141ca:	687b      	ldr	r3, [r7, #4]
200141cc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
200141d0:	43db      	mvns	r3, r3
200141d2:	4904      	ldr	r1, [pc, #16]	; (200141e4 <HAL_PWR_DisableWakeUpPin+0xb4>)
200141d4:	4013      	ands	r3, r2
200141d6:	628b      	str	r3, [r1, #40]	; 0x28
}
200141d8:	bf00      	nop
200141da:	3708      	adds	r7, #8
200141dc:	46bd      	mov	sp, r7
200141de:	bd80      	pop	{r7, pc}
200141e0:	2001c230 	.word	0x2001c230
200141e4:	58024800 	.word	0x58024800

200141e8 <HAL_PWR_EnterSLEEPMode>:
  * @note   Ensure to clear pending events before calling this API through
  *         HAL_PWREx_ClearPendingEvent() when the SLEEP entry is WFE.
  * @retval None.
  */
void HAL_PWR_EnterSLEEPMode (uint32_t Regulator, uint8_t SLEEPEntry)
{
200141e8:	b580      	push	{r7, lr}
200141ea:	b082      	sub	sp, #8
200141ec:	af00      	add	r7, sp, #0
200141ee:	6078      	str	r0, [r7, #4]
200141f0:	460b      	mov	r3, r1
200141f2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
200141f4:	687b      	ldr	r3, [r7, #4]
200141f6:	2b00      	cmp	r3, #0
200141f8:	d007      	beq.n	2001420a <HAL_PWR_EnterSLEEPMode+0x22>
200141fa:	687b      	ldr	r3, [r7, #4]
200141fc:	2b01      	cmp	r3, #1
200141fe:	d004      	beq.n	2001420a <HAL_PWR_EnterSLEEPMode+0x22>
20014200:	f240 2133 	movw	r1, #563	; 0x233
20014204:	480e      	ldr	r0, [pc, #56]	; (20014240 <HAL_PWR_EnterSLEEPMode+0x58>)
20014206:	f7ec fb75 	bl	200008f4 <assert_failed>
  assert_param (IS_PWR_SLEEP_ENTRY (SLEEPEntry));
2001420a:	78fb      	ldrb	r3, [r7, #3]
2001420c:	2b01      	cmp	r3, #1
2001420e:	d007      	beq.n	20014220 <HAL_PWR_EnterSLEEPMode+0x38>
20014210:	78fb      	ldrb	r3, [r7, #3]
20014212:	2b02      	cmp	r3, #2
20014214:	d004      	beq.n	20014220 <HAL_PWR_EnterSLEEPMode+0x38>
20014216:	f44f 710d 	mov.w	r1, #564	; 0x234
2001421a:	4809      	ldr	r0, [pc, #36]	; (20014240 <HAL_PWR_EnterSLEEPMode+0x58>)
2001421c:	f7ec fb6a 	bl	200008f4 <assert_failed>

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
20014220:	4b08      	ldr	r3, [pc, #32]	; (20014244 <HAL_PWR_EnterSLEEPMode+0x5c>)
20014222:	691b      	ldr	r3, [r3, #16]
20014224:	4a07      	ldr	r2, [pc, #28]	; (20014244 <HAL_PWR_EnterSLEEPMode+0x5c>)
20014226:	f023 0304 	bic.w	r3, r3, #4
2001422a:	6113      	str	r3, [r2, #16]

  /* Select SLEEP mode entry */
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
2001422c:	78fb      	ldrb	r3, [r7, #3]
2001422e:	2b01      	cmp	r3, #1
20014230:	d101      	bne.n	20014236 <HAL_PWR_EnterSLEEPMode+0x4e>
  {
    /* Request Wait For Interrupt */
    __WFI ();
20014232:	bf30      	wfi
  else
  {
    /* Request Wait For Event */
    __WFE ();
  }
}
20014234:	e000      	b.n	20014238 <HAL_PWR_EnterSLEEPMode+0x50>
    __WFE ();
20014236:	bf20      	wfe
}
20014238:	bf00      	nop
2001423a:	3708      	adds	r7, #8
2001423c:	46bd      	mov	sp, r7
2001423e:	bd80      	pop	{r7, pc}
20014240:	2001c230 	.word	0x2001c230
20014244:	e000ed00 	.word	0xe000ed00

20014248 <HAL_PWR_EnterSTOPMode>:
  *         is waking up. By keeping the internal regulator ON during STOP mode,
  *         the consumption is higher although the startup time is reduced.
  * @retval None.
  */
void HAL_PWR_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry)
{
20014248:	b580      	push	{r7, lr}
2001424a:	b082      	sub	sp, #8
2001424c:	af00      	add	r7, sp, #0
2001424e:	6078      	str	r0, [r7, #4]
20014250:	460b      	mov	r3, r1
20014252:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
20014254:	687b      	ldr	r3, [r7, #4]
20014256:	2b00      	cmp	r3, #0
20014258:	d007      	beq.n	2001426a <HAL_PWR_EnterSTOPMode+0x22>
2001425a:	687b      	ldr	r3, [r7, #4]
2001425c:	2b01      	cmp	r3, #1
2001425e:	d004      	beq.n	2001426a <HAL_PWR_EnterSTOPMode+0x22>
20014260:	f240 2166 	movw	r1, #614	; 0x266
20014264:	481d      	ldr	r0, [pc, #116]	; (200142dc <HAL_PWR_EnterSTOPMode+0x94>)
20014266:	f7ec fb45 	bl	200008f4 <assert_failed>
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
2001426a:	78fb      	ldrb	r3, [r7, #3]
2001426c:	2b01      	cmp	r3, #1
2001426e:	d007      	beq.n	20014280 <HAL_PWR_EnterSTOPMode+0x38>
20014270:	78fb      	ldrb	r3, [r7, #3]
20014272:	2b02      	cmp	r3, #2
20014274:	d004      	beq.n	20014280 <HAL_PWR_EnterSTOPMode+0x38>
20014276:	f240 2167 	movw	r1, #615	; 0x267
2001427a:	4818      	ldr	r0, [pc, #96]	; (200142dc <HAL_PWR_EnterSTOPMode+0x94>)
2001427c:	f7ec fb3a 	bl	200008f4 <assert_failed>

  /* Select the regulator state in STOP mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
20014280:	4b17      	ldr	r3, [pc, #92]	; (200142e0 <HAL_PWR_EnterSTOPMode+0x98>)
20014282:	681b      	ldr	r3, [r3, #0]
20014284:	f023 0201 	bic.w	r2, r3, #1
20014288:	4915      	ldr	r1, [pc, #84]	; (200142e0 <HAL_PWR_EnterSTOPMode+0x98>)
2001428a:	687b      	ldr	r3, [r7, #4]
2001428c:	4313      	orrs	r3, r2
2001428e:	600b      	str	r3, [r1, #0]
    /* Keep DSTOP mode when Cortex-M4 enters DEEP-SLEEP */
    CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
  }
#else /* Single core devices */
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
20014290:	4b13      	ldr	r3, [pc, #76]	; (200142e0 <HAL_PWR_EnterSTOPMode+0x98>)
20014292:	691b      	ldr	r3, [r3, #16]
20014294:	4a12      	ldr	r2, [pc, #72]	; (200142e0 <HAL_PWR_EnterSTOPMode+0x98>)
20014296:	f023 0305 	bic.w	r3, r3, #5
2001429a:	6113      	str	r3, [r2, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
2001429c:	4b10      	ldr	r3, [pc, #64]	; (200142e0 <HAL_PWR_EnterSTOPMode+0x98>)
2001429e:	691b      	ldr	r3, [r3, #16]
200142a0:	4a0f      	ldr	r2, [pc, #60]	; (200142e0 <HAL_PWR_EnterSTOPMode+0x98>)
200142a2:	f023 0302 	bic.w	r3, r3, #2
200142a6:	6113      	str	r3, [r2, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
200142a8:	4b0e      	ldr	r3, [pc, #56]	; (200142e4 <HAL_PWR_EnterSTOPMode+0x9c>)
200142aa:	691b      	ldr	r3, [r3, #16]
200142ac:	4a0d      	ldr	r2, [pc, #52]	; (200142e4 <HAL_PWR_EnterSTOPMode+0x9c>)
200142ae:	f043 0304 	orr.w	r3, r3, #4
200142b2:	6113      	str	r3, [r2, #16]
200142b4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
200142b8:	f3bf 8f6f 	isb	sy
  /* Ensure that all instructions are done before entering STOP mode */
  __DSB ();
  __ISB ();

  /* Select STOP mode entry */
  if (STOPEntry == PWR_STOPENTRY_WFI)
200142bc:	78fb      	ldrb	r3, [r7, #3]
200142be:	2b01      	cmp	r3, #1
200142c0:	d101      	bne.n	200142c6 <HAL_PWR_EnterSTOPMode+0x7e>
  {
    /* Request Wait For Interrupt */
    __WFI ();
200142c2:	bf30      	wfi
200142c4:	e000      	b.n	200142c8 <HAL_PWR_EnterSTOPMode+0x80>
  }
  else
  {
    /* Request Wait For Event */
    __WFE ();
200142c6:	bf20      	wfe
  }

  /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
200142c8:	4b06      	ldr	r3, [pc, #24]	; (200142e4 <HAL_PWR_EnterSTOPMode+0x9c>)
200142ca:	691b      	ldr	r3, [r3, #16]
200142cc:	4a05      	ldr	r2, [pc, #20]	; (200142e4 <HAL_PWR_EnterSTOPMode+0x9c>)
200142ce:	f023 0304 	bic.w	r3, r3, #4
200142d2:	6113      	str	r3, [r2, #16]
}
200142d4:	bf00      	nop
200142d6:	3708      	adds	r7, #8
200142d8:	46bd      	mov	sp, r7
200142da:	bd80      	pop	{r7, pc}
200142dc:	2001c230 	.word	0x2001c230
200142e0:	58024800 	.word	0x58024800
200142e4:	e000ed00 	.word	0xe000ed00

200142e8 <HAL_PWR_EnterSTANDBYMode>:
  * @note   When the System exit STANDBY mode by issuing an interrupt or a
  *         wakeup event, the HSI RC oscillator is selected as system clock.
  * @retval None.
  */
void HAL_PWR_EnterSTANDBYMode (void)
{
200142e8:	b480      	push	{r7}
200142ea:	af00      	add	r7, sp, #0
    SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
    SET_BIT (PWR->CPU2CR, (PWR_CPU2CR_PDDS_D2 | PWR_CPU2CR_PDDS_D3));
  }
#else /* Single core devices */
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
200142ec:	4b0d      	ldr	r3, [pc, #52]	; (20014324 <HAL_PWR_EnterSTANDBYMode+0x3c>)
200142ee:	691b      	ldr	r3, [r3, #16]
200142f0:	4a0c      	ldr	r2, [pc, #48]	; (20014324 <HAL_PWR_EnterSTANDBYMode+0x3c>)
200142f2:	f043 0305 	orr.w	r3, r3, #5
200142f6:	6113      	str	r3, [r2, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
200142f8:	4b0a      	ldr	r3, [pc, #40]	; (20014324 <HAL_PWR_EnterSTANDBYMode+0x3c>)
200142fa:	691b      	ldr	r3, [r3, #16]
200142fc:	4a09      	ldr	r2, [pc, #36]	; (20014324 <HAL_PWR_EnterSTANDBYMode+0x3c>)
200142fe:	f043 0302 	orr.w	r3, r3, #2
20014302:	6113      	str	r3, [r2, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
20014304:	4b08      	ldr	r3, [pc, #32]	; (20014328 <HAL_PWR_EnterSTANDBYMode+0x40>)
20014306:	691b      	ldr	r3, [r3, #16]
20014308:	4a07      	ldr	r2, [pc, #28]	; (20014328 <HAL_PWR_EnterSTANDBYMode+0x40>)
2001430a:	f043 0304 	orr.w	r3, r3, #4
2001430e:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
20014310:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
20014314:	f3bf 8f6f 	isb	sy
#if defined (__CC_ARM)
  __force_stores();
#endif /* defined (__CC_ARM) */

  /* Request Wait For Interrupt */
  __WFI ();
20014318:	bf30      	wfi
}
2001431a:	bf00      	nop
2001431c:	46bd      	mov	sp, r7
2001431e:	f85d 7b04 	ldr.w	r7, [sp], #4
20014322:	4770      	bx	lr
20014324:	58024800 	.word	0x58024800
20014328:	e000ed00 	.word	0xe000ed00

2001432c <HAL_PWR_EnableSleepOnExit>:
  *         Setting this bit is useful when the processor is expected to run
  *         only on interruptions handling.
  * @retval None.
  */
void HAL_PWR_EnableSleepOnExit (void)
{
2001432c:	b480      	push	{r7}
2001432e:	af00      	add	r7, sp, #0
  /* Set SLEEPONEXIT bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
20014330:	4b05      	ldr	r3, [pc, #20]	; (20014348 <HAL_PWR_EnableSleepOnExit+0x1c>)
20014332:	691b      	ldr	r3, [r3, #16]
20014334:	4a04      	ldr	r2, [pc, #16]	; (20014348 <HAL_PWR_EnableSleepOnExit+0x1c>)
20014336:	f043 0302 	orr.w	r3, r3, #2
2001433a:	6113      	str	r3, [r2, #16]
}
2001433c:	bf00      	nop
2001433e:	46bd      	mov	sp, r7
20014340:	f85d 7b04 	ldr.w	r7, [sp], #4
20014344:	4770      	bx	lr
20014346:	bf00      	nop
20014348:	e000ed00 	.word	0xe000ed00

2001434c <HAL_PWR_DisableSleepOnExit>:
  * @note   Clears SLEEPONEXIT bit of SCR register. When this bit is set, the
  *         processor re-enters SLEEP mode when an interruption handling is over.
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit (void)
{
2001434c:	b480      	push	{r7}
2001434e:	af00      	add	r7, sp, #0
  /* Clear SLEEPONEXIT bit of Cortex-Mx System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
20014350:	4b05      	ldr	r3, [pc, #20]	; (20014368 <HAL_PWR_DisableSleepOnExit+0x1c>)
20014352:	691b      	ldr	r3, [r3, #16]
20014354:	4a04      	ldr	r2, [pc, #16]	; (20014368 <HAL_PWR_DisableSleepOnExit+0x1c>)
20014356:	f023 0302 	bic.w	r3, r3, #2
2001435a:	6113      	str	r3, [r2, #16]
}
2001435c:	bf00      	nop
2001435e:	46bd      	mov	sp, r7
20014360:	f85d 7b04 	ldr.w	r7, [sp], #4
20014364:	4770      	bx	lr
20014366:	bf00      	nop
20014368:	e000ed00 	.word	0xe000ed00

2001436c <HAL_PWR_EnableSEVOnPend>:
  *         pending event / interrupt even if it's disabled or has insufficient
  *         priority to cause exception entry wakes up the Cortex-Mx.
  * @retval None.
  */
void HAL_PWR_EnableSEVOnPend (void)
{
2001436c:	b480      	push	{r7}
2001436e:	af00      	add	r7, sp, #0
  /* Set SEVONPEND bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
20014370:	4b05      	ldr	r3, [pc, #20]	; (20014388 <HAL_PWR_EnableSEVOnPend+0x1c>)
20014372:	691b      	ldr	r3, [r3, #16]
20014374:	4a04      	ldr	r2, [pc, #16]	; (20014388 <HAL_PWR_EnableSEVOnPend+0x1c>)
20014376:	f043 0310 	orr.w	r3, r3, #16
2001437a:	6113      	str	r3, [r2, #16]
}
2001437c:	bf00      	nop
2001437e:	46bd      	mov	sp, r7
20014380:	f85d 7b04 	ldr.w	r7, [sp], #4
20014384:	4770      	bx	lr
20014386:	bf00      	nop
20014388:	e000ed00 	.word	0xe000ed00

2001438c <HAL_PWR_DisableSEVOnPend>:
  * @note   Resets SEVONPEND bit of SCR register. When this bit is reset, only
  *         enabled pending causes exception entry wakes up the Cortex-Mx.
  * @retval None.
  */
void HAL_PWR_DisableSEVOnPend (void)
{
2001438c:	b480      	push	{r7}
2001438e:	af00      	add	r7, sp, #0
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
20014390:	4b05      	ldr	r3, [pc, #20]	; (200143a8 <HAL_PWR_DisableSEVOnPend+0x1c>)
20014392:	691b      	ldr	r3, [r3, #16]
20014394:	4a04      	ldr	r2, [pc, #16]	; (200143a8 <HAL_PWR_DisableSEVOnPend+0x1c>)
20014396:	f023 0310 	bic.w	r3, r3, #16
2001439a:	6113      	str	r3, [r2, #16]
}
2001439c:	bf00      	nop
2001439e:	46bd      	mov	sp, r7
200143a0:	f85d 7b04 	ldr.w	r7, [sp], #4
200143a4:	4770      	bx	lr
200143a6:	bf00      	nop
200143a8:	e000ed00 	.word	0xe000ed00

200143ac <HAL_PWR_PVD_IRQHandler>:
  * @brief  This function handles the PWR PVD interrupt request.
  * @note   This API should be called under the PVD_AVD_IRQHandler().
  * @retval None.
  */
void HAL_PWR_PVD_IRQHandler (void)
{
200143ac:	b580      	push	{r7, lr}
200143ae:	af00      	add	r7, sp, #0
      HAL_PWR_PVDCallback ();
    }
  }
#else /* Single core devices */
  /* PVD EXTI line interrupt detected */
  if (__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
200143b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
200143b4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200143b8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
200143bc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
200143c0:	d10b      	bne.n	200143da <HAL_PWR_PVD_IRQHandler+0x2e>
  {
    /* Clear PWR EXTI pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
200143c2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
200143c6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200143ca:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
200143ce:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200143d2:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback ();
200143d6:	f000 f802 	bl	200143de <HAL_PWR_PVDCallback>
  }
#endif /* defined (DUAL_CORE) */
}
200143da:	bf00      	nop
200143dc:	bd80      	pop	{r7, pc}

200143de <HAL_PWR_PVDCallback>:
/**
  * @brief  PWR PVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWR_PVDCallback (void)
{
200143de:	b480      	push	{r7}
200143e0:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_PVDCallback can be implemented in the user file
  */
}
200143e2:	bf00      	nop
200143e4:	46bd      	mov	sp, r7
200143e6:	f85d 7b04 	ldr.w	r7, [sp], #4
200143ea:	4770      	bx	lr

200143ec <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
200143ec:	b580      	push	{r7, lr}
200143ee:	b084      	sub	sp, #16
200143f0:	af00      	add	r7, sp, #0
200143f2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));
200143f4:	687b      	ldr	r3, [r7, #4]
200143f6:	2b02      	cmp	r3, #2
200143f8:	d007      	beq.n	2001440a <HAL_PWREx_ConfigSupply+0x1e>
200143fa:	687b      	ldr	r3, [r7, #4]
200143fc:	2b01      	cmp	r3, #1
200143fe:	d004      	beq.n	2001440a <HAL_PWREx_ConfigSupply+0x1e>
20014400:	f44f 719d 	mov.w	r1, #314	; 0x13a
20014404:	481a      	ldr	r0, [pc, #104]	; (20014470 <HAL_PWREx_ConfigSupply+0x84>)
20014406:	f7ec fa75 	bl	200008f4 <assert_failed>

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
2001440a:	4b1a      	ldr	r3, [pc, #104]	; (20014474 <HAL_PWREx_ConfigSupply+0x88>)
2001440c:	68db      	ldr	r3, [r3, #12]
2001440e:	f003 0304 	and.w	r3, r3, #4
20014412:	2b04      	cmp	r3, #4
20014414:	d00a      	beq.n	2001442c <HAL_PWREx_ConfigSupply+0x40>
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
20014416:	4b17      	ldr	r3, [pc, #92]	; (20014474 <HAL_PWREx_ConfigSupply+0x88>)
20014418:	68db      	ldr	r3, [r3, #12]
2001441a:	f003 0307 	and.w	r3, r3, #7
2001441e:	687a      	ldr	r2, [r7, #4]
20014420:	429a      	cmp	r2, r3
20014422:	d001      	beq.n	20014428 <HAL_PWREx_ConfigSupply+0x3c>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
20014424:	2301      	movs	r3, #1
20014426:	e01f      	b.n	20014468 <HAL_PWREx_ConfigSupply+0x7c>
    else
    {
      /* Supply configuration update locked, but new supply configuration
         matches with old supply configuration : nothing to do
      */
      return HAL_OK;
20014428:	2300      	movs	r3, #0
2001442a:	e01d      	b.n	20014468 <HAL_PWREx_ConfigSupply+0x7c>
    }
  }

  /* Set the power supply configuration */
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
2001442c:	4b11      	ldr	r3, [pc, #68]	; (20014474 <HAL_PWREx_ConfigSupply+0x88>)
2001442e:	68db      	ldr	r3, [r3, #12]
20014430:	f023 0207 	bic.w	r2, r3, #7
20014434:	490f      	ldr	r1, [pc, #60]	; (20014474 <HAL_PWREx_ConfigSupply+0x88>)
20014436:	687b      	ldr	r3, [r7, #4]
20014438:	4313      	orrs	r3, r2
2001443a:	60cb      	str	r3, [r1, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
2001443c:	f7ed fc56 	bl	20001cec <HAL_GetTick>
20014440:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
20014442:	e009      	b.n	20014458 <HAL_PWREx_ConfigSupply+0x6c>
  {
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
20014444:	f7ed fc52 	bl	20001cec <HAL_GetTick>
20014448:	4602      	mov	r2, r0
2001444a:	68fb      	ldr	r3, [r7, #12]
2001444c:	1ad3      	subs	r3, r2, r3
2001444e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
20014452:	d901      	bls.n	20014458 <HAL_PWREx_ConfigSupply+0x6c>
    {
      return HAL_ERROR;
20014454:	2301      	movs	r3, #1
20014456:	e007      	b.n	20014468 <HAL_PWREx_ConfigSupply+0x7c>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
20014458:	4b06      	ldr	r3, [pc, #24]	; (20014474 <HAL_PWREx_ConfigSupply+0x88>)
2001445a:	685b      	ldr	r3, [r3, #4]
2001445c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
20014460:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20014464:	d1ee      	bne.n	20014444 <HAL_PWREx_ConfigSupply+0x58>
      }
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
20014466:	2300      	movs	r3, #0
}
20014468:	4618      	mov	r0, r3
2001446a:	3710      	adds	r7, #16
2001446c:	46bd      	mov	sp, r7
2001446e:	bd80      	pop	{r7, pc}
20014470:	2001c268 	.word	0x2001c268
20014474:	58024800 	.word	0x58024800

20014478 <HAL_PWREx_GetSupplyConfig>:
/**
  * @brief Get the power supply configuration.
  * @retval The supply configuration.
  */
uint32_t HAL_PWREx_GetSupplyConfig (void)
{
20014478:	b480      	push	{r7}
2001447a:	af00      	add	r7, sp, #0
  return (PWR->CR3 & PWR_SUPPLY_CONFIG_MASK);
2001447c:	4b04      	ldr	r3, [pc, #16]	; (20014490 <HAL_PWREx_GetSupplyConfig+0x18>)
2001447e:	68db      	ldr	r3, [r3, #12]
20014480:	f003 0307 	and.w	r3, r3, #7
}
20014484:	4618      	mov	r0, r3
20014486:	46bd      	mov	sp, r7
20014488:	f85d 7b04 	ldr.w	r7, [sp], #4
2001448c:	4770      	bx	lr
2001448e:	bf00      	nop
20014490:	58024800 	.word	0x58024800

20014494 <HAL_PWREx_ControlVoltageScaling>:
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3 : Regulator voltage output
  *                                                range 3 mode.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling (uint32_t VoltageScaling)
{
20014494:	b580      	push	{r7, lr}
20014496:	b084      	sub	sp, #16
20014498:	af00      	add	r7, sp, #0
2001449a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR_VOLTAGE (VoltageScaling));
2001449c:	687b      	ldr	r3, [r7, #4]
2001449e:	2b00      	cmp	r3, #0
200144a0:	d010      	beq.n	200144c4 <HAL_PWREx_ControlVoltageScaling+0x30>
200144a2:	687b      	ldr	r3, [r7, #4]
200144a4:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
200144a8:	d00c      	beq.n	200144c4 <HAL_PWREx_ControlVoltageScaling+0x30>
200144aa:	687b      	ldr	r3, [r7, #4]
200144ac:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
200144b0:	d008      	beq.n	200144c4 <HAL_PWREx_ControlVoltageScaling+0x30>
200144b2:	687b      	ldr	r3, [r7, #4]
200144b4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
200144b8:	d004      	beq.n	200144c4 <HAL_PWREx_ControlVoltageScaling+0x30>
200144ba:	f44f 71ce 	mov.w	r1, #412	; 0x19c
200144be:	4841      	ldr	r0, [pc, #260]	; (200145c4 <HAL_PWREx_ControlVoltageScaling+0x130>)
200144c0:	f7ec fa18 	bl	200008f4 <assert_failed>

  /* Get the voltage scaling  */
  if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == VoltageScaling)
200144c4:	4b40      	ldr	r3, [pc, #256]	; (200145c8 <HAL_PWREx_ControlVoltageScaling+0x134>)
200144c6:	685b      	ldr	r3, [r3, #4]
200144c8:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
200144cc:	687a      	ldr	r2, [r7, #4]
200144ce:	429a      	cmp	r2, r3
200144d0:	d101      	bne.n	200144d6 <HAL_PWREx_ControlVoltageScaling+0x42>
  {
    /* Old and new voltage scaling configuration match : nothing to do */
    return HAL_OK;
200144d2:	2300      	movs	r3, #0
200144d4:	e072      	b.n	200145bc <HAL_PWREx_ControlVoltageScaling+0x128>

#if defined (PWR_SRDCR_VOS)
  /* Set the voltage range */
  MODIFY_REG (PWR->SRDCR, PWR_SRDCR_VOS, VoltageScaling);
#else
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE0)
200144d6:	687b      	ldr	r3, [r7, #4]
200144d8:	2b00      	cmp	r3, #0
200144da:	d129      	bne.n	20014530 <HAL_PWREx_ControlVoltageScaling+0x9c>
  {
    if ((PWR->CR3 & PWR_CR3_LDOEN) == PWR_CR3_LDOEN)
200144dc:	4b3a      	ldr	r3, [pc, #232]	; (200145c8 <HAL_PWREx_ControlVoltageScaling+0x134>)
200144de:	68db      	ldr	r3, [r3, #12]
200144e0:	f003 0302 	and.w	r3, r3, #2
200144e4:	2b02      	cmp	r3, #2
200144e6:	d121      	bne.n	2001452c <HAL_PWREx_ControlVoltageScaling+0x98>
    {
      /* Set the voltage range */
      MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
200144e8:	4b37      	ldr	r3, [pc, #220]	; (200145c8 <HAL_PWREx_ControlVoltageScaling+0x134>)
200144ea:	699b      	ldr	r3, [r3, #24]
200144ec:	4a36      	ldr	r2, [pc, #216]	; (200145c8 <HAL_PWREx_ControlVoltageScaling+0x134>)
200144ee:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
200144f2:	6193      	str	r3, [r2, #24]

      /* Get tick */
      tickstart = HAL_GetTick ();
200144f4:	f7ed fbfa 	bl	20001cec <HAL_GetTick>
200144f8:	60f8      	str	r0, [r7, #12]

      /* Wait till voltage level flag is set */
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
200144fa:	e009      	b.n	20014510 <HAL_PWREx_ControlVoltageScaling+0x7c>
      {
        if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
200144fc:	f7ed fbf6 	bl	20001cec <HAL_GetTick>
20014500:	4602      	mov	r2, r0
20014502:	68fb      	ldr	r3, [r7, #12]
20014504:	1ad3      	subs	r3, r2, r3
20014506:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2001450a:	d901      	bls.n	20014510 <HAL_PWREx_ControlVoltageScaling+0x7c>
        {
          return HAL_ERROR;
2001450c:	2301      	movs	r3, #1
2001450e:	e055      	b.n	200145bc <HAL_PWREx_ControlVoltageScaling+0x128>
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
20014510:	4b2d      	ldr	r3, [pc, #180]	; (200145c8 <HAL_PWREx_ControlVoltageScaling+0x134>)
20014512:	685b      	ldr	r3, [r3, #4]
20014514:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
20014518:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2001451c:	d1ee      	bne.n	200144fc <HAL_PWREx_ControlVoltageScaling+0x68>
        }
      }

      /* Enable the PWR overdrive */
      SET_BIT (SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
2001451e:	4b2b      	ldr	r3, [pc, #172]	; (200145cc <HAL_PWREx_ControlVoltageScaling+0x138>)
20014520:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20014522:	4a2a      	ldr	r2, [pc, #168]	; (200145cc <HAL_PWREx_ControlVoltageScaling+0x138>)
20014524:	f043 0301 	orr.w	r3, r3, #1
20014528:	62d3      	str	r3, [r2, #44]	; 0x2c
2001452a:	e031      	b.n	20014590 <HAL_PWREx_ControlVoltageScaling+0xfc>
    }
    else
    {
      /* The voltage scale 0 is only possible when LDO regulator is enabled */
      return HAL_ERROR;
2001452c:	2301      	movs	r3, #1
2001452e:	e045      	b.n	200145bc <HAL_PWREx_ControlVoltageScaling+0x128>
    }
  }
  else
  {
    if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == PWR_REGULATOR_VOLTAGE_SCALE1)
20014530:	4b25      	ldr	r3, [pc, #148]	; (200145c8 <HAL_PWREx_ControlVoltageScaling+0x134>)
20014532:	685b      	ldr	r3, [r3, #4]
20014534:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
20014538:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
2001453c:	d120      	bne.n	20014580 <HAL_PWREx_ControlVoltageScaling+0xec>
    {
      if ((SYSCFG->PWRCR & SYSCFG_PWRCR_ODEN) != 0U)
2001453e:	4b23      	ldr	r3, [pc, #140]	; (200145cc <HAL_PWREx_ControlVoltageScaling+0x138>)
20014540:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20014542:	f003 0301 	and.w	r3, r3, #1
20014546:	2b00      	cmp	r3, #0
20014548:	d01a      	beq.n	20014580 <HAL_PWREx_ControlVoltageScaling+0xec>
      {
        /* Disable the PWR overdrive */
        CLEAR_BIT(SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
2001454a:	4b20      	ldr	r3, [pc, #128]	; (200145cc <HAL_PWREx_ControlVoltageScaling+0x138>)
2001454c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001454e:	4a1f      	ldr	r2, [pc, #124]	; (200145cc <HAL_PWREx_ControlVoltageScaling+0x138>)
20014550:	f023 0301 	bic.w	r3, r3, #1
20014554:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Get tick */
        tickstart = HAL_GetTick ();
20014556:	f7ed fbc9 	bl	20001cec <HAL_GetTick>
2001455a:	60f8      	str	r0, [r7, #12]

        /* Wait till voltage level flag is set */
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2001455c:	e009      	b.n	20014572 <HAL_PWREx_ControlVoltageScaling+0xde>
        {
          if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
2001455e:	f7ed fbc5 	bl	20001cec <HAL_GetTick>
20014562:	4602      	mov	r2, r0
20014564:	68fb      	ldr	r3, [r7, #12]
20014566:	1ad3      	subs	r3, r2, r3
20014568:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2001456c:	d901      	bls.n	20014572 <HAL_PWREx_ControlVoltageScaling+0xde>
          {
            return HAL_ERROR;
2001456e:	2301      	movs	r3, #1
20014570:	e024      	b.n	200145bc <HAL_PWREx_ControlVoltageScaling+0x128>
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
20014572:	4b15      	ldr	r3, [pc, #84]	; (200145c8 <HAL_PWREx_ControlVoltageScaling+0x134>)
20014574:	685b      	ldr	r3, [r3, #4]
20014576:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2001457a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2001457e:	d1ee      	bne.n	2001455e <HAL_PWREx_ControlVoltageScaling+0xca>
        }
      }
    }

    /* Set the voltage range */
    MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
20014580:	4b11      	ldr	r3, [pc, #68]	; (200145c8 <HAL_PWREx_ControlVoltageScaling+0x134>)
20014582:	699b      	ldr	r3, [r3, #24]
20014584:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
20014588:	490f      	ldr	r1, [pc, #60]	; (200145c8 <HAL_PWREx_ControlVoltageScaling+0x134>)
2001458a:	687b      	ldr	r3, [r7, #4]
2001458c:	4313      	orrs	r3, r2
2001458e:	618b      	str	r3, [r1, #24]
  }
#endif /* defined (PWR_SRDCR_VOS) */

  /* Get tick */
  tickstart = HAL_GetTick ();
20014590:	f7ed fbac 	bl	20001cec <HAL_GetTick>
20014594:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
20014596:	e009      	b.n	200145ac <HAL_PWREx_ControlVoltageScaling+0x118>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
20014598:	f7ed fba8 	bl	20001cec <HAL_GetTick>
2001459c:	4602      	mov	r2, r0
2001459e:	68fb      	ldr	r3, [r7, #12]
200145a0:	1ad3      	subs	r3, r2, r3
200145a2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
200145a6:	d901      	bls.n	200145ac <HAL_PWREx_ControlVoltageScaling+0x118>
    {
      return HAL_ERROR;
200145a8:	2301      	movs	r3, #1
200145aa:	e007      	b.n	200145bc <HAL_PWREx_ControlVoltageScaling+0x128>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
200145ac:	4b06      	ldr	r3, [pc, #24]	; (200145c8 <HAL_PWREx_ControlVoltageScaling+0x134>)
200145ae:	685b      	ldr	r3, [r3, #4]
200145b0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
200145b4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
200145b8:	d1ee      	bne.n	20014598 <HAL_PWREx_ControlVoltageScaling+0x104>
    }
  }

  return HAL_OK;
200145ba:	2300      	movs	r3, #0
}
200145bc:	4618      	mov	r0, r3
200145be:	3710      	adds	r7, #16
200145c0:	46bd      	mov	sp, r7
200145c2:	bd80      	pop	{r7, pc}
200145c4:	2001c268 	.word	0x2001c268
200145c8:	58024800 	.word	0x58024800
200145cc:	58000400 	.word	0x58000400

200145d0 <HAL_PWREx_GetVoltageRange>:
  * @brief Get the main internal regulator output voltage. Reflecting the last
  *        VOS value applied to the PMU.
  * @retval The current applied VOS selection.
  */
uint32_t HAL_PWREx_GetVoltageRange (void)
{
200145d0:	b480      	push	{r7}
200145d2:	af00      	add	r7, sp, #0
  /* Get the active voltage scaling */
  return (PWR->CSR1 & PWR_CSR1_ACTVOS);
200145d4:	4b04      	ldr	r3, [pc, #16]	; (200145e8 <HAL_PWREx_GetVoltageRange+0x18>)
200145d6:	685b      	ldr	r3, [r3, #4]
200145d8:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
200145dc:	4618      	mov	r0, r3
200145de:	46bd      	mov	sp, r7
200145e0:	f85d 7b04 	ldr.w	r7, [sp], #4
200145e4:	4770      	bx	lr
200145e6:	bf00      	nop
200145e8:	58024800 	.word	0x58024800

200145ec <HAL_PWREx_ControlStopModeVoltageScaling>:
  * @note   The selected SVOS4 and SVOS5 levels add an additional startup delay
  *         when exiting from system Stop mode.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ControlStopModeVoltageScaling (uint32_t VoltageScaling)
{
200145ec:	b580      	push	{r7, lr}
200145ee:	b082      	sub	sp, #8
200145f0:	af00      	add	r7, sp, #0
200145f2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_STOP_MODE_REGULATOR_VOLTAGE (VoltageScaling));
200145f4:	687b      	ldr	r3, [r7, #4]
200145f6:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
200145fa:	d00c      	beq.n	20014616 <HAL_PWREx_ControlStopModeVoltageScaling+0x2a>
200145fc:	687b      	ldr	r3, [r7, #4]
200145fe:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20014602:	d008      	beq.n	20014616 <HAL_PWREx_ControlStopModeVoltageScaling+0x2a>
20014604:	687b      	ldr	r3, [r7, #4]
20014606:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2001460a:	d004      	beq.n	20014616 <HAL_PWREx_ControlStopModeVoltageScaling+0x2a>
2001460c:	f240 2112 	movw	r1, #530	; 0x212
20014610:	4807      	ldr	r0, [pc, #28]	; (20014630 <HAL_PWREx_ControlStopModeVoltageScaling+0x44>)
20014612:	f7ec f96f 	bl	200008f4 <assert_failed>

  /* Return the stop mode voltage range */
  MODIFY_REG (PWR->CR1, PWR_CR1_SVOS, VoltageScaling);
20014616:	4b07      	ldr	r3, [pc, #28]	; (20014634 <HAL_PWREx_ControlStopModeVoltageScaling+0x48>)
20014618:	681b      	ldr	r3, [r3, #0]
2001461a:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
2001461e:	4905      	ldr	r1, [pc, #20]	; (20014634 <HAL_PWREx_ControlStopModeVoltageScaling+0x48>)
20014620:	687b      	ldr	r3, [r7, #4]
20014622:	4313      	orrs	r3, r2
20014624:	600b      	str	r3, [r1, #0]

  return HAL_OK;
20014626:	2300      	movs	r3, #0
}
20014628:	4618      	mov	r0, r3
2001462a:	3708      	adds	r7, #8
2001462c:	46bd      	mov	sp, r7
2001462e:	bd80      	pop	{r7, pc}
20014630:	2001c268 	.word	0x2001c268
20014634:	58024800 	.word	0x58024800

20014638 <HAL_PWREx_GetStopModeVoltageRange>:
/**
  * @brief Get the main internal regulator output voltage in STOP mode.
  * @retval The actual applied VOS selection.
  */
uint32_t HAL_PWREx_GetStopModeVoltageRange (void)
{
20014638:	b480      	push	{r7}
2001463a:	af00      	add	r7, sp, #0
  /* Return the stop voltage scaling */
  return (PWR->CR1 & PWR_CR1_SVOS);
2001463c:	4b04      	ldr	r3, [pc, #16]	; (20014650 <HAL_PWREx_GetStopModeVoltageRange+0x18>)
2001463e:	681b      	ldr	r3, [r3, #0]
20014640:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
20014644:	4618      	mov	r0, r3
20014646:	46bd      	mov	sp, r7
20014648:	f85d 7b04 	ldr.w	r7, [sp], #4
2001464c:	4770      	bx	lr
2001464e:	bf00      	nop
20014650:	58024800 	.word	0x58024800

20014654 <HAL_PWREx_EnterSTOPMode>:
  *            @arg PWR_D2_DOMAIN : Enter D2 Domain to DSTOP mode.
  *            @arg PWR_D3_DOMAIN : Enter D3/SRD Domain to DSTOP mode.
  * @retval None.
  */
void HAL_PWREx_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain)
{
20014654:	b580      	push	{r7, lr}
20014656:	b084      	sub	sp, #16
20014658:	af00      	add	r7, sp, #0
2001465a:	60f8      	str	r0, [r7, #12]
2001465c:	460b      	mov	r3, r1
2001465e:	607a      	str	r2, [r7, #4]
20014660:	72fb      	strb	r3, [r7, #11]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
20014662:	68fb      	ldr	r3, [r7, #12]
20014664:	2b00      	cmp	r3, #0
20014666:	d007      	beq.n	20014678 <HAL_PWREx_EnterSTOPMode+0x24>
20014668:	68fb      	ldr	r3, [r7, #12]
2001466a:	2b01      	cmp	r3, #1
2001466c:	d004      	beq.n	20014678 <HAL_PWREx_EnterSTOPMode+0x24>
2001466e:	f44f 714a 	mov.w	r1, #808	; 0x328
20014672:	482c      	ldr	r0, [pc, #176]	; (20014724 <HAL_PWREx_EnterSTOPMode+0xd0>)
20014674:	f7ec f93e 	bl	200008f4 <assert_failed>
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
20014678:	7afb      	ldrb	r3, [r7, #11]
2001467a:	2b01      	cmp	r3, #1
2001467c:	d007      	beq.n	2001468e <HAL_PWREx_EnterSTOPMode+0x3a>
2001467e:	7afb      	ldrb	r3, [r7, #11]
20014680:	2b02      	cmp	r3, #2
20014682:	d004      	beq.n	2001468e <HAL_PWREx_EnterSTOPMode+0x3a>
20014684:	f240 3129 	movw	r1, #809	; 0x329
20014688:	4826      	ldr	r0, [pc, #152]	; (20014724 <HAL_PWREx_EnterSTOPMode+0xd0>)
2001468a:	f7ec f933 	bl	200008f4 <assert_failed>
  assert_param (IS_PWR_DOMAIN (Domain));
2001468e:	687b      	ldr	r3, [r7, #4]
20014690:	2b00      	cmp	r3, #0
20014692:	d00a      	beq.n	200146aa <HAL_PWREx_EnterSTOPMode+0x56>
20014694:	687b      	ldr	r3, [r7, #4]
20014696:	2b01      	cmp	r3, #1
20014698:	d007      	beq.n	200146aa <HAL_PWREx_EnterSTOPMode+0x56>
2001469a:	687b      	ldr	r3, [r7, #4]
2001469c:	2b02      	cmp	r3, #2
2001469e:	d004      	beq.n	200146aa <HAL_PWREx_EnterSTOPMode+0x56>
200146a0:	f240 312a 	movw	r1, #810	; 0x32a
200146a4:	481f      	ldr	r0, [pc, #124]	; (20014724 <HAL_PWREx_EnterSTOPMode+0xd0>)
200146a6:	f7ec f925 	bl	200008f4 <assert_failed>

  /* Select the regulator state in Stop mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
200146aa:	4b1f      	ldr	r3, [pc, #124]	; (20014728 <HAL_PWREx_EnterSTOPMode+0xd4>)
200146ac:	681b      	ldr	r3, [r3, #0]
200146ae:	f023 0201 	bic.w	r2, r3, #1
200146b2:	491d      	ldr	r1, [pc, #116]	; (20014728 <HAL_PWREx_EnterSTOPMode+0xd4>)
200146b4:	68fb      	ldr	r3, [r7, #12]
200146b6:	4313      	orrs	r3, r2
200146b8:	600b      	str	r3, [r1, #0]

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
200146ba:	687b      	ldr	r3, [r7, #4]
200146bc:	2b00      	cmp	r3, #0
200146be:	d11c      	bne.n	200146fa <HAL_PWREx_EnterSTOPMode+0xa6>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);
200146c0:	4b19      	ldr	r3, [pc, #100]	; (20014728 <HAL_PWREx_EnterSTOPMode+0xd4>)
200146c2:	691b      	ldr	r3, [r3, #16]
200146c4:	4a18      	ldr	r2, [pc, #96]	; (20014728 <HAL_PWREx_EnterSTOPMode+0xd4>)
200146c6:	f023 0301 	bic.w	r3, r3, #1
200146ca:	6113      	str	r3, [r2, #16]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
200146cc:	4b17      	ldr	r3, [pc, #92]	; (2001472c <HAL_PWREx_EnterSTOPMode+0xd8>)
200146ce:	691b      	ldr	r3, [r3, #16]
200146d0:	4a16      	ldr	r2, [pc, #88]	; (2001472c <HAL_PWREx_EnterSTOPMode+0xd8>)
200146d2:	f043 0304 	orr.w	r3, r3, #4
200146d6:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
200146d8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
200146dc:	f3bf 8f6f 	isb	sy
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
200146e0:	7afb      	ldrb	r3, [r7, #11]
200146e2:	2b01      	cmp	r3, #1
200146e4:	d101      	bne.n	200146ea <HAL_PWREx_EnterSTOPMode+0x96>
    {
      /* Request Wait For Interrupt */
      __WFI ();
200146e6:	bf30      	wfi
200146e8:	e000      	b.n	200146ec <HAL_PWREx_EnterSTOPMode+0x98>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
200146ea:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
200146ec:	4b0f      	ldr	r3, [pc, #60]	; (2001472c <HAL_PWREx_EnterSTOPMode+0xd8>)
200146ee:	691b      	ldr	r3, [r3, #16]
200146f0:	4a0e      	ldr	r2, [pc, #56]	; (2001472c <HAL_PWREx_EnterSTOPMode+0xd8>)
200146f2:	f023 0304 	bic.w	r3, r3, #4
200146f6:	6113      	str	r3, [r2, #16]
  else
  {
    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
  }
}
200146f8:	e00f      	b.n	2001471a <HAL_PWREx_EnterSTOPMode+0xc6>
  else if (Domain == PWR_D2_DOMAIN)
200146fa:	687b      	ldr	r3, [r7, #4]
200146fc:	2b01      	cmp	r3, #1
200146fe:	d106      	bne.n	2001470e <HAL_PWREx_EnterSTOPMode+0xba>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
20014700:	4b09      	ldr	r3, [pc, #36]	; (20014728 <HAL_PWREx_EnterSTOPMode+0xd4>)
20014702:	691b      	ldr	r3, [r3, #16]
20014704:	4a08      	ldr	r2, [pc, #32]	; (20014728 <HAL_PWREx_EnterSTOPMode+0xd4>)
20014706:	f023 0302 	bic.w	r3, r3, #2
2001470a:	6113      	str	r3, [r2, #16]
}
2001470c:	e005      	b.n	2001471a <HAL_PWREx_EnterSTOPMode+0xc6>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
2001470e:	4b06      	ldr	r3, [pc, #24]	; (20014728 <HAL_PWREx_EnterSTOPMode+0xd4>)
20014710:	691b      	ldr	r3, [r3, #16]
20014712:	4a05      	ldr	r2, [pc, #20]	; (20014728 <HAL_PWREx_EnterSTOPMode+0xd4>)
20014714:	f023 0304 	bic.w	r3, r3, #4
20014718:	6113      	str	r3, [r2, #16]
}
2001471a:	bf00      	nop
2001471c:	3710      	adds	r7, #16
2001471e:	46bd      	mov	sp, r7
20014720:	bd80      	pop	{r7, pc}
20014722:	bf00      	nop
20014724:	2001c268 	.word	0x2001c268
20014728:	58024800 	.word	0x58024800
2001472c:	e000ed00 	.word	0xe000ed00

20014730 <HAL_PWREx_ClearPendingEvent>:
  *         to CSLEEP or CSTOP. It should be called just before APIs performing
  *         enter low power mode using Wait For Event request.
  * @retval None.
  */
void HAL_PWREx_ClearPendingEvent (void)
{
20014730:	b480      	push	{r7}
20014732:	af00      	add	r7, sp, #0
  {
    __SEV ();
    __WFE ();
  }
#else
  __WFE ();
20014734:	bf20      	wfe
#endif /* defined (DUAL_CORE) */
}
20014736:	bf00      	nop
20014738:	46bd      	mov	sp, r7
2001473a:	f85d 7b04 	ldr.w	r7, [sp], #4
2001473e:	4770      	bx	lr

20014740 <HAL_PWREx_EnterSTANDBYMode>:
  *            @arg PWR_D2_DOMAIN: Enter D2 Domain to DSTANDBY mode.
  *            @arg PWR_D3_DOMAIN: Enter D3/SRD Domain to DSTANDBY mode.
  * @retval None
  */
void HAL_PWREx_EnterSTANDBYMode (uint32_t Domain)
{
20014740:	b580      	push	{r7, lr}
20014742:	b082      	sub	sp, #8
20014744:	af00      	add	r7, sp, #0
20014746:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_DOMAIN (Domain));
20014748:	687b      	ldr	r3, [r7, #4]
2001474a:	2b00      	cmp	r3, #0
2001474c:	d00a      	beq.n	20014764 <HAL_PWREx_EnterSTANDBYMode+0x24>
2001474e:	687b      	ldr	r3, [r7, #4]
20014750:	2b01      	cmp	r3, #1
20014752:	d007      	beq.n	20014764 <HAL_PWREx_EnterSTANDBYMode+0x24>
20014754:	687b      	ldr	r3, [r7, #4]
20014756:	2b02      	cmp	r3, #2
20014758:	d004      	beq.n	20014764 <HAL_PWREx_EnterSTANDBYMode+0x24>
2001475a:	f44f 7170 	mov.w	r1, #960	; 0x3c0
2001475e:	4814      	ldr	r0, [pc, #80]	; (200147b0 <HAL_PWREx_EnterSTANDBYMode+0x70>)
20014760:	f7ec f8c8 	bl	200008f4 <assert_failed>

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
20014764:	687b      	ldr	r3, [r7, #4]
20014766:	2b00      	cmp	r3, #0
20014768:	d10d      	bne.n	20014786 <HAL_PWREx_EnterSTANDBYMode+0x46>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D1);
2001476a:	4b12      	ldr	r3, [pc, #72]	; (200147b4 <HAL_PWREx_EnterSTANDBYMode+0x74>)
2001476c:	691b      	ldr	r3, [r3, #16]
2001476e:	4a11      	ldr	r2, [pc, #68]	; (200147b4 <HAL_PWREx_EnterSTANDBYMode+0x74>)
20014770:	f043 0301 	orr.w	r3, r3, #1
20014774:	6113      	str	r3, [r2, #16]
    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D1);
#endif /*DUAL_CORE*/

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
20014776:	4b10      	ldr	r3, [pc, #64]	; (200147b8 <HAL_PWREx_EnterSTANDBYMode+0x78>)
20014778:	691b      	ldr	r3, [r3, #16]
2001477a:	4a0f      	ldr	r2, [pc, #60]	; (200147b8 <HAL_PWREx_EnterSTANDBYMode+0x78>)
2001477c:	f043 0304 	orr.w	r3, r3, #4
20014780:	6113      	str	r3, [r2, #16]
#if defined (__CC_ARM)
    __force_stores ();
#endif /* defined (__CC_ARM) */

    /* Request Wait For Interrupt */
    __WFI ();
20014782:	bf30      	wfi
#if defined (DUAL_CORE)
    /* Allow DSTANDBY mode when D3/SRD domain enters Deepsleep */
    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D3);
#endif /* defined (DUAL_CORE) */
  }
}
20014784:	e00f      	b.n	200147a6 <HAL_PWREx_EnterSTANDBYMode+0x66>
  else if (Domain == PWR_D2_DOMAIN)
20014786:	687b      	ldr	r3, [r7, #4]
20014788:	2b01      	cmp	r3, #1
2001478a:	d106      	bne.n	2001479a <HAL_PWREx_EnterSTANDBYMode+0x5a>
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D2);
2001478c:	4b09      	ldr	r3, [pc, #36]	; (200147b4 <HAL_PWREx_EnterSTANDBYMode+0x74>)
2001478e:	691b      	ldr	r3, [r3, #16]
20014790:	4a08      	ldr	r2, [pc, #32]	; (200147b4 <HAL_PWREx_EnterSTANDBYMode+0x74>)
20014792:	f043 0302 	orr.w	r3, r3, #2
20014796:	6113      	str	r3, [r2, #16]
}
20014798:	e005      	b.n	200147a6 <HAL_PWREx_EnterSTANDBYMode+0x66>
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D3);
2001479a:	4b06      	ldr	r3, [pc, #24]	; (200147b4 <HAL_PWREx_EnterSTANDBYMode+0x74>)
2001479c:	691b      	ldr	r3, [r3, #16]
2001479e:	4a05      	ldr	r2, [pc, #20]	; (200147b4 <HAL_PWREx_EnterSTANDBYMode+0x74>)
200147a0:	f043 0304 	orr.w	r3, r3, #4
200147a4:	6113      	str	r3, [r2, #16]
}
200147a6:	bf00      	nop
200147a8:	3708      	adds	r7, #8
200147aa:	46bd      	mov	sp, r7
200147ac:	bd80      	pop	{r7, pc}
200147ae:	bf00      	nop
200147b0:	2001c268 	.word	0x2001c268
200147b4:	58024800 	.word	0x58024800
200147b8:	e000ed00 	.word	0xe000ed00

200147bc <HAL_PWREx_ConfigD3Domain>:
  *                                     regardless of the CPU sub-system low
  *                                     power mode.
  * @retval None
  */
void HAL_PWREx_ConfigD3Domain (uint32_t D3State)
{
200147bc:	b580      	push	{r7, lr}
200147be:	b082      	sub	sp, #8
200147c0:	af00      	add	r7, sp, #0
200147c2:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_D3_STATE (D3State));
200147c4:	687b      	ldr	r3, [r7, #4]
200147c6:	2b00      	cmp	r3, #0
200147c8:	d008      	beq.n	200147dc <HAL_PWREx_ConfigD3Domain+0x20>
200147ca:	687b      	ldr	r3, [r7, #4]
200147cc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
200147d0:	d004      	beq.n	200147dc <HAL_PWREx_ConfigD3Domain+0x20>
200147d2:	f240 411f 	movw	r1, #1055	; 0x41f
200147d6:	4807      	ldr	r0, [pc, #28]	; (200147f4 <HAL_PWREx_ConfigD3Domain+0x38>)
200147d8:	f7ec f88c 	bl	200008f4 <assert_failed>

  /* Keep D3/SRD in run mode */
  MODIFY_REG (PWR->CPUCR, PWR_CPUCR_RUN_D3, D3State);
200147dc:	4b06      	ldr	r3, [pc, #24]	; (200147f8 <HAL_PWREx_ConfigD3Domain+0x3c>)
200147de:	691b      	ldr	r3, [r3, #16]
200147e0:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
200147e4:	4904      	ldr	r1, [pc, #16]	; (200147f8 <HAL_PWREx_ConfigD3Domain+0x3c>)
200147e6:	687b      	ldr	r3, [r7, #4]
200147e8:	4313      	orrs	r3, r2
200147ea:	610b      	str	r3, [r1, #16]
}
200147ec:	bf00      	nop
200147ee:	3708      	adds	r7, #8
200147f0:	46bd      	mov	sp, r7
200147f2:	bd80      	pop	{r7, pc}
200147f4:	2001c268 	.word	0x2001c268
200147f8:	58024800 	.word	0x58024800

200147fc <HAL_PWREx_EnableFlashPowerDown>:
  *         obtain the best trade-off between low-power consumption and restart
  *         time when exiting from DStop mode.
  * @retval None.
  */
void HAL_PWREx_EnableFlashPowerDown (void)
{
200147fc:	b480      	push	{r7}
200147fe:	af00      	add	r7, sp, #0
  /* Enable the Flash Power Down */
  SET_BIT (PWR->CR1, PWR_CR1_FLPS);
20014800:	4b05      	ldr	r3, [pc, #20]	; (20014818 <HAL_PWREx_EnableFlashPowerDown+0x1c>)
20014802:	681b      	ldr	r3, [r3, #0]
20014804:	4a04      	ldr	r2, [pc, #16]	; (20014818 <HAL_PWREx_EnableFlashPowerDown+0x1c>)
20014806:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2001480a:	6013      	str	r3, [r2, #0]
}
2001480c:	bf00      	nop
2001480e:	46bd      	mov	sp, r7
20014810:	f85d 7b04 	ldr.w	r7, [sp], #4
20014814:	4770      	bx	lr
20014816:	bf00      	nop
20014818:	58024800 	.word	0x58024800

2001481c <HAL_PWREx_DisableFlashPowerDown>:
  *         to obtain the best trade-off between low-power consumption and
  *         restart time when exiting from DStop mode.
  * @retval None.
  */
void HAL_PWREx_DisableFlashPowerDown (void)
{
2001481c:	b480      	push	{r7}
2001481e:	af00      	add	r7, sp, #0
  /* Disable the Flash Power Down */
  CLEAR_BIT (PWR->CR1, PWR_CR1_FLPS);
20014820:	4b05      	ldr	r3, [pc, #20]	; (20014838 <HAL_PWREx_DisableFlashPowerDown+0x1c>)
20014822:	681b      	ldr	r3, [r3, #0]
20014824:	4a04      	ldr	r2, [pc, #16]	; (20014838 <HAL_PWREx_DisableFlashPowerDown+0x1c>)
20014826:	f423 7300 	bic.w	r3, r3, #512	; 0x200
2001482a:	6013      	str	r3, [r2, #0]
}
2001482c:	bf00      	nop
2001482e:	46bd      	mov	sp, r7
20014830:	f85d 7b04 	ldr.w	r7, [sp], #4
20014834:	4770      	bx	lr
20014836:	bf00      	nop
20014838:	58024800 	.word	0x58024800

2001483c <HAL_PWREx_EnableWakeUpPin>:
  *         Cortex-M7, wake up only Cortex-M4 and wake up Cortex-M7 and
  *         Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_EnableWakeUpPin (PWREx_WakeupPinTypeDef *sPinParams)
{
2001483c:	b580      	push	{r7, lr}
2001483e:	b08e      	sub	sp, #56	; 0x38
20014840:	af00      	add	r7, sp, #0
20014842:	6078      	str	r0, [r7, #4]
  uint32_t pinConfig;
  uint32_t regMask;
  const uint32_t pullMask = PWR_WKUPEPR_WKUPPUPD1;
20014844:	f44f 3340 	mov.w	r3, #196608	; 0x30000
20014848:	637b      	str	r3, [r7, #52]	; 0x34

  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (sPinParams->WakeUpPin));
2001484a:	687b      	ldr	r3, [r7, #4]
2001484c:	681b      	ldr	r3, [r3, #0]
2001484e:	2b01      	cmp	r3, #1
20014850:	d054      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
20014852:	687b      	ldr	r3, [r7, #4]
20014854:	681b      	ldr	r3, [r3, #0]
20014856:	2b02      	cmp	r3, #2
20014858:	d050      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
2001485a:	687b      	ldr	r3, [r7, #4]
2001485c:	681b      	ldr	r3, [r3, #0]
2001485e:	2b04      	cmp	r3, #4
20014860:	d04c      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
20014862:	687b      	ldr	r3, [r7, #4]
20014864:	681b      	ldr	r3, [r3, #0]
20014866:	2b08      	cmp	r3, #8
20014868:	d048      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
2001486a:	687b      	ldr	r3, [r7, #4]
2001486c:	681b      	ldr	r3, [r3, #0]
2001486e:	2b10      	cmp	r3, #16
20014870:	d044      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
20014872:	687b      	ldr	r3, [r7, #4]
20014874:	681b      	ldr	r3, [r3, #0]
20014876:	2b20      	cmp	r3, #32
20014878:	d040      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
2001487a:	687b      	ldr	r3, [r7, #4]
2001487c:	681b      	ldr	r3, [r3, #0]
2001487e:	2b01      	cmp	r3, #1
20014880:	d03c      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
20014882:	687b      	ldr	r3, [r7, #4]
20014884:	681b      	ldr	r3, [r3, #0]
20014886:	2b02      	cmp	r3, #2
20014888:	d038      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
2001488a:	687b      	ldr	r3, [r7, #4]
2001488c:	681b      	ldr	r3, [r3, #0]
2001488e:	2b04      	cmp	r3, #4
20014890:	d034      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
20014892:	687b      	ldr	r3, [r7, #4]
20014894:	681b      	ldr	r3, [r3, #0]
20014896:	2b08      	cmp	r3, #8
20014898:	d030      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
2001489a:	687b      	ldr	r3, [r7, #4]
2001489c:	681b      	ldr	r3, [r3, #0]
2001489e:	2b10      	cmp	r3, #16
200148a0:	d02c      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
200148a2:	687b      	ldr	r3, [r7, #4]
200148a4:	681b      	ldr	r3, [r3, #0]
200148a6:	2b20      	cmp	r3, #32
200148a8:	d028      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
200148aa:	687b      	ldr	r3, [r7, #4]
200148ac:	681b      	ldr	r3, [r3, #0]
200148ae:	f240 1201 	movw	r2, #257	; 0x101
200148b2:	4293      	cmp	r3, r2
200148b4:	d022      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
200148b6:	687b      	ldr	r3, [r7, #4]
200148b8:	681b      	ldr	r3, [r3, #0]
200148ba:	f240 2202 	movw	r2, #514	; 0x202
200148be:	4293      	cmp	r3, r2
200148c0:	d01c      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
200148c2:	687b      	ldr	r3, [r7, #4]
200148c4:	681b      	ldr	r3, [r3, #0]
200148c6:	f240 4204 	movw	r2, #1028	; 0x404
200148ca:	4293      	cmp	r3, r2
200148cc:	d016      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
200148ce:	687b      	ldr	r3, [r7, #4]
200148d0:	681b      	ldr	r3, [r3, #0]
200148d2:	f640 0208 	movw	r2, #2056	; 0x808
200148d6:	4293      	cmp	r3, r2
200148d8:	d010      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
200148da:	687b      	ldr	r3, [r7, #4]
200148dc:	681b      	ldr	r3, [r3, #0]
200148de:	f241 0210 	movw	r2, #4112	; 0x1010
200148e2:	4293      	cmp	r3, r2
200148e4:	d00a      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
200148e6:	687b      	ldr	r3, [r7, #4]
200148e8:	681b      	ldr	r3, [r3, #0]
200148ea:	f242 0220 	movw	r2, #8224	; 0x2020
200148ee:	4293      	cmp	r3, r2
200148f0:	d004      	beq.n	200148fc <HAL_PWREx_EnableWakeUpPin+0xc0>
200148f2:	f44f 61a0 	mov.w	r1, #1280	; 0x500
200148f6:	4846      	ldr	r0, [pc, #280]	; (20014a10 <HAL_PWREx_EnableWakeUpPin+0x1d4>)
200148f8:	f7eb fffc 	bl	200008f4 <assert_failed>
  assert_param (IS_PWR_WAKEUP_PIN_POLARITY (sPinParams->PinPolarity));
200148fc:	687b      	ldr	r3, [r7, #4]
200148fe:	685b      	ldr	r3, [r3, #4]
20014900:	2b00      	cmp	r3, #0
20014902:	d008      	beq.n	20014916 <HAL_PWREx_EnableWakeUpPin+0xda>
20014904:	687b      	ldr	r3, [r7, #4]
20014906:	685b      	ldr	r3, [r3, #4]
20014908:	2b01      	cmp	r3, #1
2001490a:	d004      	beq.n	20014916 <HAL_PWREx_EnableWakeUpPin+0xda>
2001490c:	f240 5101 	movw	r1, #1281	; 0x501
20014910:	483f      	ldr	r0, [pc, #252]	; (20014a10 <HAL_PWREx_EnableWakeUpPin+0x1d4>)
20014912:	f7eb ffef 	bl	200008f4 <assert_failed>
  assert_param (IS_PWR_WAKEUP_PIN_PULL (sPinParams->PinPull));
20014916:	687b      	ldr	r3, [r7, #4]
20014918:	689b      	ldr	r3, [r3, #8]
2001491a:	2b00      	cmp	r3, #0
2001491c:	d00c      	beq.n	20014938 <HAL_PWREx_EnableWakeUpPin+0xfc>
2001491e:	687b      	ldr	r3, [r7, #4]
20014920:	689b      	ldr	r3, [r3, #8]
20014922:	2b01      	cmp	r3, #1
20014924:	d008      	beq.n	20014938 <HAL_PWREx_EnableWakeUpPin+0xfc>
20014926:	687b      	ldr	r3, [r7, #4]
20014928:	689b      	ldr	r3, [r3, #8]
2001492a:	2b02      	cmp	r3, #2
2001492c:	d004      	beq.n	20014938 <HAL_PWREx_EnableWakeUpPin+0xfc>
2001492e:	f240 5102 	movw	r1, #1282	; 0x502
20014932:	4837      	ldr	r0, [pc, #220]	; (20014a10 <HAL_PWREx_EnableWakeUpPin+0x1d4>)
20014934:	f7eb ffde 	bl	200008f4 <assert_failed>

  pinConfig = sPinParams->WakeUpPin | \
20014938:	687b      	ldr	r3, [r7, #4]
2001493a:	681a      	ldr	r2, [r3, #0]
              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \
2001493c:	687b      	ldr	r3, [r7, #4]
2001493e:	6859      	ldr	r1, [r3, #4]
20014940:	687b      	ldr	r3, [r7, #4]
20014942:	681b      	ldr	r3, [r3, #0]
20014944:	613b      	str	r3, [r7, #16]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
20014946:	693b      	ldr	r3, [r7, #16]
20014948:	fa93 f3a3 	rbit	r3, r3
2001494c:	60fb      	str	r3, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
2001494e:	68fb      	ldr	r3, [r7, #12]
20014950:	fab3 f383 	clz	r3, r3
20014954:	b2db      	uxtb	r3, r3
20014956:	3308      	adds	r3, #8
20014958:	f003 031f 	and.w	r3, r3, #31
2001495c:	fa01 f303 	lsl.w	r3, r1, r3
  pinConfig = sPinParams->WakeUpPin | \
20014960:	431a      	orrs	r2, r3
              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));
20014962:	687b      	ldr	r3, [r7, #4]
20014964:	6899      	ldr	r1, [r3, #8]
20014966:	687b      	ldr	r3, [r7, #4]
20014968:	681b      	ldr	r3, [r3, #0]
2001496a:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2001496c:	69bb      	ldr	r3, [r7, #24]
2001496e:	fa93 f3a3 	rbit	r3, r3
20014972:	617b      	str	r3, [r7, #20]
  return result;
20014974:	697b      	ldr	r3, [r7, #20]
20014976:	fab3 f383 	clz	r3, r3
2001497a:	b2db      	uxtb	r3, r3
2001497c:	3308      	adds	r3, #8
2001497e:	005b      	lsls	r3, r3, #1
20014980:	f003 031e 	and.w	r3, r3, #30
20014984:	fa01 f303 	lsl.w	r3, r1, r3
  pinConfig = sPinParams->WakeUpPin | \
20014988:	4313      	orrs	r3, r2
2001498a:	633b      	str	r3, [r7, #48]	; 0x30

  regMask   = sPinParams->WakeUpPin | \
2001498c:	687b      	ldr	r3, [r7, #4]
2001498e:	681a      	ldr	r2, [r3, #0]
              (PWR_WKUPEPR_WKUPP1 << (POSITION_VAL(sPinParams->WakeUpPin) & 0x1FU)) | \
20014990:	687b      	ldr	r3, [r7, #4]
20014992:	681b      	ldr	r3, [r3, #0]
20014994:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
20014996:	6a3b      	ldr	r3, [r7, #32]
20014998:	fa93 f3a3 	rbit	r3, r3
2001499c:	61fb      	str	r3, [r7, #28]
  return result;
2001499e:	69fb      	ldr	r3, [r7, #28]
200149a0:	fab3 f383 	clz	r3, r3
200149a4:	b2db      	uxtb	r3, r3
200149a6:	f003 031f 	and.w	r3, r3, #31
200149aa:	f44f 7180 	mov.w	r1, #256	; 0x100
200149ae:	fa01 f303 	lsl.w	r3, r1, r3
  regMask   = sPinParams->WakeUpPin | \
200149b2:	431a      	orrs	r2, r3
              (pullMask << ((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) & 0x1FU));
200149b4:	687b      	ldr	r3, [r7, #4]
200149b6:	681b      	ldr	r3, [r3, #0]
200149b8:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
200149ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
200149bc:	fa93 f3a3 	rbit	r3, r3
200149c0:	627b      	str	r3, [r7, #36]	; 0x24
  return result;
200149c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
200149c4:	fab3 f383 	clz	r3, r3
200149c8:	b2db      	uxtb	r3, r3
200149ca:	005b      	lsls	r3, r3, #1
200149cc:	f003 031e 	and.w	r3, r3, #30
200149d0:	6b79      	ldr	r1, [r7, #52]	; 0x34
200149d2:	fa01 f303 	lsl.w	r3, r1, r3
  regMask   = sPinParams->WakeUpPin | \
200149d6:	4313      	orrs	r3, r2
200149d8:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge) */
  MODIFY_REG (PWR->WKUPEPR, regMask, pinConfig);
200149da:	4b0e      	ldr	r3, [pc, #56]	; (20014a14 <HAL_PWREx_EnableWakeUpPin+0x1d8>)
200149dc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
200149de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
200149e0:	43db      	mvns	r3, r3
200149e2:	401a      	ands	r2, r3
200149e4:	490b      	ldr	r1, [pc, #44]	; (20014a14 <HAL_PWREx_EnableWakeUpPin+0x1d8>)
200149e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
200149e8:	4313      	orrs	r3, r2
200149ea:	628b      	str	r3, [r1, #40]	; 0x28
#ifndef DUAL_CORE
  /* Configure the Wakeup Pin EXTI Line */
  MODIFY_REG (EXTI->IMR2, PWR_EXTI_WAKEUP_PINS_MASK, (sPinParams->WakeUpPin << EXTI_IMR2_IM55_Pos));
200149ec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
200149f0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
200149f4:	f023 52fc 	bic.w	r2, r3, #528482304	; 0x1f800000
200149f8:	687b      	ldr	r3, [r7, #4]
200149fa:	681b      	ldr	r3, [r3, #0]
200149fc:	05db      	lsls	r3, r3, #23
200149fe:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
20014a02:	4313      	orrs	r3, r2
20014a04:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
#endif /* !DUAL_CORE */
}
20014a08:	bf00      	nop
20014a0a:	3738      	adds	r7, #56	; 0x38
20014a0c:	46bd      	mov	sp, r7
20014a0e:	bd80      	pop	{r7, pc}
20014a10:	2001c268 	.word	0x2001c268
20014a14:	58024800 	.word	0x58024800

20014a18 <HAL_PWREx_DisableWakeUpPin>:
  *           @arg PWR_WAKEUP_PIN5 : Disable PI11 wake-up PIN.
  *           @arg PWR_WAKEUP_PIN6 : Disable PC1  wake-up PIN.
  * @retval None
  */
void HAL_PWREx_DisableWakeUpPin (uint32_t WakeUpPin)
{
20014a18:	b580      	push	{r7, lr}
20014a1a:	b082      	sub	sp, #8
20014a1c:	af00      	add	r7, sp, #0
20014a1e:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPin));
20014a20:	687b      	ldr	r3, [r7, #4]
20014a22:	2b01      	cmp	r3, #1
20014a24:	d043      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a26:	687b      	ldr	r3, [r7, #4]
20014a28:	2b02      	cmp	r3, #2
20014a2a:	d040      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a2c:	687b      	ldr	r3, [r7, #4]
20014a2e:	2b04      	cmp	r3, #4
20014a30:	d03d      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a32:	687b      	ldr	r3, [r7, #4]
20014a34:	2b08      	cmp	r3, #8
20014a36:	d03a      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a38:	687b      	ldr	r3, [r7, #4]
20014a3a:	2b10      	cmp	r3, #16
20014a3c:	d037      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a3e:	687b      	ldr	r3, [r7, #4]
20014a40:	2b20      	cmp	r3, #32
20014a42:	d034      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a44:	687b      	ldr	r3, [r7, #4]
20014a46:	2b01      	cmp	r3, #1
20014a48:	d031      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a4a:	687b      	ldr	r3, [r7, #4]
20014a4c:	2b02      	cmp	r3, #2
20014a4e:	d02e      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a50:	687b      	ldr	r3, [r7, #4]
20014a52:	2b04      	cmp	r3, #4
20014a54:	d02b      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a56:	687b      	ldr	r3, [r7, #4]
20014a58:	2b08      	cmp	r3, #8
20014a5a:	d028      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a5c:	687b      	ldr	r3, [r7, #4]
20014a5e:	2b10      	cmp	r3, #16
20014a60:	d025      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a62:	687b      	ldr	r3, [r7, #4]
20014a64:	2b20      	cmp	r3, #32
20014a66:	d022      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a68:	687b      	ldr	r3, [r7, #4]
20014a6a:	f240 1201 	movw	r2, #257	; 0x101
20014a6e:	4293      	cmp	r3, r2
20014a70:	d01d      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a72:	687b      	ldr	r3, [r7, #4]
20014a74:	f240 2202 	movw	r2, #514	; 0x202
20014a78:	4293      	cmp	r3, r2
20014a7a:	d018      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a7c:	687b      	ldr	r3, [r7, #4]
20014a7e:	f240 4204 	movw	r2, #1028	; 0x404
20014a82:	4293      	cmp	r3, r2
20014a84:	d013      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a86:	687b      	ldr	r3, [r7, #4]
20014a88:	f640 0208 	movw	r2, #2056	; 0x808
20014a8c:	4293      	cmp	r3, r2
20014a8e:	d00e      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a90:	687b      	ldr	r3, [r7, #4]
20014a92:	f241 0210 	movw	r2, #4112	; 0x1010
20014a96:	4293      	cmp	r3, r2
20014a98:	d009      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014a9a:	687b      	ldr	r3, [r7, #4]
20014a9c:	f242 0220 	movw	r2, #8224	; 0x2020
20014aa0:	4293      	cmp	r3, r2
20014aa2:	d004      	beq.n	20014aae <HAL_PWREx_DisableWakeUpPin+0x96>
20014aa4:	f240 5124 	movw	r1, #1316	; 0x524
20014aa8:	4806      	ldr	r0, [pc, #24]	; (20014ac4 <HAL_PWREx_DisableWakeUpPin+0xac>)
20014aaa:	f7eb ff23 	bl	200008f4 <assert_failed>

  /* Disable the WakeUpPin */
  CLEAR_BIT (PWR->WKUPEPR, WakeUpPin);
20014aae:	4b06      	ldr	r3, [pc, #24]	; (20014ac8 <HAL_PWREx_DisableWakeUpPin+0xb0>)
20014ab0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20014ab2:	687b      	ldr	r3, [r7, #4]
20014ab4:	43db      	mvns	r3, r3
20014ab6:	4904      	ldr	r1, [pc, #16]	; (20014ac8 <HAL_PWREx_DisableWakeUpPin+0xb0>)
20014ab8:	4013      	ands	r3, r2
20014aba:	628b      	str	r3, [r1, #40]	; 0x28
}
20014abc:	bf00      	nop
20014abe:	3708      	adds	r7, #8
20014ac0:	46bd      	mov	sp, r7
20014ac2:	bd80      	pop	{r7, pc}
20014ac4:	2001c268 	.word	0x2001c268
20014ac8:	58024800 	.word	0x58024800

20014acc <HAL_PWREx_GetWakeupFlag>:
  *            @arg PWR_WAKEUP_FLAG_ALL : Get Wakeup event received from all
  *                                      wake up pins.
  * @retval The Wake-Up pin flag.
  */
uint32_t HAL_PWREx_GetWakeupFlag (uint32_t WakeUpFlag)
{
20014acc:	b580      	push	{r7, lr}
20014ace:	b082      	sub	sp, #8
20014ad0:	af00      	add	r7, sp, #0
20014ad2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));
20014ad4:	687b      	ldr	r3, [r7, #4]
20014ad6:	2b01      	cmp	r3, #1
20014ad8:	d016      	beq.n	20014b08 <HAL_PWREx_GetWakeupFlag+0x3c>
20014ada:	687b      	ldr	r3, [r7, #4]
20014adc:	2b02      	cmp	r3, #2
20014ade:	d013      	beq.n	20014b08 <HAL_PWREx_GetWakeupFlag+0x3c>
20014ae0:	687b      	ldr	r3, [r7, #4]
20014ae2:	2b04      	cmp	r3, #4
20014ae4:	d010      	beq.n	20014b08 <HAL_PWREx_GetWakeupFlag+0x3c>
20014ae6:	687b      	ldr	r3, [r7, #4]
20014ae8:	2b08      	cmp	r3, #8
20014aea:	d00d      	beq.n	20014b08 <HAL_PWREx_GetWakeupFlag+0x3c>
20014aec:	687b      	ldr	r3, [r7, #4]
20014aee:	2b10      	cmp	r3, #16
20014af0:	d00a      	beq.n	20014b08 <HAL_PWREx_GetWakeupFlag+0x3c>
20014af2:	687b      	ldr	r3, [r7, #4]
20014af4:	2b20      	cmp	r3, #32
20014af6:	d007      	beq.n	20014b08 <HAL_PWREx_GetWakeupFlag+0x3c>
20014af8:	687b      	ldr	r3, [r7, #4]
20014afa:	2b3f      	cmp	r3, #63	; 0x3f
20014afc:	d004      	beq.n	20014b08 <HAL_PWREx_GetWakeupFlag+0x3c>
20014afe:	f240 513b 	movw	r1, #1339	; 0x53b
20014b02:	4805      	ldr	r0, [pc, #20]	; (20014b18 <HAL_PWREx_GetWakeupFlag+0x4c>)
20014b04:	f7eb fef6 	bl	200008f4 <assert_failed>

  /* Return the wake up pin flag */
  return (PWR->WKUPFR & WakeUpFlag);
20014b08:	4b04      	ldr	r3, [pc, #16]	; (20014b1c <HAL_PWREx_GetWakeupFlag+0x50>)
20014b0a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20014b0c:	687b      	ldr	r3, [r7, #4]
20014b0e:	4013      	ands	r3, r2
}
20014b10:	4618      	mov	r0, r3
20014b12:	3708      	adds	r7, #8
20014b14:	46bd      	mov	sp, r7
20014b16:	bd80      	pop	{r7, pc}
20014b18:	2001c268 	.word	0x2001c268
20014b1c:	58024800 	.word	0x58024800

20014b20 <HAL_PWREx_ClearWakeupFlag>:
  *            @arg PWR_WAKEUP_FLAG_ALL : Clear the wakeup events received from
  *                                      all wake up pins.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ClearWakeupFlag (uint32_t WakeUpFlag)
{
20014b20:	b580      	push	{r7, lr}
20014b22:	b082      	sub	sp, #8
20014b24:	af00      	add	r7, sp, #0
20014b26:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));
20014b28:	687b      	ldr	r3, [r7, #4]
20014b2a:	2b01      	cmp	r3, #1
20014b2c:	d016      	beq.n	20014b5c <HAL_PWREx_ClearWakeupFlag+0x3c>
20014b2e:	687b      	ldr	r3, [r7, #4]
20014b30:	2b02      	cmp	r3, #2
20014b32:	d013      	beq.n	20014b5c <HAL_PWREx_ClearWakeupFlag+0x3c>
20014b34:	687b      	ldr	r3, [r7, #4]
20014b36:	2b04      	cmp	r3, #4
20014b38:	d010      	beq.n	20014b5c <HAL_PWREx_ClearWakeupFlag+0x3c>
20014b3a:	687b      	ldr	r3, [r7, #4]
20014b3c:	2b08      	cmp	r3, #8
20014b3e:	d00d      	beq.n	20014b5c <HAL_PWREx_ClearWakeupFlag+0x3c>
20014b40:	687b      	ldr	r3, [r7, #4]
20014b42:	2b10      	cmp	r3, #16
20014b44:	d00a      	beq.n	20014b5c <HAL_PWREx_ClearWakeupFlag+0x3c>
20014b46:	687b      	ldr	r3, [r7, #4]
20014b48:	2b20      	cmp	r3, #32
20014b4a:	d007      	beq.n	20014b5c <HAL_PWREx_ClearWakeupFlag+0x3c>
20014b4c:	687b      	ldr	r3, [r7, #4]
20014b4e:	2b3f      	cmp	r3, #63	; 0x3f
20014b50:	d004      	beq.n	20014b5c <HAL_PWREx_ClearWakeupFlag+0x3c>
20014b52:	f240 5152 	movw	r1, #1362	; 0x552
20014b56:	480b      	ldr	r0, [pc, #44]	; (20014b84 <HAL_PWREx_ClearWakeupFlag+0x64>)
20014b58:	f7eb fecc 	bl	200008f4 <assert_failed>

  /* Clear the wake up event received from wake up pin x */
  SET_BIT (PWR->WKUPCR, WakeUpFlag);
20014b5c:	4b0a      	ldr	r3, [pc, #40]	; (20014b88 <HAL_PWREx_ClearWakeupFlag+0x68>)
20014b5e:	6a1a      	ldr	r2, [r3, #32]
20014b60:	4909      	ldr	r1, [pc, #36]	; (20014b88 <HAL_PWREx_ClearWakeupFlag+0x68>)
20014b62:	687b      	ldr	r3, [r7, #4]
20014b64:	4313      	orrs	r3, r2
20014b66:	620b      	str	r3, [r1, #32]

  /* Check if the wake up event is well cleared */
  if ((PWR->WKUPFR & WakeUpFlag) != 0U)
20014b68:	4b07      	ldr	r3, [pc, #28]	; (20014b88 <HAL_PWREx_ClearWakeupFlag+0x68>)
20014b6a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20014b6c:	687b      	ldr	r3, [r7, #4]
20014b6e:	4013      	ands	r3, r2
20014b70:	2b00      	cmp	r3, #0
20014b72:	d001      	beq.n	20014b78 <HAL_PWREx_ClearWakeupFlag+0x58>
  {
    return HAL_ERROR;
20014b74:	2301      	movs	r3, #1
20014b76:	e000      	b.n	20014b7a <HAL_PWREx_ClearWakeupFlag+0x5a>
  }

  return HAL_OK;
20014b78:	2300      	movs	r3, #0
}
20014b7a:	4618      	mov	r0, r3
20014b7c:	3708      	adds	r7, #8
20014b7e:	46bd      	mov	sp, r7
20014b80:	bd80      	pop	{r7, pc}
20014b82:	bf00      	nop
20014b84:	2001c268 	.word	0x2001c268
20014b88:	58024800 	.word	0x58024800

20014b8c <HAL_PWREx_WAKEUP_PIN_IRQHandler>:
  * @brief This function handles the PWR WAKEUP PIN interrupt request.
  * @note   This API should be called under the WAKEUP_PIN_IRQHandler().
  * @retval None.
  */
void HAL_PWREx_WAKEUP_PIN_IRQHandler (void)
{
20014b8c:	b580      	push	{r7, lr}
20014b8e:	af00      	add	r7, sp, #0
  /* Wakeup pin EXTI line interrupt detected */
  if (READ_BIT(PWR->WKUPFR, PWR_WKUPFR_WKUPF1) != 0U)
20014b90:	4b2a      	ldr	r3, [pc, #168]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014b92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20014b94:	f003 0301 	and.w	r3, r3, #1
20014b98:	2b00      	cmp	r3, #0
20014b9a:	d008      	beq.n	20014bae <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x22>
  {
    /* Clear PWR WKUPF1 flag */
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP1);
20014b9c:	4b27      	ldr	r3, [pc, #156]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014b9e:	6a1b      	ldr	r3, [r3, #32]
20014ba0:	4a26      	ldr	r2, [pc, #152]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014ba2:	f043 0301 	orr.w	r3, r3, #1
20014ba6:	6213      	str	r3, [r2, #32]

    /* PWR WKUP1 interrupt user callback */
    HAL_PWREx_WKUP1_Callback ();
20014ba8:	f000 f84a 	bl	20014c40 <HAL_PWREx_WKUP1_Callback>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);

    /* PWR WKUP6 interrupt user callback */
    HAL_PWREx_WKUP6_Callback ();
  }
}
20014bac:	e043      	b.n	20014c36 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF2) != 0U)
20014bae:	4b23      	ldr	r3, [pc, #140]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014bb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20014bb2:	f003 0302 	and.w	r3, r3, #2
20014bb6:	2b00      	cmp	r3, #0
20014bb8:	d008      	beq.n	20014bcc <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x40>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP2);
20014bba:	4b20      	ldr	r3, [pc, #128]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014bbc:	6a1b      	ldr	r3, [r3, #32]
20014bbe:	4a1f      	ldr	r2, [pc, #124]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014bc0:	f043 0302 	orr.w	r3, r3, #2
20014bc4:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP2_Callback ();
20014bc6:	f000 f842 	bl	20014c4e <HAL_PWREx_WKUP2_Callback>
}
20014bca:	e034      	b.n	20014c36 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF3) != 0U)
20014bcc:	4b1b      	ldr	r3, [pc, #108]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014bce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20014bd0:	f003 0304 	and.w	r3, r3, #4
20014bd4:	2b00      	cmp	r3, #0
20014bd6:	d008      	beq.n	20014bea <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x5e>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP3);
20014bd8:	4b18      	ldr	r3, [pc, #96]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014bda:	6a1b      	ldr	r3, [r3, #32]
20014bdc:	4a17      	ldr	r2, [pc, #92]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014bde:	f043 0304 	orr.w	r3, r3, #4
20014be2:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP3_Callback ();
20014be4:	f000 f83a 	bl	20014c5c <HAL_PWREx_WKUP3_Callback>
}
20014be8:	e025      	b.n	20014c36 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF4) != 0U)
20014bea:	4b14      	ldr	r3, [pc, #80]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014bec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20014bee:	f003 0308 	and.w	r3, r3, #8
20014bf2:	2b00      	cmp	r3, #0
20014bf4:	d008      	beq.n	20014c08 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x7c>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP4);
20014bf6:	4b11      	ldr	r3, [pc, #68]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014bf8:	6a1b      	ldr	r3, [r3, #32]
20014bfa:	4a10      	ldr	r2, [pc, #64]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014bfc:	f043 0308 	orr.w	r3, r3, #8
20014c00:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP4_Callback ();
20014c02:	f000 f832 	bl	20014c6a <HAL_PWREx_WKUP4_Callback>
}
20014c06:	e016      	b.n	20014c36 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF5) != 0U)
20014c08:	4b0c      	ldr	r3, [pc, #48]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014c0a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20014c0c:	f003 0310 	and.w	r3, r3, #16
20014c10:	2b00      	cmp	r3, #0
20014c12:	d008      	beq.n	20014c26 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x9a>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP5);
20014c14:	4b09      	ldr	r3, [pc, #36]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014c16:	6a1b      	ldr	r3, [r3, #32]
20014c18:	4a08      	ldr	r2, [pc, #32]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014c1a:	f043 0310 	orr.w	r3, r3, #16
20014c1e:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP5_Callback ();
20014c20:	f000 f82a 	bl	20014c78 <HAL_PWREx_WKUP5_Callback>
}
20014c24:	e007      	b.n	20014c36 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);
20014c26:	4b05      	ldr	r3, [pc, #20]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014c28:	6a1b      	ldr	r3, [r3, #32]
20014c2a:	4a04      	ldr	r2, [pc, #16]	; (20014c3c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
20014c2c:	f043 0320 	orr.w	r3, r3, #32
20014c30:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP6_Callback ();
20014c32:	f000 f828 	bl	20014c86 <HAL_PWREx_WKUP6_Callback>
}
20014c36:	bf00      	nop
20014c38:	bd80      	pop	{r7, pc}
20014c3a:	bf00      	nop
20014c3c:	58024800 	.word	0x58024800

20014c40 <HAL_PWREx_WKUP1_Callback>:
/**
  * @brief PWR WKUP1 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP1_Callback (void)
{
20014c40:	b480      	push	{r7}
20014c42:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP1Callback can be implemented in the user file
  */
}
20014c44:	bf00      	nop
20014c46:	46bd      	mov	sp, r7
20014c48:	f85d 7b04 	ldr.w	r7, [sp], #4
20014c4c:	4770      	bx	lr

20014c4e <HAL_PWREx_WKUP2_Callback>:
/**
  * @brief PWR WKUP2 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP2_Callback (void)
{
20014c4e:	b480      	push	{r7}
20014c50:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP2Callback can be implemented in the user file
  */
}
20014c52:	bf00      	nop
20014c54:	46bd      	mov	sp, r7
20014c56:	f85d 7b04 	ldr.w	r7, [sp], #4
20014c5a:	4770      	bx	lr

20014c5c <HAL_PWREx_WKUP3_Callback>:
/**
  * @brief PWR WKUP3 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP3_Callback (void)
{
20014c5c:	b480      	push	{r7}
20014c5e:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP3Callback can be implemented in the user file
  */
}
20014c60:	bf00      	nop
20014c62:	46bd      	mov	sp, r7
20014c64:	f85d 7b04 	ldr.w	r7, [sp], #4
20014c68:	4770      	bx	lr

20014c6a <HAL_PWREx_WKUP4_Callback>:
/**
  * @brief PWR WKUP4 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP4_Callback (void)
{
20014c6a:	b480      	push	{r7}
20014c6c:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP4Callback can be implemented in the user file
  */
}
20014c6e:	bf00      	nop
20014c70:	46bd      	mov	sp, r7
20014c72:	f85d 7b04 	ldr.w	r7, [sp], #4
20014c76:	4770      	bx	lr

20014c78 <HAL_PWREx_WKUP5_Callback>:
/**
  * @brief PWR WKUP5 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP5_Callback (void)
{
20014c78:	b480      	push	{r7}
20014c7a:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP5Callback can be implemented in the user file
  */
}
20014c7c:	bf00      	nop
20014c7e:	46bd      	mov	sp, r7
20014c80:	f85d 7b04 	ldr.w	r7, [sp], #4
20014c84:	4770      	bx	lr

20014c86 <HAL_PWREx_WKUP6_Callback>:
/**
  * @brief PWR WKUP6 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP6_Callback (void)
{
20014c86:	b480      	push	{r7}
20014c88:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP6Callback can be implemented in the user file
  */
}
20014c8a:	bf00      	nop
20014c8c:	46bd      	mov	sp, r7
20014c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
20014c92:	4770      	bx	lr

20014c94 <HAL_PWREx_EnableBkUpReg>:
/**
  * @brief Enable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg (void)
{
20014c94:	b580      	push	{r7, lr}
20014c96:	b082      	sub	sp, #8
20014c98:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the Backup regulator */
  SET_BIT (PWR->CR2, PWR_CR2_BREN);
20014c9a:	4b10      	ldr	r3, [pc, #64]	; (20014cdc <HAL_PWREx_EnableBkUpReg+0x48>)
20014c9c:	689b      	ldr	r3, [r3, #8]
20014c9e:	4a0f      	ldr	r2, [pc, #60]	; (20014cdc <HAL_PWREx_EnableBkUpReg+0x48>)
20014ca0:	f043 0301 	orr.w	r3, r3, #1
20014ca4:	6093      	str	r3, [r2, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
20014ca6:	f7ed f821 	bl	20001cec <HAL_GetTick>
20014caa:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
20014cac:	e009      	b.n	20014cc2 <HAL_PWREx_EnableBkUpReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
20014cae:	f7ed f81d 	bl	20001cec <HAL_GetTick>
20014cb2:	4602      	mov	r2, r0
20014cb4:	687b      	ldr	r3, [r7, #4]
20014cb6:	1ad3      	subs	r3, r2, r3
20014cb8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
20014cbc:	d901      	bls.n	20014cc2 <HAL_PWREx_EnableBkUpReg+0x2e>
    {
      return HAL_ERROR;
20014cbe:	2301      	movs	r3, #1
20014cc0:	e007      	b.n	20014cd2 <HAL_PWREx_EnableBkUpReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
20014cc2:	4b06      	ldr	r3, [pc, #24]	; (20014cdc <HAL_PWREx_EnableBkUpReg+0x48>)
20014cc4:	689b      	ldr	r3, [r3, #8]
20014cc6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20014cca:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20014cce:	d1ee      	bne.n	20014cae <HAL_PWREx_EnableBkUpReg+0x1a>
    }
  }

  return HAL_OK;
20014cd0:	2300      	movs	r3, #0
}
20014cd2:	4618      	mov	r0, r3
20014cd4:	3708      	adds	r7, #8
20014cd6:	46bd      	mov	sp, r7
20014cd8:	bd80      	pop	{r7, pc}
20014cda:	bf00      	nop
20014cdc:	58024800 	.word	0x58024800

20014ce0 <HAL_PWREx_DisableBkUpReg>:
/**
  * @brief Disable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg (void)
{
20014ce0:	b580      	push	{r7, lr}
20014ce2:	b082      	sub	sp, #8
20014ce4:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the Backup regulator */
  CLEAR_BIT (PWR->CR2, PWR_CR2_BREN);
20014ce6:	4b10      	ldr	r3, [pc, #64]	; (20014d28 <HAL_PWREx_DisableBkUpReg+0x48>)
20014ce8:	689b      	ldr	r3, [r3, #8]
20014cea:	4a0f      	ldr	r2, [pc, #60]	; (20014d28 <HAL_PWREx_DisableBkUpReg+0x48>)
20014cec:	f023 0301 	bic.w	r3, r3, #1
20014cf0:	6093      	str	r3, [r2, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
20014cf2:	f7ec fffb 	bl	20001cec <HAL_GetTick>
20014cf6:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is reset */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
20014cf8:	e009      	b.n	20014d0e <HAL_PWREx_DisableBkUpReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
20014cfa:	f7ec fff7 	bl	20001cec <HAL_GetTick>
20014cfe:	4602      	mov	r2, r0
20014d00:	687b      	ldr	r3, [r7, #4]
20014d02:	1ad3      	subs	r3, r2, r3
20014d04:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
20014d08:	d901      	bls.n	20014d0e <HAL_PWREx_DisableBkUpReg+0x2e>
    {
      return HAL_ERROR;
20014d0a:	2301      	movs	r3, #1
20014d0c:	e007      	b.n	20014d1e <HAL_PWREx_DisableBkUpReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
20014d0e:	4b06      	ldr	r3, [pc, #24]	; (20014d28 <HAL_PWREx_DisableBkUpReg+0x48>)
20014d10:	689b      	ldr	r3, [r3, #8]
20014d12:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20014d16:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20014d1a:	d0ee      	beq.n	20014cfa <HAL_PWREx_DisableBkUpReg+0x1a>
    }
  }

  return HAL_OK;
20014d1c:	2300      	movs	r3, #0
}
20014d1e:	4618      	mov	r0, r3
20014d20:	3708      	adds	r7, #8
20014d22:	46bd      	mov	sp, r7
20014d24:	bd80      	pop	{r7, pc}
20014d26:	bf00      	nop
20014d28:	58024800 	.word	0x58024800

20014d2c <HAL_PWREx_EnableUSBReg>:
/**
  * @brief Enable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableUSBReg (void)
{
20014d2c:	b580      	push	{r7, lr}
20014d2e:	b082      	sub	sp, #8
20014d30:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the USB regulator */
  SET_BIT (PWR->CR3, PWR_CR3_USBREGEN);
20014d32:	4b10      	ldr	r3, [pc, #64]	; (20014d74 <HAL_PWREx_EnableUSBReg+0x48>)
20014d34:	68db      	ldr	r3, [r3, #12]
20014d36:	4a0f      	ldr	r2, [pc, #60]	; (20014d74 <HAL_PWREx_EnableUSBReg+0x48>)
20014d38:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
20014d3c:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
20014d3e:	f7ec ffd5 	bl	20001cec <HAL_GetTick>
20014d42:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
20014d44:	e009      	b.n	20014d5a <HAL_PWREx_EnableUSBReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
20014d46:	f7ec ffd1 	bl	20001cec <HAL_GetTick>
20014d4a:	4602      	mov	r2, r0
20014d4c:	687b      	ldr	r3, [r7, #4]
20014d4e:	1ad3      	subs	r3, r2, r3
20014d50:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
20014d54:	d901      	bls.n	20014d5a <HAL_PWREx_EnableUSBReg+0x2e>
    {
      return HAL_ERROR;
20014d56:	2301      	movs	r3, #1
20014d58:	e007      	b.n	20014d6a <HAL_PWREx_EnableUSBReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
20014d5a:	4b06      	ldr	r3, [pc, #24]	; (20014d74 <HAL_PWREx_EnableUSBReg+0x48>)
20014d5c:	68db      	ldr	r3, [r3, #12]
20014d5e:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
20014d62:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
20014d66:	d1ee      	bne.n	20014d46 <HAL_PWREx_EnableUSBReg+0x1a>
    }
  }

  return HAL_OK;
20014d68:	2300      	movs	r3, #0
}
20014d6a:	4618      	mov	r0, r3
20014d6c:	3708      	adds	r7, #8
20014d6e:	46bd      	mov	sp, r7
20014d70:	bd80      	pop	{r7, pc}
20014d72:	bf00      	nop
20014d74:	58024800 	.word	0x58024800

20014d78 <HAL_PWREx_DisableUSBReg>:
/**
  * @brief Disable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableUSBReg (void)
{
20014d78:	b580      	push	{r7, lr}
20014d7a:	b082      	sub	sp, #8
20014d7c:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the USB regulator */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USBREGEN);
20014d7e:	4b10      	ldr	r3, [pc, #64]	; (20014dc0 <HAL_PWREx_DisableUSBReg+0x48>)
20014d80:	68db      	ldr	r3, [r3, #12]
20014d82:	4a0f      	ldr	r2, [pc, #60]	; (20014dc0 <HAL_PWREx_DisableUSBReg+0x48>)
20014d84:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
20014d88:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
20014d8a:	f7ec ffaf 	bl	20001cec <HAL_GetTick>
20014d8e:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is reset */
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
20014d90:	e009      	b.n	20014da6 <HAL_PWREx_DisableUSBReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
20014d92:	f7ec ffab 	bl	20001cec <HAL_GetTick>
20014d96:	4602      	mov	r2, r0
20014d98:	687b      	ldr	r3, [r7, #4]
20014d9a:	1ad3      	subs	r3, r2, r3
20014d9c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
20014da0:	d901      	bls.n	20014da6 <HAL_PWREx_DisableUSBReg+0x2e>
    {
      return HAL_ERROR;
20014da2:	2301      	movs	r3, #1
20014da4:	e007      	b.n	20014db6 <HAL_PWREx_DisableUSBReg+0x3e>
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
20014da6:	4b06      	ldr	r3, [pc, #24]	; (20014dc0 <HAL_PWREx_DisableUSBReg+0x48>)
20014da8:	68db      	ldr	r3, [r3, #12]
20014daa:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
20014dae:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
20014db2:	d0ee      	beq.n	20014d92 <HAL_PWREx_DisableUSBReg+0x1a>
    }
  }

  return HAL_OK;
20014db4:	2300      	movs	r3, #0
}
20014db6:	4618      	mov	r0, r3
20014db8:	3708      	adds	r7, #8
20014dba:	46bd      	mov	sp, r7
20014dbc:	bd80      	pop	{r7, pc}
20014dbe:	bf00      	nop
20014dc0:	58024800 	.word	0x58024800

20014dc4 <HAL_PWREx_EnableUSBVoltageDetector>:
/**
  * @brief Enable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
20014dc4:	b480      	push	{r7}
20014dc6:	af00      	add	r7, sp, #0
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
20014dc8:	4b05      	ldr	r3, [pc, #20]	; (20014de0 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
20014dca:	68db      	ldr	r3, [r3, #12]
20014dcc:	4a04      	ldr	r2, [pc, #16]	; (20014de0 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
20014dce:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
20014dd2:	60d3      	str	r3, [r2, #12]
}
20014dd4:	bf00      	nop
20014dd6:	46bd      	mov	sp, r7
20014dd8:	f85d 7b04 	ldr.w	r7, [sp], #4
20014ddc:	4770      	bx	lr
20014dde:	bf00      	nop
20014de0:	58024800 	.word	0x58024800

20014de4 <HAL_PWREx_DisableUSBVoltageDetector>:
/**
  * @brief Disable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
20014de4:	b480      	push	{r7}
20014de6:	af00      	add	r7, sp, #0
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
20014de8:	4b05      	ldr	r3, [pc, #20]	; (20014e00 <HAL_PWREx_DisableUSBVoltageDetector+0x1c>)
20014dea:	68db      	ldr	r3, [r3, #12]
20014dec:	4a04      	ldr	r2, [pc, #16]	; (20014e00 <HAL_PWREx_DisableUSBVoltageDetector+0x1c>)
20014dee:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
20014df2:	60d3      	str	r3, [r2, #12]
}
20014df4:	bf00      	nop
20014df6:	46bd      	mov	sp, r7
20014df8:	f85d 7b04 	ldr.w	r7, [sp], #4
20014dfc:	4770      	bx	lr
20014dfe:	bf00      	nop
20014e00:	58024800 	.word	0x58024800

20014e04 <HAL_PWREx_EnableBatteryCharging>:
  *            @arg PWR_BATTERY_CHARGING_RESISTOR_5 : 5 KOhm resistor.
  *            @arg PWR_BATTERY_CHARGING_RESISTOR_1_5 : 1.5 KOhm resistor.
  * @retval None.
  */
void HAL_PWREx_EnableBatteryCharging (uint32_t ResistorValue)
{
20014e04:	b580      	push	{r7, lr}
20014e06:	b082      	sub	sp, #8
20014e08:	af00      	add	r7, sp, #0
20014e0a:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_BATTERY_RESISTOR_SELECT (ResistorValue));
20014e0c:	687b      	ldr	r3, [r7, #4]
20014e0e:	2b00      	cmp	r3, #0
20014e10:	d008      	beq.n	20014e24 <HAL_PWREx_EnableBatteryCharging+0x20>
20014e12:	687b      	ldr	r3, [r7, #4]
20014e14:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20014e18:	d004      	beq.n	20014e24 <HAL_PWREx_EnableBatteryCharging+0x20>
20014e1a:	f240 61b3 	movw	r1, #1715	; 0x6b3
20014e1e:	480a      	ldr	r0, [pc, #40]	; (20014e48 <HAL_PWREx_EnableBatteryCharging+0x44>)
20014e20:	f7eb fd68 	bl	200008f4 <assert_failed>

  /* Specify the charging resistor */
  MODIFY_REG (PWR->CR3, PWR_CR3_VBRS, ResistorValue);
20014e24:	4b09      	ldr	r3, [pc, #36]	; (20014e4c <HAL_PWREx_EnableBatteryCharging+0x48>)
20014e26:	68db      	ldr	r3, [r3, #12]
20014e28:	f423 7200 	bic.w	r2, r3, #512	; 0x200
20014e2c:	4907      	ldr	r1, [pc, #28]	; (20014e4c <HAL_PWREx_EnableBatteryCharging+0x48>)
20014e2e:	687b      	ldr	r3, [r7, #4]
20014e30:	4313      	orrs	r3, r2
20014e32:	60cb      	str	r3, [r1, #12]

  /* Enable the Battery charging */
  SET_BIT (PWR->CR3, PWR_CR3_VBE);
20014e34:	4b05      	ldr	r3, [pc, #20]	; (20014e4c <HAL_PWREx_EnableBatteryCharging+0x48>)
20014e36:	68db      	ldr	r3, [r3, #12]
20014e38:	4a04      	ldr	r2, [pc, #16]	; (20014e4c <HAL_PWREx_EnableBatteryCharging+0x48>)
20014e3a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20014e3e:	60d3      	str	r3, [r2, #12]
}
20014e40:	bf00      	nop
20014e42:	3708      	adds	r7, #8
20014e44:	46bd      	mov	sp, r7
20014e46:	bd80      	pop	{r7, pc}
20014e48:	2001c268 	.word	0x2001c268
20014e4c:	58024800 	.word	0x58024800

20014e50 <HAL_PWREx_DisableBatteryCharging>:
/**
  * @brief Disable the Battery charging.
  * @retval None.
  */
void HAL_PWREx_DisableBatteryCharging (void)
{
20014e50:	b480      	push	{r7}
20014e52:	af00      	add	r7, sp, #0
  /* Disable the Battery charging */
  CLEAR_BIT (PWR->CR3, PWR_CR3_VBE);
20014e54:	4b05      	ldr	r3, [pc, #20]	; (20014e6c <HAL_PWREx_DisableBatteryCharging+0x1c>)
20014e56:	68db      	ldr	r3, [r3, #12]
20014e58:	4a04      	ldr	r2, [pc, #16]	; (20014e6c <HAL_PWREx_DisableBatteryCharging+0x1c>)
20014e5a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20014e5e:	60d3      	str	r3, [r2, #12]
}
20014e60:	bf00      	nop
20014e62:	46bd      	mov	sp, r7
20014e64:	f85d 7b04 	ldr.w	r7, [sp], #4
20014e68:	4770      	bx	lr
20014e6a:	bf00      	nop
20014e6c:	58024800 	.word	0x58024800

20014e70 <HAL_PWREx_EnableMonitoring>:
/**
  * @brief Enable the VBAT and temperature monitoring.
  * @retval HAL status.
  */
void HAL_PWREx_EnableMonitoring (void)
{
20014e70:	b480      	push	{r7}
20014e72:	af00      	add	r7, sp, #0
  /* Enable the VBAT and Temperature monitoring */
  SET_BIT (PWR->CR2, PWR_CR2_MONEN);
20014e74:	4b05      	ldr	r3, [pc, #20]	; (20014e8c <HAL_PWREx_EnableMonitoring+0x1c>)
20014e76:	689b      	ldr	r3, [r3, #8]
20014e78:	4a04      	ldr	r2, [pc, #16]	; (20014e8c <HAL_PWREx_EnableMonitoring+0x1c>)
20014e7a:	f043 0310 	orr.w	r3, r3, #16
20014e7e:	6093      	str	r3, [r2, #8]
}
20014e80:	bf00      	nop
20014e82:	46bd      	mov	sp, r7
20014e84:	f85d 7b04 	ldr.w	r7, [sp], #4
20014e88:	4770      	bx	lr
20014e8a:	bf00      	nop
20014e8c:	58024800 	.word	0x58024800

20014e90 <HAL_PWREx_DisableMonitoring>:
/**
  * @brief Disable the VBAT and temperature monitoring.
  * @retval HAL status.
  */
void HAL_PWREx_DisableMonitoring (void)
{
20014e90:	b480      	push	{r7}
20014e92:	af00      	add	r7, sp, #0
  /* Disable the VBAT and Temperature monitoring */
  CLEAR_BIT (PWR->CR2, PWR_CR2_MONEN);
20014e94:	4b05      	ldr	r3, [pc, #20]	; (20014eac <HAL_PWREx_DisableMonitoring+0x1c>)
20014e96:	689b      	ldr	r3, [r3, #8]
20014e98:	4a04      	ldr	r2, [pc, #16]	; (20014eac <HAL_PWREx_DisableMonitoring+0x1c>)
20014e9a:	f023 0310 	bic.w	r3, r3, #16
20014e9e:	6093      	str	r3, [r2, #8]
}
20014ea0:	bf00      	nop
20014ea2:	46bd      	mov	sp, r7
20014ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
20014ea8:	4770      	bx	lr
20014eaa:	bf00      	nop
20014eac:	58024800 	.word	0x58024800

20014eb0 <HAL_PWREx_GetTemperatureLevel>:
  * @brief Indicate whether the junction temperature is between, above or below
  *        the thresholds.
  * @retval Temperature level.
  */
uint32_t HAL_PWREx_GetTemperatureLevel (void)
{
20014eb0:	b480      	push	{r7}
20014eb2:	b083      	sub	sp, #12
20014eb4:	af00      	add	r7, sp, #0
  uint32_t tempLevel, regValue;

  /* Read the temperature flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_TEMPH | PWR_CR2_TEMPL));
20014eb6:	4b0f      	ldr	r3, [pc, #60]	; (20014ef4 <HAL_PWREx_GetTemperatureLevel+0x44>)
20014eb8:	689b      	ldr	r3, [r3, #8]
20014eba:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
20014ebe:	603b      	str	r3, [r7, #0]

  /* Check if the temperature is below the threshold */
  if (regValue == PWR_CR2_TEMPL)
20014ec0:	683b      	ldr	r3, [r7, #0]
20014ec2:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
20014ec6:	d103      	bne.n	20014ed0 <HAL_PWREx_GetTemperatureLevel+0x20>
  {
    tempLevel = PWR_TEMP_BELOW_LOW_THRESHOLD;
20014ec8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
20014ecc:	607b      	str	r3, [r7, #4]
20014ece:	e009      	b.n	20014ee4 <HAL_PWREx_GetTemperatureLevel+0x34>
  }
  /* Check if the temperature is above the threshold */
  else if (regValue == PWR_CR2_TEMPH)
20014ed0:	683b      	ldr	r3, [r7, #0]
20014ed2:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
20014ed6:	d103      	bne.n	20014ee0 <HAL_PWREx_GetTemperatureLevel+0x30>
  {
    tempLevel = PWR_TEMP_ABOVE_HIGH_THRESHOLD;
20014ed8:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
20014edc:	607b      	str	r3, [r7, #4]
20014ede:	e001      	b.n	20014ee4 <HAL_PWREx_GetTemperatureLevel+0x34>
  }
  /* The temperature is between the thresholds */
  else
  {
    tempLevel = PWR_TEMP_BETWEEN_HIGH_LOW_THRESHOLD;
20014ee0:	2300      	movs	r3, #0
20014ee2:	607b      	str	r3, [r7, #4]
  }

  return tempLevel;
20014ee4:	687b      	ldr	r3, [r7, #4]
}
20014ee6:	4618      	mov	r0, r3
20014ee8:	370c      	adds	r7, #12
20014eea:	46bd      	mov	sp, r7
20014eec:	f85d 7b04 	ldr.w	r7, [sp], #4
20014ef0:	4770      	bx	lr
20014ef2:	bf00      	nop
20014ef4:	58024800 	.word	0x58024800

20014ef8 <HAL_PWREx_GetVBATLevel>:
  * @brief Indicate whether the Battery voltage level is between, above or below
  *        the thresholds.
  * @retval VBAT level.
  */
uint32_t HAL_PWREx_GetVBATLevel (void)
{
20014ef8:	b480      	push	{r7}
20014efa:	b083      	sub	sp, #12
20014efc:	af00      	add	r7, sp, #0
  uint32_t VBATLevel, regValue;

  /* Read the VBAT flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_VBATH | PWR_CR2_VBATL));
20014efe:	4b0f      	ldr	r3, [pc, #60]	; (20014f3c <HAL_PWREx_GetVBATLevel+0x44>)
20014f00:	689b      	ldr	r3, [r3, #8]
20014f02:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20014f06:	603b      	str	r3, [r7, #0]

  /* Check if the VBAT is below the threshold */
  if (regValue == PWR_CR2_VBATL)
20014f08:	683b      	ldr	r3, [r7, #0]
20014f0a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
20014f0e:	d103      	bne.n	20014f18 <HAL_PWREx_GetVBATLevel+0x20>
  {
    VBATLevel = PWR_VBAT_BELOW_LOW_THRESHOLD;
20014f10:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
20014f14:	607b      	str	r3, [r7, #4]
20014f16:	e009      	b.n	20014f2c <HAL_PWREx_GetVBATLevel+0x34>
  }
  /* Check if the VBAT is above the threshold */
  else if (regValue == PWR_CR2_VBATH)
20014f18:	683b      	ldr	r3, [r7, #0]
20014f1a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
20014f1e:	d103      	bne.n	20014f28 <HAL_PWREx_GetVBATLevel+0x30>
  {
    VBATLevel = PWR_VBAT_ABOVE_HIGH_THRESHOLD;
20014f20:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
20014f24:	607b      	str	r3, [r7, #4]
20014f26:	e001      	b.n	20014f2c <HAL_PWREx_GetVBATLevel+0x34>
  }
  /* The VBAT is between the thresholds */
  else
  {
    VBATLevel = PWR_VBAT_BETWEEN_HIGH_LOW_THRESHOLD;
20014f28:	2300      	movs	r3, #0
20014f2a:	607b      	str	r3, [r7, #4]
  }

  return VBATLevel;
20014f2c:	687b      	ldr	r3, [r7, #4]
}
20014f2e:	4618      	mov	r0, r3
20014f30:	370c      	adds	r7, #12
20014f32:	46bd      	mov	sp, r7
20014f34:	f85d 7b04 	ldr.w	r7, [sp], #4
20014f38:	4770      	bx	lr
20014f3a:	bf00      	nop
20014f3c:	58024800 	.word	0x58024800

20014f40 <HAL_PWREx_ConfigAVD>:
  *         driver. All combination are allowed: wake up only Cortex-M7, wake up
  *         only Cortex-M4 and wake up Cortex-M7 and Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ConfigAVD (PWREx_AVDTypeDef *sConfigAVD)
{
20014f40:	b580      	push	{r7, lr}
20014f42:	b082      	sub	sp, #8
20014f44:	af00      	add	r7, sp, #0
20014f46:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_AVD_LEVEL (sConfigAVD->AVDLevel));
20014f48:	687b      	ldr	r3, [r7, #4]
20014f4a:	681b      	ldr	r3, [r3, #0]
20014f4c:	2b00      	cmp	r3, #0
20014f4e:	d013      	beq.n	20014f78 <HAL_PWREx_ConfigAVD+0x38>
20014f50:	687b      	ldr	r3, [r7, #4]
20014f52:	681b      	ldr	r3, [r3, #0]
20014f54:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20014f58:	d00e      	beq.n	20014f78 <HAL_PWREx_ConfigAVD+0x38>
20014f5a:	687b      	ldr	r3, [r7, #4]
20014f5c:	681b      	ldr	r3, [r3, #0]
20014f5e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
20014f62:	d009      	beq.n	20014f78 <HAL_PWREx_ConfigAVD+0x38>
20014f64:	687b      	ldr	r3, [r7, #4]
20014f66:	681b      	ldr	r3, [r3, #0]
20014f68:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
20014f6c:	d004      	beq.n	20014f78 <HAL_PWREx_ConfigAVD+0x38>
20014f6e:	f44f 61f2 	mov.w	r1, #1936	; 0x790
20014f72:	484b      	ldr	r0, [pc, #300]	; (200150a0 <HAL_PWREx_ConfigAVD+0x160>)
20014f74:	f7eb fcbe 	bl	200008f4 <assert_failed>
  assert_param (IS_PWR_AVD_MODE (sConfigAVD->Mode));
20014f78:	687b      	ldr	r3, [r7, #4]
20014f7a:	685b      	ldr	r3, [r3, #4]
20014f7c:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
20014f80:	d021      	beq.n	20014fc6 <HAL_PWREx_ConfigAVD+0x86>
20014f82:	687b      	ldr	r3, [r7, #4]
20014f84:	685b      	ldr	r3, [r3, #4]
20014f86:	4a47      	ldr	r2, [pc, #284]	; (200150a4 <HAL_PWREx_ConfigAVD+0x164>)
20014f88:	4293      	cmp	r3, r2
20014f8a:	d01c      	beq.n	20014fc6 <HAL_PWREx_ConfigAVD+0x86>
20014f8c:	687b      	ldr	r3, [r7, #4]
20014f8e:	685b      	ldr	r3, [r3, #4]
20014f90:	4a45      	ldr	r2, [pc, #276]	; (200150a8 <HAL_PWREx_ConfigAVD+0x168>)
20014f92:	4293      	cmp	r3, r2
20014f94:	d017      	beq.n	20014fc6 <HAL_PWREx_ConfigAVD+0x86>
20014f96:	687b      	ldr	r3, [r7, #4]
20014f98:	685b      	ldr	r3, [r3, #4]
20014f9a:	4a44      	ldr	r2, [pc, #272]	; (200150ac <HAL_PWREx_ConfigAVD+0x16c>)
20014f9c:	4293      	cmp	r3, r2
20014f9e:	d012      	beq.n	20014fc6 <HAL_PWREx_ConfigAVD+0x86>
20014fa0:	687b      	ldr	r3, [r7, #4]
20014fa2:	685b      	ldr	r3, [r3, #4]
20014fa4:	f1b3 1f02 	cmp.w	r3, #131074	; 0x20002
20014fa8:	d00d      	beq.n	20014fc6 <HAL_PWREx_ConfigAVD+0x86>
20014faa:	687b      	ldr	r3, [r7, #4]
20014fac:	685b      	ldr	r3, [r3, #4]
20014fae:	2b00      	cmp	r3, #0
20014fb0:	d009      	beq.n	20014fc6 <HAL_PWREx_ConfigAVD+0x86>
20014fb2:	687b      	ldr	r3, [r7, #4]
20014fb4:	685b      	ldr	r3, [r3, #4]
20014fb6:	4a3e      	ldr	r2, [pc, #248]	; (200150b0 <HAL_PWREx_ConfigAVD+0x170>)
20014fb8:	4293      	cmp	r3, r2
20014fba:	d004      	beq.n	20014fc6 <HAL_PWREx_ConfigAVD+0x86>
20014fbc:	f240 7191 	movw	r1, #1937	; 0x791
20014fc0:	4837      	ldr	r0, [pc, #220]	; (200150a0 <HAL_PWREx_ConfigAVD+0x160>)
20014fc2:	f7eb fc97 	bl	200008f4 <assert_failed>

  /* Set the ALS[18:17] bits according to AVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_ALS, sConfigAVD->AVDLevel);
20014fc6:	4b3b      	ldr	r3, [pc, #236]	; (200150b4 <HAL_PWREx_ConfigAVD+0x174>)
20014fc8:	681b      	ldr	r3, [r3, #0]
20014fca:	f423 22c0 	bic.w	r2, r3, #393216	; 0x60000
20014fce:	687b      	ldr	r3, [r7, #4]
20014fd0:	681b      	ldr	r3, [r3, #0]
20014fd2:	4938      	ldr	r1, [pc, #224]	; (200150b4 <HAL_PWREx_ConfigAVD+0x174>)
20014fd4:	4313      	orrs	r3, r2
20014fd6:	600b      	str	r3, [r1, #0]

  /* Clear any previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_AVD_EXTI_DISABLE_EVENT ();
20014fd8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20014fdc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
20014fe0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20014fe4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20014fe8:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __HAL_PWR_AVD_EXTI_DISABLE_IT ();
20014fec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20014ff0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
20014ff4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20014ff8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20014ffc:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_AVD_EXTI_DISABLE_RISING_EDGE ();
20015000:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20015004:	681b      	ldr	r3, [r3, #0]
20015006:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2001500a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2001500e:	6013      	str	r3, [r2, #0]
  __HAL_PWR_AVD_EXTI_DISABLE_FALLING_EDGE ();
20015010:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20015014:	685b      	ldr	r3, [r3, #4]
20015016:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2001501a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2001501e:	6053      	str	r3, [r2, #4]

#if !defined (DUAL_CORE)
  /* Configure the interrupt mode */
  if ((sConfigAVD->Mode & AVD_MODE_IT) == AVD_MODE_IT)
20015020:	687b      	ldr	r3, [r7, #4]
20015022:	685b      	ldr	r3, [r3, #4]
20015024:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20015028:	2b00      	cmp	r3, #0
2001502a:	d009      	beq.n	20015040 <HAL_PWREx_ConfigAVD+0x100>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_IT ();
2001502c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20015030:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
20015034:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20015038:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2001503c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }

  /* Configure the event mode */
  if ((sConfigAVD->Mode & AVD_MODE_EVT) == AVD_MODE_EVT)
20015040:	687b      	ldr	r3, [r7, #4]
20015042:	685b      	ldr	r3, [r3, #4]
20015044:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20015048:	2b00      	cmp	r3, #0
2001504a:	d009      	beq.n	20015060 <HAL_PWREx_ConfigAVD+0x120>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_EVENT ();
2001504c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20015050:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
20015054:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20015058:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2001505c:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigAVD->Mode & AVD_RISING_EDGE) == AVD_RISING_EDGE)
20015060:	687b      	ldr	r3, [r7, #4]
20015062:	685b      	ldr	r3, [r3, #4]
20015064:	f003 0301 	and.w	r3, r3, #1
20015068:	2b00      	cmp	r3, #0
2001506a:	d007      	beq.n	2001507c <HAL_PWREx_ConfigAVD+0x13c>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_RISING_EDGE ();
2001506c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20015070:	681b      	ldr	r3, [r3, #0]
20015072:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20015076:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2001507a:	6013      	str	r3, [r2, #0]
  }

  /* Falling edge configuration */
  if ((sConfigAVD->Mode & AVD_FALLING_EDGE) == AVD_FALLING_EDGE)
2001507c:	687b      	ldr	r3, [r7, #4]
2001507e:	685b      	ldr	r3, [r3, #4]
20015080:	f003 0302 	and.w	r3, r3, #2
20015084:	2b00      	cmp	r3, #0
20015086:	d007      	beq.n	20015098 <HAL_PWREx_ConfigAVD+0x158>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_FALLING_EDGE ();
20015088:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2001508c:	685b      	ldr	r3, [r3, #4]
2001508e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20015092:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20015096:	6053      	str	r3, [r2, #4]
  }
}
20015098:	bf00      	nop
2001509a:	3708      	adds	r7, #8
2001509c:	46bd      	mov	sp, r7
2001509e:	bd80      	pop	{r7, pc}
200150a0:	2001c268 	.word	0x2001c268
200150a4:	00010002 	.word	0x00010002
200150a8:	00010003 	.word	0x00010003
200150ac:	00020001 	.word	0x00020001
200150b0:	00020003 	.word	0x00020003
200150b4:	58024800 	.word	0x58024800

200150b8 <HAL_PWREx_EnableAVD>:
/**
  * @brief Enable the Analog Voltage Detector (AVD).
  * @retval None.
  */
void HAL_PWREx_EnableAVD (void)
{
200150b8:	b480      	push	{r7}
200150ba:	af00      	add	r7, sp, #0
  /* Enable the Analog Voltage Detector */
  SET_BIT (PWR->CR1, PWR_CR1_AVDEN);
200150bc:	4b05      	ldr	r3, [pc, #20]	; (200150d4 <HAL_PWREx_EnableAVD+0x1c>)
200150be:	681b      	ldr	r3, [r3, #0]
200150c0:	4a04      	ldr	r2, [pc, #16]	; (200150d4 <HAL_PWREx_EnableAVD+0x1c>)
200150c2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200150c6:	6013      	str	r3, [r2, #0]
}
200150c8:	bf00      	nop
200150ca:	46bd      	mov	sp, r7
200150cc:	f85d 7b04 	ldr.w	r7, [sp], #4
200150d0:	4770      	bx	lr
200150d2:	bf00      	nop
200150d4:	58024800 	.word	0x58024800

200150d8 <HAL_PWREx_DisableAVD>:
/**
  * @brief Disable the Analog Voltage Detector(AVD).
  * @retval None.
  */
void HAL_PWREx_DisableAVD (void)
{
200150d8:	b480      	push	{r7}
200150da:	af00      	add	r7, sp, #0
  /* Disable the Analog Voltage Detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_AVDEN);
200150dc:	4b05      	ldr	r3, [pc, #20]	; (200150f4 <HAL_PWREx_DisableAVD+0x1c>)
200150de:	681b      	ldr	r3, [r3, #0]
200150e0:	4a04      	ldr	r2, [pc, #16]	; (200150f4 <HAL_PWREx_DisableAVD+0x1c>)
200150e2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
200150e6:	6013      	str	r3, [r2, #0]
}
200150e8:	bf00      	nop
200150ea:	46bd      	mov	sp, r7
200150ec:	f85d 7b04 	ldr.w	r7, [sp], #4
200150f0:	4770      	bx	lr
200150f2:	bf00      	nop
200150f4:	58024800 	.word	0x58024800

200150f8 <HAL_PWREx_PVD_AVD_IRQHandler>:
  * @brief  This function handles the PWR PVD/AVD interrupt request.
  * @note   This API should be called under the PVD_AVD_IRQHandler().
  * @retval None
  */
void HAL_PWREx_PVD_AVD_IRQHandler (void)
{
200150f8:	b580      	push	{r7, lr}
200150fa:	af00      	add	r7, sp, #0
  /* Check if the Programmable Voltage Detector is enabled (PVD) */
  if(READ_BIT (PWR->CR1, PWR_CR1_PVDEN) != 0U)
200150fc:	4b1b      	ldr	r3, [pc, #108]	; (2001516c <HAL_PWREx_PVD_AVD_IRQHandler+0x74>)
200150fe:	681b      	ldr	r3, [r3, #0]
20015100:	f003 0310 	and.w	r3, r3, #16
20015104:	2b00      	cmp	r3, #0
20015106:	d014      	beq.n	20015132 <HAL_PWREx_PVD_AVD_IRQHandler+0x3a>
#if defined (DUAL_CORE)
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
#endif /* defined (DUAL_CORE) */
    {
      /* Check PWR D1/CD EXTI flag */
      if(__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
20015108:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2001510c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20015110:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20015114:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20015118:	d10b      	bne.n	20015132 <HAL_PWREx_PVD_AVD_IRQHandler+0x3a>
      {
        /* PWR PVD interrupt user callback */
        HAL_PWR_PVDCallback ();
2001511a:	f7ff f960 	bl	200143de <HAL_PWR_PVDCallback>

        /* Clear PWR EXTI D1/CD pending bit */
        __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
2001511e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20015122:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20015126:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2001512a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2001512e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    }
#endif /* defined (DUAL_CORE) */
  }

  /* Check if the Analog Voltage Detector is enabled (AVD) */
  if (READ_BIT (PWR->CR1, PWR_CR1_AVDEN) != 0U)
20015132:	4b0e      	ldr	r3, [pc, #56]	; (2001516c <HAL_PWREx_PVD_AVD_IRQHandler+0x74>)
20015134:	681b      	ldr	r3, [r3, #0]
20015136:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2001513a:	2b00      	cmp	r3, #0
2001513c:	d014      	beq.n	20015168 <HAL_PWREx_PVD_AVD_IRQHandler+0x70>
#if defined (DUAL_CORE)
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
#endif /* defined (DUAL_CORE) */
    {
      /* Check PWR EXTI D1/CD flag */
      if (__HAL_PWR_AVD_EXTI_GET_FLAG () != 0U)
2001513e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20015142:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20015146:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2001514a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2001514e:	d10b      	bne.n	20015168 <HAL_PWREx_PVD_AVD_IRQHandler+0x70>
      {
        /* PWR AVD interrupt user callback */
        HAL_PWREx_AVDCallback ();
20015150:	f000 f80e 	bl	20015170 <HAL_PWREx_AVDCallback>

        /* Clear PWR EXTI D1/CD pending bit */
        __HAL_PWR_AVD_EXTI_CLEAR_FLAG ();
20015154:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
20015158:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2001515c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
20015160:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20015164:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
        __HAL_PWR_AVD_EXTID2_CLEAR_FLAG ();
      }
    }
#endif /* defined (DUAL_CORE) */
  }
}
20015168:	bf00      	nop
2001516a:	bd80      	pop	{r7, pc}
2001516c:	58024800 	.word	0x58024800

20015170 <HAL_PWREx_AVDCallback>:
/**
  * @brief PWR AVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_AVDCallback (void)
{
20015170:	b480      	push	{r7}
20015172:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_AVDCallback can be implemented in the user file
  */
}
20015174:	bf00      	nop
20015176:	46bd      	mov	sp, r7
20015178:	f85d 7b04 	ldr.w	r7, [sp], #4
2001517c:	4770      	bx	lr
	...

20015180 <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and initialize the associated handle.
  * @param hqspi : QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
20015180:	b580      	push	{r7, lr}
20015182:	b086      	sub	sp, #24
20015184:	af02      	add	r7, sp, #8
20015186:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
20015188:	f7ec fdb0 	bl	20001cec <HAL_GetTick>
2001518c:	60f8      	str	r0, [r7, #12]

  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
2001518e:	687b      	ldr	r3, [r7, #4]
20015190:	2b00      	cmp	r3, #0
20015192:	d101      	bne.n	20015198 <HAL_QSPI_Init+0x18>
  {
    return HAL_ERROR;
20015194:	2301      	movs	r3, #1
20015196:	e0ec      	b.n	20015372 <HAL_QSPI_Init+0x1f2>
  }

  /* Check the parameters */
  assert_param(IS_QSPI_ALL_INSTANCE(hqspi->Instance));
20015198:	687b      	ldr	r3, [r7, #4]
2001519a:	681b      	ldr	r3, [r3, #0]
2001519c:	4a77      	ldr	r2, [pc, #476]	; (2001537c <HAL_QSPI_Init+0x1fc>)
2001519e:	4293      	cmp	r3, r2
200151a0:	d004      	beq.n	200151ac <HAL_QSPI_Init+0x2c>
200151a2:	f44f 719f 	mov.w	r1, #318	; 0x13e
200151a6:	4876      	ldr	r0, [pc, #472]	; (20015380 <HAL_QSPI_Init+0x200>)
200151a8:	f7eb fba4 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_CLOCK_PRESCALER(hqspi->Init.ClockPrescaler));
200151ac:	687b      	ldr	r3, [r7, #4]
200151ae:	685b      	ldr	r3, [r3, #4]
200151b0:	2bff      	cmp	r3, #255	; 0xff
200151b2:	d904      	bls.n	200151be <HAL_QSPI_Init+0x3e>
200151b4:	f240 113f 	movw	r1, #319	; 0x13f
200151b8:	4871      	ldr	r0, [pc, #452]	; (20015380 <HAL_QSPI_Init+0x200>)
200151ba:	f7eb fb9b 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_FIFO_THRESHOLD(hqspi->Init.FifoThreshold));
200151be:	687b      	ldr	r3, [r7, #4]
200151c0:	689b      	ldr	r3, [r3, #8]
200151c2:	2b00      	cmp	r3, #0
200151c4:	d003      	beq.n	200151ce <HAL_QSPI_Init+0x4e>
200151c6:	687b      	ldr	r3, [r7, #4]
200151c8:	689b      	ldr	r3, [r3, #8]
200151ca:	2b20      	cmp	r3, #32
200151cc:	d904      	bls.n	200151d8 <HAL_QSPI_Init+0x58>
200151ce:	f44f 71a0 	mov.w	r1, #320	; 0x140
200151d2:	486b      	ldr	r0, [pc, #428]	; (20015380 <HAL_QSPI_Init+0x200>)
200151d4:	f7eb fb8e 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_SSHIFT(hqspi->Init.SampleShifting));
200151d8:	687b      	ldr	r3, [r7, #4]
200151da:	68db      	ldr	r3, [r3, #12]
200151dc:	2b00      	cmp	r3, #0
200151de:	d008      	beq.n	200151f2 <HAL_QSPI_Init+0x72>
200151e0:	687b      	ldr	r3, [r7, #4]
200151e2:	68db      	ldr	r3, [r3, #12]
200151e4:	2b10      	cmp	r3, #16
200151e6:	d004      	beq.n	200151f2 <HAL_QSPI_Init+0x72>
200151e8:	f240 1141 	movw	r1, #321	; 0x141
200151ec:	4864      	ldr	r0, [pc, #400]	; (20015380 <HAL_QSPI_Init+0x200>)
200151ee:	f7eb fb81 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_FLASH_SIZE(hqspi->Init.FlashSize));
200151f2:	687b      	ldr	r3, [r7, #4]
200151f4:	691b      	ldr	r3, [r3, #16]
200151f6:	2b1f      	cmp	r3, #31
200151f8:	d904      	bls.n	20015204 <HAL_QSPI_Init+0x84>
200151fa:	f44f 71a1 	mov.w	r1, #322	; 0x142
200151fe:	4860      	ldr	r0, [pc, #384]	; (20015380 <HAL_QSPI_Init+0x200>)
20015200:	f7eb fb78 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_CS_HIGH_TIME(hqspi->Init.ChipSelectHighTime));
20015204:	687b      	ldr	r3, [r7, #4]
20015206:	695b      	ldr	r3, [r3, #20]
20015208:	2b00      	cmp	r3, #0
2001520a:	d027      	beq.n	2001525c <HAL_QSPI_Init+0xdc>
2001520c:	687b      	ldr	r3, [r7, #4]
2001520e:	695b      	ldr	r3, [r3, #20]
20015210:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20015214:	d022      	beq.n	2001525c <HAL_QSPI_Init+0xdc>
20015216:	687b      	ldr	r3, [r7, #4]
20015218:	695b      	ldr	r3, [r3, #20]
2001521a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2001521e:	d01d      	beq.n	2001525c <HAL_QSPI_Init+0xdc>
20015220:	687b      	ldr	r3, [r7, #4]
20015222:	695b      	ldr	r3, [r3, #20]
20015224:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
20015228:	d018      	beq.n	2001525c <HAL_QSPI_Init+0xdc>
2001522a:	687b      	ldr	r3, [r7, #4]
2001522c:	695b      	ldr	r3, [r3, #20]
2001522e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20015232:	d013      	beq.n	2001525c <HAL_QSPI_Init+0xdc>
20015234:	687b      	ldr	r3, [r7, #4]
20015236:	695b      	ldr	r3, [r3, #20]
20015238:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
2001523c:	d00e      	beq.n	2001525c <HAL_QSPI_Init+0xdc>
2001523e:	687b      	ldr	r3, [r7, #4]
20015240:	695b      	ldr	r3, [r3, #20]
20015242:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
20015246:	d009      	beq.n	2001525c <HAL_QSPI_Init+0xdc>
20015248:	687b      	ldr	r3, [r7, #4]
2001524a:	695b      	ldr	r3, [r3, #20]
2001524c:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
20015250:	d004      	beq.n	2001525c <HAL_QSPI_Init+0xdc>
20015252:	f240 1143 	movw	r1, #323	; 0x143
20015256:	484a      	ldr	r0, [pc, #296]	; (20015380 <HAL_QSPI_Init+0x200>)
20015258:	f7eb fb4c 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_CLOCK_MODE(hqspi->Init.ClockMode));
2001525c:	687b      	ldr	r3, [r7, #4]
2001525e:	699b      	ldr	r3, [r3, #24]
20015260:	2b00      	cmp	r3, #0
20015262:	d008      	beq.n	20015276 <HAL_QSPI_Init+0xf6>
20015264:	687b      	ldr	r3, [r7, #4]
20015266:	699b      	ldr	r3, [r3, #24]
20015268:	2b01      	cmp	r3, #1
2001526a:	d004      	beq.n	20015276 <HAL_QSPI_Init+0xf6>
2001526c:	f44f 71a2 	mov.w	r1, #324	; 0x144
20015270:	4843      	ldr	r0, [pc, #268]	; (20015380 <HAL_QSPI_Init+0x200>)
20015272:	f7eb fb3f 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DUAL_FLASH_MODE(hqspi->Init.DualFlash));
20015276:	687b      	ldr	r3, [r7, #4]
20015278:	6a1b      	ldr	r3, [r3, #32]
2001527a:	2b40      	cmp	r3, #64	; 0x40
2001527c:	d008      	beq.n	20015290 <HAL_QSPI_Init+0x110>
2001527e:	687b      	ldr	r3, [r7, #4]
20015280:	6a1b      	ldr	r3, [r3, #32]
20015282:	2b00      	cmp	r3, #0
20015284:	d004      	beq.n	20015290 <HAL_QSPI_Init+0x110>
20015286:	f240 1145 	movw	r1, #325	; 0x145
2001528a:	483d      	ldr	r0, [pc, #244]	; (20015380 <HAL_QSPI_Init+0x200>)
2001528c:	f7eb fb32 	bl	200008f4 <assert_failed>

  if (hqspi->Init.DualFlash != QSPI_DUALFLASH_ENABLE )
20015290:	687b      	ldr	r3, [r7, #4]
20015292:	6a1b      	ldr	r3, [r3, #32]
20015294:	2b40      	cmp	r3, #64	; 0x40
20015296:	d00c      	beq.n	200152b2 <HAL_QSPI_Init+0x132>
  {
    assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
20015298:	687b      	ldr	r3, [r7, #4]
2001529a:	69db      	ldr	r3, [r3, #28]
2001529c:	2b00      	cmp	r3, #0
2001529e:	d008      	beq.n	200152b2 <HAL_QSPI_Init+0x132>
200152a0:	687b      	ldr	r3, [r7, #4]
200152a2:	69db      	ldr	r3, [r3, #28]
200152a4:	2b80      	cmp	r3, #128	; 0x80
200152a6:	d004      	beq.n	200152b2 <HAL_QSPI_Init+0x132>
200152a8:	f240 1149 	movw	r1, #329	; 0x149
200152ac:	4834      	ldr	r0, [pc, #208]	; (20015380 <HAL_QSPI_Init+0x200>)
200152ae:	f7eb fb21 	bl	200008f4 <assert_failed>
  }

  if(hqspi->State == HAL_QSPI_STATE_RESET)
200152b2:	687b      	ldr	r3, [r7, #4]
200152b4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200152b8:	b2db      	uxtb	r3, r3
200152ba:	2b00      	cmp	r3, #0
200152bc:	d107      	bne.n	200152ce <HAL_QSPI_Init+0x14e>

    /* Init the low level hardware */
    hqspi->MspInitCallback(hqspi);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_QSPI_MspInit(hqspi);
200152be:	6878      	ldr	r0, [r7, #4]
200152c0:	f7eb fb50 	bl	20000964 <HAL_QSPI_MspInit>
#endif

    /* Configure the default timeout for the QSPI memory access */
    HAL_QSPI_SetTimeout(hqspi, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);
200152c4:	f241 3188 	movw	r1, #5000	; 0x1388
200152c8:	6878      	ldr	r0, [r7, #4]
200152ca:	f001 fe35 	bl	20016f38 <HAL_QSPI_SetTimeout>
  }

  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
200152ce:	687b      	ldr	r3, [r7, #4]
200152d0:	681b      	ldr	r3, [r3, #0]
200152d2:	681b      	ldr	r3, [r3, #0]
200152d4:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
200152d8:	687b      	ldr	r3, [r7, #4]
200152da:	689b      	ldr	r3, [r3, #8]
200152dc:	3b01      	subs	r3, #1
200152de:	021a      	lsls	r2, r3, #8
200152e0:	687b      	ldr	r3, [r7, #4]
200152e2:	681b      	ldr	r3, [r3, #0]
200152e4:	430a      	orrs	r2, r1
200152e6:	601a      	str	r2, [r3, #0]
             ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
200152e8:	687b      	ldr	r3, [r7, #4]
200152ea:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200152ec:	9300      	str	r3, [sp, #0]
200152ee:	68fb      	ldr	r3, [r7, #12]
200152f0:	2200      	movs	r2, #0
200152f2:	2120      	movs	r1, #32
200152f4:	6878      	ldr	r0, [r7, #4]
200152f6:	f001 ff3a 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
200152fa:	4603      	mov	r3, r0
200152fc:	72fb      	strb	r3, [r7, #11]

  if(status == HAL_OK)
200152fe:	7afb      	ldrb	r3, [r7, #11]
20015300:	2b00      	cmp	r3, #0
20015302:	d135      	bne.n	20015370 <HAL_QSPI_Init+0x1f0>
  {
    /* Configure QSPI Clock Prescaler and Sample Shift */
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
20015304:	687b      	ldr	r3, [r7, #4]
20015306:	681b      	ldr	r3, [r3, #0]
20015308:	681a      	ldr	r2, [r3, #0]
2001530a:	4b1e      	ldr	r3, [pc, #120]	; (20015384 <HAL_QSPI_Init+0x204>)
2001530c:	4013      	ands	r3, r2
2001530e:	687a      	ldr	r2, [r7, #4]
20015310:	6852      	ldr	r2, [r2, #4]
20015312:	0611      	lsls	r1, r2, #24
20015314:	687a      	ldr	r2, [r7, #4]
20015316:	68d2      	ldr	r2, [r2, #12]
20015318:	4311      	orrs	r1, r2
2001531a:	687a      	ldr	r2, [r7, #4]
2001531c:	69d2      	ldr	r2, [r2, #28]
2001531e:	4311      	orrs	r1, r2
20015320:	687a      	ldr	r2, [r7, #4]
20015322:	6a12      	ldr	r2, [r2, #32]
20015324:	4311      	orrs	r1, r2
20015326:	687a      	ldr	r2, [r7, #4]
20015328:	6812      	ldr	r2, [r2, #0]
2001532a:	430b      	orrs	r3, r1
2001532c:	6013      	str	r3, [r2, #0]
               ((hqspi->Init.ClockPrescaler << QUADSPI_CR_PRESCALER_Pos) |
                hqspi->Init.SampleShifting  | hqspi->Init.FlashID | hqspi->Init.DualFlash));

    /* Configure QSPI Flash Size, CS High Time and Clock Mode */
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
2001532e:	687b      	ldr	r3, [r7, #4]
20015330:	681b      	ldr	r3, [r3, #0]
20015332:	685a      	ldr	r2, [r3, #4]
20015334:	4b14      	ldr	r3, [pc, #80]	; (20015388 <HAL_QSPI_Init+0x208>)
20015336:	4013      	ands	r3, r2
20015338:	687a      	ldr	r2, [r7, #4]
2001533a:	6912      	ldr	r2, [r2, #16]
2001533c:	0411      	lsls	r1, r2, #16
2001533e:	687a      	ldr	r2, [r7, #4]
20015340:	6952      	ldr	r2, [r2, #20]
20015342:	4311      	orrs	r1, r2
20015344:	687a      	ldr	r2, [r7, #4]
20015346:	6992      	ldr	r2, [r2, #24]
20015348:	4311      	orrs	r1, r2
2001534a:	687a      	ldr	r2, [r7, #4]
2001534c:	6812      	ldr	r2, [r2, #0]
2001534e:	430b      	orrs	r3, r1
20015350:	6053      	str	r3, [r2, #4]
               ((hqspi->Init.FlashSize << QUADSPI_DCR_FSIZE_Pos) |
                hqspi->Init.ChipSelectHighTime | hqspi->Init.ClockMode));

    /* Enable the QSPI peripheral */
    __HAL_QSPI_ENABLE(hqspi);
20015352:	687b      	ldr	r3, [r7, #4]
20015354:	681b      	ldr	r3, [r3, #0]
20015356:	681a      	ldr	r2, [r3, #0]
20015358:	687b      	ldr	r3, [r7, #4]
2001535a:	681b      	ldr	r3, [r3, #0]
2001535c:	f042 0201 	orr.w	r2, r2, #1
20015360:	601a      	str	r2, [r3, #0]

    /* Set QSPI error code to none */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20015362:	687b      	ldr	r3, [r7, #4]
20015364:	2200      	movs	r2, #0
20015366:	645a      	str	r2, [r3, #68]	; 0x44

    /* Initialize the QSPI state */
    hqspi->State = HAL_QSPI_STATE_READY;
20015368:	687b      	ldr	r3, [r7, #4]
2001536a:	2201      	movs	r2, #1
2001536c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  }

  /* Return function status */
  return status;
20015370:	7afb      	ldrb	r3, [r7, #11]
}
20015372:	4618      	mov	r0, r3
20015374:	3710      	adds	r7, #16
20015376:	46bd      	mov	sp, r7
20015378:	bd80      	pop	{r7, pc}
2001537a:	bf00      	nop
2001537c:	52005000 	.word	0x52005000
20015380:	2001c2a4 	.word	0x2001c2a4
20015384:	00ffff2f 	.word	0x00ffff2f
20015388:	ffe0f8fe 	.word	0xffe0f8fe

2001538c <HAL_QSPI_DeInit>:
  * @brief De-Initialize the QSPI peripheral.
  * @param hqspi : QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_DeInit(QSPI_HandleTypeDef *hqspi)
{
2001538c:	b580      	push	{r7, lr}
2001538e:	b082      	sub	sp, #8
20015390:	af00      	add	r7, sp, #0
20015392:	6078      	str	r0, [r7, #4]
  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
20015394:	687b      	ldr	r3, [r7, #4]
20015396:	2b00      	cmp	r3, #0
20015398:	d101      	bne.n	2001539e <HAL_QSPI_DeInit+0x12>
  {
    return HAL_ERROR;
2001539a:	2301      	movs	r3, #1
2001539c:	e012      	b.n	200153c4 <HAL_QSPI_DeInit+0x38>
  }

  /* Disable the QSPI Peripheral Clock */
  __HAL_QSPI_DISABLE(hqspi);
2001539e:	687b      	ldr	r3, [r7, #4]
200153a0:	681b      	ldr	r3, [r3, #0]
200153a2:	681a      	ldr	r2, [r3, #0]
200153a4:	687b      	ldr	r3, [r7, #4]
200153a6:	681b      	ldr	r3, [r3, #0]
200153a8:	f022 0201 	bic.w	r2, r2, #1
200153ac:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware */
  hqspi->MspDeInitCallback(hqspi);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_QSPI_MspDeInit(hqspi);
200153ae:	6878      	ldr	r0, [r7, #4]
200153b0:	f7eb fb88 	bl	20000ac4 <HAL_QSPI_MspDeInit>
#endif

  /* Set QSPI error code to none */
  hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
200153b4:	687b      	ldr	r3, [r7, #4]
200153b6:	2200      	movs	r2, #0
200153b8:	645a      	str	r2, [r3, #68]	; 0x44

  /* Initialize the QSPI state */
  hqspi->State = HAL_QSPI_STATE_RESET;
200153ba:	687b      	ldr	r3, [r7, #4]
200153bc:	2200      	movs	r2, #0
200153be:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  return HAL_OK;
200153c2:	2300      	movs	r3, #0
}
200153c4:	4618      	mov	r0, r3
200153c6:	3708      	adds	r7, #8
200153c8:	46bd      	mov	sp, r7
200153ca:	bd80      	pop	{r7, pc}
  * @brief Initialize the QSPI MSP.
  * @param hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspInit(QSPI_HandleTypeDef *hqspi)
{
200153cc:	b480      	push	{r7}
200153ce:	b083      	sub	sp, #12
200153d0:	af00      	add	r7, sp, #0
200153d2:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspInit can be implemented in the user file
   */
}
200153d4:	bf00      	nop
200153d6:	370c      	adds	r7, #12
200153d8:	46bd      	mov	sp, r7
200153da:	f85d 7b04 	ldr.w	r7, [sp], #4
200153de:	4770      	bx	lr
  * @brief DeInitialize the QSPI MSP.
  * @param hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef *hqspi)
{
200153e0:	b480      	push	{r7}
200153e2:	b083      	sub	sp, #12
200153e4:	af00      	add	r7, sp, #0
200153e6:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspDeInit can be implemented in the user file
   */
}
200153e8:	bf00      	nop
200153ea:	370c      	adds	r7, #12
200153ec:	46bd      	mov	sp, r7
200153ee:	f85d 7b04 	ldr.w	r7, [sp], #4
200153f2:	4770      	bx	lr

200153f4 <HAL_QSPI_IRQHandler>:
  * @brief Handle QSPI interrupt request.
  * @param hqspi : QSPI handle
  * @retval None
  */
void HAL_QSPI_IRQHandler(QSPI_HandleTypeDef *hqspi)
{
200153f4:	b580      	push	{r7, lr}
200153f6:	b086      	sub	sp, #24
200153f8:	af00      	add	r7, sp, #0
200153fa:	6078      	str	r0, [r7, #4]
  __IO uint32_t *data_reg;
  uint32_t flag = READ_REG(hqspi->Instance->SR);
200153fc:	687b      	ldr	r3, [r7, #4]
200153fe:	681b      	ldr	r3, [r3, #0]
20015400:	689b      	ldr	r3, [r3, #8]
20015402:	617b      	str	r3, [r7, #20]
  uint32_t itsource = READ_REG(hqspi->Instance->CR);
20015404:	687b      	ldr	r3, [r7, #4]
20015406:	681b      	ldr	r3, [r3, #0]
20015408:	681b      	ldr	r3, [r3, #0]
2001540a:	613b      	str	r3, [r7, #16]

  /* QSPI Fifo Threshold interrupt occurred ----------------------------------*/
  if(((flag & QSPI_FLAG_FT) != 0U) && ((itsource & QSPI_IT_FT) != 0U))
2001540c:	697b      	ldr	r3, [r7, #20]
2001540e:	f003 0304 	and.w	r3, r3, #4
20015412:	2b00      	cmp	r3, #0
20015414:	d064      	beq.n	200154e0 <HAL_QSPI_IRQHandler+0xec>
20015416:	693b      	ldr	r3, [r7, #16]
20015418:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2001541c:	2b00      	cmp	r3, #0
2001541e:	d05f      	beq.n	200154e0 <HAL_QSPI_IRQHandler+0xec>
  {
    data_reg = &hqspi->Instance->DR;
20015420:	687b      	ldr	r3, [r7, #4]
20015422:	681b      	ldr	r3, [r3, #0]
20015424:	3320      	adds	r3, #32
20015426:	60fb      	str	r3, [r7, #12]

    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
20015428:	687b      	ldr	r3, [r7, #4]
2001542a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2001542e:	b2db      	uxtb	r3, r3
20015430:	2b12      	cmp	r3, #18
20015432:	d125      	bne.n	20015480 <HAL_QSPI_IRQHandler+0x8c>
    {
      /* Transmission process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
20015434:	e01c      	b.n	20015470 <HAL_QSPI_IRQHandler+0x7c>
      {
        if (hqspi->TxXferCount > 0U)
20015436:	687b      	ldr	r3, [r7, #4]
20015438:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001543a:	2b00      	cmp	r3, #0
2001543c:	d00f      	beq.n	2001545e <HAL_QSPI_IRQHandler+0x6a>
        {
          /* Fill the FIFO until the threshold is reached */
          *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
2001543e:	687b      	ldr	r3, [r7, #4]
20015440:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20015442:	781a      	ldrb	r2, [r3, #0]
20015444:	68fb      	ldr	r3, [r7, #12]
20015446:	701a      	strb	r2, [r3, #0]
          hqspi->pTxBuffPtr++;
20015448:	687b      	ldr	r3, [r7, #4]
2001544a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2001544c:	1c5a      	adds	r2, r3, #1
2001544e:	687b      	ldr	r3, [r7, #4]
20015450:	625a      	str	r2, [r3, #36]	; 0x24
          hqspi->TxXferCount--;
20015452:	687b      	ldr	r3, [r7, #4]
20015454:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20015456:	1e5a      	subs	r2, r3, #1
20015458:	687b      	ldr	r3, [r7, #4]
2001545a:	62da      	str	r2, [r3, #44]	; 0x2c
2001545c:	e008      	b.n	20015470 <HAL_QSPI_IRQHandler+0x7c>
        }
        else
        {
          /* No more data available for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
2001545e:	687b      	ldr	r3, [r7, #4]
20015460:	681b      	ldr	r3, [r3, #0]
20015462:	681a      	ldr	r2, [r3, #0]
20015464:	687b      	ldr	r3, [r7, #4]
20015466:	681b      	ldr	r3, [r3, #0]
20015468:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
2001546c:	601a      	str	r2, [r3, #0]
          break;
2001546e:	e033      	b.n	200154d8 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
20015470:	687b      	ldr	r3, [r7, #4]
20015472:	681b      	ldr	r3, [r3, #0]
20015474:	689b      	ldr	r3, [r3, #8]
20015476:	f003 0304 	and.w	r3, r3, #4
2001547a:	2b00      	cmp	r3, #0
2001547c:	d1db      	bne.n	20015436 <HAL_QSPI_IRQHandler+0x42>
2001547e:	e02b      	b.n	200154d8 <HAL_QSPI_IRQHandler+0xe4>
        }
      }
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
20015480:	687b      	ldr	r3, [r7, #4]
20015482:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20015486:	b2db      	uxtb	r3, r3
20015488:	2b22      	cmp	r3, #34	; 0x22
2001548a:	d125      	bne.n	200154d8 <HAL_QSPI_IRQHandler+0xe4>
    {
      /* Receiving Process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
2001548c:	e01d      	b.n	200154ca <HAL_QSPI_IRQHandler+0xd6>
      {
        if (hqspi->RxXferCount > 0U)
2001548e:	687b      	ldr	r3, [r7, #4]
20015490:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20015492:	2b00      	cmp	r3, #0
20015494:	d010      	beq.n	200154b8 <HAL_QSPI_IRQHandler+0xc4>
        {
          /* Read the FIFO until the threshold is reached */
          *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
20015496:	687b      	ldr	r3, [r7, #4]
20015498:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001549a:	68fa      	ldr	r2, [r7, #12]
2001549c:	7812      	ldrb	r2, [r2, #0]
2001549e:	b2d2      	uxtb	r2, r2
200154a0:	701a      	strb	r2, [r3, #0]
          hqspi->pRxBuffPtr++;
200154a2:	687b      	ldr	r3, [r7, #4]
200154a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200154a6:	1c5a      	adds	r2, r3, #1
200154a8:	687b      	ldr	r3, [r7, #4]
200154aa:	631a      	str	r2, [r3, #48]	; 0x30
          hqspi->RxXferCount--;
200154ac:	687b      	ldr	r3, [r7, #4]
200154ae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200154b0:	1e5a      	subs	r2, r3, #1
200154b2:	687b      	ldr	r3, [r7, #4]
200154b4:	639a      	str	r2, [r3, #56]	; 0x38
200154b6:	e008      	b.n	200154ca <HAL_QSPI_IRQHandler+0xd6>
        }
        else
        {
          /* All data have been received for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
200154b8:	687b      	ldr	r3, [r7, #4]
200154ba:	681b      	ldr	r3, [r3, #0]
200154bc:	681a      	ldr	r2, [r3, #0]
200154be:	687b      	ldr	r3, [r7, #4]
200154c0:	681b      	ldr	r3, [r3, #0]
200154c2:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
200154c6:	601a      	str	r2, [r3, #0]
          break;
200154c8:	e006      	b.n	200154d8 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
200154ca:	687b      	ldr	r3, [r7, #4]
200154cc:	681b      	ldr	r3, [r3, #0]
200154ce:	689b      	ldr	r3, [r3, #8]
200154d0:	f003 0304 	and.w	r3, r3, #4
200154d4:	2b00      	cmp	r3, #0
200154d6:	d1da      	bne.n	2001548e <HAL_QSPI_IRQHandler+0x9a>

    /* FIFO Threshold callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->FifoThresholdCallback(hqspi);
#else
    HAL_QSPI_FifoThresholdCallback(hqspi);
200154d8:	6878      	ldr	r0, [r7, #4]
200154da:	f001 fc2b 	bl	20016d34 <HAL_QSPI_FifoThresholdCallback>
200154de:	e13c      	b.n	2001575a <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Complete interrupt occurred -------------------------------*/
  else if(((flag & QSPI_FLAG_TC) != 0U) && ((itsource & QSPI_IT_TC) != 0U))
200154e0:	697b      	ldr	r3, [r7, #20]
200154e2:	f003 0302 	and.w	r3, r3, #2
200154e6:	2b00      	cmp	r3, #0
200154e8:	f000 80b0 	beq.w	2001564c <HAL_QSPI_IRQHandler+0x258>
200154ec:	693b      	ldr	r3, [r7, #16]
200154ee:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
200154f2:	2b00      	cmp	r3, #0
200154f4:	f000 80aa 	beq.w	2001564c <HAL_QSPI_IRQHandler+0x258>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TC);
200154f8:	687b      	ldr	r3, [r7, #4]
200154fa:	681b      	ldr	r3, [r3, #0]
200154fc:	2202      	movs	r2, #2
200154fe:	60da      	str	r2, [r3, #12]

    /* Disable the QSPI FIFO Threshold, Transfer Error and Transfer complete Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
20015500:	687b      	ldr	r3, [r7, #4]
20015502:	681b      	ldr	r3, [r3, #0]
20015504:	681a      	ldr	r2, [r3, #0]
20015506:	687b      	ldr	r3, [r7, #4]
20015508:	681b      	ldr	r3, [r3, #0]
2001550a:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
2001550e:	601a      	str	r2, [r3, #0]

    /* Transfer complete callback */
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
20015510:	687b      	ldr	r3, [r7, #4]
20015512:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20015516:	b2db      	uxtb	r3, r3
20015518:	2b12      	cmp	r3, #18
2001551a:	d120      	bne.n	2001555e <HAL_QSPI_IRQHandler+0x16a>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2001551c:	687b      	ldr	r3, [r7, #4]
2001551e:	681b      	ldr	r3, [r3, #0]
20015520:	681b      	ldr	r3, [r3, #0]
20015522:	f003 0304 	and.w	r3, r3, #4
20015526:	2b00      	cmp	r3, #0
20015528:	d011      	beq.n	2001554e <HAL_QSPI_IRQHandler+0x15a>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2001552a:	687b      	ldr	r3, [r7, #4]
2001552c:	681b      	ldr	r3, [r3, #0]
2001552e:	681a      	ldr	r2, [r3, #0]
20015530:	687b      	ldr	r3, [r7, #4]
20015532:	681b      	ldr	r3, [r3, #0]
20015534:	f022 0204 	bic.w	r2, r2, #4
20015538:	601a      	str	r2, [r3, #0]

        /* Disable the MDMA channel */
        __HAL_MDMA_DISABLE(hqspi->hmdma);
2001553a:	687b      	ldr	r3, [r7, #4]
2001553c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001553e:	681b      	ldr	r3, [r3, #0]
20015540:	68da      	ldr	r2, [r3, #12]
20015542:	687b      	ldr	r3, [r7, #4]
20015544:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20015546:	681b      	ldr	r3, [r3, #0]
20015548:	f022 0201 	bic.w	r2, r2, #1
2001554c:	60da      	str	r2, [r3, #12]
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2001554e:	687b      	ldr	r3, [r7, #4]
20015550:	2201      	movs	r2, #1
20015552:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* TX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->TxCpltCallback(hqspi);
#else
      HAL_QSPI_TxCpltCallback(hqspi);
20015556:	6878      	ldr	r0, [r7, #4]
20015558:	f001 fbe2 	bl	20016d20 <HAL_QSPI_TxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2001555c:	e0fa      	b.n	20015754 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
2001555e:	687b      	ldr	r3, [r7, #4]
20015560:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20015564:	b2db      	uxtb	r3, r3
20015566:	2b22      	cmp	r3, #34	; 0x22
20015568:	d143      	bne.n	200155f2 <HAL_QSPI_IRQHandler+0x1fe>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2001556a:	687b      	ldr	r3, [r7, #4]
2001556c:	681b      	ldr	r3, [r3, #0]
2001556e:	681b      	ldr	r3, [r3, #0]
20015570:	f003 0304 	and.w	r3, r3, #4
20015574:	2b00      	cmp	r3, #0
20015576:	d012      	beq.n	2001559e <HAL_QSPI_IRQHandler+0x1aa>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
20015578:	687b      	ldr	r3, [r7, #4]
2001557a:	681b      	ldr	r3, [r3, #0]
2001557c:	681a      	ldr	r2, [r3, #0]
2001557e:	687b      	ldr	r3, [r7, #4]
20015580:	681b      	ldr	r3, [r3, #0]
20015582:	f022 0204 	bic.w	r2, r2, #4
20015586:	601a      	str	r2, [r3, #0]

        /* Disable the MDMA channel */
        __HAL_MDMA_DISABLE(hqspi->hmdma);
20015588:	687b      	ldr	r3, [r7, #4]
2001558a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001558c:	681b      	ldr	r3, [r3, #0]
2001558e:	68da      	ldr	r2, [r3, #12]
20015590:	687b      	ldr	r3, [r7, #4]
20015592:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20015594:	681b      	ldr	r3, [r3, #0]
20015596:	f022 0201 	bic.w	r2, r2, #1
2001559a:	60da      	str	r2, [r3, #12]
2001559c:	e021      	b.n	200155e2 <HAL_QSPI_IRQHandler+0x1ee>
      }
      else
      {
        data_reg = &hqspi->Instance->DR;
2001559e:	687b      	ldr	r3, [r7, #4]
200155a0:	681b      	ldr	r3, [r3, #0]
200155a2:	3320      	adds	r3, #32
200155a4:	60fb      	str	r3, [r7, #12]
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
200155a6:	e013      	b.n	200155d0 <HAL_QSPI_IRQHandler+0x1dc>
        {
          if (hqspi->RxXferCount > 0U)
200155a8:	687b      	ldr	r3, [r7, #4]
200155aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200155ac:	2b00      	cmp	r3, #0
200155ae:	d017      	beq.n	200155e0 <HAL_QSPI_IRQHandler+0x1ec>
          {
            /* Read the last data received in the FIFO until it is empty */
            *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
200155b0:	687b      	ldr	r3, [r7, #4]
200155b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200155b4:	68fa      	ldr	r2, [r7, #12]
200155b6:	7812      	ldrb	r2, [r2, #0]
200155b8:	b2d2      	uxtb	r2, r2
200155ba:	701a      	strb	r2, [r3, #0]
            hqspi->pRxBuffPtr++;
200155bc:	687b      	ldr	r3, [r7, #4]
200155be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200155c0:	1c5a      	adds	r2, r3, #1
200155c2:	687b      	ldr	r3, [r7, #4]
200155c4:	631a      	str	r2, [r3, #48]	; 0x30
            hqspi->RxXferCount--;
200155c6:	687b      	ldr	r3, [r7, #4]
200155c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200155ca:	1e5a      	subs	r2, r3, #1
200155cc:	687b      	ldr	r3, [r7, #4]
200155ce:	639a      	str	r2, [r3, #56]	; 0x38
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
200155d0:	687b      	ldr	r3, [r7, #4]
200155d2:	681b      	ldr	r3, [r3, #0]
200155d4:	689b      	ldr	r3, [r3, #8]
200155d6:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
200155da:	2b00      	cmp	r3, #0
200155dc:	d1e4      	bne.n	200155a8 <HAL_QSPI_IRQHandler+0x1b4>
200155de:	e000      	b.n	200155e2 <HAL_QSPI_IRQHandler+0x1ee>
          }
          else
          {
            /* All data have been received for the transfer */
            break;
200155e0:	bf00      	nop
        }
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
200155e2:	687b      	ldr	r3, [r7, #4]
200155e4:	2201      	movs	r2, #1
200155e6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* RX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->RxCpltCallback(hqspi);
#else
      HAL_QSPI_RxCpltCallback(hqspi);
200155ea:	6878      	ldr	r0, [r7, #4]
200155ec:	f001 fb8e 	bl	20016d0c <HAL_QSPI_RxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
200155f0:	e0b0      	b.n	20015754 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY)
200155f2:	687b      	ldr	r3, [r7, #4]
200155f4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200155f8:	b2db      	uxtb	r3, r3
200155fa:	2b02      	cmp	r3, #2
200155fc:	d107      	bne.n	2001560e <HAL_QSPI_IRQHandler+0x21a>
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
200155fe:	687b      	ldr	r3, [r7, #4]
20015600:	2201      	movs	r2, #1
20015602:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Command Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->CmdCpltCallback(hqspi);
#else
      HAL_QSPI_CmdCpltCallback(hqspi);
20015606:	6878      	ldr	r0, [r7, #4]
20015608:	f001 fb76 	bl	20016cf8 <HAL_QSPI_CmdCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2001560c:	e0a2      	b.n	20015754 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_ABORT)
2001560e:	687b      	ldr	r3, [r7, #4]
20015610:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20015614:	b2db      	uxtb	r3, r3
20015616:	2b08      	cmp	r3, #8
20015618:	f040 809c 	bne.w	20015754 <HAL_QSPI_IRQHandler+0x360>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
2001561c:	687b      	ldr	r3, [r7, #4]
2001561e:	681b      	ldr	r3, [r3, #0]
20015620:	695a      	ldr	r2, [r3, #20]
20015622:	687b      	ldr	r3, [r7, #4]
20015624:	681b      	ldr	r3, [r3, #0]
20015626:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
2001562a:	615a      	str	r2, [r3, #20]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2001562c:	687b      	ldr	r3, [r7, #4]
2001562e:	2201      	movs	r2, #1
20015630:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      if (hqspi->ErrorCode == HAL_QSPI_ERROR_NONE)
20015634:	687b      	ldr	r3, [r7, #4]
20015636:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20015638:	2b00      	cmp	r3, #0
2001563a:	d103      	bne.n	20015644 <HAL_QSPI_IRQHandler+0x250>

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
2001563c:	6878      	ldr	r0, [r7, #4]
2001563e:	f001 fb51 	bl	20016ce4 <HAL_QSPI_AbortCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
20015642:	e087      	b.n	20015754 <HAL_QSPI_IRQHandler+0x360>

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
20015644:	6878      	ldr	r0, [r7, #4]
20015646:	f001 fb43 	bl	20016cd0 <HAL_QSPI_ErrorCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2001564a:	e083      	b.n	20015754 <HAL_QSPI_IRQHandler+0x360>
     /* Nothing to do */
    }
  }

  /* QSPI Status Match interrupt occurred ------------------------------------*/
  else if(((flag & QSPI_FLAG_SM) != 0U) && ((itsource & QSPI_IT_SM) != 0U))
2001564c:	697b      	ldr	r3, [r7, #20]
2001564e:	f003 0308 	and.w	r3, r3, #8
20015652:	2b00      	cmp	r3, #0
20015654:	d01f      	beq.n	20015696 <HAL_QSPI_IRQHandler+0x2a2>
20015656:	693b      	ldr	r3, [r7, #16]
20015658:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
2001565c:	2b00      	cmp	r3, #0
2001565e:	d01a      	beq.n	20015696 <HAL_QSPI_IRQHandler+0x2a2>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_SM);
20015660:	687b      	ldr	r3, [r7, #4]
20015662:	681b      	ldr	r3, [r3, #0]
20015664:	2208      	movs	r2, #8
20015666:	60da      	str	r2, [r3, #12]

    /* Check if the automatic poll mode stop is activated */
    if(READ_BIT(hqspi->Instance->CR, QUADSPI_CR_APMS) != 0U)
20015668:	687b      	ldr	r3, [r7, #4]
2001566a:	681b      	ldr	r3, [r3, #0]
2001566c:	681b      	ldr	r3, [r3, #0]
2001566e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
20015672:	2b00      	cmp	r3, #0
20015674:	d00b      	beq.n	2001568e <HAL_QSPI_IRQHandler+0x29a>
    {
      /* Disable the QSPI Transfer Error and Status Match Interrupts */
      __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
20015676:	687b      	ldr	r3, [r7, #4]
20015678:	681b      	ldr	r3, [r3, #0]
2001567a:	681a      	ldr	r2, [r3, #0]
2001567c:	687b      	ldr	r3, [r7, #4]
2001567e:	681b      	ldr	r3, [r3, #0]
20015680:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
20015684:	601a      	str	r2, [r3, #0]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
20015686:	687b      	ldr	r3, [r7, #4]
20015688:	2201      	movs	r2, #1
2001568a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Status match callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->StatusMatchCallback(hqspi);
#else
    HAL_QSPI_StatusMatchCallback(hqspi);
2001568e:	6878      	ldr	r0, [r7, #4]
20015690:	f001 fb5a 	bl	20016d48 <HAL_QSPI_StatusMatchCallback>
20015694:	e061      	b.n	2001575a <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Error interrupt occurred ----------------------------------*/
  else if(((flag & QSPI_FLAG_TE) != 0U) && ((itsource & QSPI_IT_TE) != 0U))
20015696:	697b      	ldr	r3, [r7, #20]
20015698:	f003 0301 	and.w	r3, r3, #1
2001569c:	2b00      	cmp	r3, #0
2001569e:	d047      	beq.n	20015730 <HAL_QSPI_IRQHandler+0x33c>
200156a0:	693b      	ldr	r3, [r7, #16]
200156a2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
200156a6:	2b00      	cmp	r3, #0
200156a8:	d042      	beq.n	20015730 <HAL_QSPI_IRQHandler+0x33c>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TE);
200156aa:	687b      	ldr	r3, [r7, #4]
200156ac:	681b      	ldr	r3, [r3, #0]
200156ae:	2201      	movs	r2, #1
200156b0:	60da      	str	r2, [r3, #12]

    /* Disable all the QSPI Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_SM | QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
200156b2:	687b      	ldr	r3, [r7, #4]
200156b4:	681b      	ldr	r3, [r3, #0]
200156b6:	681a      	ldr	r2, [r3, #0]
200156b8:	687b      	ldr	r3, [r7, #4]
200156ba:	681b      	ldr	r3, [r3, #0]
200156bc:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
200156c0:	601a      	str	r2, [r3, #0]

    /* Set error code */
    hqspi->ErrorCode |= HAL_QSPI_ERROR_TRANSFER;
200156c2:	687b      	ldr	r3, [r7, #4]
200156c4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200156c6:	f043 0202 	orr.w	r2, r3, #2
200156ca:	687b      	ldr	r3, [r7, #4]
200156cc:	645a      	str	r2, [r3, #68]	; 0x44

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
200156ce:	687b      	ldr	r3, [r7, #4]
200156d0:	681b      	ldr	r3, [r3, #0]
200156d2:	681b      	ldr	r3, [r3, #0]
200156d4:	f003 0304 	and.w	r3, r3, #4
200156d8:	2b00      	cmp	r3, #0
200156da:	d021      	beq.n	20015720 <HAL_QSPI_IRQHandler+0x32c>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
200156dc:	687b      	ldr	r3, [r7, #4]
200156de:	681b      	ldr	r3, [r3, #0]
200156e0:	681a      	ldr	r2, [r3, #0]
200156e2:	687b      	ldr	r3, [r7, #4]
200156e4:	681b      	ldr	r3, [r3, #0]
200156e6:	f022 0204 	bic.w	r2, r2, #4
200156ea:	601a      	str	r2, [r3, #0]

      /* Disable the MDMA channel */
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
200156ec:	687b      	ldr	r3, [r7, #4]
200156ee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200156f0:	4a1c      	ldr	r2, [pc, #112]	; (20015764 <HAL_QSPI_IRQHandler+0x370>)
200156f2:	659a      	str	r2, [r3, #88]	; 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
200156f4:	687b      	ldr	r3, [r7, #4]
200156f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200156f8:	4618      	mov	r0, r3
200156fa:	f7fd ffee 	bl	200136da <HAL_MDMA_Abort_IT>
200156fe:	4603      	mov	r3, r0
20015700:	2b00      	cmp	r3, #0
20015702:	d029      	beq.n	20015758 <HAL_QSPI_IRQHandler+0x364>
      {
        /* Set error code to DMA */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
20015704:	687b      	ldr	r3, [r7, #4]
20015706:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20015708:	f043 0204 	orr.w	r2, r3, #4
2001570c:	687b      	ldr	r3, [r7, #4]
2001570e:	645a      	str	r2, [r3, #68]	; 0x44

        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
20015710:	687b      	ldr	r3, [r7, #4]
20015712:	2201      	movs	r2, #1
20015714:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
20015718:	6878      	ldr	r0, [r7, #4]
2001571a:	f001 fad9 	bl	20016cd0 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2001571e:	e01b      	b.n	20015758 <HAL_QSPI_IRQHandler+0x364>
      }
    }
    else
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
20015720:	687b      	ldr	r3, [r7, #4]
20015722:	2201      	movs	r2, #1
20015724:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->ErrorCallback(hqspi);
#else
      HAL_QSPI_ErrorCallback(hqspi);
20015728:	6878      	ldr	r0, [r7, #4]
2001572a:	f001 fad1 	bl	20016cd0 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2001572e:	e013      	b.n	20015758 <HAL_QSPI_IRQHandler+0x364>
#endif
    }
  }

  /* QSPI Timeout interrupt occurred -----------------------------------------*/
  else if(((flag & QSPI_FLAG_TO) != 0U) && ((itsource & QSPI_IT_TO) != 0U))
20015730:	697b      	ldr	r3, [r7, #20]
20015732:	f003 0310 	and.w	r3, r3, #16
20015736:	2b00      	cmp	r3, #0
20015738:	d00f      	beq.n	2001575a <HAL_QSPI_IRQHandler+0x366>
2001573a:	693b      	ldr	r3, [r7, #16]
2001573c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
20015740:	2b00      	cmp	r3, #0
20015742:	d00a      	beq.n	2001575a <HAL_QSPI_IRQHandler+0x366>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
20015744:	687b      	ldr	r3, [r7, #4]
20015746:	681b      	ldr	r3, [r3, #0]
20015748:	2210      	movs	r2, #16
2001574a:	60da      	str	r2, [r3, #12]

    /* Timeout callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->TimeOutCallback(hqspi);
#else
    HAL_QSPI_TimeOutCallback(hqspi);
2001574c:	6878      	ldr	r0, [r7, #4]
2001574e:	f001 fb05 	bl	20016d5c <HAL_QSPI_TimeOutCallback>

   else
  {
   /* Nothing to do */
  }
}
20015752:	e002      	b.n	2001575a <HAL_QSPI_IRQHandler+0x366>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
20015754:	bf00      	nop
20015756:	e000      	b.n	2001575a <HAL_QSPI_IRQHandler+0x366>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
20015758:	bf00      	nop
}
2001575a:	bf00      	nop
2001575c:	3718      	adds	r7, #24
2001575e:	46bd      	mov	sp, r7
20015760:	bd80      	pop	{r7, pc}
20015762:	bf00      	nop
20015764:	20017109 	.word	0x20017109

20015768 <HAL_QSPI_Command>:
  * @param Timeout : Timeout duration
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t Timeout)
{
20015768:	b580      	push	{r7, lr}
2001576a:	b088      	sub	sp, #32
2001576c:	af02      	add	r7, sp, #8
2001576e:	60f8      	str	r0, [r7, #12]
20015770:	60b9      	str	r1, [r7, #8]
20015772:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
20015774:	f7ec faba 	bl	20001cec <HAL_GetTick>
20015778:	6138      	str	r0, [r7, #16]

  /* Check the parameters */
  assert_param(IS_QSPI_INSTRUCTION_MODE(cmd->InstructionMode));
2001577a:	68bb      	ldr	r3, [r7, #8]
2001577c:	699b      	ldr	r3, [r3, #24]
2001577e:	2b00      	cmp	r3, #0
20015780:	d013      	beq.n	200157aa <HAL_QSPI_Command+0x42>
20015782:	68bb      	ldr	r3, [r7, #8]
20015784:	699b      	ldr	r3, [r3, #24]
20015786:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2001578a:	d00e      	beq.n	200157aa <HAL_QSPI_Command+0x42>
2001578c:	68bb      	ldr	r3, [r7, #8]
2001578e:	699b      	ldr	r3, [r3, #24]
20015790:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20015794:	d009      	beq.n	200157aa <HAL_QSPI_Command+0x42>
20015796:	68bb      	ldr	r3, [r7, #8]
20015798:	699b      	ldr	r3, [r3, #24]
2001579a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
2001579e:	d004      	beq.n	200157aa <HAL_QSPI_Command+0x42>
200157a0:	f240 3113 	movw	r1, #787	; 0x313
200157a4:	488b      	ldr	r0, [pc, #556]	; (200159d4 <HAL_QSPI_Command+0x26c>)
200157a6:	f7eb f8a5 	bl	200008f4 <assert_failed>
  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
200157aa:	68bb      	ldr	r3, [r7, #8]
200157ac:	699b      	ldr	r3, [r3, #24]
200157ae:	2b00      	cmp	r3, #0
200157b0:	d008      	beq.n	200157c4 <HAL_QSPI_Command+0x5c>
  {
    assert_param(IS_QSPI_INSTRUCTION(cmd->Instruction));
200157b2:	68bb      	ldr	r3, [r7, #8]
200157b4:	681b      	ldr	r3, [r3, #0]
200157b6:	2bff      	cmp	r3, #255	; 0xff
200157b8:	d904      	bls.n	200157c4 <HAL_QSPI_Command+0x5c>
200157ba:	f240 3116 	movw	r1, #790	; 0x316
200157be:	4885      	ldr	r0, [pc, #532]	; (200159d4 <HAL_QSPI_Command+0x26c>)
200157c0:	f7eb f898 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_ADDRESS_MODE(cmd->AddressMode));
200157c4:	68bb      	ldr	r3, [r7, #8]
200157c6:	69db      	ldr	r3, [r3, #28]
200157c8:	2b00      	cmp	r3, #0
200157ca:	d013      	beq.n	200157f4 <HAL_QSPI_Command+0x8c>
200157cc:	68bb      	ldr	r3, [r7, #8]
200157ce:	69db      	ldr	r3, [r3, #28]
200157d0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
200157d4:	d00e      	beq.n	200157f4 <HAL_QSPI_Command+0x8c>
200157d6:	68bb      	ldr	r3, [r7, #8]
200157d8:	69db      	ldr	r3, [r3, #28]
200157da:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
200157de:	d009      	beq.n	200157f4 <HAL_QSPI_Command+0x8c>
200157e0:	68bb      	ldr	r3, [r7, #8]
200157e2:	69db      	ldr	r3, [r3, #28]
200157e4:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
200157e8:	d004      	beq.n	200157f4 <HAL_QSPI_Command+0x8c>
200157ea:	f240 3119 	movw	r1, #793	; 0x319
200157ee:	4879      	ldr	r0, [pc, #484]	; (200159d4 <HAL_QSPI_Command+0x26c>)
200157f0:	f7eb f880 	bl	200008f4 <assert_failed>
  if (cmd->AddressMode != QSPI_ADDRESS_NONE)
200157f4:	68bb      	ldr	r3, [r7, #8]
200157f6:	69db      	ldr	r3, [r3, #28]
200157f8:	2b00      	cmp	r3, #0
200157fa:	d017      	beq.n	2001582c <HAL_QSPI_Command+0xc4>
  {
    assert_param(IS_QSPI_ADDRESS_SIZE(cmd->AddressSize));
200157fc:	68bb      	ldr	r3, [r7, #8]
200157fe:	68db      	ldr	r3, [r3, #12]
20015800:	2b00      	cmp	r3, #0
20015802:	d013      	beq.n	2001582c <HAL_QSPI_Command+0xc4>
20015804:	68bb      	ldr	r3, [r7, #8]
20015806:	68db      	ldr	r3, [r3, #12]
20015808:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2001580c:	d00e      	beq.n	2001582c <HAL_QSPI_Command+0xc4>
2001580e:	68bb      	ldr	r3, [r7, #8]
20015810:	68db      	ldr	r3, [r3, #12]
20015812:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20015816:	d009      	beq.n	2001582c <HAL_QSPI_Command+0xc4>
20015818:	68bb      	ldr	r3, [r7, #8]
2001581a:	68db      	ldr	r3, [r3, #12]
2001581c:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
20015820:	d004      	beq.n	2001582c <HAL_QSPI_Command+0xc4>
20015822:	f44f 7147 	mov.w	r1, #796	; 0x31c
20015826:	486b      	ldr	r0, [pc, #428]	; (200159d4 <HAL_QSPI_Command+0x26c>)
20015828:	f7eb f864 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_ALTERNATE_BYTES_MODE(cmd->AlternateByteMode));
2001582c:	68bb      	ldr	r3, [r7, #8]
2001582e:	6a1b      	ldr	r3, [r3, #32]
20015830:	2b00      	cmp	r3, #0
20015832:	d013      	beq.n	2001585c <HAL_QSPI_Command+0xf4>
20015834:	68bb      	ldr	r3, [r7, #8]
20015836:	6a1b      	ldr	r3, [r3, #32]
20015838:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2001583c:	d00e      	beq.n	2001585c <HAL_QSPI_Command+0xf4>
2001583e:	68bb      	ldr	r3, [r7, #8]
20015840:	6a1b      	ldr	r3, [r3, #32]
20015842:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20015846:	d009      	beq.n	2001585c <HAL_QSPI_Command+0xf4>
20015848:	68bb      	ldr	r3, [r7, #8]
2001584a:	6a1b      	ldr	r3, [r3, #32]
2001584c:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
20015850:	d004      	beq.n	2001585c <HAL_QSPI_Command+0xf4>
20015852:	f240 311f 	movw	r1, #799	; 0x31f
20015856:	485f      	ldr	r0, [pc, #380]	; (200159d4 <HAL_QSPI_Command+0x26c>)
20015858:	f7eb f84c 	bl	200008f4 <assert_failed>
  if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
2001585c:	68bb      	ldr	r3, [r7, #8]
2001585e:	6a1b      	ldr	r3, [r3, #32]
20015860:	2b00      	cmp	r3, #0
20015862:	d017      	beq.n	20015894 <HAL_QSPI_Command+0x12c>
  {
    assert_param(IS_QSPI_ALTERNATE_BYTES_SIZE(cmd->AlternateBytesSize));
20015864:	68bb      	ldr	r3, [r7, #8]
20015866:	691b      	ldr	r3, [r3, #16]
20015868:	2b00      	cmp	r3, #0
2001586a:	d013      	beq.n	20015894 <HAL_QSPI_Command+0x12c>
2001586c:	68bb      	ldr	r3, [r7, #8]
2001586e:	691b      	ldr	r3, [r3, #16]
20015870:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20015874:	d00e      	beq.n	20015894 <HAL_QSPI_Command+0x12c>
20015876:	68bb      	ldr	r3, [r7, #8]
20015878:	691b      	ldr	r3, [r3, #16]
2001587a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2001587e:	d009      	beq.n	20015894 <HAL_QSPI_Command+0x12c>
20015880:	68bb      	ldr	r3, [r7, #8]
20015882:	691b      	ldr	r3, [r3, #16]
20015884:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
20015888:	d004      	beq.n	20015894 <HAL_QSPI_Command+0x12c>
2001588a:	f240 3122 	movw	r1, #802	; 0x322
2001588e:	4851      	ldr	r0, [pc, #324]	; (200159d4 <HAL_QSPI_Command+0x26c>)
20015890:	f7eb f830 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_DUMMY_CYCLES(cmd->DummyCycles));
20015894:	68bb      	ldr	r3, [r7, #8]
20015896:	695b      	ldr	r3, [r3, #20]
20015898:	2b1f      	cmp	r3, #31
2001589a:	d904      	bls.n	200158a6 <HAL_QSPI_Command+0x13e>
2001589c:	f240 3125 	movw	r1, #805	; 0x325
200158a0:	484c      	ldr	r0, [pc, #304]	; (200159d4 <HAL_QSPI_Command+0x26c>)
200158a2:	f7eb f827 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DATA_MODE(cmd->DataMode));
200158a6:	68bb      	ldr	r3, [r7, #8]
200158a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200158aa:	2b00      	cmp	r3, #0
200158ac:	d013      	beq.n	200158d6 <HAL_QSPI_Command+0x16e>
200158ae:	68bb      	ldr	r3, [r7, #8]
200158b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200158b2:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
200158b6:	d00e      	beq.n	200158d6 <HAL_QSPI_Command+0x16e>
200158b8:	68bb      	ldr	r3, [r7, #8]
200158ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200158bc:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200158c0:	d009      	beq.n	200158d6 <HAL_QSPI_Command+0x16e>
200158c2:	68bb      	ldr	r3, [r7, #8]
200158c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200158c6:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
200158ca:	d004      	beq.n	200158d6 <HAL_QSPI_Command+0x16e>
200158cc:	f240 3126 	movw	r1, #806	; 0x326
200158d0:	4840      	ldr	r0, [pc, #256]	; (200159d4 <HAL_QSPI_Command+0x26c>)
200158d2:	f7eb f80f 	bl	200008f4 <assert_failed>

  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
200158d6:	68bb      	ldr	r3, [r7, #8]
200158d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200158da:	2b00      	cmp	r3, #0
200158dc:	d009      	beq.n	200158f2 <HAL_QSPI_Command+0x18a>
200158de:	68bb      	ldr	r3, [r7, #8]
200158e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200158e2:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
200158e6:	d004      	beq.n	200158f2 <HAL_QSPI_Command+0x18a>
200158e8:	f44f 714a 	mov.w	r1, #808	; 0x328
200158ec:	4839      	ldr	r0, [pc, #228]	; (200159d4 <HAL_QSPI_Command+0x26c>)
200158ee:	f7eb f801 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
200158f2:	68bb      	ldr	r3, [r7, #8]
200158f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200158f6:	2b00      	cmp	r3, #0
200158f8:	d009      	beq.n	2001590e <HAL_QSPI_Command+0x1a6>
200158fa:	68bb      	ldr	r3, [r7, #8]
200158fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200158fe:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20015902:	d004      	beq.n	2001590e <HAL_QSPI_Command+0x1a6>
20015904:	f240 3129 	movw	r1, #809	; 0x329
20015908:	4832      	ldr	r0, [pc, #200]	; (200159d4 <HAL_QSPI_Command+0x26c>)
2001590a:	f7ea fff3 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
2001590e:	68bb      	ldr	r3, [r7, #8]
20015910:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20015912:	2b00      	cmp	r3, #0
20015914:	d009      	beq.n	2001592a <HAL_QSPI_Command+0x1c2>
20015916:	68bb      	ldr	r3, [r7, #8]
20015918:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2001591a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001591e:	d004      	beq.n	2001592a <HAL_QSPI_Command+0x1c2>
20015920:	f240 312a 	movw	r1, #810	; 0x32a
20015924:	482b      	ldr	r0, [pc, #172]	; (200159d4 <HAL_QSPI_Command+0x26c>)
20015926:	f7ea ffe5 	bl	200008f4 <assert_failed>

  /* Process locked */
  __HAL_LOCK(hqspi);
2001592a:	68fb      	ldr	r3, [r7, #12]
2001592c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20015930:	b2db      	uxtb	r3, r3
20015932:	2b01      	cmp	r3, #1
20015934:	d101      	bne.n	2001593a <HAL_QSPI_Command+0x1d2>
20015936:	2302      	movs	r3, #2
20015938:	e048      	b.n	200159cc <HAL_QSPI_Command+0x264>
2001593a:	68fb      	ldr	r3, [r7, #12]
2001593c:	2201      	movs	r2, #1
2001593e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20015942:	68fb      	ldr	r3, [r7, #12]
20015944:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20015948:	b2db      	uxtb	r3, r3
2001594a:	2b01      	cmp	r3, #1
2001594c:	d137      	bne.n	200159be <HAL_QSPI_Command+0x256>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2001594e:	68fb      	ldr	r3, [r7, #12]
20015950:	2200      	movs	r2, #0
20015952:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
20015954:	68fb      	ldr	r3, [r7, #12]
20015956:	2202      	movs	r2, #2
20015958:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
2001595c:	687b      	ldr	r3, [r7, #4]
2001595e:	9300      	str	r3, [sp, #0]
20015960:	693b      	ldr	r3, [r7, #16]
20015962:	2200      	movs	r2, #0
20015964:	2120      	movs	r1, #32
20015966:	68f8      	ldr	r0, [r7, #12]
20015968:	f001 fc01 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
2001596c:	4603      	mov	r3, r0
2001596e:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
20015970:	7dfb      	ldrb	r3, [r7, #23]
20015972:	2b00      	cmp	r3, #0
20015974:	d125      	bne.n	200159c2 <HAL_QSPI_Command+0x25a>
    {
      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
20015976:	2200      	movs	r2, #0
20015978:	68b9      	ldr	r1, [r7, #8]
2001597a:	68f8      	ldr	r0, [r7, #12]
2001597c:	f001 fc2e 	bl	200171dc <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
20015980:	68bb      	ldr	r3, [r7, #8]
20015982:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20015984:	2b00      	cmp	r3, #0
20015986:	d115      	bne.n	200159b4 <HAL_QSPI_Command+0x24c>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
20015988:	687b      	ldr	r3, [r7, #4]
2001598a:	9300      	str	r3, [sp, #0]
2001598c:	693b      	ldr	r3, [r7, #16]
2001598e:	2201      	movs	r2, #1
20015990:	2102      	movs	r1, #2
20015992:	68f8      	ldr	r0, [r7, #12]
20015994:	f001 fbeb 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
20015998:	4603      	mov	r3, r0
2001599a:	75fb      	strb	r3, [r7, #23]

        if (status == HAL_OK)
2001599c:	7dfb      	ldrb	r3, [r7, #23]
2001599e:	2b00      	cmp	r3, #0
200159a0:	d10f      	bne.n	200159c2 <HAL_QSPI_Command+0x25a>
        {
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
200159a2:	68fb      	ldr	r3, [r7, #12]
200159a4:	681b      	ldr	r3, [r3, #0]
200159a6:	2202      	movs	r2, #2
200159a8:	60da      	str	r2, [r3, #12]

          /* Update QSPI state */
          hqspi->State = HAL_QSPI_STATE_READY;
200159aa:	68fb      	ldr	r3, [r7, #12]
200159ac:	2201      	movs	r2, #1
200159ae:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
200159b2:	e006      	b.n	200159c2 <HAL_QSPI_Command+0x25a>
        }
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
200159b4:	68fb      	ldr	r3, [r7, #12]
200159b6:	2201      	movs	r2, #1
200159b8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
200159bc:	e001      	b.n	200159c2 <HAL_QSPI_Command+0x25a>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
200159be:	2302      	movs	r3, #2
200159c0:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
200159c2:	68fb      	ldr	r3, [r7, #12]
200159c4:	2200      	movs	r2, #0
200159c6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
200159ca:	7dfb      	ldrb	r3, [r7, #23]
}
200159cc:	4618      	mov	r0, r3
200159ce:	3718      	adds	r7, #24
200159d0:	46bd      	mov	sp, r7
200159d2:	bd80      	pop	{r7, pc}
200159d4:	2001c2a4 	.word	0x2001c2a4

200159d8 <HAL_QSPI_Command_IT>:
  * @param cmd : structure that contains the command configuration information
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd)
{
200159d8:	b580      	push	{r7, lr}
200159da:	b086      	sub	sp, #24
200159dc:	af02      	add	r7, sp, #8
200159de:	6078      	str	r0, [r7, #4]
200159e0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
200159e2:	f7ec f983 	bl	20001cec <HAL_GetTick>
200159e6:	60b8      	str	r0, [r7, #8]

  /* Check the parameters */
  assert_param(IS_QSPI_INSTRUCTION_MODE(cmd->InstructionMode));
200159e8:	683b      	ldr	r3, [r7, #0]
200159ea:	699b      	ldr	r3, [r3, #24]
200159ec:	2b00      	cmp	r3, #0
200159ee:	d013      	beq.n	20015a18 <HAL_QSPI_Command_IT+0x40>
200159f0:	683b      	ldr	r3, [r7, #0]
200159f2:	699b      	ldr	r3, [r3, #24]
200159f4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
200159f8:	d00e      	beq.n	20015a18 <HAL_QSPI_Command_IT+0x40>
200159fa:	683b      	ldr	r3, [r7, #0]
200159fc:	699b      	ldr	r3, [r3, #24]
200159fe:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20015a02:	d009      	beq.n	20015a18 <HAL_QSPI_Command_IT+0x40>
20015a04:	683b      	ldr	r3, [r7, #0]
20015a06:	699b      	ldr	r3, [r3, #24]
20015a08:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
20015a0c:	d004      	beq.n	20015a18 <HAL_QSPI_Command_IT+0x40>
20015a0e:	f44f 715b 	mov.w	r1, #876	; 0x36c
20015a12:	4890      	ldr	r0, [pc, #576]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015a14:	f7ea ff6e 	bl	200008f4 <assert_failed>
  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
20015a18:	683b      	ldr	r3, [r7, #0]
20015a1a:	699b      	ldr	r3, [r3, #24]
20015a1c:	2b00      	cmp	r3, #0
20015a1e:	d008      	beq.n	20015a32 <HAL_QSPI_Command_IT+0x5a>
  {
    assert_param(IS_QSPI_INSTRUCTION(cmd->Instruction));
20015a20:	683b      	ldr	r3, [r7, #0]
20015a22:	681b      	ldr	r3, [r3, #0]
20015a24:	2bff      	cmp	r3, #255	; 0xff
20015a26:	d904      	bls.n	20015a32 <HAL_QSPI_Command_IT+0x5a>
20015a28:	f240 316f 	movw	r1, #879	; 0x36f
20015a2c:	4889      	ldr	r0, [pc, #548]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015a2e:	f7ea ff61 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_ADDRESS_MODE(cmd->AddressMode));
20015a32:	683b      	ldr	r3, [r7, #0]
20015a34:	69db      	ldr	r3, [r3, #28]
20015a36:	2b00      	cmp	r3, #0
20015a38:	d013      	beq.n	20015a62 <HAL_QSPI_Command_IT+0x8a>
20015a3a:	683b      	ldr	r3, [r7, #0]
20015a3c:	69db      	ldr	r3, [r3, #28]
20015a3e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20015a42:	d00e      	beq.n	20015a62 <HAL_QSPI_Command_IT+0x8a>
20015a44:	683b      	ldr	r3, [r7, #0]
20015a46:	69db      	ldr	r3, [r3, #28]
20015a48:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
20015a4c:	d009      	beq.n	20015a62 <HAL_QSPI_Command_IT+0x8a>
20015a4e:	683b      	ldr	r3, [r7, #0]
20015a50:	69db      	ldr	r3, [r3, #28]
20015a52:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
20015a56:	d004      	beq.n	20015a62 <HAL_QSPI_Command_IT+0x8a>
20015a58:	f240 3172 	movw	r1, #882	; 0x372
20015a5c:	487d      	ldr	r0, [pc, #500]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015a5e:	f7ea ff49 	bl	200008f4 <assert_failed>
  if (cmd->AddressMode != QSPI_ADDRESS_NONE)
20015a62:	683b      	ldr	r3, [r7, #0]
20015a64:	69db      	ldr	r3, [r3, #28]
20015a66:	2b00      	cmp	r3, #0
20015a68:	d017      	beq.n	20015a9a <HAL_QSPI_Command_IT+0xc2>
  {
    assert_param(IS_QSPI_ADDRESS_SIZE(cmd->AddressSize));
20015a6a:	683b      	ldr	r3, [r7, #0]
20015a6c:	68db      	ldr	r3, [r3, #12]
20015a6e:	2b00      	cmp	r3, #0
20015a70:	d013      	beq.n	20015a9a <HAL_QSPI_Command_IT+0xc2>
20015a72:	683b      	ldr	r3, [r7, #0]
20015a74:	68db      	ldr	r3, [r3, #12]
20015a76:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20015a7a:	d00e      	beq.n	20015a9a <HAL_QSPI_Command_IT+0xc2>
20015a7c:	683b      	ldr	r3, [r7, #0]
20015a7e:	68db      	ldr	r3, [r3, #12]
20015a80:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20015a84:	d009      	beq.n	20015a9a <HAL_QSPI_Command_IT+0xc2>
20015a86:	683b      	ldr	r3, [r7, #0]
20015a88:	68db      	ldr	r3, [r3, #12]
20015a8a:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
20015a8e:	d004      	beq.n	20015a9a <HAL_QSPI_Command_IT+0xc2>
20015a90:	f240 3175 	movw	r1, #885	; 0x375
20015a94:	486f      	ldr	r0, [pc, #444]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015a96:	f7ea ff2d 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_ALTERNATE_BYTES_MODE(cmd->AlternateByteMode));
20015a9a:	683b      	ldr	r3, [r7, #0]
20015a9c:	6a1b      	ldr	r3, [r3, #32]
20015a9e:	2b00      	cmp	r3, #0
20015aa0:	d013      	beq.n	20015aca <HAL_QSPI_Command_IT+0xf2>
20015aa2:	683b      	ldr	r3, [r7, #0]
20015aa4:	6a1b      	ldr	r3, [r3, #32]
20015aa6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20015aaa:	d00e      	beq.n	20015aca <HAL_QSPI_Command_IT+0xf2>
20015aac:	683b      	ldr	r3, [r7, #0]
20015aae:	6a1b      	ldr	r3, [r3, #32]
20015ab0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20015ab4:	d009      	beq.n	20015aca <HAL_QSPI_Command_IT+0xf2>
20015ab6:	683b      	ldr	r3, [r7, #0]
20015ab8:	6a1b      	ldr	r3, [r3, #32]
20015aba:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
20015abe:	d004      	beq.n	20015aca <HAL_QSPI_Command_IT+0xf2>
20015ac0:	f44f 715e 	mov.w	r1, #888	; 0x378
20015ac4:	4863      	ldr	r0, [pc, #396]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015ac6:	f7ea ff15 	bl	200008f4 <assert_failed>
  if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
20015aca:	683b      	ldr	r3, [r7, #0]
20015acc:	6a1b      	ldr	r3, [r3, #32]
20015ace:	2b00      	cmp	r3, #0
20015ad0:	d017      	beq.n	20015b02 <HAL_QSPI_Command_IT+0x12a>
  {
    assert_param(IS_QSPI_ALTERNATE_BYTES_SIZE(cmd->AlternateBytesSize));
20015ad2:	683b      	ldr	r3, [r7, #0]
20015ad4:	691b      	ldr	r3, [r3, #16]
20015ad6:	2b00      	cmp	r3, #0
20015ad8:	d013      	beq.n	20015b02 <HAL_QSPI_Command_IT+0x12a>
20015ada:	683b      	ldr	r3, [r7, #0]
20015adc:	691b      	ldr	r3, [r3, #16]
20015ade:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20015ae2:	d00e      	beq.n	20015b02 <HAL_QSPI_Command_IT+0x12a>
20015ae4:	683b      	ldr	r3, [r7, #0]
20015ae6:	691b      	ldr	r3, [r3, #16]
20015ae8:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20015aec:	d009      	beq.n	20015b02 <HAL_QSPI_Command_IT+0x12a>
20015aee:	683b      	ldr	r3, [r7, #0]
20015af0:	691b      	ldr	r3, [r3, #16]
20015af2:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
20015af6:	d004      	beq.n	20015b02 <HAL_QSPI_Command_IT+0x12a>
20015af8:	f240 317b 	movw	r1, #891	; 0x37b
20015afc:	4855      	ldr	r0, [pc, #340]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015afe:	f7ea fef9 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_DUMMY_CYCLES(cmd->DummyCycles));
20015b02:	683b      	ldr	r3, [r7, #0]
20015b04:	695b      	ldr	r3, [r3, #20]
20015b06:	2b1f      	cmp	r3, #31
20015b08:	d904      	bls.n	20015b14 <HAL_QSPI_Command_IT+0x13c>
20015b0a:	f240 317e 	movw	r1, #894	; 0x37e
20015b0e:	4851      	ldr	r0, [pc, #324]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015b10:	f7ea fef0 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DATA_MODE(cmd->DataMode));
20015b14:	683b      	ldr	r3, [r7, #0]
20015b16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20015b18:	2b00      	cmp	r3, #0
20015b1a:	d013      	beq.n	20015b44 <HAL_QSPI_Command_IT+0x16c>
20015b1c:	683b      	ldr	r3, [r7, #0]
20015b1e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20015b20:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20015b24:	d00e      	beq.n	20015b44 <HAL_QSPI_Command_IT+0x16c>
20015b26:	683b      	ldr	r3, [r7, #0]
20015b28:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20015b2a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20015b2e:	d009      	beq.n	20015b44 <HAL_QSPI_Command_IT+0x16c>
20015b30:	683b      	ldr	r3, [r7, #0]
20015b32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20015b34:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
20015b38:	d004      	beq.n	20015b44 <HAL_QSPI_Command_IT+0x16c>
20015b3a:	f240 317f 	movw	r1, #895	; 0x37f
20015b3e:	4845      	ldr	r0, [pc, #276]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015b40:	f7ea fed8 	bl	200008f4 <assert_failed>

  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
20015b44:	683b      	ldr	r3, [r7, #0]
20015b46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20015b48:	2b00      	cmp	r3, #0
20015b4a:	d009      	beq.n	20015b60 <HAL_QSPI_Command_IT+0x188>
20015b4c:	683b      	ldr	r3, [r7, #0]
20015b4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20015b50:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
20015b54:	d004      	beq.n	20015b60 <HAL_QSPI_Command_IT+0x188>
20015b56:	f240 3181 	movw	r1, #897	; 0x381
20015b5a:	483e      	ldr	r0, [pc, #248]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015b5c:	f7ea feca 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
20015b60:	683b      	ldr	r3, [r7, #0]
20015b62:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20015b64:	2b00      	cmp	r3, #0
20015b66:	d009      	beq.n	20015b7c <HAL_QSPI_Command_IT+0x1a4>
20015b68:	683b      	ldr	r3, [r7, #0]
20015b6a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20015b6c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20015b70:	d004      	beq.n	20015b7c <HAL_QSPI_Command_IT+0x1a4>
20015b72:	f240 3182 	movw	r1, #898	; 0x382
20015b76:	4837      	ldr	r0, [pc, #220]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015b78:	f7ea febc 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
20015b7c:	683b      	ldr	r3, [r7, #0]
20015b7e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20015b80:	2b00      	cmp	r3, #0
20015b82:	d009      	beq.n	20015b98 <HAL_QSPI_Command_IT+0x1c0>
20015b84:	683b      	ldr	r3, [r7, #0]
20015b86:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20015b88:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
20015b8c:	d004      	beq.n	20015b98 <HAL_QSPI_Command_IT+0x1c0>
20015b8e:	f240 3183 	movw	r1, #899	; 0x383
20015b92:	4830      	ldr	r0, [pc, #192]	; (20015c54 <HAL_QSPI_Command_IT+0x27c>)
20015b94:	f7ea feae 	bl	200008f4 <assert_failed>

  /* Process locked */
  __HAL_LOCK(hqspi);
20015b98:	687b      	ldr	r3, [r7, #4]
20015b9a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20015b9e:	b2db      	uxtb	r3, r3
20015ba0:	2b01      	cmp	r3, #1
20015ba2:	d101      	bne.n	20015ba8 <HAL_QSPI_Command_IT+0x1d0>
20015ba4:	2302      	movs	r3, #2
20015ba6:	e051      	b.n	20015c4c <HAL_QSPI_Command_IT+0x274>
20015ba8:	687b      	ldr	r3, [r7, #4]
20015baa:	2201      	movs	r2, #1
20015bac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20015bb0:	687b      	ldr	r3, [r7, #4]
20015bb2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20015bb6:	b2db      	uxtb	r3, r3
20015bb8:	2b01      	cmp	r3, #1
20015bba:	d140      	bne.n	20015c3e <HAL_QSPI_Command_IT+0x266>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20015bbc:	687b      	ldr	r3, [r7, #4]
20015bbe:	2200      	movs	r2, #0
20015bc0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
20015bc2:	687b      	ldr	r3, [r7, #4]
20015bc4:	2202      	movs	r2, #2
20015bc6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
20015bca:	687b      	ldr	r3, [r7, #4]
20015bcc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20015bce:	9300      	str	r3, [sp, #0]
20015bd0:	68bb      	ldr	r3, [r7, #8]
20015bd2:	2200      	movs	r2, #0
20015bd4:	2120      	movs	r1, #32
20015bd6:	6878      	ldr	r0, [r7, #4]
20015bd8:	f001 fac9 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
20015bdc:	4603      	mov	r3, r0
20015bde:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
20015be0:	7bfb      	ldrb	r3, [r7, #15]
20015be2:	2b00      	cmp	r3, #0
20015be4:	d126      	bne.n	20015c34 <HAL_QSPI_Command_IT+0x25c>
    {
      if (cmd->DataMode == QSPI_DATA_NONE)
20015be6:	683b      	ldr	r3, [r7, #0]
20015be8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20015bea:	2b00      	cmp	r3, #0
20015bec:	d103      	bne.n	20015bf6 <HAL_QSPI_Command_IT+0x21e>
      {
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
20015bee:	687b      	ldr	r3, [r7, #4]
20015bf0:	681b      	ldr	r3, [r3, #0]
20015bf2:	2203      	movs	r2, #3
20015bf4:	60da      	str	r2, [r3, #12]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
20015bf6:	2200      	movs	r2, #0
20015bf8:	6839      	ldr	r1, [r7, #0]
20015bfa:	6878      	ldr	r0, [r7, #4]
20015bfc:	f001 faee 	bl	200171dc <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
20015c00:	683b      	ldr	r3, [r7, #0]
20015c02:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20015c04:	2b00      	cmp	r3, #0
20015c06:	d10c      	bne.n	20015c22 <HAL_QSPI_Command_IT+0x24a>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so activate TC and TE interrupts */
        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
20015c08:	687b      	ldr	r3, [r7, #4]
20015c0a:	2200      	movs	r2, #0
20015c0c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Enable the QSPI Transfer Error Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_TC);
20015c10:	687b      	ldr	r3, [r7, #4]
20015c12:	681b      	ldr	r3, [r3, #0]
20015c14:	681a      	ldr	r2, [r3, #0]
20015c16:	687b      	ldr	r3, [r7, #4]
20015c18:	681b      	ldr	r3, [r3, #0]
20015c1a:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
20015c1e:	601a      	str	r2, [r3, #0]
20015c20:	e013      	b.n	20015c4a <HAL_QSPI_Command_IT+0x272>
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
20015c22:	687b      	ldr	r3, [r7, #4]
20015c24:	2201      	movs	r2, #1
20015c26:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
20015c2a:	687b      	ldr	r3, [r7, #4]
20015c2c:	2200      	movs	r2, #0
20015c2e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20015c32:	e00a      	b.n	20015c4a <HAL_QSPI_Command_IT+0x272>
      }
    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20015c34:	687b      	ldr	r3, [r7, #4]
20015c36:	2200      	movs	r2, #0
20015c38:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20015c3c:	e005      	b.n	20015c4a <HAL_QSPI_Command_IT+0x272>
    }
  }
  else
  {
    status = HAL_BUSY;
20015c3e:	2302      	movs	r3, #2
20015c40:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20015c42:	687b      	ldr	r3, [r7, #4]
20015c44:	2200      	movs	r2, #0
20015c46:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
20015c4a:	7bfb      	ldrb	r3, [r7, #15]
}
20015c4c:	4618      	mov	r0, r3
20015c4e:	3710      	adds	r7, #16
20015c50:	46bd      	mov	sp, r7
20015c52:	bd80      	pop	{r7, pc}
20015c54:	2001c2a4 	.word	0x2001c2a4

20015c58 <HAL_QSPI_Transmit>:
  * @note   This function is used only in Indirect Write Mode
  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
20015c58:	b580      	push	{r7, lr}
20015c5a:	b08a      	sub	sp, #40	; 0x28
20015c5c:	af02      	add	r7, sp, #8
20015c5e:	60f8      	str	r0, [r7, #12]
20015c60:	60b9      	str	r1, [r7, #8]
20015c62:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20015c64:	2300      	movs	r3, #0
20015c66:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
20015c68:	f7ec f840 	bl	20001cec <HAL_GetTick>
20015c6c:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
20015c6e:	68fb      	ldr	r3, [r7, #12]
20015c70:	681b      	ldr	r3, [r3, #0]
20015c72:	3320      	adds	r3, #32
20015c74:	617b      	str	r3, [r7, #20]

  /* Process locked */
  __HAL_LOCK(hqspi);
20015c76:	68fb      	ldr	r3, [r7, #12]
20015c78:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20015c7c:	b2db      	uxtb	r3, r3
20015c7e:	2b01      	cmp	r3, #1
20015c80:	d101      	bne.n	20015c86 <HAL_QSPI_Transmit+0x2e>
20015c82:	2302      	movs	r3, #2
20015c84:	e076      	b.n	20015d74 <HAL_QSPI_Transmit+0x11c>
20015c86:	68fb      	ldr	r3, [r7, #12]
20015c88:	2201      	movs	r2, #1
20015c8a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20015c8e:	68fb      	ldr	r3, [r7, #12]
20015c90:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20015c94:	b2db      	uxtb	r3, r3
20015c96:	2b01      	cmp	r3, #1
20015c98:	d165      	bne.n	20015d66 <HAL_QSPI_Transmit+0x10e>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20015c9a:	68fb      	ldr	r3, [r7, #12]
20015c9c:	2200      	movs	r2, #0
20015c9e:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
20015ca0:	68bb      	ldr	r3, [r7, #8]
20015ca2:	2b00      	cmp	r3, #0
20015ca4:	d056      	beq.n	20015d54 <HAL_QSPI_Transmit+0xfc>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
20015ca6:	68fb      	ldr	r3, [r7, #12]
20015ca8:	2212      	movs	r2, #18
20015caa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
20015cae:	68fb      	ldr	r3, [r7, #12]
20015cb0:	681b      	ldr	r3, [r3, #0]
20015cb2:	691b      	ldr	r3, [r3, #16]
20015cb4:	1c5a      	adds	r2, r3, #1
20015cb6:	68fb      	ldr	r3, [r7, #12]
20015cb8:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
20015cba:	68fb      	ldr	r3, [r7, #12]
20015cbc:	681b      	ldr	r3, [r3, #0]
20015cbe:	691b      	ldr	r3, [r3, #16]
20015cc0:	1c5a      	adds	r2, r3, #1
20015cc2:	68fb      	ldr	r3, [r7, #12]
20015cc4:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
20015cc6:	68fb      	ldr	r3, [r7, #12]
20015cc8:	68ba      	ldr	r2, [r7, #8]
20015cca:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
20015ccc:	68fb      	ldr	r3, [r7, #12]
20015cce:	681b      	ldr	r3, [r3, #0]
20015cd0:	695a      	ldr	r2, [r3, #20]
20015cd2:	68fb      	ldr	r3, [r7, #12]
20015cd4:	681b      	ldr	r3, [r3, #0]
20015cd6:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
20015cda:	615a      	str	r2, [r3, #20]

      while(hqspi->TxXferCount > 0U)
20015cdc:	e01b      	b.n	20015d16 <HAL_QSPI_Transmit+0xbe>
      {
        /* Wait until FT flag is set to send data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
20015cde:	687b      	ldr	r3, [r7, #4]
20015ce0:	9300      	str	r3, [sp, #0]
20015ce2:	69bb      	ldr	r3, [r7, #24]
20015ce4:	2201      	movs	r2, #1
20015ce6:	2104      	movs	r1, #4
20015ce8:	68f8      	ldr	r0, [r7, #12]
20015cea:	f001 fa40 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
20015cee:	4603      	mov	r3, r0
20015cf0:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
20015cf2:	7ffb      	ldrb	r3, [r7, #31]
20015cf4:	2b00      	cmp	r3, #0
20015cf6:	d113      	bne.n	20015d20 <HAL_QSPI_Transmit+0xc8>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
20015cf8:	68fb      	ldr	r3, [r7, #12]
20015cfa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20015cfc:	781a      	ldrb	r2, [r3, #0]
20015cfe:	697b      	ldr	r3, [r7, #20]
20015d00:	701a      	strb	r2, [r3, #0]
        hqspi->pTxBuffPtr++;
20015d02:	68fb      	ldr	r3, [r7, #12]
20015d04:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20015d06:	1c5a      	adds	r2, r3, #1
20015d08:	68fb      	ldr	r3, [r7, #12]
20015d0a:	625a      	str	r2, [r3, #36]	; 0x24
        hqspi->TxXferCount--;
20015d0c:	68fb      	ldr	r3, [r7, #12]
20015d0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20015d10:	1e5a      	subs	r2, r3, #1
20015d12:	68fb      	ldr	r3, [r7, #12]
20015d14:	62da      	str	r2, [r3, #44]	; 0x2c
      while(hqspi->TxXferCount > 0U)
20015d16:	68fb      	ldr	r3, [r7, #12]
20015d18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20015d1a:	2b00      	cmp	r3, #0
20015d1c:	d1df      	bne.n	20015cde <HAL_QSPI_Transmit+0x86>
20015d1e:	e000      	b.n	20015d22 <HAL_QSPI_Transmit+0xca>
          break;
20015d20:	bf00      	nop
      }

      if (status == HAL_OK)
20015d22:	7ffb      	ldrb	r3, [r7, #31]
20015d24:	2b00      	cmp	r3, #0
20015d26:	d110      	bne.n	20015d4a <HAL_QSPI_Transmit+0xf2>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
20015d28:	687b      	ldr	r3, [r7, #4]
20015d2a:	9300      	str	r3, [sp, #0]
20015d2c:	69bb      	ldr	r3, [r7, #24]
20015d2e:	2201      	movs	r2, #1
20015d30:	2102      	movs	r1, #2
20015d32:	68f8      	ldr	r0, [r7, #12]
20015d34:	f001 fa1b 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
20015d38:	4603      	mov	r3, r0
20015d3a:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
20015d3c:	7ffb      	ldrb	r3, [r7, #31]
20015d3e:	2b00      	cmp	r3, #0
20015d40:	d103      	bne.n	20015d4a <HAL_QSPI_Transmit+0xf2>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
20015d42:	68fb      	ldr	r3, [r7, #12]
20015d44:	681b      	ldr	r3, [r3, #0]
20015d46:	2202      	movs	r2, #2
20015d48:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
20015d4a:	68fb      	ldr	r3, [r7, #12]
20015d4c:	2201      	movs	r2, #1
20015d4e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
20015d52:	e00a      	b.n	20015d6a <HAL_QSPI_Transmit+0x112>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20015d54:	68fb      	ldr	r3, [r7, #12]
20015d56:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20015d58:	f043 0208 	orr.w	r2, r3, #8
20015d5c:	68fb      	ldr	r3, [r7, #12]
20015d5e:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
20015d60:	2301      	movs	r3, #1
20015d62:	77fb      	strb	r3, [r7, #31]
20015d64:	e001      	b.n	20015d6a <HAL_QSPI_Transmit+0x112>
    }
  }
  else
  {
    status = HAL_BUSY;
20015d66:	2302      	movs	r3, #2
20015d68:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
20015d6a:	68fb      	ldr	r3, [r7, #12]
20015d6c:	2200      	movs	r2, #0
20015d6e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
20015d72:	7ffb      	ldrb	r3, [r7, #31]
}
20015d74:	4618      	mov	r0, r3
20015d76:	3720      	adds	r7, #32
20015d78:	46bd      	mov	sp, r7
20015d7a:	bd80      	pop	{r7, pc}

20015d7c <HAL_QSPI_Receive>:
  * @param Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
20015d7c:	b580      	push	{r7, lr}
20015d7e:	b08a      	sub	sp, #40	; 0x28
20015d80:	af02      	add	r7, sp, #8
20015d82:	60f8      	str	r0, [r7, #12]
20015d84:	60b9      	str	r1, [r7, #8]
20015d86:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20015d88:	2300      	movs	r3, #0
20015d8a:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
20015d8c:	f7eb ffae 	bl	20001cec <HAL_GetTick>
20015d90:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
20015d92:	68fb      	ldr	r3, [r7, #12]
20015d94:	681b      	ldr	r3, [r3, #0]
20015d96:	699b      	ldr	r3, [r3, #24]
20015d98:	617b      	str	r3, [r7, #20]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
20015d9a:	68fb      	ldr	r3, [r7, #12]
20015d9c:	681b      	ldr	r3, [r3, #0]
20015d9e:	3320      	adds	r3, #32
20015da0:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hqspi);
20015da2:	68fb      	ldr	r3, [r7, #12]
20015da4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20015da8:	b2db      	uxtb	r3, r3
20015daa:	2b01      	cmp	r3, #1
20015dac:	d101      	bne.n	20015db2 <HAL_QSPI_Receive+0x36>
20015dae:	2302      	movs	r3, #2
20015db0:	e07d      	b.n	20015eae <HAL_QSPI_Receive+0x132>
20015db2:	68fb      	ldr	r3, [r7, #12]
20015db4:	2201      	movs	r2, #1
20015db6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20015dba:	68fb      	ldr	r3, [r7, #12]
20015dbc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20015dc0:	b2db      	uxtb	r3, r3
20015dc2:	2b01      	cmp	r3, #1
20015dc4:	d16c      	bne.n	20015ea0 <HAL_QSPI_Receive+0x124>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20015dc6:	68fb      	ldr	r3, [r7, #12]
20015dc8:	2200      	movs	r2, #0
20015dca:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
20015dcc:	68bb      	ldr	r3, [r7, #8]
20015dce:	2b00      	cmp	r3, #0
20015dd0:	d05d      	beq.n	20015e8e <HAL_QSPI_Receive+0x112>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
20015dd2:	68fb      	ldr	r3, [r7, #12]
20015dd4:	2222      	movs	r2, #34	; 0x22
20015dd6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
20015dda:	68fb      	ldr	r3, [r7, #12]
20015ddc:	681b      	ldr	r3, [r3, #0]
20015dde:	691b      	ldr	r3, [r3, #16]
20015de0:	1c5a      	adds	r2, r3, #1
20015de2:	68fb      	ldr	r3, [r7, #12]
20015de4:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
20015de6:	68fb      	ldr	r3, [r7, #12]
20015de8:	681b      	ldr	r3, [r3, #0]
20015dea:	691b      	ldr	r3, [r3, #16]
20015dec:	1c5a      	adds	r2, r3, #1
20015dee:	68fb      	ldr	r3, [r7, #12]
20015df0:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
20015df2:	68fb      	ldr	r3, [r7, #12]
20015df4:	68ba      	ldr	r2, [r7, #8]
20015df6:	631a      	str	r2, [r3, #48]	; 0x30

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
20015df8:	68fb      	ldr	r3, [r7, #12]
20015dfa:	681b      	ldr	r3, [r3, #0]
20015dfc:	695b      	ldr	r3, [r3, #20]
20015dfe:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
20015e02:	68fb      	ldr	r3, [r7, #12]
20015e04:	681b      	ldr	r3, [r3, #0]
20015e06:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
20015e0a:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
20015e0c:	68fb      	ldr	r3, [r7, #12]
20015e0e:	681b      	ldr	r3, [r3, #0]
20015e10:	697a      	ldr	r2, [r7, #20]
20015e12:	619a      	str	r2, [r3, #24]

      while(hqspi->RxXferCount > 0U)
20015e14:	e01c      	b.n	20015e50 <HAL_QSPI_Receive+0xd4>
      {
        /* Wait until FT or TC flag is set to read received data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
20015e16:	687b      	ldr	r3, [r7, #4]
20015e18:	9300      	str	r3, [sp, #0]
20015e1a:	69bb      	ldr	r3, [r7, #24]
20015e1c:	2201      	movs	r2, #1
20015e1e:	2106      	movs	r1, #6
20015e20:	68f8      	ldr	r0, [r7, #12]
20015e22:	f001 f9a4 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
20015e26:	4603      	mov	r3, r0
20015e28:	77fb      	strb	r3, [r7, #31]

        if  (status != HAL_OK)
20015e2a:	7ffb      	ldrb	r3, [r7, #31]
20015e2c:	2b00      	cmp	r3, #0
20015e2e:	d114      	bne.n	20015e5a <HAL_QSPI_Receive+0xde>
        {
          break;
        }

        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
20015e30:	68fb      	ldr	r3, [r7, #12]
20015e32:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20015e34:	693a      	ldr	r2, [r7, #16]
20015e36:	7812      	ldrb	r2, [r2, #0]
20015e38:	b2d2      	uxtb	r2, r2
20015e3a:	701a      	strb	r2, [r3, #0]
        hqspi->pRxBuffPtr++;
20015e3c:	68fb      	ldr	r3, [r7, #12]
20015e3e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20015e40:	1c5a      	adds	r2, r3, #1
20015e42:	68fb      	ldr	r3, [r7, #12]
20015e44:	631a      	str	r2, [r3, #48]	; 0x30
        hqspi->RxXferCount--;
20015e46:	68fb      	ldr	r3, [r7, #12]
20015e48:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20015e4a:	1e5a      	subs	r2, r3, #1
20015e4c:	68fb      	ldr	r3, [r7, #12]
20015e4e:	639a      	str	r2, [r3, #56]	; 0x38
      while(hqspi->RxXferCount > 0U)
20015e50:	68fb      	ldr	r3, [r7, #12]
20015e52:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20015e54:	2b00      	cmp	r3, #0
20015e56:	d1de      	bne.n	20015e16 <HAL_QSPI_Receive+0x9a>
20015e58:	e000      	b.n	20015e5c <HAL_QSPI_Receive+0xe0>
          break;
20015e5a:	bf00      	nop
      }

      if (status == HAL_OK)
20015e5c:	7ffb      	ldrb	r3, [r7, #31]
20015e5e:	2b00      	cmp	r3, #0
20015e60:	d110      	bne.n	20015e84 <HAL_QSPI_Receive+0x108>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
20015e62:	687b      	ldr	r3, [r7, #4]
20015e64:	9300      	str	r3, [sp, #0]
20015e66:	69bb      	ldr	r3, [r7, #24]
20015e68:	2201      	movs	r2, #1
20015e6a:	2102      	movs	r1, #2
20015e6c:	68f8      	ldr	r0, [r7, #12]
20015e6e:	f001 f97e 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
20015e72:	4603      	mov	r3, r0
20015e74:	77fb      	strb	r3, [r7, #31]

        if  (status == HAL_OK)
20015e76:	7ffb      	ldrb	r3, [r7, #31]
20015e78:	2b00      	cmp	r3, #0
20015e7a:	d103      	bne.n	20015e84 <HAL_QSPI_Receive+0x108>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
20015e7c:	68fb      	ldr	r3, [r7, #12]
20015e7e:	681b      	ldr	r3, [r3, #0]
20015e80:	2202      	movs	r2, #2
20015e82:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
20015e84:	68fb      	ldr	r3, [r7, #12]
20015e86:	2201      	movs	r2, #1
20015e88:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
20015e8c:	e00a      	b.n	20015ea4 <HAL_QSPI_Receive+0x128>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20015e8e:	68fb      	ldr	r3, [r7, #12]
20015e90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20015e92:	f043 0208 	orr.w	r2, r3, #8
20015e96:	68fb      	ldr	r3, [r7, #12]
20015e98:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
20015e9a:	2301      	movs	r3, #1
20015e9c:	77fb      	strb	r3, [r7, #31]
20015e9e:	e001      	b.n	20015ea4 <HAL_QSPI_Receive+0x128>
    }
  }
  else
  {
    status = HAL_BUSY;
20015ea0:	2302      	movs	r3, #2
20015ea2:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
20015ea4:	68fb      	ldr	r3, [r7, #12]
20015ea6:	2200      	movs	r2, #0
20015ea8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
20015eac:	7ffb      	ldrb	r3, [r7, #31]
}
20015eae:	4618      	mov	r0, r3
20015eb0:	3720      	adds	r7, #32
20015eb2:	46bd      	mov	sp, r7
20015eb4:	bd80      	pop	{r7, pc}

20015eb6 <HAL_QSPI_Transmit_IT>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
20015eb6:	b480      	push	{r7}
20015eb8:	b085      	sub	sp, #20
20015eba:	af00      	add	r7, sp, #0
20015ebc:	6078      	str	r0, [r7, #4]
20015ebe:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20015ec0:	2300      	movs	r3, #0
20015ec2:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
20015ec4:	687b      	ldr	r3, [r7, #4]
20015ec6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20015eca:	b2db      	uxtb	r3, r3
20015ecc:	2b01      	cmp	r3, #1
20015ece:	d101      	bne.n	20015ed4 <HAL_QSPI_Transmit_IT+0x1e>
20015ed0:	2302      	movs	r3, #2
20015ed2:	e04f      	b.n	20015f74 <HAL_QSPI_Transmit_IT+0xbe>
20015ed4:	687b      	ldr	r3, [r7, #4]
20015ed6:	2201      	movs	r2, #1
20015ed8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20015edc:	687b      	ldr	r3, [r7, #4]
20015ede:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20015ee2:	b2db      	uxtb	r3, r3
20015ee4:	2b01      	cmp	r3, #1
20015ee6:	d13e      	bne.n	20015f66 <HAL_QSPI_Transmit_IT+0xb0>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20015ee8:	687b      	ldr	r3, [r7, #4]
20015eea:	2200      	movs	r2, #0
20015eec:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
20015eee:	683b      	ldr	r3, [r7, #0]
20015ef0:	2b00      	cmp	r3, #0
20015ef2:	d02b      	beq.n	20015f4c <HAL_QSPI_Transmit_IT+0x96>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
20015ef4:	687b      	ldr	r3, [r7, #4]
20015ef6:	2212      	movs	r2, #18
20015ef8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
20015efc:	687b      	ldr	r3, [r7, #4]
20015efe:	681b      	ldr	r3, [r3, #0]
20015f00:	691b      	ldr	r3, [r3, #16]
20015f02:	1c5a      	adds	r2, r3, #1
20015f04:	687b      	ldr	r3, [r7, #4]
20015f06:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
20015f08:	687b      	ldr	r3, [r7, #4]
20015f0a:	681b      	ldr	r3, [r3, #0]
20015f0c:	691b      	ldr	r3, [r3, #16]
20015f0e:	1c5a      	adds	r2, r3, #1
20015f10:	687b      	ldr	r3, [r7, #4]
20015f12:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
20015f14:	687b      	ldr	r3, [r7, #4]
20015f16:	683a      	ldr	r2, [r7, #0]
20015f18:	625a      	str	r2, [r3, #36]	; 0x24

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
20015f1a:	687b      	ldr	r3, [r7, #4]
20015f1c:	681b      	ldr	r3, [r3, #0]
20015f1e:	2203      	movs	r2, #3
20015f20:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
20015f22:	687b      	ldr	r3, [r7, #4]
20015f24:	681b      	ldr	r3, [r3, #0]
20015f26:	695a      	ldr	r2, [r3, #20]
20015f28:	687b      	ldr	r3, [r7, #4]
20015f2a:	681b      	ldr	r3, [r3, #0]
20015f2c:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
20015f30:	615a      	str	r2, [r3, #20]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20015f32:	687b      	ldr	r3, [r7, #4]
20015f34:	2200      	movs	r2, #0
20015f36:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
20015f3a:	687b      	ldr	r3, [r7, #4]
20015f3c:	681b      	ldr	r3, [r3, #0]
20015f3e:	681a      	ldr	r2, [r3, #0]
20015f40:	687b      	ldr	r3, [r7, #4]
20015f42:	681b      	ldr	r3, [r3, #0]
20015f44:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
20015f48:	601a      	str	r2, [r3, #0]
20015f4a:	e012      	b.n	20015f72 <HAL_QSPI_Transmit_IT+0xbc>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20015f4c:	687b      	ldr	r3, [r7, #4]
20015f4e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20015f50:	f043 0208 	orr.w	r2, r3, #8
20015f54:	687b      	ldr	r3, [r7, #4]
20015f56:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
20015f58:	2301      	movs	r3, #1
20015f5a:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20015f5c:	687b      	ldr	r3, [r7, #4]
20015f5e:	2200      	movs	r2, #0
20015f60:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20015f64:	e005      	b.n	20015f72 <HAL_QSPI_Transmit_IT+0xbc>
    }
  }
  else
  {
    status = HAL_BUSY;
20015f66:	2302      	movs	r3, #2
20015f68:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20015f6a:	687b      	ldr	r3, [r7, #4]
20015f6c:	2200      	movs	r2, #0
20015f6e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
20015f72:	7bfb      	ldrb	r3, [r7, #15]
}
20015f74:	4618      	mov	r0, r3
20015f76:	3714      	adds	r7, #20
20015f78:	46bd      	mov	sp, r7
20015f7a:	f85d 7b04 	ldr.w	r7, [sp], #4
20015f7e:	4770      	bx	lr

20015f80 <HAL_QSPI_Receive_IT>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
20015f80:	b480      	push	{r7}
20015f82:	b085      	sub	sp, #20
20015f84:	af00      	add	r7, sp, #0
20015f86:	6078      	str	r0, [r7, #4]
20015f88:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20015f8a:	2300      	movs	r3, #0
20015f8c:	73fb      	strb	r3, [r7, #15]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
20015f8e:	687b      	ldr	r3, [r7, #4]
20015f90:	681b      	ldr	r3, [r3, #0]
20015f92:	699b      	ldr	r3, [r3, #24]
20015f94:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
20015f96:	687b      	ldr	r3, [r7, #4]
20015f98:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20015f9c:	b2db      	uxtb	r3, r3
20015f9e:	2b01      	cmp	r3, #1
20015fa0:	d101      	bne.n	20015fa6 <HAL_QSPI_Receive_IT+0x26>
20015fa2:	2302      	movs	r3, #2
20015fa4:	e055      	b.n	20016052 <HAL_QSPI_Receive_IT+0xd2>
20015fa6:	687b      	ldr	r3, [r7, #4]
20015fa8:	2201      	movs	r2, #1
20015faa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20015fae:	687b      	ldr	r3, [r7, #4]
20015fb0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20015fb4:	b2db      	uxtb	r3, r3
20015fb6:	2b01      	cmp	r3, #1
20015fb8:	d144      	bne.n	20016044 <HAL_QSPI_Receive_IT+0xc4>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20015fba:	687b      	ldr	r3, [r7, #4]
20015fbc:	2200      	movs	r2, #0
20015fbe:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
20015fc0:	683b      	ldr	r3, [r7, #0]
20015fc2:	2b00      	cmp	r3, #0
20015fc4:	d031      	beq.n	2001602a <HAL_QSPI_Receive_IT+0xaa>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
20015fc6:	687b      	ldr	r3, [r7, #4]
20015fc8:	2222      	movs	r2, #34	; 0x22
20015fca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
20015fce:	687b      	ldr	r3, [r7, #4]
20015fd0:	681b      	ldr	r3, [r3, #0]
20015fd2:	691b      	ldr	r3, [r3, #16]
20015fd4:	1c5a      	adds	r2, r3, #1
20015fd6:	687b      	ldr	r3, [r7, #4]
20015fd8:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
20015fda:	687b      	ldr	r3, [r7, #4]
20015fdc:	681b      	ldr	r3, [r3, #0]
20015fde:	691b      	ldr	r3, [r3, #16]
20015fe0:	1c5a      	adds	r2, r3, #1
20015fe2:	687b      	ldr	r3, [r7, #4]
20015fe4:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
20015fe6:	687b      	ldr	r3, [r7, #4]
20015fe8:	683a      	ldr	r2, [r7, #0]
20015fea:	631a      	str	r2, [r3, #48]	; 0x30

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
20015fec:	687b      	ldr	r3, [r7, #4]
20015fee:	681b      	ldr	r3, [r3, #0]
20015ff0:	2203      	movs	r2, #3
20015ff2:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
20015ff4:	687b      	ldr	r3, [r7, #4]
20015ff6:	681b      	ldr	r3, [r3, #0]
20015ff8:	695b      	ldr	r3, [r3, #20]
20015ffa:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
20015ffe:	687b      	ldr	r3, [r7, #4]
20016000:	681b      	ldr	r3, [r3, #0]
20016002:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
20016006:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
20016008:	687b      	ldr	r3, [r7, #4]
2001600a:	681b      	ldr	r3, [r3, #0]
2001600c:	68ba      	ldr	r2, [r7, #8]
2001600e:	619a      	str	r2, [r3, #24]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20016010:	687b      	ldr	r3, [r7, #4]
20016012:	2200      	movs	r2, #0
20016014:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
20016018:	687b      	ldr	r3, [r7, #4]
2001601a:	681b      	ldr	r3, [r3, #0]
2001601c:	681a      	ldr	r2, [r3, #0]
2001601e:	687b      	ldr	r3, [r7, #4]
20016020:	681b      	ldr	r3, [r3, #0]
20016022:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
20016026:	601a      	str	r2, [r3, #0]
20016028:	e012      	b.n	20016050 <HAL_QSPI_Receive_IT+0xd0>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2001602a:	687b      	ldr	r3, [r7, #4]
2001602c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2001602e:	f043 0208 	orr.w	r2, r3, #8
20016032:	687b      	ldr	r3, [r7, #4]
20016034:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
20016036:	2301      	movs	r3, #1
20016038:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2001603a:	687b      	ldr	r3, [r7, #4]
2001603c:	2200      	movs	r2, #0
2001603e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20016042:	e005      	b.n	20016050 <HAL_QSPI_Receive_IT+0xd0>
    }
  }
  else
  {
    status = HAL_BUSY;
20016044:	2302      	movs	r3, #2
20016046:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20016048:	687b      	ldr	r3, [r7, #4]
2001604a:	2200      	movs	r2, #0
2001604c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
20016050:	7bfb      	ldrb	r3, [r7, #15]
}
20016052:	4618      	mov	r0, r3
20016054:	3714      	adds	r7, #20
20016056:	46bd      	mov	sp, r7
20016058:	f85d 7b04 	ldr.w	r7, [sp], #4
2001605c:	4770      	bx	lr
	...

20016060 <HAL_QSPI_Transmit_DMA>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
20016060:	b590      	push	{r4, r7, lr}
20016062:	b087      	sub	sp, #28
20016064:	af02      	add	r7, sp, #8
20016066:	6078      	str	r0, [r7, #4]
20016068:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2001606a:	2300      	movs	r3, #0
2001606c:	73fb      	strb	r3, [r7, #15]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
2001606e:	687b      	ldr	r3, [r7, #4]
20016070:	681b      	ldr	r3, [r3, #0]
20016072:	691b      	ldr	r3, [r3, #16]
20016074:	3301      	adds	r3, #1
20016076:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
20016078:	687b      	ldr	r3, [r7, #4]
2001607a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2001607e:	b2db      	uxtb	r3, r3
20016080:	2b01      	cmp	r3, #1
20016082:	d101      	bne.n	20016088 <HAL_QSPI_Transmit_DMA+0x28>
20016084:	2302      	movs	r3, #2
20016086:	e0cc      	b.n	20016222 <HAL_QSPI_Transmit_DMA+0x1c2>
20016088:	687b      	ldr	r3, [r7, #4]
2001608a:	2201      	movs	r2, #1
2001608c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20016090:	687b      	ldr	r3, [r7, #4]
20016092:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20016096:	b2db      	uxtb	r3, r3
20016098:	2b01      	cmp	r3, #1
2001609a:	f040 80bb 	bne.w	20016214 <HAL_QSPI_Transmit_DMA+0x1b4>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2001609e:	687b      	ldr	r3, [r7, #4]
200160a0:	2200      	movs	r2, #0
200160a2:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
200160a4:	683b      	ldr	r3, [r7, #0]
200160a6:	2b00      	cmp	r3, #0
200160a8:	f000 80a7 	beq.w	200161fa <HAL_QSPI_Transmit_DMA+0x19a>
    {
      /* Configure counters of the handle */
      hqspi->TxXferCount = data_size;
200160ac:	687b      	ldr	r3, [r7, #4]
200160ae:	68ba      	ldr	r2, [r7, #8]
200160b0:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
200160b2:	687b      	ldr	r3, [r7, #4]
200160b4:	2212      	movs	r2, #18
200160b6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
200160ba:	687b      	ldr	r3, [r7, #4]
200160bc:	681b      	ldr	r3, [r3, #0]
200160be:	2203      	movs	r2, #3
200160c0:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->TxXferSize = hqspi->TxXferCount;
200160c2:	687b      	ldr	r3, [r7, #4]
200160c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
200160c6:	687b      	ldr	r3, [r7, #4]
200160c8:	629a      	str	r2, [r3, #40]	; 0x28
        hqspi->pTxBuffPtr = pData;
200160ca:	687b      	ldr	r3, [r7, #4]
200160cc:	683a      	ldr	r2, [r7, #0]
200160ce:	625a      	str	r2, [r3, #36]	; 0x24

        /* Configure QSPI: CCR register with functional mode as indirect write */
        MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
200160d0:	687b      	ldr	r3, [r7, #4]
200160d2:	681b      	ldr	r3, [r3, #0]
200160d4:	695a      	ldr	r2, [r3, #20]
200160d6:	687b      	ldr	r3, [r7, #4]
200160d8:	681b      	ldr	r3, [r3, #0]
200160da:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
200160de:	615a      	str	r2, [r3, #20]

        /* Set the QSPI MDMA transfer complete callback */
        hqspi->hmdma->XferCpltCallback = QSPI_DMATxCplt;
200160e0:	687b      	ldr	r3, [r7, #4]
200160e2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200160e4:	4a51      	ldr	r2, [pc, #324]	; (2001622c <HAL_QSPI_Transmit_DMA+0x1cc>)
200160e6:	645a      	str	r2, [r3, #68]	; 0x44

        /* Set the MDMA error callback */
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
200160e8:	687b      	ldr	r3, [r7, #4]
200160ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200160ec:	4a50      	ldr	r2, [pc, #320]	; (20016230 <HAL_QSPI_Transmit_DMA+0x1d0>)
200160ee:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the MDMA abort callback */
        hqspi->hmdma->XferAbortCallback = NULL;
200160f0:	687b      	ldr	r3, [r7, #4]
200160f2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200160f4:	2200      	movs	r2, #0
200160f6:	659a      	str	r2, [r3, #88]	; 0x58

        /* In Transmit mode , the MDMA destination is the QSPI DR register : Force the MDMA Destination Increment to disable */
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) ,MDMA_DEST_INC_DISABLE);
200160f8:	687b      	ldr	r3, [r7, #4]
200160fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200160fc:	681b      	ldr	r3, [r3, #0]
200160fe:	6919      	ldr	r1, [r3, #16]
20016100:	687b      	ldr	r3, [r7, #4]
20016102:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016104:	681a      	ldr	r2, [r3, #0]
20016106:	4b4b      	ldr	r3, [pc, #300]	; (20016234 <HAL_QSPI_Transmit_DMA+0x1d4>)
20016108:	400b      	ands	r3, r1
2001610a:	6113      	str	r3, [r2, #16]

        /* Update MDMA configuration with the correct SourceInc field for Write operation */
        if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_BYTE)
2001610c:	687b      	ldr	r3, [r7, #4]
2001610e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016110:	69db      	ldr	r3, [r3, #28]
20016112:	2b00      	cmp	r3, #0
20016114:	d10c      	bne.n	20016130 <HAL_QSPI_Transmit_DMA+0xd0>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_BYTE);
20016116:	687b      	ldr	r3, [r7, #4]
20016118:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001611a:	681b      	ldr	r3, [r3, #0]
2001611c:	691a      	ldr	r2, [r3, #16]
2001611e:	4b46      	ldr	r3, [pc, #280]	; (20016238 <HAL_QSPI_Transmit_DMA+0x1d8>)
20016120:	4013      	ands	r3, r2
20016122:	687a      	ldr	r2, [r7, #4]
20016124:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
20016126:	6812      	ldr	r2, [r2, #0]
20016128:	f043 0302 	orr.w	r3, r3, #2
2001612c:	6113      	str	r3, [r2, #16]
2001612e:	e02c      	b.n	2001618a <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_HALFWORD)
20016130:	687b      	ldr	r3, [r7, #4]
20016132:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016134:	69db      	ldr	r3, [r3, #28]
20016136:	2b10      	cmp	r3, #16
20016138:	d10c      	bne.n	20016154 <HAL_QSPI_Transmit_DMA+0xf4>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_HALFWORD);
2001613a:	687b      	ldr	r3, [r7, #4]
2001613c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001613e:	681b      	ldr	r3, [r3, #0]
20016140:	691a      	ldr	r2, [r3, #16]
20016142:	4b3d      	ldr	r3, [pc, #244]	; (20016238 <HAL_QSPI_Transmit_DMA+0x1d8>)
20016144:	4013      	ands	r3, r2
20016146:	687a      	ldr	r2, [r7, #4]
20016148:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2001614a:	6812      	ldr	r2, [r2, #0]
2001614c:	f443 7381 	orr.w	r3, r3, #258	; 0x102
20016150:	6113      	str	r3, [r2, #16]
20016152:	e01a      	b.n	2001618a <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_WORD)
20016154:	687b      	ldr	r3, [r7, #4]
20016156:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016158:	69db      	ldr	r3, [r3, #28]
2001615a:	2b20      	cmp	r3, #32
2001615c:	d10d      	bne.n	2001617a <HAL_QSPI_Transmit_DMA+0x11a>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_WORD);
2001615e:	687b      	ldr	r3, [r7, #4]
20016160:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016162:	681b      	ldr	r3, [r3, #0]
20016164:	691b      	ldr	r3, [r3, #16]
20016166:	4a34      	ldr	r2, [pc, #208]	; (20016238 <HAL_QSPI_Transmit_DMA+0x1d8>)
20016168:	401a      	ands	r2, r3
2001616a:	687b      	ldr	r3, [r7, #4]
2001616c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001616e:	6819      	ldr	r1, [r3, #0]
20016170:	f240 2302 	movw	r3, #514	; 0x202
20016174:	4313      	orrs	r3, r2
20016176:	610b      	str	r3, [r1, #16]
20016178:	e007      	b.n	2001618a <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else
        {
          /* in case of incorrect source data size */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
2001617a:	687b      	ldr	r3, [r7, #4]
2001617c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2001617e:	f043 0204 	orr.w	r2, r3, #4
20016182:	687b      	ldr	r3, [r7, #4]
20016184:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
20016186:	2301      	movs	r3, #1
20016188:	73fb      	strb	r3, [r7, #15]
        }

        /* Enable the QSPI transmit MDMA */
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)pData, (uint32_t)&hqspi->Instance->DR, hqspi->TxXferSize, 1) == HAL_OK)
2001618a:	687b      	ldr	r3, [r7, #4]
2001618c:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2001618e:	6839      	ldr	r1, [r7, #0]
20016190:	687b      	ldr	r3, [r7, #4]
20016192:	681b      	ldr	r3, [r3, #0]
20016194:	3320      	adds	r3, #32
20016196:	461c      	mov	r4, r3
20016198:	687b      	ldr	r3, [r7, #4]
2001619a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2001619c:	2301      	movs	r3, #1
2001619e:	9300      	str	r3, [sp, #0]
200161a0:	4613      	mov	r3, r2
200161a2:	4622      	mov	r2, r4
200161a4:	f7fd f9a2 	bl	200134ec <HAL_MDMA_Start_IT>
200161a8:	4603      	mov	r3, r0
200161aa:	2b00      	cmp	r3, #0
200161ac:	d114      	bne.n	200161d8 <HAL_QSPI_Transmit_DMA+0x178>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
200161ae:	687b      	ldr	r3, [r7, #4]
200161b0:	2200      	movs	r2, #0
200161b2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
200161b6:	687b      	ldr	r3, [r7, #4]
200161b8:	681b      	ldr	r3, [r3, #0]
200161ba:	681a      	ldr	r2, [r3, #0]
200161bc:	687b      	ldr	r3, [r7, #4]
200161be:	681b      	ldr	r3, [r3, #0]
200161c0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
200161c4:	601a      	str	r2, [r3, #0]

          /* Enable the MDMA transfer by setting the DMAEN bit in the QSPI CR register */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
200161c6:	687b      	ldr	r3, [r7, #4]
200161c8:	681b      	ldr	r3, [r3, #0]
200161ca:	681a      	ldr	r2, [r3, #0]
200161cc:	687b      	ldr	r3, [r7, #4]
200161ce:	681b      	ldr	r3, [r3, #0]
200161d0:	f042 0204 	orr.w	r2, r2, #4
200161d4:	601a      	str	r2, [r3, #0]
200161d6:	e023      	b.n	20016220 <HAL_QSPI_Transmit_DMA+0x1c0>
        }
        else
        {
          status = HAL_ERROR;
200161d8:	2301      	movs	r3, #1
200161da:	73fb      	strb	r3, [r7, #15]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
200161dc:	687b      	ldr	r3, [r7, #4]
200161de:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200161e0:	f043 0204 	orr.w	r2, r3, #4
200161e4:	687b      	ldr	r3, [r7, #4]
200161e6:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
200161e8:	687b      	ldr	r3, [r7, #4]
200161ea:	2201      	movs	r2, #1
200161ec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
200161f0:	687b      	ldr	r3, [r7, #4]
200161f2:	2200      	movs	r2, #0
200161f4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
200161f8:	e012      	b.n	20016220 <HAL_QSPI_Transmit_DMA+0x1c0>
        }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
200161fa:	687b      	ldr	r3, [r7, #4]
200161fc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200161fe:	f043 0208 	orr.w	r2, r3, #8
20016202:	687b      	ldr	r3, [r7, #4]
20016204:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
20016206:	2301      	movs	r3, #1
20016208:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2001620a:	687b      	ldr	r3, [r7, #4]
2001620c:	2200      	movs	r2, #0
2001620e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20016212:	e005      	b.n	20016220 <HAL_QSPI_Transmit_DMA+0x1c0>
    }
  }
  else
  {
    status = HAL_BUSY;
20016214:	2302      	movs	r3, #2
20016216:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20016218:	687b      	ldr	r3, [r7, #4]
2001621a:	2200      	movs	r2, #0
2001621c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
20016220:	7bfb      	ldrb	r3, [r7, #15]
}
20016222:	4618      	mov	r0, r3
20016224:	3714      	adds	r7, #20
20016226:	46bd      	mov	sp, r7
20016228:	bd90      	pop	{r4, r7, pc}
2001622a:	bf00      	nop
2001622c:	20017095 	.word	0x20017095
20016230:	200170c5 	.word	0x200170c5
20016234:	fffff3f3 	.word	0xfffff3f3
20016238:	fffffcfc 	.word	0xfffffcfc

2001623c <HAL_QSPI_Receive_DMA>:
  * @param  pData : pointer to data buffer.
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
2001623c:	b590      	push	{r4, r7, lr}
2001623e:	b089      	sub	sp, #36	; 0x24
20016240:	af02      	add	r7, sp, #8
20016242:	6078      	str	r0, [r7, #4]
20016244:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20016246:	2300      	movs	r3, #0
20016248:	75fb      	strb	r3, [r7, #23]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
2001624a:	687b      	ldr	r3, [r7, #4]
2001624c:	681b      	ldr	r3, [r3, #0]
2001624e:	699b      	ldr	r3, [r3, #24]
20016250:	613b      	str	r3, [r7, #16]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
20016252:	687b      	ldr	r3, [r7, #4]
20016254:	681b      	ldr	r3, [r3, #0]
20016256:	691b      	ldr	r3, [r3, #16]
20016258:	3301      	adds	r3, #1
2001625a:	60fb      	str	r3, [r7, #12]

  /* Process locked */
  __HAL_LOCK(hqspi);
2001625c:	687b      	ldr	r3, [r7, #4]
2001625e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20016262:	b2db      	uxtb	r3, r3
20016264:	2b01      	cmp	r3, #1
20016266:	d101      	bne.n	2001626c <HAL_QSPI_Receive_DMA+0x30>
20016268:	2302      	movs	r3, #2
2001626a:	e0d2      	b.n	20016412 <HAL_QSPI_Receive_DMA+0x1d6>
2001626c:	687b      	ldr	r3, [r7, #4]
2001626e:	2201      	movs	r2, #1
20016270:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20016274:	687b      	ldr	r3, [r7, #4]
20016276:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2001627a:	b2db      	uxtb	r3, r3
2001627c:	2b01      	cmp	r3, #1
2001627e:	f040 80c1 	bne.w	20016404 <HAL_QSPI_Receive_DMA+0x1c8>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20016282:	687b      	ldr	r3, [r7, #4]
20016284:	2200      	movs	r2, #0
20016286:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
20016288:	683b      	ldr	r3, [r7, #0]
2001628a:	2b00      	cmp	r3, #0
2001628c:	f000 80ad 	beq.w	200163ea <HAL_QSPI_Receive_DMA+0x1ae>
    {
      /* Configure counters of the handle */
      hqspi->RxXferCount = data_size;
20016290:	687b      	ldr	r3, [r7, #4]
20016292:	68fa      	ldr	r2, [r7, #12]
20016294:	639a      	str	r2, [r3, #56]	; 0x38
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
20016296:	687b      	ldr	r3, [r7, #4]
20016298:	2222      	movs	r2, #34	; 0x22
2001629a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
2001629e:	687b      	ldr	r3, [r7, #4]
200162a0:	681b      	ldr	r3, [r3, #0]
200162a2:	2203      	movs	r2, #3
200162a4:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->RxXferSize = hqspi->RxXferCount;
200162a6:	687b      	ldr	r3, [r7, #4]
200162a8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
200162aa:	687b      	ldr	r3, [r7, #4]
200162ac:	635a      	str	r2, [r3, #52]	; 0x34
        hqspi->pRxBuffPtr = pData;
200162ae:	687b      	ldr	r3, [r7, #4]
200162b0:	683a      	ldr	r2, [r7, #0]
200162b2:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the QSPI MDMA transfer complete callback */
        hqspi->hmdma->XferCpltCallback = QSPI_DMARxCplt;
200162b4:	687b      	ldr	r3, [r7, #4]
200162b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200162b8:	4a58      	ldr	r2, [pc, #352]	; (2001641c <HAL_QSPI_Receive_DMA+0x1e0>)
200162ba:	645a      	str	r2, [r3, #68]	; 0x44

        /* Set the MDMA error callback */
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
200162bc:	687b      	ldr	r3, [r7, #4]
200162be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200162c0:	4a57      	ldr	r2, [pc, #348]	; (20016420 <HAL_QSPI_Receive_DMA+0x1e4>)
200162c2:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the MDMA abort callback */
        hqspi->hmdma->XferAbortCallback = NULL;
200162c4:	687b      	ldr	r3, [r7, #4]
200162c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200162c8:	2200      	movs	r2, #0
200162ca:	659a      	str	r2, [r3, #88]	; 0x58

      /* In Receive mode , the MDMA source is the QSPI DR register : Force the MDMA Source Increment to disable */
      MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_DISABLE);
200162cc:	687b      	ldr	r3, [r7, #4]
200162ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200162d0:	681b      	ldr	r3, [r3, #0]
200162d2:	6919      	ldr	r1, [r3, #16]
200162d4:	687b      	ldr	r3, [r7, #4]
200162d6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200162d8:	681a      	ldr	r2, [r3, #0]
200162da:	4b52      	ldr	r3, [pc, #328]	; (20016424 <HAL_QSPI_Receive_DMA+0x1e8>)
200162dc:	400b      	ands	r3, r1
200162de:	6113      	str	r3, [r2, #16]

      /* Update MDMA configuration with the correct DestinationInc field for read operation */
      if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_BYTE)
200162e0:	687b      	ldr	r3, [r7, #4]
200162e2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200162e4:	6a1b      	ldr	r3, [r3, #32]
200162e6:	2b00      	cmp	r3, #0
200162e8:	d10c      	bne.n	20016304 <HAL_QSPI_Receive_DMA+0xc8>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_BYTE);
200162ea:	687b      	ldr	r3, [r7, #4]
200162ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200162ee:	681b      	ldr	r3, [r3, #0]
200162f0:	691a      	ldr	r2, [r3, #16]
200162f2:	4b4d      	ldr	r3, [pc, #308]	; (20016428 <HAL_QSPI_Receive_DMA+0x1ec>)
200162f4:	4013      	ands	r3, r2
200162f6:	687a      	ldr	r2, [r7, #4]
200162f8:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
200162fa:	6812      	ldr	r2, [r2, #0]
200162fc:	f043 0308 	orr.w	r3, r3, #8
20016300:	6113      	str	r3, [r2, #16]
20016302:	e02c      	b.n	2001635e <HAL_QSPI_Receive_DMA+0x122>
      }
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_HALFWORD)
20016304:	687b      	ldr	r3, [r7, #4]
20016306:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016308:	6a1b      	ldr	r3, [r3, #32]
2001630a:	2b40      	cmp	r3, #64	; 0x40
2001630c:	d10c      	bne.n	20016328 <HAL_QSPI_Receive_DMA+0xec>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_HALFWORD);
2001630e:	687b      	ldr	r3, [r7, #4]
20016310:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016312:	681b      	ldr	r3, [r3, #0]
20016314:	691a      	ldr	r2, [r3, #16]
20016316:	4b44      	ldr	r3, [pc, #272]	; (20016428 <HAL_QSPI_Receive_DMA+0x1ec>)
20016318:	4013      	ands	r3, r2
2001631a:	687a      	ldr	r2, [r7, #4]
2001631c:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2001631e:	6812      	ldr	r2, [r2, #0]
20016320:	f443 6381 	orr.w	r3, r3, #1032	; 0x408
20016324:	6113      	str	r3, [r2, #16]
20016326:	e01a      	b.n	2001635e <HAL_QSPI_Receive_DMA+0x122>
      }
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_WORD)
20016328:	687b      	ldr	r3, [r7, #4]
2001632a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001632c:	6a1b      	ldr	r3, [r3, #32]
2001632e:	2b80      	cmp	r3, #128	; 0x80
20016330:	d10d      	bne.n	2001634e <HAL_QSPI_Receive_DMA+0x112>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_WORD);
20016332:	687b      	ldr	r3, [r7, #4]
20016334:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016336:	681b      	ldr	r3, [r3, #0]
20016338:	691b      	ldr	r3, [r3, #16]
2001633a:	4a3b      	ldr	r2, [pc, #236]	; (20016428 <HAL_QSPI_Receive_DMA+0x1ec>)
2001633c:	401a      	ands	r2, r3
2001633e:	687b      	ldr	r3, [r7, #4]
20016340:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016342:	6819      	ldr	r1, [r3, #0]
20016344:	f640 0308 	movw	r3, #2056	; 0x808
20016348:	4313      	orrs	r3, r2
2001634a:	610b      	str	r3, [r1, #16]
2001634c:	e007      	b.n	2001635e <HAL_QSPI_Receive_DMA+0x122>
      }
      else
      {
       /* in case of incorrect destination data size */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
2001634e:	687b      	ldr	r3, [r7, #4]
20016350:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20016352:	f043 0204 	orr.w	r2, r3, #4
20016356:	687b      	ldr	r3, [r7, #4]
20016358:	645a      	str	r2, [r3, #68]	; 0x44
        status = HAL_ERROR;
2001635a:	2301      	movs	r3, #1
2001635c:	75fb      	strb	r3, [r7, #23]
      }
          /* Configure QSPI: CCR register with functional as indirect read */
          MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
2001635e:	687b      	ldr	r3, [r7, #4]
20016360:	681b      	ldr	r3, [r3, #0]
20016362:	695b      	ldr	r3, [r3, #20]
20016364:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
20016368:	687b      	ldr	r3, [r7, #4]
2001636a:	681b      	ldr	r3, [r3, #0]
2001636c:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
20016370:	615a      	str	r2, [r3, #20]

          /* Start the transfer by re-writing the address in AR register */
          WRITE_REG(hqspi->Instance->AR, addr_reg);
20016372:	687b      	ldr	r3, [r7, #4]
20016374:	681b      	ldr	r3, [r3, #0]
20016376:	693a      	ldr	r2, [r7, #16]
20016378:	619a      	str	r2, [r3, #24]

        /* Enable the MDMA */
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)&hqspi->Instance->DR, (uint32_t)pData, hqspi->RxXferSize, 1) == HAL_OK)
2001637a:	687b      	ldr	r3, [r7, #4]
2001637c:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2001637e:	687b      	ldr	r3, [r7, #4]
20016380:	681b      	ldr	r3, [r3, #0]
20016382:	3320      	adds	r3, #32
20016384:	461c      	mov	r4, r3
20016386:	683a      	ldr	r2, [r7, #0]
20016388:	687b      	ldr	r3, [r7, #4]
2001638a:	6b59      	ldr	r1, [r3, #52]	; 0x34
2001638c:	2301      	movs	r3, #1
2001638e:	9300      	str	r3, [sp, #0]
20016390:	460b      	mov	r3, r1
20016392:	4621      	mov	r1, r4
20016394:	f7fd f8aa 	bl	200134ec <HAL_MDMA_Start_IT>
20016398:	4603      	mov	r3, r0
2001639a:	2b00      	cmp	r3, #0
2001639c:	d114      	bne.n	200163c8 <HAL_QSPI_Receive_DMA+0x18c>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
2001639e:	687b      	ldr	r3, [r7, #4]
200163a0:	2200      	movs	r2, #0
200163a2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
200163a6:	687b      	ldr	r3, [r7, #4]
200163a8:	681b      	ldr	r3, [r3, #0]
200163aa:	681a      	ldr	r2, [r3, #0]
200163ac:	687b      	ldr	r3, [r7, #4]
200163ae:	681b      	ldr	r3, [r3, #0]
200163b0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
200163b4:	601a      	str	r2, [r3, #0]

          /* Enable the MDMA transfer by setting the DMAEN bit in the QSPI CR register */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
200163b6:	687b      	ldr	r3, [r7, #4]
200163b8:	681b      	ldr	r3, [r3, #0]
200163ba:	681a      	ldr	r2, [r3, #0]
200163bc:	687b      	ldr	r3, [r7, #4]
200163be:	681b      	ldr	r3, [r3, #0]
200163c0:	f042 0204 	orr.w	r2, r2, #4
200163c4:	601a      	str	r2, [r3, #0]
200163c6:	e023      	b.n	20016410 <HAL_QSPI_Receive_DMA+0x1d4>
        }
        else
        {
          status = HAL_ERROR;
200163c8:	2301      	movs	r3, #1
200163ca:	75fb      	strb	r3, [r7, #23]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
200163cc:	687b      	ldr	r3, [r7, #4]
200163ce:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200163d0:	f043 0204 	orr.w	r2, r3, #4
200163d4:	687b      	ldr	r3, [r7, #4]
200163d6:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
200163d8:	687b      	ldr	r3, [r7, #4]
200163da:	2201      	movs	r2, #1
200163dc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
200163e0:	687b      	ldr	r3, [r7, #4]
200163e2:	2200      	movs	r2, #0
200163e4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
200163e8:	e012      	b.n	20016410 <HAL_QSPI_Receive_DMA+0x1d4>
        }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
200163ea:	687b      	ldr	r3, [r7, #4]
200163ec:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200163ee:	f043 0208 	orr.w	r2, r3, #8
200163f2:	687b      	ldr	r3, [r7, #4]
200163f4:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
200163f6:	2301      	movs	r3, #1
200163f8:	75fb      	strb	r3, [r7, #23]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
200163fa:	687b      	ldr	r3, [r7, #4]
200163fc:	2200      	movs	r2, #0
200163fe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20016402:	e005      	b.n	20016410 <HAL_QSPI_Receive_DMA+0x1d4>
    }
  }
  else
  {
    status = HAL_BUSY;
20016404:	2302      	movs	r3, #2
20016406:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20016408:	687b      	ldr	r3, [r7, #4]
2001640a:	2200      	movs	r2, #0
2001640c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
20016410:	7dfb      	ldrb	r3, [r7, #23]
}
20016412:	4618      	mov	r0, r3
20016414:	371c      	adds	r7, #28
20016416:	46bd      	mov	sp, r7
20016418:	bd90      	pop	{r4, r7, pc}
2001641a:	bf00      	nop
2001641c:	20017065 	.word	0x20017065
20016420:	200170c5 	.word	0x200170c5
20016424:	fffffcfc 	.word	0xfffffcfc
20016428:	fffff3f3 	.word	0xfffff3f3

2001642c <HAL_QSPI_AutoPolling>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
2001642c:	b580      	push	{r7, lr}
2001642e:	b088      	sub	sp, #32
20016430:	af02      	add	r7, sp, #8
20016432:	60f8      	str	r0, [r7, #12]
20016434:	60b9      	str	r1, [r7, #8]
20016436:	607a      	str	r2, [r7, #4]
20016438:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
2001643a:	f7eb fc57 	bl	20001cec <HAL_GetTick>
2001643e:	6138      	str	r0, [r7, #16]

  /* Check the parameters */
  assert_param(IS_QSPI_INSTRUCTION_MODE(cmd->InstructionMode));
20016440:	68bb      	ldr	r3, [r7, #8]
20016442:	699b      	ldr	r3, [r3, #24]
20016444:	2b00      	cmp	r3, #0
20016446:	d013      	beq.n	20016470 <HAL_QSPI_AutoPolling+0x44>
20016448:	68bb      	ldr	r3, [r7, #8]
2001644a:	699b      	ldr	r3, [r3, #24]
2001644c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20016450:	d00e      	beq.n	20016470 <HAL_QSPI_AutoPolling+0x44>
20016452:	68bb      	ldr	r3, [r7, #8]
20016454:	699b      	ldr	r3, [r3, #24]
20016456:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2001645a:	d009      	beq.n	20016470 <HAL_QSPI_AutoPolling+0x44>
2001645c:	68bb      	ldr	r3, [r7, #8]
2001645e:	699b      	ldr	r3, [r3, #24]
20016460:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
20016464:	d004      	beq.n	20016470 <HAL_QSPI_AutoPolling+0x44>
20016466:	f240 51d9 	movw	r1, #1497	; 0x5d9
2001646a:	4878      	ldr	r0, [pc, #480]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
2001646c:	f7ea fa42 	bl	200008f4 <assert_failed>
  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
20016470:	68bb      	ldr	r3, [r7, #8]
20016472:	699b      	ldr	r3, [r3, #24]
20016474:	2b00      	cmp	r3, #0
20016476:	d008      	beq.n	2001648a <HAL_QSPI_AutoPolling+0x5e>
  {
    assert_param(IS_QSPI_INSTRUCTION(cmd->Instruction));
20016478:	68bb      	ldr	r3, [r7, #8]
2001647a:	681b      	ldr	r3, [r3, #0]
2001647c:	2bff      	cmp	r3, #255	; 0xff
2001647e:	d904      	bls.n	2001648a <HAL_QSPI_AutoPolling+0x5e>
20016480:	f240 51dc 	movw	r1, #1500	; 0x5dc
20016484:	4871      	ldr	r0, [pc, #452]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
20016486:	f7ea fa35 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_ADDRESS_MODE(cmd->AddressMode));
2001648a:	68bb      	ldr	r3, [r7, #8]
2001648c:	69db      	ldr	r3, [r3, #28]
2001648e:	2b00      	cmp	r3, #0
20016490:	d013      	beq.n	200164ba <HAL_QSPI_AutoPolling+0x8e>
20016492:	68bb      	ldr	r3, [r7, #8]
20016494:	69db      	ldr	r3, [r3, #28]
20016496:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2001649a:	d00e      	beq.n	200164ba <HAL_QSPI_AutoPolling+0x8e>
2001649c:	68bb      	ldr	r3, [r7, #8]
2001649e:	69db      	ldr	r3, [r3, #28]
200164a0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
200164a4:	d009      	beq.n	200164ba <HAL_QSPI_AutoPolling+0x8e>
200164a6:	68bb      	ldr	r3, [r7, #8]
200164a8:	69db      	ldr	r3, [r3, #28]
200164aa:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
200164ae:	d004      	beq.n	200164ba <HAL_QSPI_AutoPolling+0x8e>
200164b0:	f240 51df 	movw	r1, #1503	; 0x5df
200164b4:	4865      	ldr	r0, [pc, #404]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
200164b6:	f7ea fa1d 	bl	200008f4 <assert_failed>
  if (cmd->AddressMode != QSPI_ADDRESS_NONE)
200164ba:	68bb      	ldr	r3, [r7, #8]
200164bc:	69db      	ldr	r3, [r3, #28]
200164be:	2b00      	cmp	r3, #0
200164c0:	d017      	beq.n	200164f2 <HAL_QSPI_AutoPolling+0xc6>
  {
    assert_param(IS_QSPI_ADDRESS_SIZE(cmd->AddressSize));
200164c2:	68bb      	ldr	r3, [r7, #8]
200164c4:	68db      	ldr	r3, [r3, #12]
200164c6:	2b00      	cmp	r3, #0
200164c8:	d013      	beq.n	200164f2 <HAL_QSPI_AutoPolling+0xc6>
200164ca:	68bb      	ldr	r3, [r7, #8]
200164cc:	68db      	ldr	r3, [r3, #12]
200164ce:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
200164d2:	d00e      	beq.n	200164f2 <HAL_QSPI_AutoPolling+0xc6>
200164d4:	68bb      	ldr	r3, [r7, #8]
200164d6:	68db      	ldr	r3, [r3, #12]
200164d8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
200164dc:	d009      	beq.n	200164f2 <HAL_QSPI_AutoPolling+0xc6>
200164de:	68bb      	ldr	r3, [r7, #8]
200164e0:	68db      	ldr	r3, [r3, #12]
200164e2:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
200164e6:	d004      	beq.n	200164f2 <HAL_QSPI_AutoPolling+0xc6>
200164e8:	f240 51e2 	movw	r1, #1506	; 0x5e2
200164ec:	4857      	ldr	r0, [pc, #348]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
200164ee:	f7ea fa01 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_ALTERNATE_BYTES_MODE(cmd->AlternateByteMode));
200164f2:	68bb      	ldr	r3, [r7, #8]
200164f4:	6a1b      	ldr	r3, [r3, #32]
200164f6:	2b00      	cmp	r3, #0
200164f8:	d013      	beq.n	20016522 <HAL_QSPI_AutoPolling+0xf6>
200164fa:	68bb      	ldr	r3, [r7, #8]
200164fc:	6a1b      	ldr	r3, [r3, #32]
200164fe:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20016502:	d00e      	beq.n	20016522 <HAL_QSPI_AutoPolling+0xf6>
20016504:	68bb      	ldr	r3, [r7, #8]
20016506:	6a1b      	ldr	r3, [r3, #32]
20016508:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2001650c:	d009      	beq.n	20016522 <HAL_QSPI_AutoPolling+0xf6>
2001650e:	68bb      	ldr	r3, [r7, #8]
20016510:	6a1b      	ldr	r3, [r3, #32]
20016512:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
20016516:	d004      	beq.n	20016522 <HAL_QSPI_AutoPolling+0xf6>
20016518:	f240 51e5 	movw	r1, #1509	; 0x5e5
2001651c:	484b      	ldr	r0, [pc, #300]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
2001651e:	f7ea f9e9 	bl	200008f4 <assert_failed>
  if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
20016522:	68bb      	ldr	r3, [r7, #8]
20016524:	6a1b      	ldr	r3, [r3, #32]
20016526:	2b00      	cmp	r3, #0
20016528:	d017      	beq.n	2001655a <HAL_QSPI_AutoPolling+0x12e>
  {
    assert_param(IS_QSPI_ALTERNATE_BYTES_SIZE(cmd->AlternateBytesSize));
2001652a:	68bb      	ldr	r3, [r7, #8]
2001652c:	691b      	ldr	r3, [r3, #16]
2001652e:	2b00      	cmp	r3, #0
20016530:	d013      	beq.n	2001655a <HAL_QSPI_AutoPolling+0x12e>
20016532:	68bb      	ldr	r3, [r7, #8]
20016534:	691b      	ldr	r3, [r3, #16]
20016536:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2001653a:	d00e      	beq.n	2001655a <HAL_QSPI_AutoPolling+0x12e>
2001653c:	68bb      	ldr	r3, [r7, #8]
2001653e:	691b      	ldr	r3, [r3, #16]
20016540:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20016544:	d009      	beq.n	2001655a <HAL_QSPI_AutoPolling+0x12e>
20016546:	68bb      	ldr	r3, [r7, #8]
20016548:	691b      	ldr	r3, [r3, #16]
2001654a:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
2001654e:	d004      	beq.n	2001655a <HAL_QSPI_AutoPolling+0x12e>
20016550:	f44f 61bd 	mov.w	r1, #1512	; 0x5e8
20016554:	483d      	ldr	r0, [pc, #244]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
20016556:	f7ea f9cd 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_DUMMY_CYCLES(cmd->DummyCycles));
2001655a:	68bb      	ldr	r3, [r7, #8]
2001655c:	695b      	ldr	r3, [r3, #20]
2001655e:	2b1f      	cmp	r3, #31
20016560:	d904      	bls.n	2001656c <HAL_QSPI_AutoPolling+0x140>
20016562:	f240 51eb 	movw	r1, #1515	; 0x5eb
20016566:	4839      	ldr	r0, [pc, #228]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
20016568:	f7ea f9c4 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DATA_MODE(cmd->DataMode));
2001656c:	68bb      	ldr	r3, [r7, #8]
2001656e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20016570:	2b00      	cmp	r3, #0
20016572:	d013      	beq.n	2001659c <HAL_QSPI_AutoPolling+0x170>
20016574:	68bb      	ldr	r3, [r7, #8]
20016576:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20016578:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2001657c:	d00e      	beq.n	2001659c <HAL_QSPI_AutoPolling+0x170>
2001657e:	68bb      	ldr	r3, [r7, #8]
20016580:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20016582:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20016586:	d009      	beq.n	2001659c <HAL_QSPI_AutoPolling+0x170>
20016588:	68bb      	ldr	r3, [r7, #8]
2001658a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2001658c:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
20016590:	d004      	beq.n	2001659c <HAL_QSPI_AutoPolling+0x170>
20016592:	f240 51ec 	movw	r1, #1516	; 0x5ec
20016596:	482d      	ldr	r0, [pc, #180]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
20016598:	f7ea f9ac 	bl	200008f4 <assert_failed>

  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
2001659c:	68bb      	ldr	r3, [r7, #8]
2001659e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200165a0:	2b00      	cmp	r3, #0
200165a2:	d009      	beq.n	200165b8 <HAL_QSPI_AutoPolling+0x18c>
200165a4:	68bb      	ldr	r3, [r7, #8]
200165a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200165a8:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
200165ac:	d004      	beq.n	200165b8 <HAL_QSPI_AutoPolling+0x18c>
200165ae:	f240 51ee 	movw	r1, #1518	; 0x5ee
200165b2:	4826      	ldr	r0, [pc, #152]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
200165b4:	f7ea f99e 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
200165b8:	68bb      	ldr	r3, [r7, #8]
200165ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200165bc:	2b00      	cmp	r3, #0
200165be:	d009      	beq.n	200165d4 <HAL_QSPI_AutoPolling+0x1a8>
200165c0:	68bb      	ldr	r3, [r7, #8]
200165c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200165c4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
200165c8:	d004      	beq.n	200165d4 <HAL_QSPI_AutoPolling+0x1a8>
200165ca:	f240 51ef 	movw	r1, #1519	; 0x5ef
200165ce:	481f      	ldr	r0, [pc, #124]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
200165d0:	f7ea f990 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
200165d4:	68bb      	ldr	r3, [r7, #8]
200165d6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200165d8:	2b00      	cmp	r3, #0
200165da:	d009      	beq.n	200165f0 <HAL_QSPI_AutoPolling+0x1c4>
200165dc:	68bb      	ldr	r3, [r7, #8]
200165de:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200165e0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
200165e4:	d004      	beq.n	200165f0 <HAL_QSPI_AutoPolling+0x1c4>
200165e6:	f44f 61be 	mov.w	r1, #1520	; 0x5f0
200165ea:	4818      	ldr	r0, [pc, #96]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
200165ec:	f7ea f982 	bl	200008f4 <assert_failed>

  assert_param(IS_QSPI_INTERVAL(cfg->Interval));
200165f0:	687b      	ldr	r3, [r7, #4]
200165f2:	689b      	ldr	r3, [r3, #8]
200165f4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
200165f8:	d304      	bcc.n	20016604 <HAL_QSPI_AutoPolling+0x1d8>
200165fa:	f240 51f2 	movw	r1, #1522	; 0x5f2
200165fe:	4813      	ldr	r0, [pc, #76]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
20016600:	f7ea f978 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
20016604:	687b      	ldr	r3, [r7, #4]
20016606:	68db      	ldr	r3, [r3, #12]
20016608:	2b00      	cmp	r3, #0
2001660a:	d003      	beq.n	20016614 <HAL_QSPI_AutoPolling+0x1e8>
2001660c:	687b      	ldr	r3, [r7, #4]
2001660e:	68db      	ldr	r3, [r3, #12]
20016610:	2b04      	cmp	r3, #4
20016612:	d904      	bls.n	2001661e <HAL_QSPI_AutoPolling+0x1f2>
20016614:	f240 51f3 	movw	r1, #1523	; 0x5f3
20016618:	480c      	ldr	r0, [pc, #48]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
2001661a:	f7ea f96b 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
2001661e:	687b      	ldr	r3, [r7, #4]
20016620:	691b      	ldr	r3, [r3, #16]
20016622:	2b00      	cmp	r3, #0
20016624:	d009      	beq.n	2001663a <HAL_QSPI_AutoPolling+0x20e>
20016626:	687b      	ldr	r3, [r7, #4]
20016628:	691b      	ldr	r3, [r3, #16]
2001662a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
2001662e:	d004      	beq.n	2001663a <HAL_QSPI_AutoPolling+0x20e>
20016630:	f240 51f4 	movw	r1, #1524	; 0x5f4
20016634:	4805      	ldr	r0, [pc, #20]	; (2001664c <HAL_QSPI_AutoPolling+0x220>)
20016636:	f7ea f95d 	bl	200008f4 <assert_failed>

  /* Process locked */
  __HAL_LOCK(hqspi);
2001663a:	68fb      	ldr	r3, [r7, #12]
2001663c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20016640:	b2db      	uxtb	r3, r3
20016642:	2b01      	cmp	r3, #1
20016644:	d104      	bne.n	20016650 <HAL_QSPI_AutoPolling+0x224>
20016646:	2302      	movs	r3, #2
20016648:	e063      	b.n	20016712 <HAL_QSPI_AutoPolling+0x2e6>
2001664a:	bf00      	nop
2001664c:	2001c2a4 	.word	0x2001c2a4
20016650:	68fb      	ldr	r3, [r7, #12]
20016652:	2201      	movs	r2, #1
20016654:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20016658:	68fb      	ldr	r3, [r7, #12]
2001665a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2001665e:	b2db      	uxtb	r3, r3
20016660:	2b01      	cmp	r3, #1
20016662:	d14f      	bne.n	20016704 <HAL_QSPI_AutoPolling+0x2d8>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20016664:	68fb      	ldr	r3, [r7, #12]
20016666:	2200      	movs	r2, #0
20016668:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
2001666a:	68fb      	ldr	r3, [r7, #12]
2001666c:	2242      	movs	r2, #66	; 0x42
2001666e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
20016672:	683b      	ldr	r3, [r7, #0]
20016674:	9300      	str	r3, [sp, #0]
20016676:	693b      	ldr	r3, [r7, #16]
20016678:	2200      	movs	r2, #0
2001667a:	2120      	movs	r1, #32
2001667c:	68f8      	ldr	r0, [r7, #12]
2001667e:	f000 fd76 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
20016682:	4603      	mov	r3, r0
20016684:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
20016686:	7dfb      	ldrb	r3, [r7, #23]
20016688:	2b00      	cmp	r3, #0
2001668a:	d13d      	bne.n	20016708 <HAL_QSPI_AutoPolling+0x2dc>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
2001668c:	68fb      	ldr	r3, [r7, #12]
2001668e:	681b      	ldr	r3, [r3, #0]
20016690:	687a      	ldr	r2, [r7, #4]
20016692:	6812      	ldr	r2, [r2, #0]
20016694:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
20016696:	68fb      	ldr	r3, [r7, #12]
20016698:	681b      	ldr	r3, [r3, #0]
2001669a:	687a      	ldr	r2, [r7, #4]
2001669c:	6852      	ldr	r2, [r2, #4]
2001669e:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
200166a0:	68fb      	ldr	r3, [r7, #12]
200166a2:	681b      	ldr	r3, [r3, #0]
200166a4:	687a      	ldr	r2, [r7, #4]
200166a6:	6892      	ldr	r2, [r2, #8]
200166a8:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop enabled
      (otherwise there will be an infinite loop in blocking mode) */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
200166aa:	68fb      	ldr	r3, [r7, #12]
200166ac:	681b      	ldr	r3, [r3, #0]
200166ae:	681b      	ldr	r3, [r3, #0]
200166b0:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
200166b4:	687b      	ldr	r3, [r7, #4]
200166b6:	691b      	ldr	r3, [r3, #16]
200166b8:	431a      	orrs	r2, r3
200166ba:	68fb      	ldr	r3, [r7, #12]
200166bc:	681b      	ldr	r3, [r3, #0]
200166be:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
200166c2:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | QSPI_AUTOMATIC_STOP_ENABLE));

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
200166c4:	687b      	ldr	r3, [r7, #4]
200166c6:	68da      	ldr	r2, [r3, #12]
200166c8:	68bb      	ldr	r3, [r7, #8]
200166ca:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
200166cc:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
200166d0:	68b9      	ldr	r1, [r7, #8]
200166d2:	68f8      	ldr	r0, [r7, #12]
200166d4:	f000 fd82 	bl	200171dc <QSPI_Config>

      /* Wait until SM flag is set to go back in idle state */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
200166d8:	683b      	ldr	r3, [r7, #0]
200166da:	9300      	str	r3, [sp, #0]
200166dc:	693b      	ldr	r3, [r7, #16]
200166de:	2201      	movs	r2, #1
200166e0:	2108      	movs	r1, #8
200166e2:	68f8      	ldr	r0, [r7, #12]
200166e4:	f000 fd43 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
200166e8:	4603      	mov	r3, r0
200166ea:	75fb      	strb	r3, [r7, #23]

      if (status == HAL_OK)
200166ec:	7dfb      	ldrb	r3, [r7, #23]
200166ee:	2b00      	cmp	r3, #0
200166f0:	d10a      	bne.n	20016708 <HAL_QSPI_AutoPolling+0x2dc>
      {
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
200166f2:	68fb      	ldr	r3, [r7, #12]
200166f4:	681b      	ldr	r3, [r3, #0]
200166f6:	2208      	movs	r2, #8
200166f8:	60da      	str	r2, [r3, #12]

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_READY;
200166fa:	68fb      	ldr	r3, [r7, #12]
200166fc:	2201      	movs	r2, #1
200166fe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
20016702:	e001      	b.n	20016708 <HAL_QSPI_AutoPolling+0x2dc>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
20016704:	2302      	movs	r3, #2
20016706:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
20016708:	68fb      	ldr	r3, [r7, #12]
2001670a:	2200      	movs	r2, #0
2001670c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
20016710:	7dfb      	ldrb	r3, [r7, #23]
}
20016712:	4618      	mov	r0, r3
20016714:	3718      	adds	r7, #24
20016716:	46bd      	mov	sp, r7
20016718:	bd80      	pop	{r7, pc}
2001671a:	bf00      	nop

2001671c <HAL_QSPI_AutoPolling_IT>:
  * @param  cfg : structure that contains the polling configuration information.
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg)
{
2001671c:	b580      	push	{r7, lr}
2001671e:	b088      	sub	sp, #32
20016720:	af02      	add	r7, sp, #8
20016722:	60f8      	str	r0, [r7, #12]
20016724:	60b9      	str	r1, [r7, #8]
20016726:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
20016728:	f7eb fae0 	bl	20001cec <HAL_GetTick>
2001672c:	6138      	str	r0, [r7, #16]

  /* Check the parameters */
  assert_param(IS_QSPI_INSTRUCTION_MODE(cmd->InstructionMode));
2001672e:	68bb      	ldr	r3, [r7, #8]
20016730:	699b      	ldr	r3, [r3, #24]
20016732:	2b00      	cmp	r3, #0
20016734:	d013      	beq.n	2001675e <HAL_QSPI_AutoPolling_IT+0x42>
20016736:	68bb      	ldr	r3, [r7, #8]
20016738:	699b      	ldr	r3, [r3, #24]
2001673a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2001673e:	d00e      	beq.n	2001675e <HAL_QSPI_AutoPolling_IT+0x42>
20016740:	68bb      	ldr	r3, [r7, #8]
20016742:	699b      	ldr	r3, [r3, #24]
20016744:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20016748:	d009      	beq.n	2001675e <HAL_QSPI_AutoPolling_IT+0x42>
2001674a:	68bb      	ldr	r3, [r7, #8]
2001674c:	699b      	ldr	r3, [r3, #24]
2001674e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
20016752:	d004      	beq.n	2001675e <HAL_QSPI_AutoPolling_IT+0x42>
20016754:	f240 613d 	movw	r1, #1597	; 0x63d
20016758:	487e      	ldr	r0, [pc, #504]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
2001675a:	f7ea f8cb 	bl	200008f4 <assert_failed>
  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
2001675e:	68bb      	ldr	r3, [r7, #8]
20016760:	699b      	ldr	r3, [r3, #24]
20016762:	2b00      	cmp	r3, #0
20016764:	d008      	beq.n	20016778 <HAL_QSPI_AutoPolling_IT+0x5c>
  {
    assert_param(IS_QSPI_INSTRUCTION(cmd->Instruction));
20016766:	68bb      	ldr	r3, [r7, #8]
20016768:	681b      	ldr	r3, [r3, #0]
2001676a:	2bff      	cmp	r3, #255	; 0xff
2001676c:	d904      	bls.n	20016778 <HAL_QSPI_AutoPolling_IT+0x5c>
2001676e:	f44f 61c8 	mov.w	r1, #1600	; 0x640
20016772:	4878      	ldr	r0, [pc, #480]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
20016774:	f7ea f8be 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_ADDRESS_MODE(cmd->AddressMode));
20016778:	68bb      	ldr	r3, [r7, #8]
2001677a:	69db      	ldr	r3, [r3, #28]
2001677c:	2b00      	cmp	r3, #0
2001677e:	d013      	beq.n	200167a8 <HAL_QSPI_AutoPolling_IT+0x8c>
20016780:	68bb      	ldr	r3, [r7, #8]
20016782:	69db      	ldr	r3, [r3, #28]
20016784:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20016788:	d00e      	beq.n	200167a8 <HAL_QSPI_AutoPolling_IT+0x8c>
2001678a:	68bb      	ldr	r3, [r7, #8]
2001678c:	69db      	ldr	r3, [r3, #28]
2001678e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
20016792:	d009      	beq.n	200167a8 <HAL_QSPI_AutoPolling_IT+0x8c>
20016794:	68bb      	ldr	r3, [r7, #8]
20016796:	69db      	ldr	r3, [r3, #28]
20016798:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
2001679c:	d004      	beq.n	200167a8 <HAL_QSPI_AutoPolling_IT+0x8c>
2001679e:	f240 6143 	movw	r1, #1603	; 0x643
200167a2:	486c      	ldr	r0, [pc, #432]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
200167a4:	f7ea f8a6 	bl	200008f4 <assert_failed>
  if (cmd->AddressMode != QSPI_ADDRESS_NONE)
200167a8:	68bb      	ldr	r3, [r7, #8]
200167aa:	69db      	ldr	r3, [r3, #28]
200167ac:	2b00      	cmp	r3, #0
200167ae:	d017      	beq.n	200167e0 <HAL_QSPI_AutoPolling_IT+0xc4>
  {
    assert_param(IS_QSPI_ADDRESS_SIZE(cmd->AddressSize));
200167b0:	68bb      	ldr	r3, [r7, #8]
200167b2:	68db      	ldr	r3, [r3, #12]
200167b4:	2b00      	cmp	r3, #0
200167b6:	d013      	beq.n	200167e0 <HAL_QSPI_AutoPolling_IT+0xc4>
200167b8:	68bb      	ldr	r3, [r7, #8]
200167ba:	68db      	ldr	r3, [r3, #12]
200167bc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
200167c0:	d00e      	beq.n	200167e0 <HAL_QSPI_AutoPolling_IT+0xc4>
200167c2:	68bb      	ldr	r3, [r7, #8]
200167c4:	68db      	ldr	r3, [r3, #12]
200167c6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
200167ca:	d009      	beq.n	200167e0 <HAL_QSPI_AutoPolling_IT+0xc4>
200167cc:	68bb      	ldr	r3, [r7, #8]
200167ce:	68db      	ldr	r3, [r3, #12]
200167d0:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
200167d4:	d004      	beq.n	200167e0 <HAL_QSPI_AutoPolling_IT+0xc4>
200167d6:	f240 6146 	movw	r1, #1606	; 0x646
200167da:	485e      	ldr	r0, [pc, #376]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
200167dc:	f7ea f88a 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_ALTERNATE_BYTES_MODE(cmd->AlternateByteMode));
200167e0:	68bb      	ldr	r3, [r7, #8]
200167e2:	6a1b      	ldr	r3, [r3, #32]
200167e4:	2b00      	cmp	r3, #0
200167e6:	d013      	beq.n	20016810 <HAL_QSPI_AutoPolling_IT+0xf4>
200167e8:	68bb      	ldr	r3, [r7, #8]
200167ea:	6a1b      	ldr	r3, [r3, #32]
200167ec:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
200167f0:	d00e      	beq.n	20016810 <HAL_QSPI_AutoPolling_IT+0xf4>
200167f2:	68bb      	ldr	r3, [r7, #8]
200167f4:	6a1b      	ldr	r3, [r3, #32]
200167f6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
200167fa:	d009      	beq.n	20016810 <HAL_QSPI_AutoPolling_IT+0xf4>
200167fc:	68bb      	ldr	r3, [r7, #8]
200167fe:	6a1b      	ldr	r3, [r3, #32]
20016800:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
20016804:	d004      	beq.n	20016810 <HAL_QSPI_AutoPolling_IT+0xf4>
20016806:	f240 6149 	movw	r1, #1609	; 0x649
2001680a:	4852      	ldr	r0, [pc, #328]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
2001680c:	f7ea f872 	bl	200008f4 <assert_failed>
  if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
20016810:	68bb      	ldr	r3, [r7, #8]
20016812:	6a1b      	ldr	r3, [r3, #32]
20016814:	2b00      	cmp	r3, #0
20016816:	d017      	beq.n	20016848 <HAL_QSPI_AutoPolling_IT+0x12c>
  {
    assert_param(IS_QSPI_ALTERNATE_BYTES_SIZE(cmd->AlternateBytesSize));
20016818:	68bb      	ldr	r3, [r7, #8]
2001681a:	691b      	ldr	r3, [r3, #16]
2001681c:	2b00      	cmp	r3, #0
2001681e:	d013      	beq.n	20016848 <HAL_QSPI_AutoPolling_IT+0x12c>
20016820:	68bb      	ldr	r3, [r7, #8]
20016822:	691b      	ldr	r3, [r3, #16]
20016824:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20016828:	d00e      	beq.n	20016848 <HAL_QSPI_AutoPolling_IT+0x12c>
2001682a:	68bb      	ldr	r3, [r7, #8]
2001682c:	691b      	ldr	r3, [r3, #16]
2001682e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20016832:	d009      	beq.n	20016848 <HAL_QSPI_AutoPolling_IT+0x12c>
20016834:	68bb      	ldr	r3, [r7, #8]
20016836:	691b      	ldr	r3, [r3, #16]
20016838:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
2001683c:	d004      	beq.n	20016848 <HAL_QSPI_AutoPolling_IT+0x12c>
2001683e:	f240 614c 	movw	r1, #1612	; 0x64c
20016842:	4844      	ldr	r0, [pc, #272]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
20016844:	f7ea f856 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_DUMMY_CYCLES(cmd->DummyCycles));
20016848:	68bb      	ldr	r3, [r7, #8]
2001684a:	695b      	ldr	r3, [r3, #20]
2001684c:	2b1f      	cmp	r3, #31
2001684e:	d904      	bls.n	2001685a <HAL_QSPI_AutoPolling_IT+0x13e>
20016850:	f240 614f 	movw	r1, #1615	; 0x64f
20016854:	483f      	ldr	r0, [pc, #252]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
20016856:	f7ea f84d 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DATA_MODE(cmd->DataMode));
2001685a:	68bb      	ldr	r3, [r7, #8]
2001685c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2001685e:	2b00      	cmp	r3, #0
20016860:	d013      	beq.n	2001688a <HAL_QSPI_AutoPolling_IT+0x16e>
20016862:	68bb      	ldr	r3, [r7, #8]
20016864:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20016866:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2001686a:	d00e      	beq.n	2001688a <HAL_QSPI_AutoPolling_IT+0x16e>
2001686c:	68bb      	ldr	r3, [r7, #8]
2001686e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20016870:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20016874:	d009      	beq.n	2001688a <HAL_QSPI_AutoPolling_IT+0x16e>
20016876:	68bb      	ldr	r3, [r7, #8]
20016878:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2001687a:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
2001687e:	d004      	beq.n	2001688a <HAL_QSPI_AutoPolling_IT+0x16e>
20016880:	f44f 61ca 	mov.w	r1, #1616	; 0x650
20016884:	4833      	ldr	r0, [pc, #204]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
20016886:	f7ea f835 	bl	200008f4 <assert_failed>

  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
2001688a:	68bb      	ldr	r3, [r7, #8]
2001688c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001688e:	2b00      	cmp	r3, #0
20016890:	d009      	beq.n	200168a6 <HAL_QSPI_AutoPolling_IT+0x18a>
20016892:	68bb      	ldr	r3, [r7, #8]
20016894:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20016896:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
2001689a:	d004      	beq.n	200168a6 <HAL_QSPI_AutoPolling_IT+0x18a>
2001689c:	f240 6152 	movw	r1, #1618	; 0x652
200168a0:	482c      	ldr	r0, [pc, #176]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
200168a2:	f7ea f827 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
200168a6:	68bb      	ldr	r3, [r7, #8]
200168a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200168aa:	2b00      	cmp	r3, #0
200168ac:	d009      	beq.n	200168c2 <HAL_QSPI_AutoPolling_IT+0x1a6>
200168ae:	68bb      	ldr	r3, [r7, #8]
200168b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200168b2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
200168b6:	d004      	beq.n	200168c2 <HAL_QSPI_AutoPolling_IT+0x1a6>
200168b8:	f240 6153 	movw	r1, #1619	; 0x653
200168bc:	4825      	ldr	r0, [pc, #148]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
200168be:	f7ea f819 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
200168c2:	68bb      	ldr	r3, [r7, #8]
200168c4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200168c6:	2b00      	cmp	r3, #0
200168c8:	d009      	beq.n	200168de <HAL_QSPI_AutoPolling_IT+0x1c2>
200168ca:	68bb      	ldr	r3, [r7, #8]
200168cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200168ce:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
200168d2:	d004      	beq.n	200168de <HAL_QSPI_AutoPolling_IT+0x1c2>
200168d4:	f240 6154 	movw	r1, #1620	; 0x654
200168d8:	481e      	ldr	r0, [pc, #120]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
200168da:	f7ea f80b 	bl	200008f4 <assert_failed>

  assert_param(IS_QSPI_INTERVAL(cfg->Interval));
200168de:	687b      	ldr	r3, [r7, #4]
200168e0:	689b      	ldr	r3, [r3, #8]
200168e2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
200168e6:	d304      	bcc.n	200168f2 <HAL_QSPI_AutoPolling_IT+0x1d6>
200168e8:	f240 6156 	movw	r1, #1622	; 0x656
200168ec:	4819      	ldr	r0, [pc, #100]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
200168ee:	f7ea f801 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
200168f2:	687b      	ldr	r3, [r7, #4]
200168f4:	68db      	ldr	r3, [r3, #12]
200168f6:	2b00      	cmp	r3, #0
200168f8:	d003      	beq.n	20016902 <HAL_QSPI_AutoPolling_IT+0x1e6>
200168fa:	687b      	ldr	r3, [r7, #4]
200168fc:	68db      	ldr	r3, [r3, #12]
200168fe:	2b04      	cmp	r3, #4
20016900:	d904      	bls.n	2001690c <HAL_QSPI_AutoPolling_IT+0x1f0>
20016902:	f240 6157 	movw	r1, #1623	; 0x657
20016906:	4813      	ldr	r0, [pc, #76]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
20016908:	f7e9 fff4 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
2001690c:	687b      	ldr	r3, [r7, #4]
2001690e:	691b      	ldr	r3, [r3, #16]
20016910:	2b00      	cmp	r3, #0
20016912:	d009      	beq.n	20016928 <HAL_QSPI_AutoPolling_IT+0x20c>
20016914:	687b      	ldr	r3, [r7, #4]
20016916:	691b      	ldr	r3, [r3, #16]
20016918:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
2001691c:	d004      	beq.n	20016928 <HAL_QSPI_AutoPolling_IT+0x20c>
2001691e:	f44f 61cb 	mov.w	r1, #1624	; 0x658
20016922:	480c      	ldr	r0, [pc, #48]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
20016924:	f7e9 ffe6 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_AUTOMATIC_STOP(cfg->AutomaticStop));
20016928:	687b      	ldr	r3, [r7, #4]
2001692a:	695b      	ldr	r3, [r3, #20]
2001692c:	2b00      	cmp	r3, #0
2001692e:	d009      	beq.n	20016944 <HAL_QSPI_AutoPolling_IT+0x228>
20016930:	687b      	ldr	r3, [r7, #4]
20016932:	695b      	ldr	r3, [r3, #20]
20016934:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
20016938:	d004      	beq.n	20016944 <HAL_QSPI_AutoPolling_IT+0x228>
2001693a:	f240 6159 	movw	r1, #1625	; 0x659
2001693e:	4805      	ldr	r0, [pc, #20]	; (20016954 <HAL_QSPI_AutoPolling_IT+0x238>)
20016940:	f7e9 ffd8 	bl	200008f4 <assert_failed>

  /* Process locked */
  __HAL_LOCK(hqspi);
20016944:	68fb      	ldr	r3, [r7, #12]
20016946:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2001694a:	b2db      	uxtb	r3, r3
2001694c:	2b01      	cmp	r3, #1
2001694e:	d103      	bne.n	20016958 <HAL_QSPI_AutoPolling_IT+0x23c>
20016950:	2302      	movs	r3, #2
20016952:	e064      	b.n	20016a1e <HAL_QSPI_AutoPolling_IT+0x302>
20016954:	2001c2a4 	.word	0x2001c2a4
20016958:	68fb      	ldr	r3, [r7, #12]
2001695a:	2201      	movs	r2, #1
2001695c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20016960:	68fb      	ldr	r3, [r7, #12]
20016962:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20016966:	b2db      	uxtb	r3, r3
20016968:	2b01      	cmp	r3, #1
2001696a:	d151      	bne.n	20016a10 <HAL_QSPI_AutoPolling_IT+0x2f4>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2001696c:	68fb      	ldr	r3, [r7, #12]
2001696e:	2200      	movs	r2, #0
20016970:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
20016972:	68fb      	ldr	r3, [r7, #12]
20016974:	2242      	movs	r2, #66	; 0x42
20016976:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2001697a:	68fb      	ldr	r3, [r7, #12]
2001697c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2001697e:	9300      	str	r3, [sp, #0]
20016980:	693b      	ldr	r3, [r7, #16]
20016982:	2200      	movs	r2, #0
20016984:	2120      	movs	r1, #32
20016986:	68f8      	ldr	r0, [r7, #12]
20016988:	f000 fbf1 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
2001698c:	4603      	mov	r3, r0
2001698e:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
20016990:	7dfb      	ldrb	r3, [r7, #23]
20016992:	2b00      	cmp	r3, #0
20016994:	d137      	bne.n	20016a06 <HAL_QSPI_AutoPolling_IT+0x2ea>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
20016996:	68fb      	ldr	r3, [r7, #12]
20016998:	681b      	ldr	r3, [r3, #0]
2001699a:	687a      	ldr	r2, [r7, #4]
2001699c:	6812      	ldr	r2, [r2, #0]
2001699e:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
200169a0:	68fb      	ldr	r3, [r7, #12]
200169a2:	681b      	ldr	r3, [r3, #0]
200169a4:	687a      	ldr	r2, [r7, #4]
200169a6:	6852      	ldr	r2, [r2, #4]
200169a8:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
200169aa:	68fb      	ldr	r3, [r7, #12]
200169ac:	681b      	ldr	r3, [r3, #0]
200169ae:	687a      	ldr	r2, [r7, #4]
200169b0:	6892      	ldr	r2, [r2, #8]
200169b2:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop mode */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
200169b4:	68fb      	ldr	r3, [r7, #12]
200169b6:	681b      	ldr	r3, [r3, #0]
200169b8:	681b      	ldr	r3, [r3, #0]
200169ba:	f423 0140 	bic.w	r1, r3, #12582912	; 0xc00000
200169be:	687b      	ldr	r3, [r7, #4]
200169c0:	691a      	ldr	r2, [r3, #16]
200169c2:	687b      	ldr	r3, [r7, #4]
200169c4:	695b      	ldr	r3, [r3, #20]
200169c6:	431a      	orrs	r2, r3
200169c8:	68fb      	ldr	r3, [r7, #12]
200169ca:	681b      	ldr	r3, [r3, #0]
200169cc:	430a      	orrs	r2, r1
200169ce:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | cfg->AutomaticStop));

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_SM);
200169d0:	68fb      	ldr	r3, [r7, #12]
200169d2:	681b      	ldr	r3, [r3, #0]
200169d4:	2209      	movs	r2, #9
200169d6:	60da      	str	r2, [r3, #12]

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
200169d8:	687b      	ldr	r3, [r7, #4]
200169da:	68da      	ldr	r2, [r3, #12]
200169dc:	68bb      	ldr	r3, [r7, #8]
200169de:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
200169e0:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
200169e4:	68b9      	ldr	r1, [r7, #8]
200169e6:	68f8      	ldr	r0, [r7, #12]
200169e8:	f000 fbf8 	bl	200171dc <QSPI_Config>

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
200169ec:	68fb      	ldr	r3, [r7, #12]
200169ee:	2200      	movs	r2, #0
200169f0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI Transfer Error and status match Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
200169f4:	68fb      	ldr	r3, [r7, #12]
200169f6:	681b      	ldr	r3, [r3, #0]
200169f8:	681a      	ldr	r2, [r3, #0]
200169fa:	68fb      	ldr	r3, [r7, #12]
200169fc:	681b      	ldr	r3, [r3, #0]
200169fe:	f442 2210 	orr.w	r2, r2, #589824	; 0x90000
20016a02:	601a      	str	r2, [r3, #0]
20016a04:	e00a      	b.n	20016a1c <HAL_QSPI_AutoPolling_IT+0x300>

    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20016a06:	68fb      	ldr	r3, [r7, #12]
20016a08:	2200      	movs	r2, #0
20016a0a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20016a0e:	e005      	b.n	20016a1c <HAL_QSPI_AutoPolling_IT+0x300>
    }
  }
  else
  {
    status = HAL_BUSY;
20016a10:	2302      	movs	r3, #2
20016a12:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20016a14:	68fb      	ldr	r3, [r7, #12]
20016a16:	2200      	movs	r2, #0
20016a18:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
20016a1c:	7dfb      	ldrb	r3, [r7, #23]
}
20016a1e:	4618      	mov	r0, r3
20016a20:	3718      	adds	r7, #24
20016a22:	46bd      	mov	sp, r7
20016a24:	bd80      	pop	{r7, pc}
20016a26:	bf00      	nop

20016a28 <HAL_QSPI_MemoryMapped>:
  * @param  cfg : structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_MemoryMapped(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_MemoryMappedTypeDef *cfg)
{
20016a28:	b580      	push	{r7, lr}
20016a2a:	b088      	sub	sp, #32
20016a2c:	af02      	add	r7, sp, #8
20016a2e:	60f8      	str	r0, [r7, #12]
20016a30:	60b9      	str	r1, [r7, #8]
20016a32:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
20016a34:	f7eb f95a 	bl	20001cec <HAL_GetTick>
20016a38:	6138      	str	r0, [r7, #16]

  /* Check the parameters */
  assert_param(IS_QSPI_INSTRUCTION_MODE(cmd->InstructionMode));
20016a3a:	68bb      	ldr	r3, [r7, #8]
20016a3c:	699b      	ldr	r3, [r3, #24]
20016a3e:	2b00      	cmp	r3, #0
20016a40:	d013      	beq.n	20016a6a <HAL_QSPI_MemoryMapped+0x42>
20016a42:	68bb      	ldr	r3, [r7, #8]
20016a44:	699b      	ldr	r3, [r3, #24]
20016a46:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20016a4a:	d00e      	beq.n	20016a6a <HAL_QSPI_MemoryMapped+0x42>
20016a4c:	68bb      	ldr	r3, [r7, #8]
20016a4e:	699b      	ldr	r3, [r3, #24]
20016a50:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20016a54:	d009      	beq.n	20016a6a <HAL_QSPI_MemoryMapped+0x42>
20016a56:	68bb      	ldr	r3, [r7, #8]
20016a58:	699b      	ldr	r3, [r3, #24]
20016a5a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
20016a5e:	d004      	beq.n	20016a6a <HAL_QSPI_MemoryMapped+0x42>
20016a60:	f240 61a5 	movw	r1, #1701	; 0x6a5
20016a64:	4899      	ldr	r0, [pc, #612]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016a66:	f7e9 ff45 	bl	200008f4 <assert_failed>
  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
20016a6a:	68bb      	ldr	r3, [r7, #8]
20016a6c:	699b      	ldr	r3, [r3, #24]
20016a6e:	2b00      	cmp	r3, #0
20016a70:	d008      	beq.n	20016a84 <HAL_QSPI_MemoryMapped+0x5c>
  {
  assert_param(IS_QSPI_INSTRUCTION(cmd->Instruction));
20016a72:	68bb      	ldr	r3, [r7, #8]
20016a74:	681b      	ldr	r3, [r3, #0]
20016a76:	2bff      	cmp	r3, #255	; 0xff
20016a78:	d904      	bls.n	20016a84 <HAL_QSPI_MemoryMapped+0x5c>
20016a7a:	f44f 61d5 	mov.w	r1, #1704	; 0x6a8
20016a7e:	4893      	ldr	r0, [pc, #588]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016a80:	f7e9 ff38 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_ADDRESS_MODE(cmd->AddressMode));
20016a84:	68bb      	ldr	r3, [r7, #8]
20016a86:	69db      	ldr	r3, [r3, #28]
20016a88:	2b00      	cmp	r3, #0
20016a8a:	d013      	beq.n	20016ab4 <HAL_QSPI_MemoryMapped+0x8c>
20016a8c:	68bb      	ldr	r3, [r7, #8]
20016a8e:	69db      	ldr	r3, [r3, #28]
20016a90:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20016a94:	d00e      	beq.n	20016ab4 <HAL_QSPI_MemoryMapped+0x8c>
20016a96:	68bb      	ldr	r3, [r7, #8]
20016a98:	69db      	ldr	r3, [r3, #28]
20016a9a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
20016a9e:	d009      	beq.n	20016ab4 <HAL_QSPI_MemoryMapped+0x8c>
20016aa0:	68bb      	ldr	r3, [r7, #8]
20016aa2:	69db      	ldr	r3, [r3, #28]
20016aa4:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
20016aa8:	d004      	beq.n	20016ab4 <HAL_QSPI_MemoryMapped+0x8c>
20016aaa:	f240 61ab 	movw	r1, #1707	; 0x6ab
20016aae:	4887      	ldr	r0, [pc, #540]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016ab0:	f7e9 ff20 	bl	200008f4 <assert_failed>
  if (cmd->AddressMode != QSPI_ADDRESS_NONE)
20016ab4:	68bb      	ldr	r3, [r7, #8]
20016ab6:	69db      	ldr	r3, [r3, #28]
20016ab8:	2b00      	cmp	r3, #0
20016aba:	d017      	beq.n	20016aec <HAL_QSPI_MemoryMapped+0xc4>
  {
    assert_param(IS_QSPI_ADDRESS_SIZE(cmd->AddressSize));
20016abc:	68bb      	ldr	r3, [r7, #8]
20016abe:	68db      	ldr	r3, [r3, #12]
20016ac0:	2b00      	cmp	r3, #0
20016ac2:	d013      	beq.n	20016aec <HAL_QSPI_MemoryMapped+0xc4>
20016ac4:	68bb      	ldr	r3, [r7, #8]
20016ac6:	68db      	ldr	r3, [r3, #12]
20016ac8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20016acc:	d00e      	beq.n	20016aec <HAL_QSPI_MemoryMapped+0xc4>
20016ace:	68bb      	ldr	r3, [r7, #8]
20016ad0:	68db      	ldr	r3, [r3, #12]
20016ad2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20016ad6:	d009      	beq.n	20016aec <HAL_QSPI_MemoryMapped+0xc4>
20016ad8:	68bb      	ldr	r3, [r7, #8]
20016ada:	68db      	ldr	r3, [r3, #12]
20016adc:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
20016ae0:	d004      	beq.n	20016aec <HAL_QSPI_MemoryMapped+0xc4>
20016ae2:	f240 61ae 	movw	r1, #1710	; 0x6ae
20016ae6:	4879      	ldr	r0, [pc, #484]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016ae8:	f7e9 ff04 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_ALTERNATE_BYTES_MODE(cmd->AlternateByteMode));
20016aec:	68bb      	ldr	r3, [r7, #8]
20016aee:	6a1b      	ldr	r3, [r3, #32]
20016af0:	2b00      	cmp	r3, #0
20016af2:	d013      	beq.n	20016b1c <HAL_QSPI_MemoryMapped+0xf4>
20016af4:	68bb      	ldr	r3, [r7, #8]
20016af6:	6a1b      	ldr	r3, [r3, #32]
20016af8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20016afc:	d00e      	beq.n	20016b1c <HAL_QSPI_MemoryMapped+0xf4>
20016afe:	68bb      	ldr	r3, [r7, #8]
20016b00:	6a1b      	ldr	r3, [r3, #32]
20016b02:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20016b06:	d009      	beq.n	20016b1c <HAL_QSPI_MemoryMapped+0xf4>
20016b08:	68bb      	ldr	r3, [r7, #8]
20016b0a:	6a1b      	ldr	r3, [r3, #32]
20016b0c:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
20016b10:	d004      	beq.n	20016b1c <HAL_QSPI_MemoryMapped+0xf4>
20016b12:	f240 61b1 	movw	r1, #1713	; 0x6b1
20016b16:	486d      	ldr	r0, [pc, #436]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016b18:	f7e9 feec 	bl	200008f4 <assert_failed>
  if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
20016b1c:	68bb      	ldr	r3, [r7, #8]
20016b1e:	6a1b      	ldr	r3, [r3, #32]
20016b20:	2b00      	cmp	r3, #0
20016b22:	d017      	beq.n	20016b54 <HAL_QSPI_MemoryMapped+0x12c>
  {
    assert_param(IS_QSPI_ALTERNATE_BYTES_SIZE(cmd->AlternateBytesSize));
20016b24:	68bb      	ldr	r3, [r7, #8]
20016b26:	691b      	ldr	r3, [r3, #16]
20016b28:	2b00      	cmp	r3, #0
20016b2a:	d013      	beq.n	20016b54 <HAL_QSPI_MemoryMapped+0x12c>
20016b2c:	68bb      	ldr	r3, [r7, #8]
20016b2e:	691b      	ldr	r3, [r3, #16]
20016b30:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20016b34:	d00e      	beq.n	20016b54 <HAL_QSPI_MemoryMapped+0x12c>
20016b36:	68bb      	ldr	r3, [r7, #8]
20016b38:	691b      	ldr	r3, [r3, #16]
20016b3a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20016b3e:	d009      	beq.n	20016b54 <HAL_QSPI_MemoryMapped+0x12c>
20016b40:	68bb      	ldr	r3, [r7, #8]
20016b42:	691b      	ldr	r3, [r3, #16]
20016b44:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
20016b48:	d004      	beq.n	20016b54 <HAL_QSPI_MemoryMapped+0x12c>
20016b4a:	f240 61b4 	movw	r1, #1716	; 0x6b4
20016b4e:	485f      	ldr	r0, [pc, #380]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016b50:	f7e9 fed0 	bl	200008f4 <assert_failed>
  }

  assert_param(IS_QSPI_DUMMY_CYCLES(cmd->DummyCycles));
20016b54:	68bb      	ldr	r3, [r7, #8]
20016b56:	695b      	ldr	r3, [r3, #20]
20016b58:	2b1f      	cmp	r3, #31
20016b5a:	d904      	bls.n	20016b66 <HAL_QSPI_MemoryMapped+0x13e>
20016b5c:	f240 61b7 	movw	r1, #1719	; 0x6b7
20016b60:	485a      	ldr	r0, [pc, #360]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016b62:	f7e9 fec7 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DATA_MODE(cmd->DataMode));
20016b66:	68bb      	ldr	r3, [r7, #8]
20016b68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20016b6a:	2b00      	cmp	r3, #0
20016b6c:	d013      	beq.n	20016b96 <HAL_QSPI_MemoryMapped+0x16e>
20016b6e:	68bb      	ldr	r3, [r7, #8]
20016b70:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20016b72:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20016b76:	d00e      	beq.n	20016b96 <HAL_QSPI_MemoryMapped+0x16e>
20016b78:	68bb      	ldr	r3, [r7, #8]
20016b7a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20016b7c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20016b80:	d009      	beq.n	20016b96 <HAL_QSPI_MemoryMapped+0x16e>
20016b82:	68bb      	ldr	r3, [r7, #8]
20016b84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20016b86:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
20016b8a:	d004      	beq.n	20016b96 <HAL_QSPI_MemoryMapped+0x16e>
20016b8c:	f44f 61d7 	mov.w	r1, #1720	; 0x6b8
20016b90:	484e      	ldr	r0, [pc, #312]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016b92:	f7e9 feaf 	bl	200008f4 <assert_failed>

  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
20016b96:	68bb      	ldr	r3, [r7, #8]
20016b98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20016b9a:	2b00      	cmp	r3, #0
20016b9c:	d009      	beq.n	20016bb2 <HAL_QSPI_MemoryMapped+0x18a>
20016b9e:	68bb      	ldr	r3, [r7, #8]
20016ba0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20016ba2:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
20016ba6:	d004      	beq.n	20016bb2 <HAL_QSPI_MemoryMapped+0x18a>
20016ba8:	f240 61ba 	movw	r1, #1722	; 0x6ba
20016bac:	4847      	ldr	r0, [pc, #284]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016bae:	f7e9 fea1 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
20016bb2:	68bb      	ldr	r3, [r7, #8]
20016bb4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20016bb6:	2b00      	cmp	r3, #0
20016bb8:	d009      	beq.n	20016bce <HAL_QSPI_MemoryMapped+0x1a6>
20016bba:	68bb      	ldr	r3, [r7, #8]
20016bbc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20016bbe:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20016bc2:	d004      	beq.n	20016bce <HAL_QSPI_MemoryMapped+0x1a6>
20016bc4:	f240 61bb 	movw	r1, #1723	; 0x6bb
20016bc8:	4840      	ldr	r0, [pc, #256]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016bca:	f7e9 fe93 	bl	200008f4 <assert_failed>
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
20016bce:	68bb      	ldr	r3, [r7, #8]
20016bd0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20016bd2:	2b00      	cmp	r3, #0
20016bd4:	d009      	beq.n	20016bea <HAL_QSPI_MemoryMapped+0x1c2>
20016bd6:	68bb      	ldr	r3, [r7, #8]
20016bd8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20016bda:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
20016bde:	d004      	beq.n	20016bea <HAL_QSPI_MemoryMapped+0x1c2>
20016be0:	f240 61bc 	movw	r1, #1724	; 0x6bc
20016be4:	4839      	ldr	r0, [pc, #228]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016be6:	f7e9 fe85 	bl	200008f4 <assert_failed>

  assert_param(IS_QSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));
20016bea:	687b      	ldr	r3, [r7, #4]
20016bec:	685b      	ldr	r3, [r3, #4]
20016bee:	2b00      	cmp	r3, #0
20016bf0:	d008      	beq.n	20016c04 <HAL_QSPI_MemoryMapped+0x1dc>
20016bf2:	687b      	ldr	r3, [r7, #4]
20016bf4:	685b      	ldr	r3, [r3, #4]
20016bf6:	2b08      	cmp	r3, #8
20016bf8:	d004      	beq.n	20016c04 <HAL_QSPI_MemoryMapped+0x1dc>
20016bfa:	f240 61be 	movw	r1, #1726	; 0x6be
20016bfe:	4833      	ldr	r0, [pc, #204]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016c00:	f7e9 fe78 	bl	200008f4 <assert_failed>

  /* Process locked */
  __HAL_LOCK(hqspi);
20016c04:	68fb      	ldr	r3, [r7, #12]
20016c06:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20016c0a:	b2db      	uxtb	r3, r3
20016c0c:	2b01      	cmp	r3, #1
20016c0e:	d101      	bne.n	20016c14 <HAL_QSPI_MemoryMapped+0x1ec>
20016c10:	2302      	movs	r3, #2
20016c12:	e056      	b.n	20016cc2 <HAL_QSPI_MemoryMapped+0x29a>
20016c14:	68fb      	ldr	r3, [r7, #12]
20016c16:	2201      	movs	r2, #1
20016c18:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20016c1c:	68fb      	ldr	r3, [r7, #12]
20016c1e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20016c22:	b2db      	uxtb	r3, r3
20016c24:	2b01      	cmp	r3, #1
20016c26:	d145      	bne.n	20016cb4 <HAL_QSPI_MemoryMapped+0x28c>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20016c28:	68fb      	ldr	r3, [r7, #12]
20016c2a:	2200      	movs	r2, #0
20016c2c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
20016c2e:	68fb      	ldr	r3, [r7, #12]
20016c30:	2282      	movs	r2, #130	; 0x82
20016c32:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
20016c36:	68fb      	ldr	r3, [r7, #12]
20016c38:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20016c3a:	9300      	str	r3, [sp, #0]
20016c3c:	693b      	ldr	r3, [r7, #16]
20016c3e:	2200      	movs	r2, #0
20016c40:	2120      	movs	r1, #32
20016c42:	68f8      	ldr	r0, [r7, #12]
20016c44:	f000 fa93 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
20016c48:	4603      	mov	r3, r0
20016c4a:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
20016c4c:	7dfb      	ldrb	r3, [r7, #23]
20016c4e:	2b00      	cmp	r3, #0
20016c50:	d132      	bne.n	20016cb8 <HAL_QSPI_MemoryMapped+0x290>
    {
      /* Configure QSPI: CR register with timeout counter enable */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
20016c52:	68fb      	ldr	r3, [r7, #12]
20016c54:	681b      	ldr	r3, [r3, #0]
20016c56:	681b      	ldr	r3, [r3, #0]
20016c58:	f023 0108 	bic.w	r1, r3, #8
20016c5c:	687b      	ldr	r3, [r7, #4]
20016c5e:	685a      	ldr	r2, [r3, #4]
20016c60:	68fb      	ldr	r3, [r7, #12]
20016c62:	681b      	ldr	r3, [r3, #0]
20016c64:	430a      	orrs	r2, r1
20016c66:	601a      	str	r2, [r3, #0]

    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
20016c68:	687b      	ldr	r3, [r7, #4]
20016c6a:	685b      	ldr	r3, [r3, #4]
20016c6c:	2b08      	cmp	r3, #8
20016c6e:	d11a      	bne.n	20016ca6 <HAL_QSPI_MemoryMapped+0x27e>
      {
        assert_param(IS_QSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));
20016c70:	687b      	ldr	r3, [r7, #4]
20016c72:	681b      	ldr	r3, [r3, #0]
20016c74:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20016c78:	d304      	bcc.n	20016c84 <HAL_QSPI_MemoryMapped+0x25c>
20016c7a:	f240 61d4 	movw	r1, #1748	; 0x6d4
20016c7e:	4813      	ldr	r0, [pc, #76]	; (20016ccc <HAL_QSPI_MemoryMapped+0x2a4>)
20016c80:	f7e9 fe38 	bl	200008f4 <assert_failed>

        /* Configure QSPI: LPTR register with the low-power timeout value */
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
20016c84:	68fb      	ldr	r3, [r7, #12]
20016c86:	681b      	ldr	r3, [r3, #0]
20016c88:	687a      	ldr	r2, [r7, #4]
20016c8a:	6812      	ldr	r2, [r2, #0]
20016c8c:	631a      	str	r2, [r3, #48]	; 0x30

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
20016c8e:	68fb      	ldr	r3, [r7, #12]
20016c90:	681b      	ldr	r3, [r3, #0]
20016c92:	2210      	movs	r2, #16
20016c94:	60da      	str	r2, [r3, #12]

        /* Enable the QSPI TimeOut Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
20016c96:	68fb      	ldr	r3, [r7, #12]
20016c98:	681b      	ldr	r3, [r3, #0]
20016c9a:	681a      	ldr	r2, [r3, #0]
20016c9c:	68fb      	ldr	r3, [r7, #12]
20016c9e:	681b      	ldr	r3, [r3, #0]
20016ca0:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
20016ca4:	601a      	str	r2, [r3, #0]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
20016ca6:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
20016caa:	68b9      	ldr	r1, [r7, #8]
20016cac:	68f8      	ldr	r0, [r7, #12]
20016cae:	f000 fa95 	bl	200171dc <QSPI_Config>
20016cb2:	e001      	b.n	20016cb8 <HAL_QSPI_MemoryMapped+0x290>
    }
  }
  else
  {
    status = HAL_BUSY;
20016cb4:	2302      	movs	r3, #2
20016cb6:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
20016cb8:	68fb      	ldr	r3, [r7, #12]
20016cba:	2200      	movs	r2, #0
20016cbc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
20016cc0:	7dfb      	ldrb	r3, [r7, #23]
}
20016cc2:	4618      	mov	r0, r3
20016cc4:	3718      	adds	r7, #24
20016cc6:	46bd      	mov	sp, r7
20016cc8:	bd80      	pop	{r7, pc}
20016cca:	bf00      	nop
20016ccc:	2001c2a4 	.word	0x2001c2a4

20016cd0 <HAL_QSPI_ErrorCallback>:
  * @brief  Transfer Error callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_ErrorCallback(QSPI_HandleTypeDef *hqspi)
{
20016cd0:	b480      	push	{r7}
20016cd2:	b083      	sub	sp, #12
20016cd4:	af00      	add	r7, sp, #0
20016cd6:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_ErrorCallback could be implemented in the user file
   */
}
20016cd8:	bf00      	nop
20016cda:	370c      	adds	r7, #12
20016cdc:	46bd      	mov	sp, r7
20016cde:	f85d 7b04 	ldr.w	r7, [sp], #4
20016ce2:	4770      	bx	lr

20016ce4 <HAL_QSPI_AbortCpltCallback>:
  * @brief  Abort completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_AbortCpltCallback(QSPI_HandleTypeDef *hqspi)
{
20016ce4:	b480      	push	{r7}
20016ce6:	b083      	sub	sp, #12
20016ce8:	af00      	add	r7, sp, #0
20016cea:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_AbortCpltCallback could be implemented in the user file
   */
}
20016cec:	bf00      	nop
20016cee:	370c      	adds	r7, #12
20016cf0:	46bd      	mov	sp, r7
20016cf2:	f85d 7b04 	ldr.w	r7, [sp], #4
20016cf6:	4770      	bx	lr

20016cf8 <HAL_QSPI_CmdCpltCallback>:
  * @brief  Command completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_CmdCpltCallback(QSPI_HandleTypeDef *hqspi)
{
20016cf8:	b480      	push	{r7}
20016cfa:	b083      	sub	sp, #12
20016cfc:	af00      	add	r7, sp, #0
20016cfe:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_CmdCpltCallback could be implemented in the user file
   */
}
20016d00:	bf00      	nop
20016d02:	370c      	adds	r7, #12
20016d04:	46bd      	mov	sp, r7
20016d06:	f85d 7b04 	ldr.w	r7, [sp], #4
20016d0a:	4770      	bx	lr

20016d0c <HAL_QSPI_RxCpltCallback>:
  * @brief  Rx Transfer completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_RxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
20016d0c:	b480      	push	{r7}
20016d0e:	b083      	sub	sp, #12
20016d10:	af00      	add	r7, sp, #0
20016d12:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_RxCpltCallback could be implemented in the user file
   */
}
20016d14:	bf00      	nop
20016d16:	370c      	adds	r7, #12
20016d18:	46bd      	mov	sp, r7
20016d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
20016d1e:	4770      	bx	lr

20016d20 <HAL_QSPI_TxCpltCallback>:
  * @brief  Tx Transfer completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
20016d20:	b480      	push	{r7}
20016d22:	b083      	sub	sp, #12
20016d24:	af00      	add	r7, sp, #0
20016d26:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_TxCpltCallback could be implemented in the user file
   */
}
20016d28:	bf00      	nop
20016d2a:	370c      	adds	r7, #12
20016d2c:	46bd      	mov	sp, r7
20016d2e:	f85d 7b04 	ldr.w	r7, [sp], #4
20016d32:	4770      	bx	lr

20016d34 <HAL_QSPI_FifoThresholdCallback>:
  * @brief  FIFO Threshold callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi)
{
20016d34:	b480      	push	{r7}
20016d36:	b083      	sub	sp, #12
20016d38:	af00      	add	r7, sp, #0
20016d3a:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_FIFOThresholdCallback could be implemented in the user file
   */
}
20016d3c:	bf00      	nop
20016d3e:	370c      	adds	r7, #12
20016d40:	46bd      	mov	sp, r7
20016d42:	f85d 7b04 	ldr.w	r7, [sp], #4
20016d46:	4770      	bx	lr

20016d48 <HAL_QSPI_StatusMatchCallback>:
  * @brief  Status Match callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_StatusMatchCallback(QSPI_HandleTypeDef *hqspi)
{
20016d48:	b480      	push	{r7}
20016d4a:	b083      	sub	sp, #12
20016d4c:	af00      	add	r7, sp, #0
20016d4e:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_StatusMatchCallback could be implemented in the user file
   */
}
20016d50:	bf00      	nop
20016d52:	370c      	adds	r7, #12
20016d54:	46bd      	mov	sp, r7
20016d56:	f85d 7b04 	ldr.w	r7, [sp], #4
20016d5a:	4770      	bx	lr

20016d5c <HAL_QSPI_TimeOutCallback>:
  * @brief  Timeout callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TimeOutCallback(QSPI_HandleTypeDef *hqspi)
{
20016d5c:	b480      	push	{r7}
20016d5e:	b083      	sub	sp, #12
20016d60:	af00      	add	r7, sp, #0
20016d62:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_TimeOutCallback could be implemented in the user file
   */
}
20016d64:	bf00      	nop
20016d66:	370c      	adds	r7, #12
20016d68:	46bd      	mov	sp, r7
20016d6a:	f85d 7b04 	ldr.w	r7, [sp], #4
20016d6e:	4770      	bx	lr

20016d70 <HAL_QSPI_GetState>:
  * @brief  Return the QSPI handle state.
  * @param  hqspi : QSPI handle
  * @retval HAL state
  */
HAL_QSPI_StateTypeDef HAL_QSPI_GetState(QSPI_HandleTypeDef *hqspi)
{
20016d70:	b480      	push	{r7}
20016d72:	b083      	sub	sp, #12
20016d74:	af00      	add	r7, sp, #0
20016d76:	6078      	str	r0, [r7, #4]
  /* Return QSPI handle state */
  return hqspi->State;
20016d78:	687b      	ldr	r3, [r7, #4]
20016d7a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20016d7e:	b2db      	uxtb	r3, r3
}
20016d80:	4618      	mov	r0, r3
20016d82:	370c      	adds	r7, #12
20016d84:	46bd      	mov	sp, r7
20016d86:	f85d 7b04 	ldr.w	r7, [sp], #4
20016d8a:	4770      	bx	lr

20016d8c <HAL_QSPI_GetError>:
* @brief  Return the QSPI error code.
* @param  hqspi : QSPI handle
* @retval QSPI Error Code
*/
uint32_t HAL_QSPI_GetError(QSPI_HandleTypeDef *hqspi)
{
20016d8c:	b480      	push	{r7}
20016d8e:	b083      	sub	sp, #12
20016d90:	af00      	add	r7, sp, #0
20016d92:	6078      	str	r0, [r7, #4]
  return hqspi->ErrorCode;
20016d94:	687b      	ldr	r3, [r7, #4]
20016d96:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
20016d98:	4618      	mov	r0, r3
20016d9a:	370c      	adds	r7, #12
20016d9c:	46bd      	mov	sp, r7
20016d9e:	f85d 7b04 	ldr.w	r7, [sp], #4
20016da2:	4770      	bx	lr

20016da4 <HAL_QSPI_Abort>:
* @brief  Abort the current transmission.
* @param  hqspi : QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort(QSPI_HandleTypeDef *hqspi)
{
20016da4:	b580      	push	{r7, lr}
20016da6:	b086      	sub	sp, #24
20016da8:	af02      	add	r7, sp, #8
20016daa:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20016dac:	2300      	movs	r3, #0
20016dae:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
20016db0:	f7ea ff9c 	bl	20001cec <HAL_GetTick>
20016db4:	60b8      	str	r0, [r7, #8]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
20016db6:	687b      	ldr	r3, [r7, #4]
20016db8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20016dbc:	b2db      	uxtb	r3, r3
20016dbe:	f003 0302 	and.w	r3, r3, #2
20016dc2:	2b00      	cmp	r3, #0
20016dc4:	d056      	beq.n	20016e74 <HAL_QSPI_Abort+0xd0>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20016dc6:	687b      	ldr	r3, [r7, #4]
20016dc8:	2200      	movs	r2, #0
20016dca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
20016dce:	687b      	ldr	r3, [r7, #4]
20016dd0:	681b      	ldr	r3, [r3, #0]
20016dd2:	681b      	ldr	r3, [r3, #0]
20016dd4:	f003 0304 	and.w	r3, r3, #4
20016dd8:	2b00      	cmp	r3, #0
20016dda:	d017      	beq.n	20016e0c <HAL_QSPI_Abort+0x68>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
20016ddc:	687b      	ldr	r3, [r7, #4]
20016dde:	681b      	ldr	r3, [r3, #0]
20016de0:	681a      	ldr	r2, [r3, #0]
20016de2:	687b      	ldr	r3, [r7, #4]
20016de4:	681b      	ldr	r3, [r3, #0]
20016de6:	f022 0204 	bic.w	r2, r2, #4
20016dea:	601a      	str	r2, [r3, #0]

      /* Abort MDMA */
      status = HAL_MDMA_Abort(hqspi->hmdma);
20016dec:	687b      	ldr	r3, [r7, #4]
20016dee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016df0:	4618      	mov	r0, r3
20016df2:	f7fc fc17 	bl	20013624 <HAL_MDMA_Abort>
20016df6:	4603      	mov	r3, r0
20016df8:	73fb      	strb	r3, [r7, #15]
      if(status != HAL_OK)
20016dfa:	7bfb      	ldrb	r3, [r7, #15]
20016dfc:	2b00      	cmp	r3, #0
20016dfe:	d005      	beq.n	20016e0c <HAL_QSPI_Abort+0x68>
      {
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
20016e00:	687b      	ldr	r3, [r7, #4]
20016e02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20016e04:	f043 0204 	orr.w	r2, r3, #4
20016e08:	687b      	ldr	r3, [r7, #4]
20016e0a:	645a      	str	r2, [r3, #68]	; 0x44
      }
    }

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
20016e0c:	687b      	ldr	r3, [r7, #4]
20016e0e:	681b      	ldr	r3, [r3, #0]
20016e10:	681a      	ldr	r2, [r3, #0]
20016e12:	687b      	ldr	r3, [r7, #4]
20016e14:	681b      	ldr	r3, [r3, #0]
20016e16:	f042 0202 	orr.w	r2, r2, #2
20016e1a:	601a      	str	r2, [r3, #0]

    /* Wait until TC flag is set to go back in idle state */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
20016e1c:	687b      	ldr	r3, [r7, #4]
20016e1e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20016e20:	9300      	str	r3, [sp, #0]
20016e22:	68bb      	ldr	r3, [r7, #8]
20016e24:	2201      	movs	r2, #1
20016e26:	2102      	movs	r1, #2
20016e28:	6878      	ldr	r0, [r7, #4]
20016e2a:	f000 f9a0 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
20016e2e:	4603      	mov	r3, r0
20016e30:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
20016e32:	7bfb      	ldrb	r3, [r7, #15]
20016e34:	2b00      	cmp	r3, #0
20016e36:	d10e      	bne.n	20016e56 <HAL_QSPI_Abort+0xb2>
    {
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
20016e38:	687b      	ldr	r3, [r7, #4]
20016e3a:	681b      	ldr	r3, [r3, #0]
20016e3c:	2202      	movs	r2, #2
20016e3e:	60da      	str	r2, [r3, #12]

      /* Wait until BUSY flag is reset */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
20016e40:	687b      	ldr	r3, [r7, #4]
20016e42:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20016e44:	9300      	str	r3, [sp, #0]
20016e46:	68bb      	ldr	r3, [r7, #8]
20016e48:	2200      	movs	r2, #0
20016e4a:	2120      	movs	r1, #32
20016e4c:	6878      	ldr	r0, [r7, #4]
20016e4e:	f000 f98e 	bl	2001716e <QSPI_WaitFlagStateUntilTimeout>
20016e52:	4603      	mov	r3, r0
20016e54:	73fb      	strb	r3, [r7, #15]
    }

    if (status == HAL_OK)
20016e56:	7bfb      	ldrb	r3, [r7, #15]
20016e58:	2b00      	cmp	r3, #0
20016e5a:	d10b      	bne.n	20016e74 <HAL_QSPI_Abort+0xd0>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
20016e5c:	687b      	ldr	r3, [r7, #4]
20016e5e:	681b      	ldr	r3, [r3, #0]
20016e60:	695a      	ldr	r2, [r3, #20]
20016e62:	687b      	ldr	r3, [r7, #4]
20016e64:	681b      	ldr	r3, [r3, #0]
20016e66:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
20016e6a:	615a      	str	r2, [r3, #20]

      /* Update state */
      hqspi->State = HAL_QSPI_STATE_READY;
20016e6c:	687b      	ldr	r3, [r7, #4]
20016e6e:	2201      	movs	r2, #1
20016e70:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
  }

  return status;
20016e74:	7bfb      	ldrb	r3, [r7, #15]
}
20016e76:	4618      	mov	r0, r3
20016e78:	3710      	adds	r7, #16
20016e7a:	46bd      	mov	sp, r7
20016e7c:	bd80      	pop	{r7, pc}
	...

20016e80 <HAL_QSPI_Abort_IT>:
* @brief  Abort the current transmission (non-blocking function)
* @param  hqspi : QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort_IT(QSPI_HandleTypeDef *hqspi)
{
20016e80:	b580      	push	{r7, lr}
20016e82:	b084      	sub	sp, #16
20016e84:	af00      	add	r7, sp, #0
20016e86:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20016e88:	2300      	movs	r3, #0
20016e8a:	73fb      	strb	r3, [r7, #15]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
20016e8c:	687b      	ldr	r3, [r7, #4]
20016e8e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20016e92:	b2db      	uxtb	r3, r3
20016e94:	f003 0302 	and.w	r3, r3, #2
20016e98:	2b00      	cmp	r3, #0
20016e9a:	d046      	beq.n	20016f2a <HAL_QSPI_Abort_IT+0xaa>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20016e9c:	687b      	ldr	r3, [r7, #4]
20016e9e:	2200      	movs	r2, #0
20016ea0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_ABORT;
20016ea4:	687b      	ldr	r3, [r7, #4]
20016ea6:	2208      	movs	r2, #8
20016ea8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable all interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_TO | QSPI_IT_SM | QSPI_IT_FT | QSPI_IT_TC | QSPI_IT_TE));
20016eac:	687b      	ldr	r3, [r7, #4]
20016eae:	681b      	ldr	r3, [r3, #0]
20016eb0:	681a      	ldr	r2, [r3, #0]
20016eb2:	687b      	ldr	r3, [r7, #4]
20016eb4:	681b      	ldr	r3, [r3, #0]
20016eb6:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
20016eba:	601a      	str	r2, [r3, #0]

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
20016ebc:	687b      	ldr	r3, [r7, #4]
20016ebe:	681b      	ldr	r3, [r3, #0]
20016ec0:	681b      	ldr	r3, [r3, #0]
20016ec2:	f003 0304 	and.w	r3, r3, #4
20016ec6:	2b00      	cmp	r3, #0
20016ec8:	d01b      	beq.n	20016f02 <HAL_QSPI_Abort_IT+0x82>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
20016eca:	687b      	ldr	r3, [r7, #4]
20016ecc:	681b      	ldr	r3, [r3, #0]
20016ece:	681a      	ldr	r2, [r3, #0]
20016ed0:	687b      	ldr	r3, [r7, #4]
20016ed2:	681b      	ldr	r3, [r3, #0]
20016ed4:	f022 0204 	bic.w	r2, r2, #4
20016ed8:	601a      	str	r2, [r3, #0]

      /* Abort MDMA channel */
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
20016eda:	687b      	ldr	r3, [r7, #4]
20016edc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016ede:	4a15      	ldr	r2, [pc, #84]	; (20016f34 <HAL_QSPI_Abort_IT+0xb4>)
20016ee0:	659a      	str	r2, [r3, #88]	; 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
20016ee2:	687b      	ldr	r3, [r7, #4]
20016ee4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20016ee6:	4618      	mov	r0, r3
20016ee8:	f7fc fbf7 	bl	200136da <HAL_MDMA_Abort_IT>
20016eec:	4603      	mov	r3, r0
20016eee:	2b00      	cmp	r3, #0
20016ef0:	d01b      	beq.n	20016f2a <HAL_QSPI_Abort_IT+0xaa>
      {
        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
20016ef2:	687b      	ldr	r3, [r7, #4]
20016ef4:	2201      	movs	r2, #1
20016ef6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
20016efa:	6878      	ldr	r0, [r7, #4]
20016efc:	f7ff fef2 	bl	20016ce4 <HAL_QSPI_AbortCpltCallback>
20016f00:	e013      	b.n	20016f2a <HAL_QSPI_Abort_IT+0xaa>
      }
    }
    else
    {
      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
20016f02:	687b      	ldr	r3, [r7, #4]
20016f04:	681b      	ldr	r3, [r3, #0]
20016f06:	2202      	movs	r2, #2
20016f08:	60da      	str	r2, [r3, #12]

      /* Enable the QSPI Transfer Complete Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
20016f0a:	687b      	ldr	r3, [r7, #4]
20016f0c:	681b      	ldr	r3, [r3, #0]
20016f0e:	681a      	ldr	r2, [r3, #0]
20016f10:	687b      	ldr	r3, [r7, #4]
20016f12:	681b      	ldr	r3, [r3, #0]
20016f14:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
20016f18:	601a      	str	r2, [r3, #0]

      /* Configure QSPI: CR register with Abort request */
      SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
20016f1a:	687b      	ldr	r3, [r7, #4]
20016f1c:	681b      	ldr	r3, [r3, #0]
20016f1e:	681a      	ldr	r2, [r3, #0]
20016f20:	687b      	ldr	r3, [r7, #4]
20016f22:	681b      	ldr	r3, [r3, #0]
20016f24:	f042 0202 	orr.w	r2, r2, #2
20016f28:	601a      	str	r2, [r3, #0]
    }
  }
  return status;
20016f2a:	7bfb      	ldrb	r3, [r7, #15]
}
20016f2c:	4618      	mov	r0, r3
20016f2e:	3710      	adds	r7, #16
20016f30:	46bd      	mov	sp, r7
20016f32:	bd80      	pop	{r7, pc}
20016f34:	20017109 	.word	0x20017109

20016f38 <HAL_QSPI_SetTimeout>:
  * @param  hqspi : QSPI handle.
  * @param  Timeout : Timeout for the QSPI memory access.
  * @retval None
  */
void HAL_QSPI_SetTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
{
20016f38:	b480      	push	{r7}
20016f3a:	b083      	sub	sp, #12
20016f3c:	af00      	add	r7, sp, #0
20016f3e:	6078      	str	r0, [r7, #4]
20016f40:	6039      	str	r1, [r7, #0]
  hqspi->Timeout = Timeout;
20016f42:	687b      	ldr	r3, [r7, #4]
20016f44:	683a      	ldr	r2, [r7, #0]
20016f46:	649a      	str	r2, [r3, #72]	; 0x48
}
20016f48:	bf00      	nop
20016f4a:	370c      	adds	r7, #12
20016f4c:	46bd      	mov	sp, r7
20016f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
20016f52:	4770      	bx	lr

20016f54 <HAL_QSPI_SetFifoThreshold>:
  * @param  hqspi : QSPI handle.
  * @param  Threshold : Threshold of the Fifo (value between 1 and 16).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFifoThreshold(QSPI_HandleTypeDef *hqspi, uint32_t Threshold)
{
20016f54:	b480      	push	{r7}
20016f56:	b085      	sub	sp, #20
20016f58:	af00      	add	r7, sp, #0
20016f5a:	6078      	str	r0, [r7, #4]
20016f5c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20016f5e:	2300      	movs	r3, #0
20016f60:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
20016f62:	687b      	ldr	r3, [r7, #4]
20016f64:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20016f68:	b2db      	uxtb	r3, r3
20016f6a:	2b01      	cmp	r3, #1
20016f6c:	d101      	bne.n	20016f72 <HAL_QSPI_SetFifoThreshold+0x1e>
20016f6e:	2302      	movs	r3, #2
20016f70:	e021      	b.n	20016fb6 <HAL_QSPI_SetFifoThreshold+0x62>
20016f72:	687b      	ldr	r3, [r7, #4]
20016f74:	2201      	movs	r2, #1
20016f76:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20016f7a:	687b      	ldr	r3, [r7, #4]
20016f7c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20016f80:	b2db      	uxtb	r3, r3
20016f82:	2b01      	cmp	r3, #1
20016f84:	d110      	bne.n	20016fa8 <HAL_QSPI_SetFifoThreshold+0x54>
  {
    /* Synchronize init structure with new FIFO threshold value */
    hqspi->Init.FifoThreshold = Threshold;
20016f86:	687b      	ldr	r3, [r7, #4]
20016f88:	683a      	ldr	r2, [r7, #0]
20016f8a:	609a      	str	r2, [r3, #8]

    /* Configure QSPI FIFO Threshold */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
20016f8c:	687b      	ldr	r3, [r7, #4]
20016f8e:	681b      	ldr	r3, [r3, #0]
20016f90:	681b      	ldr	r3, [r3, #0]
20016f92:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
20016f96:	687b      	ldr	r3, [r7, #4]
20016f98:	689b      	ldr	r3, [r3, #8]
20016f9a:	3b01      	subs	r3, #1
20016f9c:	021a      	lsls	r2, r3, #8
20016f9e:	687b      	ldr	r3, [r7, #4]
20016fa0:	681b      	ldr	r3, [r3, #0]
20016fa2:	430a      	orrs	r2, r1
20016fa4:	601a      	str	r2, [r3, #0]
20016fa6:	e001      	b.n	20016fac <HAL_QSPI_SetFifoThreshold+0x58>
               ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));
  }
  else
  {
    status = HAL_BUSY;
20016fa8:	2302      	movs	r3, #2
20016faa:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
20016fac:	687b      	ldr	r3, [r7, #4]
20016fae:	2200      	movs	r2, #0
20016fb0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
20016fb4:	7bfb      	ldrb	r3, [r7, #15]
}
20016fb6:	4618      	mov	r0, r3
20016fb8:	3714      	adds	r7, #20
20016fba:	46bd      	mov	sp, r7
20016fbc:	f85d 7b04 	ldr.w	r7, [sp], #4
20016fc0:	4770      	bx	lr

20016fc2 <HAL_QSPI_GetFifoThreshold>:
/** @brief Get QSPI Fifo threshold.
  * @param  hqspi : QSPI handle.
  * @retval Fifo threshold (value between 1 and 16)
  */
uint32_t HAL_QSPI_GetFifoThreshold(QSPI_HandleTypeDef *hqspi)
{
20016fc2:	b480      	push	{r7}
20016fc4:	b083      	sub	sp, #12
20016fc6:	af00      	add	r7, sp, #0
20016fc8:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(hqspi->Instance->CR, QUADSPI_CR_FTHRES) >> QUADSPI_CR_FTHRES_Pos) + 1U);
20016fca:	687b      	ldr	r3, [r7, #4]
20016fcc:	681b      	ldr	r3, [r3, #0]
20016fce:	681b      	ldr	r3, [r3, #0]
20016fd0:	0a1b      	lsrs	r3, r3, #8
20016fd2:	f003 030f 	and.w	r3, r3, #15
20016fd6:	3301      	adds	r3, #1
}
20016fd8:	4618      	mov	r0, r3
20016fda:	370c      	adds	r7, #12
20016fdc:	46bd      	mov	sp, r7
20016fde:	f85d 7b04 	ldr.w	r7, [sp], #4
20016fe2:	4770      	bx	lr

20016fe4 <HAL_QSPI_SetFlashID>:
  *                   This parameter can be a value of @ref QSPI_Flash_Select.
  * @note   The FlashID is ignored when dual flash mode is enabled.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFlashID(QSPI_HandleTypeDef *hqspi, uint32_t FlashID)
{
20016fe4:	b580      	push	{r7, lr}
20016fe6:	b084      	sub	sp, #16
20016fe8:	af00      	add	r7, sp, #0
20016fea:	6078      	str	r0, [r7, #4]
20016fec:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20016fee:	2300      	movs	r3, #0
20016ff0:	73fb      	strb	r3, [r7, #15]

  /* Check the parameter */
  assert_param(IS_QSPI_FLASH_ID(FlashID));
20016ff2:	683b      	ldr	r3, [r7, #0]
20016ff4:	2b00      	cmp	r3, #0
20016ff6:	d007      	beq.n	20017008 <HAL_QSPI_SetFlashID+0x24>
20016ff8:	683b      	ldr	r3, [r7, #0]
20016ffa:	2b80      	cmp	r3, #128	; 0x80
20016ffc:	d004      	beq.n	20017008 <HAL_QSPI_SetFlashID+0x24>
20016ffe:	f640 1111 	movw	r1, #2321	; 0x911
20017002:	4817      	ldr	r0, [pc, #92]	; (20017060 <HAL_QSPI_SetFlashID+0x7c>)
20017004:	f7e9 fc76 	bl	200008f4 <assert_failed>

  /* Process locked */
  __HAL_LOCK(hqspi);
20017008:	687b      	ldr	r3, [r7, #4]
2001700a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2001700e:	b2db      	uxtb	r3, r3
20017010:	2b01      	cmp	r3, #1
20017012:	d101      	bne.n	20017018 <HAL_QSPI_SetFlashID+0x34>
20017014:	2302      	movs	r3, #2
20017016:	e01e      	b.n	20017056 <HAL_QSPI_SetFlashID+0x72>
20017018:	687b      	ldr	r3, [r7, #4]
2001701a:	2201      	movs	r2, #1
2001701c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20017020:	687b      	ldr	r3, [r7, #4]
20017022:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20017026:	b2db      	uxtb	r3, r3
20017028:	2b01      	cmp	r3, #1
2001702a:	d10d      	bne.n	20017048 <HAL_QSPI_SetFlashID+0x64>
  {
    /* Synchronize init structure with new FlashID value */
    hqspi->Init.FlashID = FlashID;
2001702c:	687b      	ldr	r3, [r7, #4]
2001702e:	683a      	ldr	r2, [r7, #0]
20017030:	61da      	str	r2, [r3, #28]

    /* Configure QSPI FlashID */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FSEL, FlashID);
20017032:	687b      	ldr	r3, [r7, #4]
20017034:	681b      	ldr	r3, [r3, #0]
20017036:	681b      	ldr	r3, [r3, #0]
20017038:	f023 0180 	bic.w	r1, r3, #128	; 0x80
2001703c:	687b      	ldr	r3, [r7, #4]
2001703e:	681b      	ldr	r3, [r3, #0]
20017040:	683a      	ldr	r2, [r7, #0]
20017042:	430a      	orrs	r2, r1
20017044:	601a      	str	r2, [r3, #0]
20017046:	e001      	b.n	2001704c <HAL_QSPI_SetFlashID+0x68>
  }
  else
  {
    status = HAL_BUSY;
20017048:	2302      	movs	r3, #2
2001704a:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2001704c:	687b      	ldr	r3, [r7, #4]
2001704e:	2200      	movs	r2, #0
20017050:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
20017054:	7bfb      	ldrb	r3, [r7, #15]
}
20017056:	4618      	mov	r0, r3
20017058:	3710      	adds	r7, #16
2001705a:	46bd      	mov	sp, r7
2001705c:	bd80      	pop	{r7, pc}
2001705e:	bf00      	nop
20017060:	2001c2a4 	.word	0x2001c2a4

20017064 <QSPI_DMARxCplt>:
  * @brief  DMA QSPI receive process complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMARxCplt(MDMA_HandleTypeDef *hmdma)
{
20017064:	b480      	push	{r7}
20017066:	b085      	sub	sp, #20
20017068:	af00      	add	r7, sp, #0
2001706a:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
2001706c:	687b      	ldr	r3, [r7, #4]
2001706e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20017070:	60fb      	str	r3, [r7, #12]
  hqspi->RxXferCount = 0U;
20017072:	68fb      	ldr	r3, [r7, #12]
20017074:	2200      	movs	r2, #0
20017076:	639a      	str	r2, [r3, #56]	; 0x38

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
20017078:	68fb      	ldr	r3, [r7, #12]
2001707a:	681b      	ldr	r3, [r3, #0]
2001707c:	681a      	ldr	r2, [r3, #0]
2001707e:	68fb      	ldr	r3, [r7, #12]
20017080:	681b      	ldr	r3, [r3, #0]
20017082:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
20017086:	601a      	str	r2, [r3, #0]
}
20017088:	bf00      	nop
2001708a:	3714      	adds	r7, #20
2001708c:	46bd      	mov	sp, r7
2001708e:	f85d 7b04 	ldr.w	r7, [sp], #4
20017092:	4770      	bx	lr

20017094 <QSPI_DMATxCplt>:
  * @brief  DMA QSPI transmit process complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMATxCplt(MDMA_HandleTypeDef *hmdma)
{
20017094:	b480      	push	{r7}
20017096:	b085      	sub	sp, #20
20017098:	af00      	add	r7, sp, #0
2001709a:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
2001709c:	687b      	ldr	r3, [r7, #4]
2001709e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200170a0:	60fb      	str	r3, [r7, #12]
  hqspi->TxXferCount = 0U;
200170a2:	68fb      	ldr	r3, [r7, #12]
200170a4:	2200      	movs	r2, #0
200170a6:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
200170a8:	68fb      	ldr	r3, [r7, #12]
200170aa:	681b      	ldr	r3, [r3, #0]
200170ac:	681a      	ldr	r2, [r3, #0]
200170ae:	68fb      	ldr	r3, [r7, #12]
200170b0:	681b      	ldr	r3, [r3, #0]
200170b2:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
200170b6:	601a      	str	r2, [r3, #0]
}
200170b8:	bf00      	nop
200170ba:	3714      	adds	r7, #20
200170bc:	46bd      	mov	sp, r7
200170be:	f85d 7b04 	ldr.w	r7, [sp], #4
200170c2:	4770      	bx	lr

200170c4 <QSPI_DMAError>:
  * @brief  DMA QSPI communication error callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMAError(MDMA_HandleTypeDef *hmdma)
{
200170c4:	b580      	push	{r7, lr}
200170c6:	b084      	sub	sp, #16
200170c8:	af00      	add	r7, sp, #0
200170ca:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
200170cc:	687b      	ldr	r3, [r7, #4]
200170ce:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200170d0:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
200170d2:	68fb      	ldr	r3, [r7, #12]
200170d4:	2200      	movs	r2, #0
200170d6:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
200170d8:	68fb      	ldr	r3, [r7, #12]
200170da:	2200      	movs	r2, #0
200170dc:	62da      	str	r2, [r3, #44]	; 0x2c
  hqspi->ErrorCode   |= HAL_QSPI_ERROR_DMA;
200170de:	68fb      	ldr	r3, [r7, #12]
200170e0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200170e2:	f043 0204 	orr.w	r2, r3, #4
200170e6:	68fb      	ldr	r3, [r7, #12]
200170e8:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable the MDMA transfer by clearing the DMAEN bit in the QSPI CR register */
  CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
200170ea:	68fb      	ldr	r3, [r7, #12]
200170ec:	681b      	ldr	r3, [r3, #0]
200170ee:	681a      	ldr	r2, [r3, #0]
200170f0:	68fb      	ldr	r3, [r7, #12]
200170f2:	681b      	ldr	r3, [r3, #0]
200170f4:	f022 0204 	bic.w	r2, r2, #4
200170f8:	601a      	str	r2, [r3, #0]

  /* Abort the QSPI */
  (void)HAL_QSPI_Abort_IT(hqspi);
200170fa:	68f8      	ldr	r0, [r7, #12]
200170fc:	f7ff fec0 	bl	20016e80 <HAL_QSPI_Abort_IT>

}
20017100:	bf00      	nop
20017102:	3710      	adds	r7, #16
20017104:	46bd      	mov	sp, r7
20017106:	bd80      	pop	{r7, pc}

20017108 <QSPI_DMAAbortCplt>:
  * @brief  MDMA QSPI abort complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMAAbortCplt(MDMA_HandleTypeDef *hmdma)
{
20017108:	b580      	push	{r7, lr}
2001710a:	b084      	sub	sp, #16
2001710c:	af00      	add	r7, sp, #0
2001710e:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
20017110:	687b      	ldr	r3, [r7, #4]
20017112:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20017114:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
20017116:	68fb      	ldr	r3, [r7, #12]
20017118:	2200      	movs	r2, #0
2001711a:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
2001711c:	68fb      	ldr	r3, [r7, #12]
2001711e:	2200      	movs	r2, #0
20017120:	62da      	str	r2, [r3, #44]	; 0x2c

  if(hqspi->State == HAL_QSPI_STATE_ABORT)
20017122:	68fb      	ldr	r3, [r7, #12]
20017124:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20017128:	b2db      	uxtb	r3, r3
2001712a:	2b08      	cmp	r3, #8
2001712c:	d114      	bne.n	20017158 <QSPI_DMAAbortCplt+0x50>
  {
    /* MDMA Abort called by QSPI abort */
    /* Clear interrupt */
    __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2001712e:	68fb      	ldr	r3, [r7, #12]
20017130:	681b      	ldr	r3, [r3, #0]
20017132:	2202      	movs	r2, #2
20017134:	60da      	str	r2, [r3, #12]

    /* Enable the QSPI Transfer Complete Interrupt */
    __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
20017136:	68fb      	ldr	r3, [r7, #12]
20017138:	681b      	ldr	r3, [r3, #0]
2001713a:	681a      	ldr	r2, [r3, #0]
2001713c:	68fb      	ldr	r3, [r7, #12]
2001713e:	681b      	ldr	r3, [r3, #0]
20017140:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
20017144:	601a      	str	r2, [r3, #0]

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
20017146:	68fb      	ldr	r3, [r7, #12]
20017148:	681b      	ldr	r3, [r3, #0]
2001714a:	681a      	ldr	r2, [r3, #0]
2001714c:	68fb      	ldr	r3, [r7, #12]
2001714e:	681b      	ldr	r3, [r3, #0]
20017150:	f042 0202 	orr.w	r2, r2, #2
20017154:	601a      	str	r2, [r3, #0]
    hqspi->ErrorCallback(hqspi);
#else
    HAL_QSPI_ErrorCallback(hqspi);
#endif
  }
}
20017156:	e006      	b.n	20017166 <QSPI_DMAAbortCplt+0x5e>
    hqspi->State = HAL_QSPI_STATE_READY;
20017158:	68fb      	ldr	r3, [r7, #12]
2001715a:	2201      	movs	r2, #1
2001715c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    HAL_QSPI_ErrorCallback(hqspi);
20017160:	68f8      	ldr	r0, [r7, #12]
20017162:	f7ff fdb5 	bl	20016cd0 <HAL_QSPI_ErrorCallback>
}
20017166:	bf00      	nop
20017168:	3710      	adds	r7, #16
2001716a:	46bd      	mov	sp, r7
2001716c:	bd80      	pop	{r7, pc}

2001716e <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout : Duration of the timeout
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
2001716e:	b580      	push	{r7, lr}
20017170:	b084      	sub	sp, #16
20017172:	af00      	add	r7, sp, #0
20017174:	60f8      	str	r0, [r7, #12]
20017176:	60b9      	str	r1, [r7, #8]
20017178:	603b      	str	r3, [r7, #0]
2001717a:	4613      	mov	r3, r2
2001717c:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
2001717e:	e01a      	b.n	200171b6 <QSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
20017180:	69bb      	ldr	r3, [r7, #24]
20017182:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
20017186:	d016      	beq.n	200171b6 <QSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
20017188:	f7ea fdb0 	bl	20001cec <HAL_GetTick>
2001718c:	4602      	mov	r2, r0
2001718e:	683b      	ldr	r3, [r7, #0]
20017190:	1ad3      	subs	r3, r2, r3
20017192:	69ba      	ldr	r2, [r7, #24]
20017194:	429a      	cmp	r2, r3
20017196:	d302      	bcc.n	2001719e <QSPI_WaitFlagStateUntilTimeout+0x30>
20017198:	69bb      	ldr	r3, [r7, #24]
2001719a:	2b00      	cmp	r3, #0
2001719c:	d10b      	bne.n	200171b6 <QSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
2001719e:	68fb      	ldr	r3, [r7, #12]
200171a0:	2204      	movs	r2, #4
200171a2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
200171a6:	68fb      	ldr	r3, [r7, #12]
200171a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200171aa:	f043 0201 	orr.w	r2, r3, #1
200171ae:	68fb      	ldr	r3, [r7, #12]
200171b0:	645a      	str	r2, [r3, #68]	; 0x44

        return HAL_ERROR;
200171b2:	2301      	movs	r3, #1
200171b4:	e00e      	b.n	200171d4 <QSPI_WaitFlagStateUntilTimeout+0x66>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
200171b6:	68fb      	ldr	r3, [r7, #12]
200171b8:	681b      	ldr	r3, [r3, #0]
200171ba:	689a      	ldr	r2, [r3, #8]
200171bc:	68bb      	ldr	r3, [r7, #8]
200171be:	4013      	ands	r3, r2
200171c0:	2b00      	cmp	r3, #0
200171c2:	bf14      	ite	ne
200171c4:	2301      	movne	r3, #1
200171c6:	2300      	moveq	r3, #0
200171c8:	b2db      	uxtb	r3, r3
200171ca:	461a      	mov	r2, r3
200171cc:	79fb      	ldrb	r3, [r7, #7]
200171ce:	429a      	cmp	r2, r3
200171d0:	d1d6      	bne.n	20017180 <QSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
200171d2:	2300      	movs	r3, #0
}
200171d4:	4618      	mov	r0, r3
200171d6:	3710      	adds	r7, #16
200171d8:	46bd      	mov	sp, r7
200171da:	bd80      	pop	{r7, pc}

200171dc <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
200171dc:	b580      	push	{r7, lr}
200171de:	b084      	sub	sp, #16
200171e0:	af00      	add	r7, sp, #0
200171e2:	60f8      	str	r0, [r7, #12]
200171e4:	60b9      	str	r1, [r7, #8]
200171e6:	607a      	str	r2, [r7, #4]
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));
200171e8:	687b      	ldr	r3, [r7, #4]
200171ea:	2b00      	cmp	r3, #0
200171ec:	d010      	beq.n	20017210 <QSPI_Config+0x34>
200171ee:	687b      	ldr	r3, [r7, #4]
200171f0:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
200171f4:	d00c      	beq.n	20017210 <QSPI_Config+0x34>
200171f6:	687b      	ldr	r3, [r7, #4]
200171f8:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
200171fc:	d008      	beq.n	20017210 <QSPI_Config+0x34>
200171fe:	687b      	ldr	r3, [r7, #4]
20017200:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
20017204:	d004      	beq.n	20017210 <QSPI_Config+0x34>
20017206:	f640 11ba 	movw	r1, #2490	; 0x9ba
2001720a:	4896      	ldr	r0, [pc, #600]	; (20017464 <QSPI_Config+0x288>)
2001720c:	f7e9 fb72 	bl	200008f4 <assert_failed>

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
20017210:	68bb      	ldr	r3, [r7, #8]
20017212:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20017214:	2b00      	cmp	r3, #0
20017216:	d009      	beq.n	2001722c <QSPI_Config+0x50>
20017218:	687b      	ldr	r3, [r7, #4]
2001721a:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
2001721e:	d005      	beq.n	2001722c <QSPI_Config+0x50>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
20017220:	68bb      	ldr	r3, [r7, #8]
20017222:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20017224:	68fb      	ldr	r3, [r7, #12]
20017226:	681b      	ldr	r3, [r3, #0]
20017228:	3a01      	subs	r2, #1
2001722a:	611a      	str	r2, [r3, #16]
  }

  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
2001722c:	68bb      	ldr	r3, [r7, #8]
2001722e:	699b      	ldr	r3, [r3, #24]
20017230:	2b00      	cmp	r3, #0
20017232:	f000 80b9 	beq.w	200173a8 <QSPI_Config+0x1cc>
  {
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
20017236:	68bb      	ldr	r3, [r7, #8]
20017238:	6a1b      	ldr	r3, [r3, #32]
2001723a:	2b00      	cmp	r3, #0
2001723c:	d05f      	beq.n	200172fe <QSPI_Config+0x122>
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
2001723e:	68fb      	ldr	r3, [r7, #12]
20017240:	681b      	ldr	r3, [r3, #0]
20017242:	68ba      	ldr	r2, [r7, #8]
20017244:	6892      	ldr	r2, [r2, #8]
20017246:	61da      	str	r2, [r3, #28]

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
20017248:	68bb      	ldr	r3, [r7, #8]
2001724a:	69db      	ldr	r3, [r3, #28]
2001724c:	2b00      	cmp	r3, #0
2001724e:	d031      	beq.n	200172b4 <QSPI_Config+0xd8>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
20017250:	68bb      	ldr	r3, [r7, #8]
20017252:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20017254:	68bb      	ldr	r3, [r7, #8]
20017256:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20017258:	431a      	orrs	r2, r3
2001725a:	68bb      	ldr	r3, [r7, #8]
2001725c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2001725e:	431a      	orrs	r2, r3
20017260:	68bb      	ldr	r3, [r7, #8]
20017262:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20017264:	431a      	orrs	r2, r3
20017266:	68bb      	ldr	r3, [r7, #8]
20017268:	695b      	ldr	r3, [r3, #20]
2001726a:	049b      	lsls	r3, r3, #18
2001726c:	431a      	orrs	r2, r3
2001726e:	68bb      	ldr	r3, [r7, #8]
20017270:	691b      	ldr	r3, [r3, #16]
20017272:	431a      	orrs	r2, r3
20017274:	68bb      	ldr	r3, [r7, #8]
20017276:	6a1b      	ldr	r3, [r3, #32]
20017278:	431a      	orrs	r2, r3
2001727a:	68bb      	ldr	r3, [r7, #8]
2001727c:	68db      	ldr	r3, [r3, #12]
2001727e:	431a      	orrs	r2, r3
20017280:	68bb      	ldr	r3, [r7, #8]
20017282:	69db      	ldr	r3, [r3, #28]
20017284:	431a      	orrs	r2, r3
20017286:	68bb      	ldr	r3, [r7, #8]
20017288:	699b      	ldr	r3, [r3, #24]
2001728a:	431a      	orrs	r2, r3
2001728c:	68bb      	ldr	r3, [r7, #8]
2001728e:	681b      	ldr	r3, [r3, #0]
20017290:	ea42 0103 	orr.w	r1, r2, r3
20017294:	68fb      	ldr	r3, [r7, #12]
20017296:	681b      	ldr	r3, [r3, #0]
20017298:	687a      	ldr	r2, [r7, #4]
2001729a:	430a      	orrs	r2, r1
2001729c:	615a      	str	r2, [r3, #20]
                                         cmd->DataMode | (cmd->DummyCycles << QUADSPI_CCR_DCYC_Pos) |
                                         cmd->AlternateBytesSize | cmd->AlternateByteMode |
                                         cmd->AddressSize | cmd->AddressMode | cmd->InstructionMode |
                                         cmd->Instruction | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2001729e:	687b      	ldr	r3, [r7, #4]
200172a0:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
200172a4:	f000 8131 	beq.w	2001750a <QSPI_Config+0x32e>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
200172a8:	68fb      	ldr	r3, [r7, #12]
200172aa:	681b      	ldr	r3, [r3, #0]
200172ac:	68ba      	ldr	r2, [r7, #8]
200172ae:	6852      	ldr	r2, [r2, #4]
200172b0:	619a      	str	r2, [r3, #24]
                                           cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
200172b2:	e12a      	b.n	2001750a <QSPI_Config+0x32e>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
200172b4:	68bb      	ldr	r3, [r7, #8]
200172b6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
200172b8:	68bb      	ldr	r3, [r7, #8]
200172ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200172bc:	431a      	orrs	r2, r3
200172be:	68bb      	ldr	r3, [r7, #8]
200172c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200172c2:	431a      	orrs	r2, r3
200172c4:	68bb      	ldr	r3, [r7, #8]
200172c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200172c8:	431a      	orrs	r2, r3
200172ca:	68bb      	ldr	r3, [r7, #8]
200172cc:	695b      	ldr	r3, [r3, #20]
200172ce:	049b      	lsls	r3, r3, #18
200172d0:	431a      	orrs	r2, r3
200172d2:	68bb      	ldr	r3, [r7, #8]
200172d4:	691b      	ldr	r3, [r3, #16]
200172d6:	431a      	orrs	r2, r3
200172d8:	68bb      	ldr	r3, [r7, #8]
200172da:	6a1b      	ldr	r3, [r3, #32]
200172dc:	431a      	orrs	r2, r3
200172de:	68bb      	ldr	r3, [r7, #8]
200172e0:	69db      	ldr	r3, [r3, #28]
200172e2:	431a      	orrs	r2, r3
200172e4:	68bb      	ldr	r3, [r7, #8]
200172e6:	699b      	ldr	r3, [r3, #24]
200172e8:	431a      	orrs	r2, r3
200172ea:	68bb      	ldr	r3, [r7, #8]
200172ec:	681b      	ldr	r3, [r3, #0]
200172ee:	ea42 0103 	orr.w	r1, r2, r3
200172f2:	68fb      	ldr	r3, [r7, #12]
200172f4:	681b      	ldr	r3, [r3, #0]
200172f6:	687a      	ldr	r2, [r7, #4]
200172f8:	430a      	orrs	r2, r1
200172fa:	615a      	str	r2, [r3, #20]
}
200172fc:	e105      	b.n	2001750a <QSPI_Config+0x32e>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
200172fe:	68bb      	ldr	r3, [r7, #8]
20017300:	69db      	ldr	r3, [r3, #28]
20017302:	2b00      	cmp	r3, #0
20017304:	d02e      	beq.n	20017364 <QSPI_Config+0x188>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
20017306:	68bb      	ldr	r3, [r7, #8]
20017308:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2001730a:	68bb      	ldr	r3, [r7, #8]
2001730c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001730e:	431a      	orrs	r2, r3
20017310:	68bb      	ldr	r3, [r7, #8]
20017312:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20017314:	431a      	orrs	r2, r3
20017316:	68bb      	ldr	r3, [r7, #8]
20017318:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2001731a:	431a      	orrs	r2, r3
2001731c:	68bb      	ldr	r3, [r7, #8]
2001731e:	695b      	ldr	r3, [r3, #20]
20017320:	049b      	lsls	r3, r3, #18
20017322:	431a      	orrs	r2, r3
20017324:	68bb      	ldr	r3, [r7, #8]
20017326:	6a1b      	ldr	r3, [r3, #32]
20017328:	431a      	orrs	r2, r3
2001732a:	68bb      	ldr	r3, [r7, #8]
2001732c:	68db      	ldr	r3, [r3, #12]
2001732e:	431a      	orrs	r2, r3
20017330:	68bb      	ldr	r3, [r7, #8]
20017332:	69db      	ldr	r3, [r3, #28]
20017334:	431a      	orrs	r2, r3
20017336:	68bb      	ldr	r3, [r7, #8]
20017338:	699b      	ldr	r3, [r3, #24]
2001733a:	431a      	orrs	r2, r3
2001733c:	68bb      	ldr	r3, [r7, #8]
2001733e:	681b      	ldr	r3, [r3, #0]
20017340:	ea42 0103 	orr.w	r1, r2, r3
20017344:	68fb      	ldr	r3, [r7, #12]
20017346:	681b      	ldr	r3, [r3, #0]
20017348:	687a      	ldr	r2, [r7, #4]
2001734a:	430a      	orrs	r2, r1
2001734c:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2001734e:	687b      	ldr	r3, [r7, #4]
20017350:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
20017354:	f000 80d9 	beq.w	2001750a <QSPI_Config+0x32e>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
20017358:	68fb      	ldr	r3, [r7, #12]
2001735a:	681b      	ldr	r3, [r3, #0]
2001735c:	68ba      	ldr	r2, [r7, #8]
2001735e:	6852      	ldr	r2, [r2, #4]
20017360:	619a      	str	r2, [r3, #24]
}
20017362:	e0d2      	b.n	2001750a <QSPI_Config+0x32e>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
20017364:	68bb      	ldr	r3, [r7, #8]
20017366:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20017368:	68bb      	ldr	r3, [r7, #8]
2001736a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001736c:	431a      	orrs	r2, r3
2001736e:	68bb      	ldr	r3, [r7, #8]
20017370:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20017372:	431a      	orrs	r2, r3
20017374:	68bb      	ldr	r3, [r7, #8]
20017376:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20017378:	431a      	orrs	r2, r3
2001737a:	68bb      	ldr	r3, [r7, #8]
2001737c:	695b      	ldr	r3, [r3, #20]
2001737e:	049b      	lsls	r3, r3, #18
20017380:	431a      	orrs	r2, r3
20017382:	68bb      	ldr	r3, [r7, #8]
20017384:	6a1b      	ldr	r3, [r3, #32]
20017386:	431a      	orrs	r2, r3
20017388:	68bb      	ldr	r3, [r7, #8]
2001738a:	69db      	ldr	r3, [r3, #28]
2001738c:	431a      	orrs	r2, r3
2001738e:	68bb      	ldr	r3, [r7, #8]
20017390:	699b      	ldr	r3, [r3, #24]
20017392:	431a      	orrs	r2, r3
20017394:	68bb      	ldr	r3, [r7, #8]
20017396:	681b      	ldr	r3, [r3, #0]
20017398:	ea42 0103 	orr.w	r1, r2, r3
2001739c:	68fb      	ldr	r3, [r7, #12]
2001739e:	681b      	ldr	r3, [r3, #0]
200173a0:	687a      	ldr	r2, [r7, #4]
200173a2:	430a      	orrs	r2, r1
200173a4:	615a      	str	r2, [r3, #20]
}
200173a6:	e0b0      	b.n	2001750a <QSPI_Config+0x32e>
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
200173a8:	68bb      	ldr	r3, [r7, #8]
200173aa:	6a1b      	ldr	r3, [r3, #32]
200173ac:	2b00      	cmp	r3, #0
200173ae:	d05b      	beq.n	20017468 <QSPI_Config+0x28c>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
200173b0:	68fb      	ldr	r3, [r7, #12]
200173b2:	681b      	ldr	r3, [r3, #0]
200173b4:	68ba      	ldr	r2, [r7, #8]
200173b6:	6892      	ldr	r2, [r2, #8]
200173b8:	61da      	str	r2, [r3, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
200173ba:	68bb      	ldr	r3, [r7, #8]
200173bc:	69db      	ldr	r3, [r3, #28]
200173be:	2b00      	cmp	r3, #0
200173c0:	d02d      	beq.n	2001741e <QSPI_Config+0x242>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
200173c2:	68bb      	ldr	r3, [r7, #8]
200173c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
200173c6:	68bb      	ldr	r3, [r7, #8]
200173c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200173ca:	431a      	orrs	r2, r3
200173cc:	68bb      	ldr	r3, [r7, #8]
200173ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200173d0:	431a      	orrs	r2, r3
200173d2:	68bb      	ldr	r3, [r7, #8]
200173d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200173d6:	431a      	orrs	r2, r3
200173d8:	68bb      	ldr	r3, [r7, #8]
200173da:	695b      	ldr	r3, [r3, #20]
200173dc:	049b      	lsls	r3, r3, #18
200173de:	431a      	orrs	r2, r3
200173e0:	68bb      	ldr	r3, [r7, #8]
200173e2:	691b      	ldr	r3, [r3, #16]
200173e4:	431a      	orrs	r2, r3
200173e6:	68bb      	ldr	r3, [r7, #8]
200173e8:	6a1b      	ldr	r3, [r3, #32]
200173ea:	431a      	orrs	r2, r3
200173ec:	68bb      	ldr	r3, [r7, #8]
200173ee:	68db      	ldr	r3, [r3, #12]
200173f0:	431a      	orrs	r2, r3
200173f2:	68bb      	ldr	r3, [r7, #8]
200173f4:	69db      	ldr	r3, [r3, #28]
200173f6:	431a      	orrs	r2, r3
200173f8:	68bb      	ldr	r3, [r7, #8]
200173fa:	699b      	ldr	r3, [r3, #24]
200173fc:	ea42 0103 	orr.w	r1, r2, r3
20017400:	68fb      	ldr	r3, [r7, #12]
20017402:	681b      	ldr	r3, [r3, #0]
20017404:	687a      	ldr	r2, [r7, #4]
20017406:	430a      	orrs	r2, r1
20017408:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2001740a:	687b      	ldr	r3, [r7, #4]
2001740c:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
20017410:	d07b      	beq.n	2001750a <QSPI_Config+0x32e>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
20017412:	68fb      	ldr	r3, [r7, #12]
20017414:	681b      	ldr	r3, [r3, #0]
20017416:	68ba      	ldr	r2, [r7, #8]
20017418:	6852      	ldr	r2, [r2, #4]
2001741a:	619a      	str	r2, [r3, #24]
}
2001741c:	e075      	b.n	2001750a <QSPI_Config+0x32e>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2001741e:	68bb      	ldr	r3, [r7, #8]
20017420:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20017422:	68bb      	ldr	r3, [r7, #8]
20017424:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20017426:	431a      	orrs	r2, r3
20017428:	68bb      	ldr	r3, [r7, #8]
2001742a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2001742c:	431a      	orrs	r2, r3
2001742e:	68bb      	ldr	r3, [r7, #8]
20017430:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20017432:	431a      	orrs	r2, r3
20017434:	68bb      	ldr	r3, [r7, #8]
20017436:	695b      	ldr	r3, [r3, #20]
20017438:	049b      	lsls	r3, r3, #18
2001743a:	431a      	orrs	r2, r3
2001743c:	68bb      	ldr	r3, [r7, #8]
2001743e:	691b      	ldr	r3, [r3, #16]
20017440:	431a      	orrs	r2, r3
20017442:	68bb      	ldr	r3, [r7, #8]
20017444:	6a1b      	ldr	r3, [r3, #32]
20017446:	431a      	orrs	r2, r3
20017448:	68bb      	ldr	r3, [r7, #8]
2001744a:	69db      	ldr	r3, [r3, #28]
2001744c:	431a      	orrs	r2, r3
2001744e:	68bb      	ldr	r3, [r7, #8]
20017450:	699b      	ldr	r3, [r3, #24]
20017452:	ea42 0103 	orr.w	r1, r2, r3
20017456:	68fb      	ldr	r3, [r7, #12]
20017458:	681b      	ldr	r3, [r3, #0]
2001745a:	687a      	ldr	r2, [r7, #4]
2001745c:	430a      	orrs	r2, r1
2001745e:	615a      	str	r2, [r3, #20]
}
20017460:	e053      	b.n	2001750a <QSPI_Config+0x32e>
20017462:	bf00      	nop
20017464:	2001c2a4 	.word	0x2001c2a4
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
20017468:	68bb      	ldr	r3, [r7, #8]
2001746a:	69db      	ldr	r3, [r3, #28]
2001746c:	2b00      	cmp	r3, #0
2001746e:	d02a      	beq.n	200174c6 <QSPI_Config+0x2ea>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
20017470:	68bb      	ldr	r3, [r7, #8]
20017472:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20017474:	68bb      	ldr	r3, [r7, #8]
20017476:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20017478:	431a      	orrs	r2, r3
2001747a:	68bb      	ldr	r3, [r7, #8]
2001747c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2001747e:	431a      	orrs	r2, r3
20017480:	68bb      	ldr	r3, [r7, #8]
20017482:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20017484:	431a      	orrs	r2, r3
20017486:	68bb      	ldr	r3, [r7, #8]
20017488:	695b      	ldr	r3, [r3, #20]
2001748a:	049b      	lsls	r3, r3, #18
2001748c:	431a      	orrs	r2, r3
2001748e:	68bb      	ldr	r3, [r7, #8]
20017490:	6a1b      	ldr	r3, [r3, #32]
20017492:	431a      	orrs	r2, r3
20017494:	68bb      	ldr	r3, [r7, #8]
20017496:	68db      	ldr	r3, [r3, #12]
20017498:	431a      	orrs	r2, r3
2001749a:	68bb      	ldr	r3, [r7, #8]
2001749c:	69db      	ldr	r3, [r3, #28]
2001749e:	431a      	orrs	r2, r3
200174a0:	68bb      	ldr	r3, [r7, #8]
200174a2:	699b      	ldr	r3, [r3, #24]
200174a4:	ea42 0103 	orr.w	r1, r2, r3
200174a8:	68fb      	ldr	r3, [r7, #12]
200174aa:	681b      	ldr	r3, [r3, #0]
200174ac:	687a      	ldr	r2, [r7, #4]
200174ae:	430a      	orrs	r2, r1
200174b0:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
200174b2:	687b      	ldr	r3, [r7, #4]
200174b4:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
200174b8:	d027      	beq.n	2001750a <QSPI_Config+0x32e>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
200174ba:	68fb      	ldr	r3, [r7, #12]
200174bc:	681b      	ldr	r3, [r3, #0]
200174be:	68ba      	ldr	r2, [r7, #8]
200174c0:	6852      	ldr	r2, [r2, #4]
200174c2:	619a      	str	r2, [r3, #24]
}
200174c4:	e021      	b.n	2001750a <QSPI_Config+0x32e>
        if (cmd->DataMode != QSPI_DATA_NONE)
200174c6:	68bb      	ldr	r3, [r7, #8]
200174c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200174ca:	2b00      	cmp	r3, #0
200174cc:	d01d      	beq.n	2001750a <QSPI_Config+0x32e>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
200174ce:	68bb      	ldr	r3, [r7, #8]
200174d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
200174d2:	68bb      	ldr	r3, [r7, #8]
200174d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200174d6:	431a      	orrs	r2, r3
200174d8:	68bb      	ldr	r3, [r7, #8]
200174da:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200174dc:	431a      	orrs	r2, r3
200174de:	68bb      	ldr	r3, [r7, #8]
200174e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200174e2:	431a      	orrs	r2, r3
200174e4:	68bb      	ldr	r3, [r7, #8]
200174e6:	695b      	ldr	r3, [r3, #20]
200174e8:	049b      	lsls	r3, r3, #18
200174ea:	431a      	orrs	r2, r3
200174ec:	68bb      	ldr	r3, [r7, #8]
200174ee:	6a1b      	ldr	r3, [r3, #32]
200174f0:	431a      	orrs	r2, r3
200174f2:	68bb      	ldr	r3, [r7, #8]
200174f4:	69db      	ldr	r3, [r3, #28]
200174f6:	431a      	orrs	r2, r3
200174f8:	68bb      	ldr	r3, [r7, #8]
200174fa:	699b      	ldr	r3, [r3, #24]
200174fc:	ea42 0103 	orr.w	r1, r2, r3
20017500:	68fb      	ldr	r3, [r7, #12]
20017502:	681b      	ldr	r3, [r3, #0]
20017504:	687a      	ldr	r2, [r7, #4]
20017506:	430a      	orrs	r2, r1
20017508:	615a      	str	r2, [r3, #20]
}
2001750a:	bf00      	nop
2001750c:	3710      	adds	r7, #16
2001750e:	46bd      	mov	sp, r7
20017510:	bd80      	pop	{r7, pc}
20017512:	bf00      	nop

20017514 <HAL_RCC_DeInit>:
  *            - Peripheral clocks
  *            - LSI, LSE and RTC clocks
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
20017514:	b580      	push	{r7, lr}
20017516:	b082      	sub	sp, #8
20017518:	af00      	add	r7, sp, #0
  uint32_t tickstart;

        /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())
2001751a:	4b89      	ldr	r3, [pc, #548]	; (20017740 <HAL_RCC_DeInit+0x22c>)
2001751c:	681b      	ldr	r3, [r3, #0]
2001751e:	f003 030f 	and.w	r3, r3, #15
20017522:	2b06      	cmp	r3, #6
20017524:	d80f      	bhi.n	20017546 <HAL_RCC_DeInit+0x32>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
20017526:	4b86      	ldr	r3, [pc, #536]	; (20017740 <HAL_RCC_DeInit+0x22c>)
20017528:	681b      	ldr	r3, [r3, #0]
2001752a:	f023 030f 	bic.w	r3, r3, #15
2001752e:	4a84      	ldr	r2, [pc, #528]	; (20017740 <HAL_RCC_DeInit+0x22c>)
20017530:	f043 0307 	orr.w	r3, r3, #7
20017534:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
20017536:	4b82      	ldr	r3, [pc, #520]	; (20017740 <HAL_RCC_DeInit+0x22c>)
20017538:	681b      	ldr	r3, [r3, #0]
2001753a:	f003 030f 	and.w	r3, r3, #15
2001753e:	2b07      	cmp	r3, #7
20017540:	d001      	beq.n	20017546 <HAL_RCC_DeInit+0x32>
    {
      return HAL_ERROR;
20017542:	2301      	movs	r3, #1
20017544:	e0f7      	b.n	20017736 <HAL_RCC_DeInit+0x222>

  }


  /* Get Start Tick */
  tickstart = HAL_GetTick();
20017546:	f7ea fbd1 	bl	20001cec <HAL_GetTick>
2001754a:	6078      	str	r0, [r7, #4]

  /* Set HSION bit */
  SET_BIT(RCC->CR, RCC_CR_HSION);
2001754c:	4b7d      	ldr	r3, [pc, #500]	; (20017744 <HAL_RCC_DeInit+0x230>)
2001754e:	681b      	ldr	r3, [r3, #0]
20017550:	4a7c      	ldr	r2, [pc, #496]	; (20017744 <HAL_RCC_DeInit+0x230>)
20017552:	f043 0301 	orr.w	r3, r3, #1
20017556:	6013      	str	r3, [r2, #0]

  /* Wait till HSI is ready */
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
20017558:	e008      	b.n	2001756c <HAL_RCC_DeInit+0x58>
  {
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
2001755a:	f7ea fbc7 	bl	20001cec <HAL_GetTick>
2001755e:	4602      	mov	r2, r0
20017560:	687b      	ldr	r3, [r7, #4]
20017562:	1ad3      	subs	r3, r2, r3
20017564:	2b02      	cmp	r3, #2
20017566:	d901      	bls.n	2001756c <HAL_RCC_DeInit+0x58>
    {
      return HAL_TIMEOUT;
20017568:	2303      	movs	r3, #3
2001756a:	e0e4      	b.n	20017736 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
2001756c:	4b75      	ldr	r3, [pc, #468]	; (20017744 <HAL_RCC_DeInit+0x230>)
2001756e:	681b      	ldr	r3, [r3, #0]
20017570:	f003 0304 	and.w	r3, r3, #4
20017574:	2b00      	cmp	r3, #0
20017576:	d0f0      	beq.n	2001755a <HAL_RCC_DeInit+0x46>
    }
  }

  /* Set HSITRIM[6:0] bits to the reset value */
  SET_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);
20017578:	4b72      	ldr	r3, [pc, #456]	; (20017744 <HAL_RCC_DeInit+0x230>)
2001757a:	685b      	ldr	r3, [r3, #4]
2001757c:	4a71      	ldr	r2, [pc, #452]	; (20017744 <HAL_RCC_DeInit+0x230>)
2001757e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
20017582:	6053      	str	r3, [r2, #4]

  /* Reset CFGR register */
  CLEAR_REG(RCC->CFGR);
20017584:	4b6f      	ldr	r3, [pc, #444]	; (20017744 <HAL_RCC_DeInit+0x230>)
20017586:	2200      	movs	r2, #0
20017588:	611a      	str	r2, [r3, #16]

  /* Update the SystemCoreClock and SystemD2Clock global variables */
  SystemCoreClock = HSI_VALUE;
2001758a:	4b6f      	ldr	r3, [pc, #444]	; (20017748 <HAL_RCC_DeInit+0x234>)
2001758c:	4a6f      	ldr	r2, [pc, #444]	; (2001774c <HAL_RCC_DeInit+0x238>)
2001758e:	601a      	str	r2, [r3, #0]
  SystemD2Clock = HSI_VALUE;
20017590:	4b6f      	ldr	r3, [pc, #444]	; (20017750 <HAL_RCC_DeInit+0x23c>)
20017592:	4a6e      	ldr	r2, [pc, #440]	; (2001774c <HAL_RCC_DeInit+0x238>)
20017594:	601a      	str	r2, [r3, #0]

  /* Adapt Systick interrupt period */
  if(HAL_InitTick(uwTickPrio) != HAL_OK)
20017596:	4b6f      	ldr	r3, [pc, #444]	; (20017754 <HAL_RCC_DeInit+0x240>)
20017598:	681b      	ldr	r3, [r3, #0]
2001759a:	4618      	mov	r0, r3
2001759c:	f7ea fb5c 	bl	20001c58 <HAL_InitTick>
200175a0:	4603      	mov	r3, r0
200175a2:	2b00      	cmp	r3, #0
200175a4:	d001      	beq.n	200175aa <HAL_RCC_DeInit+0x96>
  {
    return HAL_ERROR;
200175a6:	2301      	movs	r3, #1
200175a8:	e0c5      	b.n	20017736 <HAL_RCC_DeInit+0x222>
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
200175aa:	f7ea fb9f 	bl	20001cec <HAL_GetTick>
200175ae:	6078      	str	r0, [r7, #4]

  /* Wait till clock switch is ready */
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
200175b0:	e00a      	b.n	200175c8 <HAL_RCC_DeInit+0xb4>
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
200175b2:	f7ea fb9b 	bl	20001cec <HAL_GetTick>
200175b6:	4602      	mov	r2, r0
200175b8:	687b      	ldr	r3, [r7, #4]
200175ba:	1ad3      	subs	r3, r2, r3
200175bc:	f241 3288 	movw	r2, #5000	; 0x1388
200175c0:	4293      	cmp	r3, r2
200175c2:	d901      	bls.n	200175c8 <HAL_RCC_DeInit+0xb4>
    {
      return HAL_TIMEOUT;
200175c4:	2303      	movs	r3, #3
200175c6:	e0b6      	b.n	20017736 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
200175c8:	4b5e      	ldr	r3, [pc, #376]	; (20017744 <HAL_RCC_DeInit+0x230>)
200175ca:	691b      	ldr	r3, [r3, #16]
200175cc:	f003 0338 	and.w	r3, r3, #56	; 0x38
200175d0:	2b00      	cmp	r3, #0
200175d2:	d1ee      	bne.n	200175b2 <HAL_RCC_DeInit+0x9e>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
200175d4:	f7ea fb8a 	bl	20001cec <HAL_GetTick>
200175d8:	6078      	str	r0, [r7, #4]

  /* Reset CSION, CSIKERON, HSEON, HSI48ON, HSECSSON, HSIDIV bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON| RCC_CR_HSIDIV| RCC_CR_HSIDIVF| RCC_CR_CSION | RCC_CR_CSIKERON  \
200175da:	4b5a      	ldr	r3, [pc, #360]	; (20017744 <HAL_RCC_DeInit+0x230>)
200175dc:	681a      	ldr	r2, [r3, #0]
200175de:	4959      	ldr	r1, [pc, #356]	; (20017744 <HAL_RCC_DeInit+0x230>)
200175e0:	4b5d      	ldr	r3, [pc, #372]	; (20017758 <HAL_RCC_DeInit+0x244>)
200175e2:	4013      	ands	r3, r2
200175e4:	600b      	str	r3, [r1, #0]
  | RCC_CR_HSI48ON | RCC_CR_CSSHSEON);

  /* Wait till HSE is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
200175e6:	e008      	b.n	200175fa <HAL_RCC_DeInit+0xe6>
  {
    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
200175e8:	f7ea fb80 	bl	20001cec <HAL_GetTick>
200175ec:	4602      	mov	r2, r0
200175ee:	687b      	ldr	r3, [r7, #4]
200175f0:	1ad3      	subs	r3, r2, r3
200175f2:	2b64      	cmp	r3, #100	; 0x64
200175f4:	d901      	bls.n	200175fa <HAL_RCC_DeInit+0xe6>
    {
      return HAL_TIMEOUT;
200175f6:	2303      	movs	r3, #3
200175f8:	e09d      	b.n	20017736 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
200175fa:	4b52      	ldr	r3, [pc, #328]	; (20017744 <HAL_RCC_DeInit+0x230>)
200175fc:	681b      	ldr	r3, [r3, #0]
200175fe:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20017602:	2b00      	cmp	r3, #0
20017604:	d1f0      	bne.n	200175e8 <HAL_RCC_DeInit+0xd4>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
20017606:	f7ea fb71 	bl	20001cec <HAL_GetTick>
2001760a:	6078      	str	r0, [r7, #4]

  /* Clear PLLON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
2001760c:	4b4d      	ldr	r3, [pc, #308]	; (20017744 <HAL_RCC_DeInit+0x230>)
2001760e:	681b      	ldr	r3, [r3, #0]
20017610:	4a4c      	ldr	r2, [pc, #304]	; (20017744 <HAL_RCC_DeInit+0x230>)
20017612:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
20017616:	6013      	str	r3, [r2, #0]

  /* Wait till PLL is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
20017618:	e008      	b.n	2001762c <HAL_RCC_DeInit+0x118>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2001761a:	f7ea fb67 	bl	20001cec <HAL_GetTick>
2001761e:	4602      	mov	r2, r0
20017620:	687b      	ldr	r3, [r7, #4]
20017622:	1ad3      	subs	r3, r2, r3
20017624:	2b02      	cmp	r3, #2
20017626:	d901      	bls.n	2001762c <HAL_RCC_DeInit+0x118>
    {
      return HAL_TIMEOUT;
20017628:	2303      	movs	r3, #3
2001762a:	e084      	b.n	20017736 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
2001762c:	4b45      	ldr	r3, [pc, #276]	; (20017744 <HAL_RCC_DeInit+0x230>)
2001762e:	681b      	ldr	r3, [r3, #0]
20017630:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20017634:	2b00      	cmp	r3, #0
20017636:	d1f0      	bne.n	2001761a <HAL_RCC_DeInit+0x106>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
20017638:	f7ea fb58 	bl	20001cec <HAL_GetTick>
2001763c:	6078      	str	r0, [r7, #4]

  /* Reset PLL2ON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
2001763e:	4b41      	ldr	r3, [pc, #260]	; (20017744 <HAL_RCC_DeInit+0x230>)
20017640:	681b      	ldr	r3, [r3, #0]
20017642:	4a40      	ldr	r2, [pc, #256]	; (20017744 <HAL_RCC_DeInit+0x230>)
20017644:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
20017648:	6013      	str	r3, [r2, #0]

  /* Wait till PLL2 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
2001764a:	e008      	b.n	2001765e <HAL_RCC_DeInit+0x14a>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2001764c:	f7ea fb4e 	bl	20001cec <HAL_GetTick>
20017650:	4602      	mov	r2, r0
20017652:	687b      	ldr	r3, [r7, #4]
20017654:	1ad3      	subs	r3, r2, r3
20017656:	2b02      	cmp	r3, #2
20017658:	d901      	bls.n	2001765e <HAL_RCC_DeInit+0x14a>
    {
      return HAL_TIMEOUT;
2001765a:	2303      	movs	r3, #3
2001765c:	e06b      	b.n	20017736 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
2001765e:	4b39      	ldr	r3, [pc, #228]	; (20017744 <HAL_RCC_DeInit+0x230>)
20017660:	681b      	ldr	r3, [r3, #0]
20017662:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
20017666:	2b00      	cmp	r3, #0
20017668:	d1f0      	bne.n	2001764c <HAL_RCC_DeInit+0x138>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
2001766a:	f7ea fb3f 	bl	20001cec <HAL_GetTick>
2001766e:	6078      	str	r0, [r7, #4]

  /* Reset PLL3 bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
20017670:	4b34      	ldr	r3, [pc, #208]	; (20017744 <HAL_RCC_DeInit+0x230>)
20017672:	681b      	ldr	r3, [r3, #0]
20017674:	4a33      	ldr	r2, [pc, #204]	; (20017744 <HAL_RCC_DeInit+0x230>)
20017676:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
2001767a:	6013      	str	r3, [r2, #0]

  /* Wait till PLL3 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
2001767c:	e008      	b.n	20017690 <HAL_RCC_DeInit+0x17c>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2001767e:	f7ea fb35 	bl	20001cec <HAL_GetTick>
20017682:	4602      	mov	r2, r0
20017684:	687b      	ldr	r3, [r7, #4]
20017686:	1ad3      	subs	r3, r2, r3
20017688:	2b02      	cmp	r3, #2
2001768a:	d901      	bls.n	20017690 <HAL_RCC_DeInit+0x17c>
    {
      return HAL_TIMEOUT;
2001768c:	2303      	movs	r3, #3
2001768e:	e052      	b.n	20017736 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
20017690:	4b2c      	ldr	r3, [pc, #176]	; (20017744 <HAL_RCC_DeInit+0x230>)
20017692:	681b      	ldr	r3, [r3, #0]
20017694:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
20017698:	2b00      	cmp	r3, #0
2001769a:	d1f0      	bne.n	2001767e <HAL_RCC_DeInit+0x16a>
    }
  }

#if defined(RCC_D1CFGR_HPRE)
  /* Reset D1CFGR register */
  CLEAR_REG(RCC->D1CFGR);
2001769c:	4b29      	ldr	r3, [pc, #164]	; (20017744 <HAL_RCC_DeInit+0x230>)
2001769e:	2200      	movs	r2, #0
200176a0:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  CLEAR_REG(RCC->D2CFGR);
200176a2:	4b28      	ldr	r3, [pc, #160]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176a4:	2200      	movs	r2, #0
200176a6:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  CLEAR_REG(RCC->D3CFGR);
200176a8:	4b26      	ldr	r3, [pc, #152]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176aa:	2200      	movs	r2, #0
200176ac:	621a      	str	r2, [r3, #32]
  /* Reset SRDCFGR register */
  CLEAR_REG(RCC->SRDCFGR);
#endif

  /* Reset PLLCKSELR register to default value */
  RCC->PLLCKSELR= RCC_PLLCKSELR_DIVM1_5|RCC_PLLCKSELR_DIVM2_5|RCC_PLLCKSELR_DIVM3_5;
200176ae:	4b25      	ldr	r3, [pc, #148]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176b0:	4a2a      	ldr	r2, [pc, #168]	; (2001775c <HAL_RCC_DeInit+0x248>)
200176b2:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register to default value */
  WRITE_REG(RCC->PLLCFGR, 0x01FF0000U);
200176b4:	4b23      	ldr	r3, [pc, #140]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176b6:	4a2a      	ldr	r2, [pc, #168]	; (20017760 <HAL_RCC_DeInit+0x24c>)
200176b8:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset PLL1DIVR register to default value */
  WRITE_REG(RCC->PLL1DIVR,0x01010280U);
200176ba:	4b22      	ldr	r3, [pc, #136]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176bc:	4a29      	ldr	r2, [pc, #164]	; (20017764 <HAL_RCC_DeInit+0x250>)
200176be:	631a      	str	r2, [r3, #48]	; 0x30

  /* Reset PLL1FRACR register */
  CLEAR_REG(RCC->PLL1FRACR);
200176c0:	4b20      	ldr	r3, [pc, #128]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176c2:	2200      	movs	r2, #0
200176c4:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register to default value */
  WRITE_REG(RCC->PLL2DIVR,0x01010280U);
200176c6:	4b1f      	ldr	r3, [pc, #124]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176c8:	4a26      	ldr	r2, [pc, #152]	; (20017764 <HAL_RCC_DeInit+0x250>)
200176ca:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */
  CLEAR_REG(RCC->PLL2FRACR);
200176cc:	4b1d      	ldr	r3, [pc, #116]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176ce:	2200      	movs	r2, #0
200176d0:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Reset PLL3DIVR register to default value */
  WRITE_REG(RCC->PLL3DIVR,0x01010280U);
200176d2:	4b1c      	ldr	r3, [pc, #112]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176d4:	4a23      	ldr	r2, [pc, #140]	; (20017764 <HAL_RCC_DeInit+0x250>)
200176d6:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  CLEAR_REG(RCC->PLL3FRACR);
200176d8:	4b1a      	ldr	r3, [pc, #104]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176da:	2200      	movs	r2, #0
200176dc:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
200176de:	4b19      	ldr	r3, [pc, #100]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176e0:	681b      	ldr	r3, [r3, #0]
200176e2:	4a18      	ldr	r2, [pc, #96]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176e4:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
200176e8:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
200176ea:	4b16      	ldr	r3, [pc, #88]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176ec:	2200      	movs	r2, #0
200176ee:	661a      	str	r2, [r3, #96]	; 0x60

  /* Clear all interrupts flags */
  WRITE_REG(RCC->CICR,0xFFFFFFFFU);
200176f0:	4b14      	ldr	r3, [pc, #80]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176f2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
200176f6:	669a      	str	r2, [r3, #104]	; 0x68

  /* Reset all RSR flags */
  SET_BIT(RCC->RSR, RCC_RSR_RMVF);
200176f8:	4b12      	ldr	r3, [pc, #72]	; (20017744 <HAL_RCC_DeInit+0x230>)
200176fa:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
200176fe:	4a11      	ldr	r2, [pc, #68]	; (20017744 <HAL_RCC_DeInit+0x230>)
20017700:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20017704:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0

      /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())
20017708:	4b0d      	ldr	r3, [pc, #52]	; (20017740 <HAL_RCC_DeInit+0x22c>)
2001770a:	681b      	ldr	r3, [r3, #0]
2001770c:	f003 030f 	and.w	r3, r3, #15
20017710:	2b07      	cmp	r3, #7
20017712:	d90f      	bls.n	20017734 <HAL_RCC_DeInit+0x220>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
20017714:	4b0a      	ldr	r3, [pc, #40]	; (20017740 <HAL_RCC_DeInit+0x22c>)
20017716:	681b      	ldr	r3, [r3, #0]
20017718:	f023 030f 	bic.w	r3, r3, #15
2001771c:	4a08      	ldr	r2, [pc, #32]	; (20017740 <HAL_RCC_DeInit+0x22c>)
2001771e:	f043 0307 	orr.w	r3, r3, #7
20017722:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
20017724:	4b06      	ldr	r3, [pc, #24]	; (20017740 <HAL_RCC_DeInit+0x22c>)
20017726:	681b      	ldr	r3, [r3, #0]
20017728:	f003 030f 	and.w	r3, r3, #15
2001772c:	2b07      	cmp	r3, #7
2001772e:	d001      	beq.n	20017734 <HAL_RCC_DeInit+0x220>
    {
      return HAL_ERROR;
20017730:	2301      	movs	r3, #1
20017732:	e000      	b.n	20017736 <HAL_RCC_DeInit+0x222>
    }

}

  return HAL_OK;
20017734:	2300      	movs	r3, #0
}
20017736:	4618      	mov	r0, r3
20017738:	3708      	adds	r7, #8
2001773a:	46bd      	mov	sp, r7
2001773c:	bd80      	pop	{r7, pc}
2001773e:	bf00      	nop
20017740:	52002000 	.word	0x52002000
20017744:	58024400 	.word	0x58024400
20017748:	2001c978 	.word	0x2001c978
2001774c:	03d09000 	.word	0x03d09000
20017750:	2001c97c 	.word	0x2001c97c
20017754:	2001c980 	.word	0x2001c980
20017758:	fff6ed45 	.word	0xfff6ed45
2001775c:	02020200 	.word	0x02020200
20017760:	01ff0000 	.word	0x01ff0000
20017764:	01010280 	.word	0x01010280

20017768 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
20017768:	b580      	push	{r7, lr}
2001776a:	b08c      	sub	sp, #48	; 0x30
2001776c:	af00      	add	r7, sp, #0
2001776e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
20017770:	687b      	ldr	r3, [r7, #4]
20017772:	2b00      	cmp	r3, #0
20017774:	d102      	bne.n	2001777c <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
20017776:	2301      	movs	r3, #1
20017778:	f000 bce9 	b.w	2001814e <HAL_RCC_OscConfig+0x9e6>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
2001777c:	687b      	ldr	r3, [r7, #4]
2001777e:	681b      	ldr	r3, [r3, #0]
20017780:	2b00      	cmp	r3, #0
20017782:	d028      	beq.n	200177d6 <HAL_RCC_OscConfig+0x6e>
20017784:	687b      	ldr	r3, [r7, #4]
20017786:	681b      	ldr	r3, [r3, #0]
20017788:	f003 0301 	and.w	r3, r3, #1
2001778c:	2b00      	cmp	r3, #0
2001778e:	d122      	bne.n	200177d6 <HAL_RCC_OscConfig+0x6e>
20017790:	687b      	ldr	r3, [r7, #4]
20017792:	681b      	ldr	r3, [r3, #0]
20017794:	f003 0302 	and.w	r3, r3, #2
20017798:	2b00      	cmp	r3, #0
2001779a:	d11c      	bne.n	200177d6 <HAL_RCC_OscConfig+0x6e>
2001779c:	687b      	ldr	r3, [r7, #4]
2001779e:	681b      	ldr	r3, [r3, #0]
200177a0:	f003 0310 	and.w	r3, r3, #16
200177a4:	2b00      	cmp	r3, #0
200177a6:	d116      	bne.n	200177d6 <HAL_RCC_OscConfig+0x6e>
200177a8:	687b      	ldr	r3, [r7, #4]
200177aa:	681b      	ldr	r3, [r3, #0]
200177ac:	f003 0308 	and.w	r3, r3, #8
200177b0:	2b00      	cmp	r3, #0
200177b2:	d110      	bne.n	200177d6 <HAL_RCC_OscConfig+0x6e>
200177b4:	687b      	ldr	r3, [r7, #4]
200177b6:	681b      	ldr	r3, [r3, #0]
200177b8:	f003 0304 	and.w	r3, r3, #4
200177bc:	2b00      	cmp	r3, #0
200177be:	d10a      	bne.n	200177d6 <HAL_RCC_OscConfig+0x6e>
200177c0:	687b      	ldr	r3, [r7, #4]
200177c2:	681b      	ldr	r3, [r3, #0]
200177c4:	f003 0320 	and.w	r3, r3, #32
200177c8:	2b00      	cmp	r3, #0
200177ca:	d104      	bne.n	200177d6 <HAL_RCC_OscConfig+0x6e>
200177cc:	f44f 71cf 	mov.w	r1, #414	; 0x19e
200177d0:	48a0      	ldr	r0, [pc, #640]	; (20017a54 <HAL_RCC_OscConfig+0x2ec>)
200177d2:	f7e9 f88f 	bl	200008f4 <assert_failed>
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
200177d6:	687b      	ldr	r3, [r7, #4]
200177d8:	681b      	ldr	r3, [r3, #0]
200177da:	f003 0301 	and.w	r3, r3, #1
200177de:	2b00      	cmp	r3, #0
200177e0:	f000 809d 	beq.w	2001791e <HAL_RCC_OscConfig+0x1b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
200177e4:	687b      	ldr	r3, [r7, #4]
200177e6:	685b      	ldr	r3, [r3, #4]
200177e8:	2b00      	cmp	r3, #0
200177ea:	d00e      	beq.n	2001780a <HAL_RCC_OscConfig+0xa2>
200177ec:	687b      	ldr	r3, [r7, #4]
200177ee:	685b      	ldr	r3, [r3, #4]
200177f0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
200177f4:	d009      	beq.n	2001780a <HAL_RCC_OscConfig+0xa2>
200177f6:	687b      	ldr	r3, [r7, #4]
200177f8:	685b      	ldr	r3, [r3, #4]
200177fa:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
200177fe:	d004      	beq.n	2001780a <HAL_RCC_OscConfig+0xa2>
20017800:	f240 11a3 	movw	r1, #419	; 0x1a3
20017804:	4893      	ldr	r0, [pc, #588]	; (20017a54 <HAL_RCC_OscConfig+0x2ec>)
20017806:	f7e9 f875 	bl	200008f4 <assert_failed>

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
2001780a:	4b93      	ldr	r3, [pc, #588]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
2001780c:	691b      	ldr	r3, [r3, #16]
2001780e:	f003 0338 	and.w	r3, r3, #56	; 0x38
20017812:	62fb      	str	r3, [r7, #44]	; 0x2c
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
20017814:	4b90      	ldr	r3, [pc, #576]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017816:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20017818:	62bb      	str	r3, [r7, #40]	; 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
2001781a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
2001781c:	2b10      	cmp	r3, #16
2001781e:	d007      	beq.n	20017830 <HAL_RCC_OscConfig+0xc8>
20017820:	6afb      	ldr	r3, [r7, #44]	; 0x2c
20017822:	2b18      	cmp	r3, #24
20017824:	d111      	bne.n	2001784a <HAL_RCC_OscConfig+0xe2>
20017826:	6abb      	ldr	r3, [r7, #40]	; 0x28
20017828:	f003 0303 	and.w	r3, r3, #3
2001782c:	2b02      	cmp	r3, #2
2001782e:	d10c      	bne.n	2001784a <HAL_RCC_OscConfig+0xe2>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
20017830:	4b89      	ldr	r3, [pc, #548]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017832:	681b      	ldr	r3, [r3, #0]
20017834:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20017838:	2b00      	cmp	r3, #0
2001783a:	d06f      	beq.n	2001791c <HAL_RCC_OscConfig+0x1b4>
2001783c:	687b      	ldr	r3, [r7, #4]
2001783e:	685b      	ldr	r3, [r3, #4]
20017840:	2b00      	cmp	r3, #0
20017842:	d16b      	bne.n	2001791c <HAL_RCC_OscConfig+0x1b4>
      {
        return HAL_ERROR;
20017844:	2301      	movs	r3, #1
20017846:	f000 bc82 	b.w	2001814e <HAL_RCC_OscConfig+0x9e6>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
2001784a:	687b      	ldr	r3, [r7, #4]
2001784c:	685b      	ldr	r3, [r3, #4]
2001784e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20017852:	d106      	bne.n	20017862 <HAL_RCC_OscConfig+0xfa>
20017854:	4b80      	ldr	r3, [pc, #512]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017856:	681b      	ldr	r3, [r3, #0]
20017858:	4a7f      	ldr	r2, [pc, #508]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
2001785a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2001785e:	6013      	str	r3, [r2, #0]
20017860:	e02e      	b.n	200178c0 <HAL_RCC_OscConfig+0x158>
20017862:	687b      	ldr	r3, [r7, #4]
20017864:	685b      	ldr	r3, [r3, #4]
20017866:	2b00      	cmp	r3, #0
20017868:	d10c      	bne.n	20017884 <HAL_RCC_OscConfig+0x11c>
2001786a:	4b7b      	ldr	r3, [pc, #492]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
2001786c:	681b      	ldr	r3, [r3, #0]
2001786e:	4a7a      	ldr	r2, [pc, #488]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017870:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20017874:	6013      	str	r3, [r2, #0]
20017876:	4b78      	ldr	r3, [pc, #480]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017878:	681b      	ldr	r3, [r3, #0]
2001787a:	4a77      	ldr	r2, [pc, #476]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
2001787c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
20017880:	6013      	str	r3, [r2, #0]
20017882:	e01d      	b.n	200178c0 <HAL_RCC_OscConfig+0x158>
20017884:	687b      	ldr	r3, [r7, #4]
20017886:	685b      	ldr	r3, [r3, #4]
20017888:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
2001788c:	d10c      	bne.n	200178a8 <HAL_RCC_OscConfig+0x140>
2001788e:	4b72      	ldr	r3, [pc, #456]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017890:	681b      	ldr	r3, [r3, #0]
20017892:	4a71      	ldr	r2, [pc, #452]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017894:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
20017898:	6013      	str	r3, [r2, #0]
2001789a:	4b6f      	ldr	r3, [pc, #444]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
2001789c:	681b      	ldr	r3, [r3, #0]
2001789e:	4a6e      	ldr	r2, [pc, #440]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200178a0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200178a4:	6013      	str	r3, [r2, #0]
200178a6:	e00b      	b.n	200178c0 <HAL_RCC_OscConfig+0x158>
200178a8:	4b6b      	ldr	r3, [pc, #428]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200178aa:	681b      	ldr	r3, [r3, #0]
200178ac:	4a6a      	ldr	r2, [pc, #424]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200178ae:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
200178b2:	6013      	str	r3, [r2, #0]
200178b4:	4b68      	ldr	r3, [pc, #416]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200178b6:	681b      	ldr	r3, [r3, #0]
200178b8:	4a67      	ldr	r2, [pc, #412]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200178ba:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
200178be:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
200178c0:	687b      	ldr	r3, [r7, #4]
200178c2:	685b      	ldr	r3, [r3, #4]
200178c4:	2b00      	cmp	r3, #0
200178c6:	d014      	beq.n	200178f2 <HAL_RCC_OscConfig+0x18a>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
200178c8:	f7ea fa10 	bl	20001cec <HAL_GetTick>
200178cc:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
200178ce:	e009      	b.n	200178e4 <HAL_RCC_OscConfig+0x17c>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
200178d0:	f7ea fa0c 	bl	20001cec <HAL_GetTick>
200178d4:	4602      	mov	r2, r0
200178d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
200178d8:	1ad3      	subs	r3, r2, r3
200178da:	2b64      	cmp	r3, #100	; 0x64
200178dc:	d902      	bls.n	200178e4 <HAL_RCC_OscConfig+0x17c>
          {
            return HAL_TIMEOUT;
200178de:	2303      	movs	r3, #3
200178e0:	f000 bc35 	b.w	2001814e <HAL_RCC_OscConfig+0x9e6>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
200178e4:	4b5c      	ldr	r3, [pc, #368]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200178e6:	681b      	ldr	r3, [r3, #0]
200178e8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
200178ec:	2b00      	cmp	r3, #0
200178ee:	d0ef      	beq.n	200178d0 <HAL_RCC_OscConfig+0x168>
200178f0:	e015      	b.n	2001791e <HAL_RCC_OscConfig+0x1b6>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
200178f2:	f7ea f9fb 	bl	20001cec <HAL_GetTick>
200178f6:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
200178f8:	e009      	b.n	2001790e <HAL_RCC_OscConfig+0x1a6>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
200178fa:	f7ea f9f7 	bl	20001cec <HAL_GetTick>
200178fe:	4602      	mov	r2, r0
20017900:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017902:	1ad3      	subs	r3, r2, r3
20017904:	2b64      	cmp	r3, #100	; 0x64
20017906:	d902      	bls.n	2001790e <HAL_RCC_OscConfig+0x1a6>
          {
            return HAL_TIMEOUT;
20017908:	2303      	movs	r3, #3
2001790a:	f000 bc20 	b.w	2001814e <HAL_RCC_OscConfig+0x9e6>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
2001790e:	4b52      	ldr	r3, [pc, #328]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017910:	681b      	ldr	r3, [r3, #0]
20017912:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20017916:	2b00      	cmp	r3, #0
20017918:	d1ef      	bne.n	200178fa <HAL_RCC_OscConfig+0x192>
2001791a:	e000      	b.n	2001791e <HAL_RCC_OscConfig+0x1b6>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
2001791c:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
2001791e:	687b      	ldr	r3, [r7, #4]
20017920:	681b      	ldr	r3, [r3, #0]
20017922:	f003 0302 	and.w	r3, r3, #2
20017926:	2b00      	cmp	r3, #0
20017928:	f000 80bc 	beq.w	20017aa4 <HAL_RCC_OscConfig+0x33c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
2001792c:	687b      	ldr	r3, [r7, #4]
2001792e:	68db      	ldr	r3, [r3, #12]
20017930:	2b00      	cmp	r3, #0
20017932:	d018      	beq.n	20017966 <HAL_RCC_OscConfig+0x1fe>
20017934:	687b      	ldr	r3, [r7, #4]
20017936:	68db      	ldr	r3, [r3, #12]
20017938:	2b01      	cmp	r3, #1
2001793a:	d014      	beq.n	20017966 <HAL_RCC_OscConfig+0x1fe>
2001793c:	687b      	ldr	r3, [r7, #4]
2001793e:	68db      	ldr	r3, [r3, #12]
20017940:	2b01      	cmp	r3, #1
20017942:	d010      	beq.n	20017966 <HAL_RCC_OscConfig+0x1fe>
20017944:	687b      	ldr	r3, [r7, #4]
20017946:	68db      	ldr	r3, [r3, #12]
20017948:	2b09      	cmp	r3, #9
2001794a:	d00c      	beq.n	20017966 <HAL_RCC_OscConfig+0x1fe>
2001794c:	687b      	ldr	r3, [r7, #4]
2001794e:	68db      	ldr	r3, [r3, #12]
20017950:	2b11      	cmp	r3, #17
20017952:	d008      	beq.n	20017966 <HAL_RCC_OscConfig+0x1fe>
20017954:	687b      	ldr	r3, [r7, #4]
20017956:	68db      	ldr	r3, [r3, #12]
20017958:	2b19      	cmp	r3, #25
2001795a:	d004      	beq.n	20017966 <HAL_RCC_OscConfig+0x1fe>
2001795c:	f240 11d7 	movw	r1, #471	; 0x1d7
20017960:	483c      	ldr	r0, [pc, #240]	; (20017a54 <HAL_RCC_OscConfig+0x2ec>)
20017962:	f7e8 ffc7 	bl	200008f4 <assert_failed>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
20017966:	687b      	ldr	r3, [r7, #4]
20017968:	691b      	ldr	r3, [r3, #16]
2001796a:	2b7f      	cmp	r3, #127	; 0x7f
2001796c:	d904      	bls.n	20017978 <HAL_RCC_OscConfig+0x210>
2001796e:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
20017972:	4838      	ldr	r0, [pc, #224]	; (20017a54 <HAL_RCC_OscConfig+0x2ec>)
20017974:	f7e8 ffbe 	bl	200008f4 <assert_failed>

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
20017978:	4b37      	ldr	r3, [pc, #220]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
2001797a:	691b      	ldr	r3, [r3, #16]
2001797c:	f003 0338 	and.w	r3, r3, #56	; 0x38
20017980:	623b      	str	r3, [r7, #32]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
20017982:	4b35      	ldr	r3, [pc, #212]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017984:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20017986:	61fb      	str	r3, [r7, #28]
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
20017988:	6a3b      	ldr	r3, [r7, #32]
2001798a:	2b00      	cmp	r3, #0
2001798c:	d007      	beq.n	2001799e <HAL_RCC_OscConfig+0x236>
2001798e:	6a3b      	ldr	r3, [r7, #32]
20017990:	2b18      	cmp	r3, #24
20017992:	d12d      	bne.n	200179f0 <HAL_RCC_OscConfig+0x288>
20017994:	69fb      	ldr	r3, [r7, #28]
20017996:	f003 0303 	and.w	r3, r3, #3
2001799a:	2b00      	cmp	r3, #0
2001799c:	d128      	bne.n	200179f0 <HAL_RCC_OscConfig+0x288>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
2001799e:	4b2e      	ldr	r3, [pc, #184]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200179a0:	681b      	ldr	r3, [r3, #0]
200179a2:	f003 0304 	and.w	r3, r3, #4
200179a6:	2b00      	cmp	r3, #0
200179a8:	d005      	beq.n	200179b6 <HAL_RCC_OscConfig+0x24e>
200179aa:	687b      	ldr	r3, [r7, #4]
200179ac:	68db      	ldr	r3, [r3, #12]
200179ae:	2b00      	cmp	r3, #0
200179b0:	d101      	bne.n	200179b6 <HAL_RCC_OscConfig+0x24e>
      {
        return HAL_ERROR;
200179b2:	2301      	movs	r3, #1
200179b4:	e3cb      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
200179b6:	f7ea fa41 	bl	20001e3c <HAL_GetREVID>
200179ba:	4602      	mov	r2, r0
200179bc:	f241 0303 	movw	r3, #4099	; 0x1003
200179c0:	429a      	cmp	r2, r3
200179c2:	d80a      	bhi.n	200179da <HAL_RCC_OscConfig+0x272>
200179c4:	4b24      	ldr	r3, [pc, #144]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200179c6:	685b      	ldr	r3, [r3, #4]
200179c8:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
200179cc:	687b      	ldr	r3, [r7, #4]
200179ce:	691b      	ldr	r3, [r3, #16]
200179d0:	031b      	lsls	r3, r3, #12
200179d2:	4921      	ldr	r1, [pc, #132]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200179d4:	4313      	orrs	r3, r2
200179d6:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
200179d8:	e064      	b.n	20017aa4 <HAL_RCC_OscConfig+0x33c>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
200179da:	4b1f      	ldr	r3, [pc, #124]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200179dc:	685b      	ldr	r3, [r3, #4]
200179de:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
200179e2:	687b      	ldr	r3, [r7, #4]
200179e4:	691b      	ldr	r3, [r3, #16]
200179e6:	061b      	lsls	r3, r3, #24
200179e8:	491b      	ldr	r1, [pc, #108]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200179ea:	4313      	orrs	r3, r2
200179ec:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
200179ee:	e059      	b.n	20017aa4 <HAL_RCC_OscConfig+0x33c>
    }

    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
200179f0:	687b      	ldr	r3, [r7, #4]
200179f2:	68db      	ldr	r3, [r3, #12]
200179f4:	2b00      	cmp	r3, #0
200179f6:	d03c      	beq.n	20017a72 <HAL_RCC_OscConfig+0x30a>
      {
     /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
200179f8:	4b17      	ldr	r3, [pc, #92]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
200179fa:	681b      	ldr	r3, [r3, #0]
200179fc:	f023 0219 	bic.w	r2, r3, #25
20017a00:	687b      	ldr	r3, [r7, #4]
20017a02:	68db      	ldr	r3, [r3, #12]
20017a04:	4914      	ldr	r1, [pc, #80]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017a06:	4313      	orrs	r3, r2
20017a08:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20017a0a:	f7ea f96f 	bl	20001cec <HAL_GetTick>
20017a0e:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
20017a10:	e008      	b.n	20017a24 <HAL_RCC_OscConfig+0x2bc>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
20017a12:	f7ea f96b 	bl	20001cec <HAL_GetTick>
20017a16:	4602      	mov	r2, r0
20017a18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017a1a:	1ad3      	subs	r3, r2, r3
20017a1c:	2b02      	cmp	r3, #2
20017a1e:	d901      	bls.n	20017a24 <HAL_RCC_OscConfig+0x2bc>
          {
            return HAL_TIMEOUT;
20017a20:	2303      	movs	r3, #3
20017a22:	e394      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
20017a24:	4b0c      	ldr	r3, [pc, #48]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017a26:	681b      	ldr	r3, [r3, #0]
20017a28:	f003 0304 	and.w	r3, r3, #4
20017a2c:	2b00      	cmp	r3, #0
20017a2e:	d0f0      	beq.n	20017a12 <HAL_RCC_OscConfig+0x2aa>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
20017a30:	f7ea fa04 	bl	20001e3c <HAL_GetREVID>
20017a34:	4602      	mov	r2, r0
20017a36:	f241 0303 	movw	r3, #4099	; 0x1003
20017a3a:	429a      	cmp	r2, r3
20017a3c:	d80e      	bhi.n	20017a5c <HAL_RCC_OscConfig+0x2f4>
20017a3e:	4b06      	ldr	r3, [pc, #24]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017a40:	685b      	ldr	r3, [r3, #4]
20017a42:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
20017a46:	687b      	ldr	r3, [r7, #4]
20017a48:	691b      	ldr	r3, [r3, #16]
20017a4a:	031b      	lsls	r3, r3, #12
20017a4c:	4902      	ldr	r1, [pc, #8]	; (20017a58 <HAL_RCC_OscConfig+0x2f0>)
20017a4e:	4313      	orrs	r3, r2
20017a50:	604b      	str	r3, [r1, #4]
20017a52:	e027      	b.n	20017aa4 <HAL_RCC_OscConfig+0x33c>
20017a54:	2001c2e0 	.word	0x2001c2e0
20017a58:	58024400 	.word	0x58024400
20017a5c:	4ba5      	ldr	r3, [pc, #660]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017a5e:	685b      	ldr	r3, [r3, #4]
20017a60:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
20017a64:	687b      	ldr	r3, [r7, #4]
20017a66:	691b      	ldr	r3, [r3, #16]
20017a68:	061b      	lsls	r3, r3, #24
20017a6a:	49a2      	ldr	r1, [pc, #648]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017a6c:	4313      	orrs	r3, r2
20017a6e:	604b      	str	r3, [r1, #4]
20017a70:	e018      	b.n	20017aa4 <HAL_RCC_OscConfig+0x33c>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
20017a72:	4ba0      	ldr	r3, [pc, #640]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017a74:	681b      	ldr	r3, [r3, #0]
20017a76:	4a9f      	ldr	r2, [pc, #636]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017a78:	f023 0301 	bic.w	r3, r3, #1
20017a7c:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20017a7e:	f7ea f935 	bl	20001cec <HAL_GetTick>
20017a82:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
20017a84:	e008      	b.n	20017a98 <HAL_RCC_OscConfig+0x330>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
20017a86:	f7ea f931 	bl	20001cec <HAL_GetTick>
20017a8a:	4602      	mov	r2, r0
20017a8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017a8e:	1ad3      	subs	r3, r2, r3
20017a90:	2b02      	cmp	r3, #2
20017a92:	d901      	bls.n	20017a98 <HAL_RCC_OscConfig+0x330>
          {
            return HAL_TIMEOUT;
20017a94:	2303      	movs	r3, #3
20017a96:	e35a      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
20017a98:	4b96      	ldr	r3, [pc, #600]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017a9a:	681b      	ldr	r3, [r3, #0]
20017a9c:	f003 0304 	and.w	r3, r3, #4
20017aa0:	2b00      	cmp	r3, #0
20017aa2:	d1f0      	bne.n	20017a86 <HAL_RCC_OscConfig+0x31e>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
20017aa4:	687b      	ldr	r3, [r7, #4]
20017aa6:	681b      	ldr	r3, [r3, #0]
20017aa8:	f003 0310 	and.w	r3, r3, #16
20017aac:	2b00      	cmp	r3, #0
20017aae:	f000 80a5 	beq.w	20017bfc <HAL_RCC_OscConfig+0x494>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
20017ab2:	687b      	ldr	r3, [r7, #4]
20017ab4:	69db      	ldr	r3, [r3, #28]
20017ab6:	2b00      	cmp	r3, #0
20017ab8:	d008      	beq.n	20017acc <HAL_RCC_OscConfig+0x364>
20017aba:	687b      	ldr	r3, [r7, #4]
20017abc:	69db      	ldr	r3, [r3, #28]
20017abe:	2b80      	cmp	r3, #128	; 0x80
20017ac0:	d004      	beq.n	20017acc <HAL_RCC_OscConfig+0x364>
20017ac2:	f240 211a 	movw	r1, #538	; 0x21a
20017ac6:	488c      	ldr	r0, [pc, #560]	; (20017cf8 <HAL_RCC_OscConfig+0x590>)
20017ac8:	f7e8 ff14 	bl	200008f4 <assert_failed>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
20017acc:	687b      	ldr	r3, [r7, #4]
20017ace:	6a1b      	ldr	r3, [r3, #32]
20017ad0:	2b3f      	cmp	r3, #63	; 0x3f
20017ad2:	d904      	bls.n	20017ade <HAL_RCC_OscConfig+0x376>
20017ad4:	f240 211b 	movw	r1, #539	; 0x21b
20017ad8:	4887      	ldr	r0, [pc, #540]	; (20017cf8 <HAL_RCC_OscConfig+0x590>)
20017ada:	f7e8 ff0b 	bl	200008f4 <assert_failed>

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
20017ade:	4b85      	ldr	r3, [pc, #532]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017ae0:	691b      	ldr	r3, [r3, #16]
20017ae2:	f003 0338 	and.w	r3, r3, #56	; 0x38
20017ae6:	61bb      	str	r3, [r7, #24]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
20017ae8:	4b82      	ldr	r3, [pc, #520]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017aea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20017aec:	617b      	str	r3, [r7, #20]
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
20017aee:	69bb      	ldr	r3, [r7, #24]
20017af0:	2b08      	cmp	r3, #8
20017af2:	d007      	beq.n	20017b04 <HAL_RCC_OscConfig+0x39c>
20017af4:	69bb      	ldr	r3, [r7, #24]
20017af6:	2b18      	cmp	r3, #24
20017af8:	d12d      	bne.n	20017b56 <HAL_RCC_OscConfig+0x3ee>
20017afa:	697b      	ldr	r3, [r7, #20]
20017afc:	f003 0303 	and.w	r3, r3, #3
20017b00:	2b01      	cmp	r3, #1
20017b02:	d128      	bne.n	20017b56 <HAL_RCC_OscConfig+0x3ee>
    {
      /* When CSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
20017b04:	4b7b      	ldr	r3, [pc, #492]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017b06:	681b      	ldr	r3, [r3, #0]
20017b08:	f403 7380 	and.w	r3, r3, #256	; 0x100
20017b0c:	2b00      	cmp	r3, #0
20017b0e:	d005      	beq.n	20017b1c <HAL_RCC_OscConfig+0x3b4>
20017b10:	687b      	ldr	r3, [r7, #4]
20017b12:	69db      	ldr	r3, [r3, #28]
20017b14:	2b80      	cmp	r3, #128	; 0x80
20017b16:	d001      	beq.n	20017b1c <HAL_RCC_OscConfig+0x3b4>
      {
        return HAL_ERROR;
20017b18:	2301      	movs	r3, #1
20017b1a:	e318      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
20017b1c:	f7ea f98e 	bl	20001e3c <HAL_GetREVID>
20017b20:	4602      	mov	r2, r0
20017b22:	f241 0303 	movw	r3, #4099	; 0x1003
20017b26:	429a      	cmp	r2, r3
20017b28:	d80a      	bhi.n	20017b40 <HAL_RCC_OscConfig+0x3d8>
20017b2a:	4b72      	ldr	r3, [pc, #456]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017b2c:	685b      	ldr	r3, [r3, #4]
20017b2e:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
20017b32:	687b      	ldr	r3, [r7, #4]
20017b34:	6a1b      	ldr	r3, [r3, #32]
20017b36:	069b      	lsls	r3, r3, #26
20017b38:	496e      	ldr	r1, [pc, #440]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017b3a:	4313      	orrs	r3, r2
20017b3c:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
20017b3e:	e05d      	b.n	20017bfc <HAL_RCC_OscConfig+0x494>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
20017b40:	4b6c      	ldr	r3, [pc, #432]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017b42:	68db      	ldr	r3, [r3, #12]
20017b44:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
20017b48:	687b      	ldr	r3, [r7, #4]
20017b4a:	6a1b      	ldr	r3, [r3, #32]
20017b4c:	061b      	lsls	r3, r3, #24
20017b4e:	4969      	ldr	r1, [pc, #420]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017b50:	4313      	orrs	r3, r2
20017b52:	60cb      	str	r3, [r1, #12]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
20017b54:	e052      	b.n	20017bfc <HAL_RCC_OscConfig+0x494>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
20017b56:	687b      	ldr	r3, [r7, #4]
20017b58:	69db      	ldr	r3, [r3, #28]
20017b5a:	2b00      	cmp	r3, #0
20017b5c:	d035      	beq.n	20017bca <HAL_RCC_OscConfig+0x462>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
20017b5e:	4b65      	ldr	r3, [pc, #404]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017b60:	681b      	ldr	r3, [r3, #0]
20017b62:	4a64      	ldr	r2, [pc, #400]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017b64:	f043 0380 	orr.w	r3, r3, #128	; 0x80
20017b68:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20017b6a:	f7ea f8bf 	bl	20001cec <HAL_GetTick>
20017b6e:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
20017b70:	e008      	b.n	20017b84 <HAL_RCC_OscConfig+0x41c>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
20017b72:	f7ea f8bb 	bl	20001cec <HAL_GetTick>
20017b76:	4602      	mov	r2, r0
20017b78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017b7a:	1ad3      	subs	r3, r2, r3
20017b7c:	2b02      	cmp	r3, #2
20017b7e:	d901      	bls.n	20017b84 <HAL_RCC_OscConfig+0x41c>
          {
            return HAL_TIMEOUT;
20017b80:	2303      	movs	r3, #3
20017b82:	e2e4      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
20017b84:	4b5b      	ldr	r3, [pc, #364]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017b86:	681b      	ldr	r3, [r3, #0]
20017b88:	f403 7380 	and.w	r3, r3, #256	; 0x100
20017b8c:	2b00      	cmp	r3, #0
20017b8e:	d0f0      	beq.n	20017b72 <HAL_RCC_OscConfig+0x40a>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
20017b90:	f7ea f954 	bl	20001e3c <HAL_GetREVID>
20017b94:	4602      	mov	r2, r0
20017b96:	f241 0303 	movw	r3, #4099	; 0x1003
20017b9a:	429a      	cmp	r2, r3
20017b9c:	d80a      	bhi.n	20017bb4 <HAL_RCC_OscConfig+0x44c>
20017b9e:	4b55      	ldr	r3, [pc, #340]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017ba0:	685b      	ldr	r3, [r3, #4]
20017ba2:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
20017ba6:	687b      	ldr	r3, [r7, #4]
20017ba8:	6a1b      	ldr	r3, [r3, #32]
20017baa:	069b      	lsls	r3, r3, #26
20017bac:	4951      	ldr	r1, [pc, #324]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017bae:	4313      	orrs	r3, r2
20017bb0:	604b      	str	r3, [r1, #4]
20017bb2:	e023      	b.n	20017bfc <HAL_RCC_OscConfig+0x494>
20017bb4:	4b4f      	ldr	r3, [pc, #316]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017bb6:	68db      	ldr	r3, [r3, #12]
20017bb8:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
20017bbc:	687b      	ldr	r3, [r7, #4]
20017bbe:	6a1b      	ldr	r3, [r3, #32]
20017bc0:	061b      	lsls	r3, r3, #24
20017bc2:	494c      	ldr	r1, [pc, #304]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017bc4:	4313      	orrs	r3, r2
20017bc6:	60cb      	str	r3, [r1, #12]
20017bc8:	e018      	b.n	20017bfc <HAL_RCC_OscConfig+0x494>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
20017bca:	4b4a      	ldr	r3, [pc, #296]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017bcc:	681b      	ldr	r3, [r3, #0]
20017bce:	4a49      	ldr	r2, [pc, #292]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017bd0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
20017bd4:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20017bd6:	f7ea f889 	bl	20001cec <HAL_GetTick>
20017bda:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
20017bdc:	e008      	b.n	20017bf0 <HAL_RCC_OscConfig+0x488>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
20017bde:	f7ea f885 	bl	20001cec <HAL_GetTick>
20017be2:	4602      	mov	r2, r0
20017be4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017be6:	1ad3      	subs	r3, r2, r3
20017be8:	2b02      	cmp	r3, #2
20017bea:	d901      	bls.n	20017bf0 <HAL_RCC_OscConfig+0x488>
          {
            return HAL_TIMEOUT;
20017bec:	2303      	movs	r3, #3
20017bee:	e2ae      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
20017bf0:	4b40      	ldr	r3, [pc, #256]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017bf2:	681b      	ldr	r3, [r3, #0]
20017bf4:	f403 7380 	and.w	r3, r3, #256	; 0x100
20017bf8:	2b00      	cmp	r3, #0
20017bfa:	d1f0      	bne.n	20017bde <HAL_RCC_OscConfig+0x476>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
20017bfc:	687b      	ldr	r3, [r7, #4]
20017bfe:	681b      	ldr	r3, [r3, #0]
20017c00:	f003 0308 	and.w	r3, r3, #8
20017c04:	2b00      	cmp	r3, #0
20017c06:	d043      	beq.n	20017c90 <HAL_RCC_OscConfig+0x528>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
20017c08:	687b      	ldr	r3, [r7, #4]
20017c0a:	695b      	ldr	r3, [r3, #20]
20017c0c:	2b00      	cmp	r3, #0
20017c0e:	d008      	beq.n	20017c22 <HAL_RCC_OscConfig+0x4ba>
20017c10:	687b      	ldr	r3, [r7, #4]
20017c12:	695b      	ldr	r3, [r3, #20]
20017c14:	2b01      	cmp	r3, #1
20017c16:	d004      	beq.n	20017c22 <HAL_RCC_OscConfig+0x4ba>
20017c18:	f44f 7117 	mov.w	r1, #604	; 0x25c
20017c1c:	4836      	ldr	r0, [pc, #216]	; (20017cf8 <HAL_RCC_OscConfig+0x590>)
20017c1e:	f7e8 fe69 	bl	200008f4 <assert_failed>

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
20017c22:	687b      	ldr	r3, [r7, #4]
20017c24:	695b      	ldr	r3, [r3, #20]
20017c26:	2b00      	cmp	r3, #0
20017c28:	d019      	beq.n	20017c5e <HAL_RCC_OscConfig+0x4f6>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
20017c2a:	4b32      	ldr	r3, [pc, #200]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017c2c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20017c2e:	4a31      	ldr	r2, [pc, #196]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017c30:	f043 0301 	orr.w	r3, r3, #1
20017c34:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20017c36:	f7ea f859 	bl	20001cec <HAL_GetTick>
20017c3a:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
20017c3c:	e008      	b.n	20017c50 <HAL_RCC_OscConfig+0x4e8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
20017c3e:	f7ea f855 	bl	20001cec <HAL_GetTick>
20017c42:	4602      	mov	r2, r0
20017c44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017c46:	1ad3      	subs	r3, r2, r3
20017c48:	2b02      	cmp	r3, #2
20017c4a:	d901      	bls.n	20017c50 <HAL_RCC_OscConfig+0x4e8>
        {
          return HAL_TIMEOUT;
20017c4c:	2303      	movs	r3, #3
20017c4e:	e27e      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
20017c50:	4b28      	ldr	r3, [pc, #160]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017c52:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20017c54:	f003 0302 	and.w	r3, r3, #2
20017c58:	2b00      	cmp	r3, #0
20017c5a:	d0f0      	beq.n	20017c3e <HAL_RCC_OscConfig+0x4d6>
20017c5c:	e018      	b.n	20017c90 <HAL_RCC_OscConfig+0x528>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
20017c5e:	4b25      	ldr	r3, [pc, #148]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017c60:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20017c62:	4a24      	ldr	r2, [pc, #144]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017c64:	f023 0301 	bic.w	r3, r3, #1
20017c68:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20017c6a:	f7ea f83f 	bl	20001cec <HAL_GetTick>
20017c6e:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
20017c70:	e008      	b.n	20017c84 <HAL_RCC_OscConfig+0x51c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
20017c72:	f7ea f83b 	bl	20001cec <HAL_GetTick>
20017c76:	4602      	mov	r2, r0
20017c78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017c7a:	1ad3      	subs	r3, r2, r3
20017c7c:	2b02      	cmp	r3, #2
20017c7e:	d901      	bls.n	20017c84 <HAL_RCC_OscConfig+0x51c>
        {
          return HAL_TIMEOUT;
20017c80:	2303      	movs	r3, #3
20017c82:	e264      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
20017c84:	4b1b      	ldr	r3, [pc, #108]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017c86:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20017c88:	f003 0302 	and.w	r3, r3, #2
20017c8c:	2b00      	cmp	r3, #0
20017c8e:	d1f0      	bne.n	20017c72 <HAL_RCC_OscConfig+0x50a>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
20017c90:	687b      	ldr	r3, [r7, #4]
20017c92:	681b      	ldr	r3, [r3, #0]
20017c94:	f003 0320 	and.w	r3, r3, #32
20017c98:	2b00      	cmp	r3, #0
20017c9a:	d048      	beq.n	20017d2e <HAL_RCC_OscConfig+0x5c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
20017c9c:	687b      	ldr	r3, [r7, #4]
20017c9e:	699b      	ldr	r3, [r3, #24]
20017ca0:	2b00      	cmp	r3, #0
20017ca2:	d008      	beq.n	20017cb6 <HAL_RCC_OscConfig+0x54e>
20017ca4:	687b      	ldr	r3, [r7, #4]
20017ca6:	699b      	ldr	r3, [r3, #24]
20017ca8:	2b01      	cmp	r3, #1
20017caa:	d004      	beq.n	20017cb6 <HAL_RCC_OscConfig+0x54e>
20017cac:	f240 2187 	movw	r1, #647	; 0x287
20017cb0:	4811      	ldr	r0, [pc, #68]	; (20017cf8 <HAL_RCC_OscConfig+0x590>)
20017cb2:	f7e8 fe1f 	bl	200008f4 <assert_failed>

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
20017cb6:	687b      	ldr	r3, [r7, #4]
20017cb8:	699b      	ldr	r3, [r3, #24]
20017cba:	2b00      	cmp	r3, #0
20017cbc:	d01e      	beq.n	20017cfc <HAL_RCC_OscConfig+0x594>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
20017cbe:	4b0d      	ldr	r3, [pc, #52]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017cc0:	681b      	ldr	r3, [r3, #0]
20017cc2:	4a0c      	ldr	r2, [pc, #48]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017cc4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
20017cc8:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
20017cca:	f7ea f80f 	bl	20001cec <HAL_GetTick>
20017cce:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
20017cd0:	e008      	b.n	20017ce4 <HAL_RCC_OscConfig+0x57c>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
20017cd2:	f7ea f80b 	bl	20001cec <HAL_GetTick>
20017cd6:	4602      	mov	r2, r0
20017cd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017cda:	1ad3      	subs	r3, r2, r3
20017cdc:	2b02      	cmp	r3, #2
20017cde:	d901      	bls.n	20017ce4 <HAL_RCC_OscConfig+0x57c>
        {
          return HAL_TIMEOUT;
20017ce0:	2303      	movs	r3, #3
20017ce2:	e234      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
20017ce4:	4b03      	ldr	r3, [pc, #12]	; (20017cf4 <HAL_RCC_OscConfig+0x58c>)
20017ce6:	681b      	ldr	r3, [r3, #0]
20017ce8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
20017cec:	2b00      	cmp	r3, #0
20017cee:	d0f0      	beq.n	20017cd2 <HAL_RCC_OscConfig+0x56a>
20017cf0:	e01d      	b.n	20017d2e <HAL_RCC_OscConfig+0x5c6>
20017cf2:	bf00      	nop
20017cf4:	58024400 	.word	0x58024400
20017cf8:	2001c2e0 	.word	0x2001c2e0
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
20017cfc:	4ba3      	ldr	r3, [pc, #652]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017cfe:	681b      	ldr	r3, [r3, #0]
20017d00:	4aa2      	ldr	r2, [pc, #648]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017d02:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
20017d06:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
20017d08:	f7e9 fff0 	bl	20001cec <HAL_GetTick>
20017d0c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
20017d0e:	e008      	b.n	20017d22 <HAL_RCC_OscConfig+0x5ba>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
20017d10:	f7e9 ffec 	bl	20001cec <HAL_GetTick>
20017d14:	4602      	mov	r2, r0
20017d16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017d18:	1ad3      	subs	r3, r2, r3
20017d1a:	2b02      	cmp	r3, #2
20017d1c:	d901      	bls.n	20017d22 <HAL_RCC_OscConfig+0x5ba>
        {
          return HAL_TIMEOUT;
20017d1e:	2303      	movs	r3, #3
20017d20:	e215      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
20017d22:	4b9a      	ldr	r3, [pc, #616]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017d24:	681b      	ldr	r3, [r3, #0]
20017d26:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
20017d2a:	2b00      	cmp	r3, #0
20017d2c:	d1f0      	bne.n	20017d10 <HAL_RCC_OscConfig+0x5a8>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
20017d2e:	687b      	ldr	r3, [r7, #4]
20017d30:	681b      	ldr	r3, [r3, #0]
20017d32:	f003 0304 	and.w	r3, r3, #4
20017d36:	2b00      	cmp	r3, #0
20017d38:	f000 8092 	beq.w	20017e60 <HAL_RCC_OscConfig+0x6f8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
20017d3c:	687b      	ldr	r3, [r7, #4]
20017d3e:	689b      	ldr	r3, [r3, #8]
20017d40:	2b00      	cmp	r3, #0
20017d42:	d00c      	beq.n	20017d5e <HAL_RCC_OscConfig+0x5f6>
20017d44:	687b      	ldr	r3, [r7, #4]
20017d46:	689b      	ldr	r3, [r3, #8]
20017d48:	2b01      	cmp	r3, #1
20017d4a:	d008      	beq.n	20017d5e <HAL_RCC_OscConfig+0x5f6>
20017d4c:	687b      	ldr	r3, [r7, #4]
20017d4e:	689b      	ldr	r3, [r3, #8]
20017d50:	2b05      	cmp	r3, #5
20017d52:	d004      	beq.n	20017d5e <HAL_RCC_OscConfig+0x5f6>
20017d54:	f240 21b1 	movw	r1, #689	; 0x2b1
20017d58:	488d      	ldr	r0, [pc, #564]	; (20017f90 <HAL_RCC_OscConfig+0x828>)
20017d5a:	f7e8 fdcb 	bl	200008f4 <assert_failed>

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
20017d5e:	4b8d      	ldr	r3, [pc, #564]	; (20017f94 <HAL_RCC_OscConfig+0x82c>)
20017d60:	681b      	ldr	r3, [r3, #0]
20017d62:	4a8c      	ldr	r2, [pc, #560]	; (20017f94 <HAL_RCC_OscConfig+0x82c>)
20017d64:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20017d68:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
20017d6a:	f7e9 ffbf 	bl	20001cec <HAL_GetTick>
20017d6e:	6278      	str	r0, [r7, #36]	; 0x24

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
20017d70:	e008      	b.n	20017d84 <HAL_RCC_OscConfig+0x61c>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
20017d72:	f7e9 ffbb 	bl	20001cec <HAL_GetTick>
20017d76:	4602      	mov	r2, r0
20017d78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017d7a:	1ad3      	subs	r3, r2, r3
20017d7c:	2b64      	cmp	r3, #100	; 0x64
20017d7e:	d901      	bls.n	20017d84 <HAL_RCC_OscConfig+0x61c>
      {
        return HAL_TIMEOUT;
20017d80:	2303      	movs	r3, #3
20017d82:	e1e4      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
20017d84:	4b83      	ldr	r3, [pc, #524]	; (20017f94 <HAL_RCC_OscConfig+0x82c>)
20017d86:	681b      	ldr	r3, [r3, #0]
20017d88:	f403 7380 	and.w	r3, r3, #256	; 0x100
20017d8c:	2b00      	cmp	r3, #0
20017d8e:	d0f0      	beq.n	20017d72 <HAL_RCC_OscConfig+0x60a>
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
20017d90:	687b      	ldr	r3, [r7, #4]
20017d92:	689b      	ldr	r3, [r3, #8]
20017d94:	2b01      	cmp	r3, #1
20017d96:	d106      	bne.n	20017da6 <HAL_RCC_OscConfig+0x63e>
20017d98:	4b7c      	ldr	r3, [pc, #496]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017d9a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20017d9c:	4a7b      	ldr	r2, [pc, #492]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017d9e:	f043 0301 	orr.w	r3, r3, #1
20017da2:	6713      	str	r3, [r2, #112]	; 0x70
20017da4:	e02d      	b.n	20017e02 <HAL_RCC_OscConfig+0x69a>
20017da6:	687b      	ldr	r3, [r7, #4]
20017da8:	689b      	ldr	r3, [r3, #8]
20017daa:	2b00      	cmp	r3, #0
20017dac:	d10c      	bne.n	20017dc8 <HAL_RCC_OscConfig+0x660>
20017dae:	4b77      	ldr	r3, [pc, #476]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017db0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20017db2:	4a76      	ldr	r2, [pc, #472]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017db4:	f023 0301 	bic.w	r3, r3, #1
20017db8:	6713      	str	r3, [r2, #112]	; 0x70
20017dba:	4b74      	ldr	r3, [pc, #464]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017dbc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20017dbe:	4a73      	ldr	r2, [pc, #460]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017dc0:	f023 0304 	bic.w	r3, r3, #4
20017dc4:	6713      	str	r3, [r2, #112]	; 0x70
20017dc6:	e01c      	b.n	20017e02 <HAL_RCC_OscConfig+0x69a>
20017dc8:	687b      	ldr	r3, [r7, #4]
20017dca:	689b      	ldr	r3, [r3, #8]
20017dcc:	2b05      	cmp	r3, #5
20017dce:	d10c      	bne.n	20017dea <HAL_RCC_OscConfig+0x682>
20017dd0:	4b6e      	ldr	r3, [pc, #440]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017dd2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20017dd4:	4a6d      	ldr	r2, [pc, #436]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017dd6:	f043 0304 	orr.w	r3, r3, #4
20017dda:	6713      	str	r3, [r2, #112]	; 0x70
20017ddc:	4b6b      	ldr	r3, [pc, #428]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017dde:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20017de0:	4a6a      	ldr	r2, [pc, #424]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017de2:	f043 0301 	orr.w	r3, r3, #1
20017de6:	6713      	str	r3, [r2, #112]	; 0x70
20017de8:	e00b      	b.n	20017e02 <HAL_RCC_OscConfig+0x69a>
20017dea:	4b68      	ldr	r3, [pc, #416]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017dec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20017dee:	4a67      	ldr	r2, [pc, #412]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017df0:	f023 0301 	bic.w	r3, r3, #1
20017df4:	6713      	str	r3, [r2, #112]	; 0x70
20017df6:	4b65      	ldr	r3, [pc, #404]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017df8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20017dfa:	4a64      	ldr	r2, [pc, #400]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017dfc:	f023 0304 	bic.w	r3, r3, #4
20017e00:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
20017e02:	687b      	ldr	r3, [r7, #4]
20017e04:	689b      	ldr	r3, [r3, #8]
20017e06:	2b00      	cmp	r3, #0
20017e08:	d015      	beq.n	20017e36 <HAL_RCC_OscConfig+0x6ce>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20017e0a:	f7e9 ff6f 	bl	20001cec <HAL_GetTick>
20017e0e:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
20017e10:	e00a      	b.n	20017e28 <HAL_RCC_OscConfig+0x6c0>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
20017e12:	f7e9 ff6b 	bl	20001cec <HAL_GetTick>
20017e16:	4602      	mov	r2, r0
20017e18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017e1a:	1ad3      	subs	r3, r2, r3
20017e1c:	f241 3288 	movw	r2, #5000	; 0x1388
20017e20:	4293      	cmp	r3, r2
20017e22:	d901      	bls.n	20017e28 <HAL_RCC_OscConfig+0x6c0>
        {
          return HAL_TIMEOUT;
20017e24:	2303      	movs	r3, #3
20017e26:	e192      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
20017e28:	4b58      	ldr	r3, [pc, #352]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017e2a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20017e2c:	f003 0302 	and.w	r3, r3, #2
20017e30:	2b00      	cmp	r3, #0
20017e32:	d0ee      	beq.n	20017e12 <HAL_RCC_OscConfig+0x6aa>
20017e34:	e014      	b.n	20017e60 <HAL_RCC_OscConfig+0x6f8>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20017e36:	f7e9 ff59 	bl	20001cec <HAL_GetTick>
20017e3a:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
20017e3c:	e00a      	b.n	20017e54 <HAL_RCC_OscConfig+0x6ec>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
20017e3e:	f7e9 ff55 	bl	20001cec <HAL_GetTick>
20017e42:	4602      	mov	r2, r0
20017e44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017e46:	1ad3      	subs	r3, r2, r3
20017e48:	f241 3288 	movw	r2, #5000	; 0x1388
20017e4c:	4293      	cmp	r3, r2
20017e4e:	d901      	bls.n	20017e54 <HAL_RCC_OscConfig+0x6ec>
        {
          return HAL_TIMEOUT;
20017e50:	2303      	movs	r3, #3
20017e52:	e17c      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
20017e54:	4b4d      	ldr	r3, [pc, #308]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017e56:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20017e58:	f003 0302 	and.w	r3, r3, #2
20017e5c:	2b00      	cmp	r3, #0
20017e5e:	d1ee      	bne.n	20017e3e <HAL_RCC_OscConfig+0x6d6>
      }
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
20017e60:	687b      	ldr	r3, [r7, #4]
20017e62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20017e64:	2b00      	cmp	r3, #0
20017e66:	d00c      	beq.n	20017e82 <HAL_RCC_OscConfig+0x71a>
20017e68:	687b      	ldr	r3, [r7, #4]
20017e6a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20017e6c:	2b01      	cmp	r3, #1
20017e6e:	d008      	beq.n	20017e82 <HAL_RCC_OscConfig+0x71a>
20017e70:	687b      	ldr	r3, [r7, #4]
20017e72:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20017e74:	2b02      	cmp	r3, #2
20017e76:	d004      	beq.n	20017e82 <HAL_RCC_OscConfig+0x71a>
20017e78:	f240 21e3 	movw	r1, #739	; 0x2e3
20017e7c:	4844      	ldr	r0, [pc, #272]	; (20017f90 <HAL_RCC_OscConfig+0x828>)
20017e7e:	f7e8 fd39 	bl	200008f4 <assert_failed>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
20017e82:	687b      	ldr	r3, [r7, #4]
20017e84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20017e86:	2b00      	cmp	r3, #0
20017e88:	f000 8160 	beq.w	2001814c <HAL_RCC_OscConfig+0x9e4>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
20017e8c:	4b3f      	ldr	r3, [pc, #252]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017e8e:	691b      	ldr	r3, [r3, #16]
20017e90:	f003 0338 	and.w	r3, r3, #56	; 0x38
20017e94:	2b18      	cmp	r3, #24
20017e96:	f000 811b 	beq.w	200180d0 <HAL_RCC_OscConfig+0x968>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
20017e9a:	687b      	ldr	r3, [r7, #4]
20017e9c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20017e9e:	2b02      	cmp	r3, #2
20017ea0:	f040 80fc 	bne.w	2001809c <HAL_RCC_OscConfig+0x934>
      {
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
20017ea4:	687b      	ldr	r3, [r7, #4]
20017ea6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20017ea8:	2b01      	cmp	r3, #1
20017eaa:	d010      	beq.n	20017ece <HAL_RCC_OscConfig+0x766>
20017eac:	687b      	ldr	r3, [r7, #4]
20017eae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20017eb0:	2b00      	cmp	r3, #0
20017eb2:	d00c      	beq.n	20017ece <HAL_RCC_OscConfig+0x766>
20017eb4:	687b      	ldr	r3, [r7, #4]
20017eb6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20017eb8:	2b03      	cmp	r3, #3
20017eba:	d008      	beq.n	20017ece <HAL_RCC_OscConfig+0x766>
20017ebc:	687b      	ldr	r3, [r7, #4]
20017ebe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20017ec0:	2b02      	cmp	r3, #2
20017ec2:	d004      	beq.n	20017ece <HAL_RCC_OscConfig+0x766>
20017ec4:	f44f 713b 	mov.w	r1, #748	; 0x2ec
20017ec8:	4831      	ldr	r0, [pc, #196]	; (20017f90 <HAL_RCC_OscConfig+0x828>)
20017eca:	f7e8 fd13 	bl	200008f4 <assert_failed>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
20017ece:	687b      	ldr	r3, [r7, #4]
20017ed0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20017ed2:	2b00      	cmp	r3, #0
20017ed4:	d003      	beq.n	20017ede <HAL_RCC_OscConfig+0x776>
20017ed6:	687b      	ldr	r3, [r7, #4]
20017ed8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20017eda:	2b3f      	cmp	r3, #63	; 0x3f
20017edc:	d904      	bls.n	20017ee8 <HAL_RCC_OscConfig+0x780>
20017ede:	f240 21ed 	movw	r1, #749	; 0x2ed
20017ee2:	482b      	ldr	r0, [pc, #172]	; (20017f90 <HAL_RCC_OscConfig+0x828>)
20017ee4:	f7e8 fd06 	bl	200008f4 <assert_failed>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
20017ee8:	687b      	ldr	r3, [r7, #4]
20017eea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20017eec:	2b03      	cmp	r3, #3
20017eee:	d904      	bls.n	20017efa <HAL_RCC_OscConfig+0x792>
20017ef0:	687b      	ldr	r3, [r7, #4]
20017ef2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20017ef4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20017ef8:	d904      	bls.n	20017f04 <HAL_RCC_OscConfig+0x79c>
20017efa:	f240 21ee 	movw	r1, #750	; 0x2ee
20017efe:	4824      	ldr	r0, [pc, #144]	; (20017f90 <HAL_RCC_OscConfig+0x828>)
20017f00:	f7e8 fcf8 	bl	200008f4 <assert_failed>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
20017f04:	687b      	ldr	r3, [r7, #4]
20017f06:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20017f08:	2b00      	cmp	r3, #0
20017f0a:	d003      	beq.n	20017f14 <HAL_RCC_OscConfig+0x7ac>
20017f0c:	687b      	ldr	r3, [r7, #4]
20017f0e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20017f10:	2b80      	cmp	r3, #128	; 0x80
20017f12:	d904      	bls.n	20017f1e <HAL_RCC_OscConfig+0x7b6>
20017f14:	f240 21ef 	movw	r1, #751	; 0x2ef
20017f18:	481d      	ldr	r0, [pc, #116]	; (20017f90 <HAL_RCC_OscConfig+0x828>)
20017f1a:	f7e8 fceb 	bl	200008f4 <assert_failed>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
20017f1e:	687b      	ldr	r3, [r7, #4]
20017f20:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20017f22:	2b00      	cmp	r3, #0
20017f24:	d003      	beq.n	20017f2e <HAL_RCC_OscConfig+0x7c6>
20017f26:	687b      	ldr	r3, [r7, #4]
20017f28:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20017f2a:	2b80      	cmp	r3, #128	; 0x80
20017f2c:	d904      	bls.n	20017f38 <HAL_RCC_OscConfig+0x7d0>
20017f2e:	f44f 713c 	mov.w	r1, #752	; 0x2f0
20017f32:	4817      	ldr	r0, [pc, #92]	; (20017f90 <HAL_RCC_OscConfig+0x828>)
20017f34:	f7e8 fcde 	bl	200008f4 <assert_failed>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
20017f38:	687b      	ldr	r3, [r7, #4]
20017f3a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20017f3c:	2b00      	cmp	r3, #0
20017f3e:	d003      	beq.n	20017f48 <HAL_RCC_OscConfig+0x7e0>
20017f40:	687b      	ldr	r3, [r7, #4]
20017f42:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20017f44:	2b80      	cmp	r3, #128	; 0x80
20017f46:	d904      	bls.n	20017f52 <HAL_RCC_OscConfig+0x7ea>
20017f48:	f240 21f1 	movw	r1, #753	; 0x2f1
20017f4c:	4810      	ldr	r0, [pc, #64]	; (20017f90 <HAL_RCC_OscConfig+0x828>)
20017f4e:	f7e8 fcd1 	bl	200008f4 <assert_failed>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
20017f52:	687b      	ldr	r3, [r7, #4]
20017f54:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20017f56:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20017f5a:	d304      	bcc.n	20017f66 <HAL_RCC_OscConfig+0x7fe>
20017f5c:	f240 21f2 	movw	r1, #754	; 0x2f2
20017f60:	480b      	ldr	r0, [pc, #44]	; (20017f90 <HAL_RCC_OscConfig+0x828>)
20017f62:	f7e8 fcc7 	bl	200008f4 <assert_failed>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
20017f66:	4b09      	ldr	r3, [pc, #36]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017f68:	681b      	ldr	r3, [r3, #0]
20017f6a:	4a08      	ldr	r2, [pc, #32]	; (20017f8c <HAL_RCC_OscConfig+0x824>)
20017f6c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
20017f70:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20017f72:	f7e9 febb 	bl	20001cec <HAL_GetTick>
20017f76:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
20017f78:	e00e      	b.n	20017f98 <HAL_RCC_OscConfig+0x830>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
20017f7a:	f7e9 feb7 	bl	20001cec <HAL_GetTick>
20017f7e:	4602      	mov	r2, r0
20017f80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20017f82:	1ad3      	subs	r3, r2, r3
20017f84:	2b02      	cmp	r3, #2
20017f86:	d907      	bls.n	20017f98 <HAL_RCC_OscConfig+0x830>
          {
            return HAL_TIMEOUT;
20017f88:	2303      	movs	r3, #3
20017f8a:	e0e0      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
20017f8c:	58024400 	.word	0x58024400
20017f90:	2001c2e0 	.word	0x2001c2e0
20017f94:	58024800 	.word	0x58024800
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
20017f98:	4b6f      	ldr	r3, [pc, #444]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20017f9a:	681b      	ldr	r3, [r3, #0]
20017f9c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20017fa0:	2b00      	cmp	r3, #0
20017fa2:	d1ea      	bne.n	20017f7a <HAL_RCC_OscConfig+0x812>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
20017fa4:	4b6c      	ldr	r3, [pc, #432]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20017fa6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20017fa8:	4b6c      	ldr	r3, [pc, #432]	; (2001815c <HAL_RCC_OscConfig+0x9f4>)
20017faa:	4013      	ands	r3, r2
20017fac:	687a      	ldr	r2, [r7, #4]
20017fae:	6a91      	ldr	r1, [r2, #40]	; 0x28
20017fb0:	687a      	ldr	r2, [r7, #4]
20017fb2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20017fb4:	0112      	lsls	r2, r2, #4
20017fb6:	430a      	orrs	r2, r1
20017fb8:	4967      	ldr	r1, [pc, #412]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20017fba:	4313      	orrs	r3, r2
20017fbc:	628b      	str	r3, [r1, #40]	; 0x28
20017fbe:	687b      	ldr	r3, [r7, #4]
20017fc0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20017fc2:	3b01      	subs	r3, #1
20017fc4:	f3c3 0208 	ubfx	r2, r3, #0, #9
20017fc8:	687b      	ldr	r3, [r7, #4]
20017fca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20017fcc:	3b01      	subs	r3, #1
20017fce:	025b      	lsls	r3, r3, #9
20017fd0:	b29b      	uxth	r3, r3
20017fd2:	431a      	orrs	r2, r3
20017fd4:	687b      	ldr	r3, [r7, #4]
20017fd6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20017fd8:	3b01      	subs	r3, #1
20017fda:	041b      	lsls	r3, r3, #16
20017fdc:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
20017fe0:	431a      	orrs	r2, r3
20017fe2:	687b      	ldr	r3, [r7, #4]
20017fe4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20017fe6:	3b01      	subs	r3, #1
20017fe8:	061b      	lsls	r3, r3, #24
20017fea:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
20017fee:	495a      	ldr	r1, [pc, #360]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20017ff0:	4313      	orrs	r3, r2
20017ff2:	630b      	str	r3, [r1, #48]	; 0x30
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();
20017ff4:	4b58      	ldr	r3, [pc, #352]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20017ff6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20017ff8:	4a57      	ldr	r2, [pc, #348]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20017ffa:	f023 0301 	bic.w	r3, r3, #1
20017ffe:	62d3      	str	r3, [r2, #44]	; 0x2c

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
20018000:	4b55      	ldr	r3, [pc, #340]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018002:	6b5a      	ldr	r2, [r3, #52]	; 0x34
20018004:	4b56      	ldr	r3, [pc, #344]	; (20018160 <HAL_RCC_OscConfig+0x9f8>)
20018006:	4013      	ands	r3, r2
20018008:	687a      	ldr	r2, [r7, #4]
2001800a:	6c92      	ldr	r2, [r2, #72]	; 0x48
2001800c:	00d2      	lsls	r2, r2, #3
2001800e:	4952      	ldr	r1, [pc, #328]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018010:	4313      	orrs	r3, r2
20018012:	634b      	str	r3, [r1, #52]	; 0x34

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
20018014:	4b50      	ldr	r3, [pc, #320]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018016:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20018018:	f023 020c 	bic.w	r2, r3, #12
2001801c:	687b      	ldr	r3, [r7, #4]
2001801e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20018020:	494d      	ldr	r1, [pc, #308]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018022:	4313      	orrs	r3, r2
20018024:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
20018026:	4b4c      	ldr	r3, [pc, #304]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018028:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001802a:	f023 0202 	bic.w	r2, r3, #2
2001802e:	687b      	ldr	r3, [r7, #4]
20018030:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20018032:	4949      	ldr	r1, [pc, #292]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018034:	4313      	orrs	r3, r2
20018036:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
20018038:	4b47      	ldr	r3, [pc, #284]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
2001803a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001803c:	4a46      	ldr	r2, [pc, #280]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
2001803e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20018042:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1Q Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
20018044:	4b44      	ldr	r3, [pc, #272]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018046:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20018048:	4a43      	ldr	r2, [pc, #268]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
2001804a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2001804e:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1R  Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
20018050:	4b41      	ldr	r3, [pc, #260]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018052:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20018054:	4a40      	ldr	r2, [pc, #256]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018056:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
2001805a:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1FRACN . */
         __HAL_RCC_PLLFRACN_ENABLE();
2001805c:	4b3e      	ldr	r3, [pc, #248]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
2001805e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20018060:	4a3d      	ldr	r2, [pc, #244]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018062:	f043 0301 	orr.w	r3, r3, #1
20018066:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
20018068:	4b3b      	ldr	r3, [pc, #236]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
2001806a:	681b      	ldr	r3, [r3, #0]
2001806c:	4a3a      	ldr	r2, [pc, #232]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
2001806e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
20018072:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20018074:	f7e9 fe3a 	bl	20001cec <HAL_GetTick>
20018078:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
2001807a:	e008      	b.n	2001808e <HAL_RCC_OscConfig+0x926>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
2001807c:	f7e9 fe36 	bl	20001cec <HAL_GetTick>
20018080:	4602      	mov	r2, r0
20018082:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20018084:	1ad3      	subs	r3, r2, r3
20018086:	2b02      	cmp	r3, #2
20018088:	d901      	bls.n	2001808e <HAL_RCC_OscConfig+0x926>
          {
            return HAL_TIMEOUT;
2001808a:	2303      	movs	r3, #3
2001808c:	e05f      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
2001808e:	4b32      	ldr	r3, [pc, #200]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
20018090:	681b      	ldr	r3, [r3, #0]
20018092:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20018096:	2b00      	cmp	r3, #0
20018098:	d0f0      	beq.n	2001807c <HAL_RCC_OscConfig+0x914>
2001809a:	e057      	b.n	2001814c <HAL_RCC_OscConfig+0x9e4>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
2001809c:	4b2e      	ldr	r3, [pc, #184]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
2001809e:	681b      	ldr	r3, [r3, #0]
200180a0:	4a2d      	ldr	r2, [pc, #180]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
200180a2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
200180a6:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
200180a8:	f7e9 fe20 	bl	20001cec <HAL_GetTick>
200180ac:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
200180ae:	e008      	b.n	200180c2 <HAL_RCC_OscConfig+0x95a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
200180b0:	f7e9 fe1c 	bl	20001cec <HAL_GetTick>
200180b4:	4602      	mov	r2, r0
200180b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
200180b8:	1ad3      	subs	r3, r2, r3
200180ba:	2b02      	cmp	r3, #2
200180bc:	d901      	bls.n	200180c2 <HAL_RCC_OscConfig+0x95a>
          {
            return HAL_TIMEOUT;
200180be:	2303      	movs	r3, #3
200180c0:	e045      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
200180c2:	4b25      	ldr	r3, [pc, #148]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
200180c4:	681b      	ldr	r3, [r3, #0]
200180c6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
200180ca:	2b00      	cmp	r3, #0
200180cc:	d1f0      	bne.n	200180b0 <HAL_RCC_OscConfig+0x948>
200180ce:	e03d      	b.n	2001814c <HAL_RCC_OscConfig+0x9e4>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLLCKSELR;
200180d0:	4b21      	ldr	r3, [pc, #132]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
200180d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200180d4:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
200180d6:	4b20      	ldr	r3, [pc, #128]	; (20018158 <HAL_RCC_OscConfig+0x9f0>)
200180d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200180da:	60fb      	str	r3, [r7, #12]
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
200180dc:	687b      	ldr	r3, [r7, #4]
200180de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200180e0:	2b01      	cmp	r3, #1
200180e2:	d031      	beq.n	20018148 <HAL_RCC_OscConfig+0x9e0>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
200180e4:	693b      	ldr	r3, [r7, #16]
200180e6:	f003 0203 	and.w	r2, r3, #3
200180ea:	687b      	ldr	r3, [r7, #4]
200180ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
200180ee:	429a      	cmp	r2, r3
200180f0:	d12a      	bne.n	20018148 <HAL_RCC_OscConfig+0x9e0>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
200180f2:	693b      	ldr	r3, [r7, #16]
200180f4:	091b      	lsrs	r3, r3, #4
200180f6:	f003 023f 	and.w	r2, r3, #63	; 0x3f
200180fa:	687b      	ldr	r3, [r7, #4]
200180fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
200180fe:	429a      	cmp	r2, r3
20018100:	d122      	bne.n	20018148 <HAL_RCC_OscConfig+0x9e0>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
20018102:	68fb      	ldr	r3, [r7, #12]
20018104:	f3c3 0208 	ubfx	r2, r3, #0, #9
20018108:	687b      	ldr	r3, [r7, #4]
2001810a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001810c:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
2001810e:	429a      	cmp	r2, r3
20018110:	d11a      	bne.n	20018148 <HAL_RCC_OscConfig+0x9e0>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
20018112:	68fb      	ldr	r3, [r7, #12]
20018114:	0a5b      	lsrs	r3, r3, #9
20018116:	f003 027f 	and.w	r2, r3, #127	; 0x7f
2001811a:	687b      	ldr	r3, [r7, #4]
2001811c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2001811e:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
20018120:	429a      	cmp	r2, r3
20018122:	d111      	bne.n	20018148 <HAL_RCC_OscConfig+0x9e0>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
20018124:	68fb      	ldr	r3, [r7, #12]
20018126:	0c1b      	lsrs	r3, r3, #16
20018128:	f003 027f 	and.w	r2, r3, #127	; 0x7f
2001812c:	687b      	ldr	r3, [r7, #4]
2001812e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20018130:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
20018132:	429a      	cmp	r2, r3
20018134:	d108      	bne.n	20018148 <HAL_RCC_OscConfig+0x9e0>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
20018136:	68fb      	ldr	r3, [r7, #12]
20018138:	0e1b      	lsrs	r3, r3, #24
2001813a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
2001813e:	687b      	ldr	r3, [r7, #4]
20018140:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20018142:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
20018144:	429a      	cmp	r2, r3
20018146:	d001      	beq.n	2001814c <HAL_RCC_OscConfig+0x9e4>
      {
        return HAL_ERROR;
20018148:	2301      	movs	r3, #1
2001814a:	e000      	b.n	2001814e <HAL_RCC_OscConfig+0x9e6>
      }
    }
  }
  return HAL_OK;
2001814c:	2300      	movs	r3, #0
}
2001814e:	4618      	mov	r0, r3
20018150:	3730      	adds	r7, #48	; 0x30
20018152:	46bd      	mov	sp, r7
20018154:	bd80      	pop	{r7, pc}
20018156:	bf00      	nop
20018158:	58024400 	.word	0x58024400
2001815c:	fffffc0c 	.word	0xfffffc0c
20018160:	ffff0007 	.word	0xffff0007

20018164 <HAL_RCC_ClockConfig>:
  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
20018164:	b580      	push	{r7, lr}
20018166:	b086      	sub	sp, #24
20018168:	af00      	add	r7, sp, #0
2001816a:	6078      	str	r0, [r7, #4]
2001816c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;
  uint32_t common_system_clock;

   /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
2001816e:	687b      	ldr	r3, [r7, #4]
20018170:	2b00      	cmp	r3, #0
20018172:	d101      	bne.n	20018178 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
20018174:	2301      	movs	r3, #1
20018176:	e354      	b.n	20018822 <HAL_RCC_ClockConfig+0x6be>
  }

  /* Check the parameters */
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
20018178:	687b      	ldr	r3, [r7, #4]
2001817a:	681b      	ldr	r3, [r3, #0]
2001817c:	2b00      	cmp	r3, #0
2001817e:	d003      	beq.n	20018188 <HAL_RCC_ClockConfig+0x24>
20018180:	687b      	ldr	r3, [r7, #4]
20018182:	681b      	ldr	r3, [r3, #0]
20018184:	2b3f      	cmp	r3, #63	; 0x3f
20018186:	d904      	bls.n	20018192 <HAL_RCC_ClockConfig+0x2e>
20018188:	f240 317f 	movw	r1, #895	; 0x37f
2001818c:	4827      	ldr	r0, [pc, #156]	; (2001822c <HAL_RCC_ClockConfig+0xc8>)
2001818e:	f7e8 fbb1 	bl	200008f4 <assert_failed>
  assert_param(IS_FLASH_LATENCY(FLatency));
20018192:	683b      	ldr	r3, [r7, #0]
20018194:	2b00      	cmp	r3, #0
20018196:	d031      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
20018198:	683b      	ldr	r3, [r7, #0]
2001819a:	2b01      	cmp	r3, #1
2001819c:	d02e      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
2001819e:	683b      	ldr	r3, [r7, #0]
200181a0:	2b02      	cmp	r3, #2
200181a2:	d02b      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181a4:	683b      	ldr	r3, [r7, #0]
200181a6:	2b03      	cmp	r3, #3
200181a8:	d028      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181aa:	683b      	ldr	r3, [r7, #0]
200181ac:	2b04      	cmp	r3, #4
200181ae:	d025      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181b0:	683b      	ldr	r3, [r7, #0]
200181b2:	2b05      	cmp	r3, #5
200181b4:	d022      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181b6:	683b      	ldr	r3, [r7, #0]
200181b8:	2b06      	cmp	r3, #6
200181ba:	d01f      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181bc:	683b      	ldr	r3, [r7, #0]
200181be:	2b07      	cmp	r3, #7
200181c0:	d01c      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181c2:	683b      	ldr	r3, [r7, #0]
200181c4:	2b08      	cmp	r3, #8
200181c6:	d019      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181c8:	683b      	ldr	r3, [r7, #0]
200181ca:	2b09      	cmp	r3, #9
200181cc:	d016      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181ce:	683b      	ldr	r3, [r7, #0]
200181d0:	2b0a      	cmp	r3, #10
200181d2:	d013      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181d4:	683b      	ldr	r3, [r7, #0]
200181d6:	2b0b      	cmp	r3, #11
200181d8:	d010      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181da:	683b      	ldr	r3, [r7, #0]
200181dc:	2b0c      	cmp	r3, #12
200181de:	d00d      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181e0:	683b      	ldr	r3, [r7, #0]
200181e2:	2b0d      	cmp	r3, #13
200181e4:	d00a      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181e6:	683b      	ldr	r3, [r7, #0]
200181e8:	2b0e      	cmp	r3, #14
200181ea:	d007      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181ec:	683b      	ldr	r3, [r7, #0]
200181ee:	2b0f      	cmp	r3, #15
200181f0:	d004      	beq.n	200181fc <HAL_RCC_ClockConfig+0x98>
200181f2:	f44f 7160 	mov.w	r1, #896	; 0x380
200181f6:	480d      	ldr	r0, [pc, #52]	; (2001822c <HAL_RCC_ClockConfig+0xc8>)
200181f8:	f7e8 fb7c 	bl	200008f4 <assert_failed>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
200181fc:	4b0c      	ldr	r3, [pc, #48]	; (20018230 <HAL_RCC_ClockConfig+0xcc>)
200181fe:	681b      	ldr	r3, [r3, #0]
20018200:	f003 030f 	and.w	r3, r3, #15
20018204:	683a      	ldr	r2, [r7, #0]
20018206:	429a      	cmp	r2, r3
20018208:	d914      	bls.n	20018234 <HAL_RCC_ClockConfig+0xd0>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
2001820a:	4b09      	ldr	r3, [pc, #36]	; (20018230 <HAL_RCC_ClockConfig+0xcc>)
2001820c:	681b      	ldr	r3, [r3, #0]
2001820e:	f023 020f 	bic.w	r2, r3, #15
20018212:	4907      	ldr	r1, [pc, #28]	; (20018230 <HAL_RCC_ClockConfig+0xcc>)
20018214:	683b      	ldr	r3, [r7, #0]
20018216:	4313      	orrs	r3, r2
20018218:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
2001821a:	4b05      	ldr	r3, [pc, #20]	; (20018230 <HAL_RCC_ClockConfig+0xcc>)
2001821c:	681b      	ldr	r3, [r3, #0]
2001821e:	f003 030f 	and.w	r3, r3, #15
20018222:	683a      	ldr	r2, [r7, #0]
20018224:	429a      	cmp	r2, r3
20018226:	d005      	beq.n	20018234 <HAL_RCC_ClockConfig+0xd0>
    {
      return HAL_ERROR;
20018228:	2301      	movs	r3, #1
2001822a:	e2fa      	b.n	20018822 <HAL_RCC_ClockConfig+0x6be>
2001822c:	2001c2e0 	.word	0x2001c2e0
20018230:	52002000 	.word	0x52002000

  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
20018234:	687b      	ldr	r3, [r7, #4]
20018236:	681b      	ldr	r3, [r3, #0]
20018238:	f003 0304 	and.w	r3, r3, #4
2001823c:	2b00      	cmp	r3, #0
2001823e:	d029      	beq.n	20018294 <HAL_RCC_ClockConfig+0x130>
  {
#if defined (RCC_D1CFGR_D1PPRE)
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
20018240:	687b      	ldr	r3, [r7, #4]
20018242:	691a      	ldr	r2, [r3, #16]
20018244:	4b9a      	ldr	r3, [pc, #616]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
20018246:	699b      	ldr	r3, [r3, #24]
20018248:	f003 0370 	and.w	r3, r3, #112	; 0x70
2001824c:	429a      	cmp	r2, r3
2001824e:	d921      	bls.n	20018294 <HAL_RCC_ClockConfig+0x130>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
20018250:	687b      	ldr	r3, [r7, #4]
20018252:	691b      	ldr	r3, [r3, #16]
20018254:	2b00      	cmp	r3, #0
20018256:	d014      	beq.n	20018282 <HAL_RCC_ClockConfig+0x11e>
20018258:	687b      	ldr	r3, [r7, #4]
2001825a:	691b      	ldr	r3, [r3, #16]
2001825c:	2b40      	cmp	r3, #64	; 0x40
2001825e:	d010      	beq.n	20018282 <HAL_RCC_ClockConfig+0x11e>
20018260:	687b      	ldr	r3, [r7, #4]
20018262:	691b      	ldr	r3, [r3, #16]
20018264:	2b50      	cmp	r3, #80	; 0x50
20018266:	d00c      	beq.n	20018282 <HAL_RCC_ClockConfig+0x11e>
20018268:	687b      	ldr	r3, [r7, #4]
2001826a:	691b      	ldr	r3, [r3, #16]
2001826c:	2b60      	cmp	r3, #96	; 0x60
2001826e:	d008      	beq.n	20018282 <HAL_RCC_ClockConfig+0x11e>
20018270:	687b      	ldr	r3, [r7, #4]
20018272:	691b      	ldr	r3, [r3, #16]
20018274:	2b70      	cmp	r3, #112	; 0x70
20018276:	d004      	beq.n	20018282 <HAL_RCC_ClockConfig+0x11e>
20018278:	f44f 7167 	mov.w	r1, #924	; 0x39c
2001827c:	488d      	ldr	r0, [pc, #564]	; (200184b4 <HAL_RCC_ClockConfig+0x350>)
2001827e:	f7e8 fb39 	bl	200008f4 <assert_failed>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
20018282:	4b8b      	ldr	r3, [pc, #556]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
20018284:	699b      	ldr	r3, [r3, #24]
20018286:	f023 0270 	bic.w	r2, r3, #112	; 0x70
2001828a:	687b      	ldr	r3, [r7, #4]
2001828c:	691b      	ldr	r3, [r3, #16]
2001828e:	4988      	ldr	r1, [pc, #544]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
20018290:	4313      	orrs	r3, r2
20018292:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
20018294:	687b      	ldr	r3, [r7, #4]
20018296:	681b      	ldr	r3, [r3, #0]
20018298:	f003 0308 	and.w	r3, r3, #8
2001829c:	2b00      	cmp	r3, #0
2001829e:	d029      	beq.n	200182f4 <HAL_RCC_ClockConfig+0x190>
  {
#if defined (RCC_D2CFGR_D2PPRE1)
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
200182a0:	687b      	ldr	r3, [r7, #4]
200182a2:	695a      	ldr	r2, [r3, #20]
200182a4:	4b82      	ldr	r3, [pc, #520]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
200182a6:	69db      	ldr	r3, [r3, #28]
200182a8:	f003 0370 	and.w	r3, r3, #112	; 0x70
200182ac:	429a      	cmp	r2, r3
200182ae:	d921      	bls.n	200182f4 <HAL_RCC_ClockConfig+0x190>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
200182b0:	687b      	ldr	r3, [r7, #4]
200182b2:	695b      	ldr	r3, [r3, #20]
200182b4:	2b00      	cmp	r3, #0
200182b6:	d014      	beq.n	200182e2 <HAL_RCC_ClockConfig+0x17e>
200182b8:	687b      	ldr	r3, [r7, #4]
200182ba:	695b      	ldr	r3, [r3, #20]
200182bc:	2b40      	cmp	r3, #64	; 0x40
200182be:	d010      	beq.n	200182e2 <HAL_RCC_ClockConfig+0x17e>
200182c0:	687b      	ldr	r3, [r7, #4]
200182c2:	695b      	ldr	r3, [r3, #20]
200182c4:	2b50      	cmp	r3, #80	; 0x50
200182c6:	d00c      	beq.n	200182e2 <HAL_RCC_ClockConfig+0x17e>
200182c8:	687b      	ldr	r3, [r7, #4]
200182ca:	695b      	ldr	r3, [r3, #20]
200182cc:	2b60      	cmp	r3, #96	; 0x60
200182ce:	d008      	beq.n	200182e2 <HAL_RCC_ClockConfig+0x17e>
200182d0:	687b      	ldr	r3, [r7, #4]
200182d2:	695b      	ldr	r3, [r3, #20]
200182d4:	2b70      	cmp	r3, #112	; 0x70
200182d6:	d004      	beq.n	200182e2 <HAL_RCC_ClockConfig+0x17e>
200182d8:	f240 31ae 	movw	r1, #942	; 0x3ae
200182dc:	4875      	ldr	r0, [pc, #468]	; (200184b4 <HAL_RCC_ClockConfig+0x350>)
200182de:	f7e8 fb09 	bl	200008f4 <assert_failed>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
200182e2:	4b73      	ldr	r3, [pc, #460]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
200182e4:	69db      	ldr	r3, [r3, #28]
200182e6:	f023 0270 	bic.w	r2, r3, #112	; 0x70
200182ea:	687b      	ldr	r3, [r7, #4]
200182ec:	695b      	ldr	r3, [r3, #20]
200182ee:	4970      	ldr	r1, [pc, #448]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
200182f0:	4313      	orrs	r3, r2
200182f2:	61cb      	str	r3, [r1, #28]
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
  }
#endif
    }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
200182f4:	687b      	ldr	r3, [r7, #4]
200182f6:	681b      	ldr	r3, [r3, #0]
200182f8:	f003 0310 	and.w	r3, r3, #16
200182fc:	2b00      	cmp	r3, #0
200182fe:	d02d      	beq.n	2001835c <HAL_RCC_ClockConfig+0x1f8>
  {
#if defined(RCC_D2CFGR_D2PPRE2)
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
20018300:	687b      	ldr	r3, [r7, #4]
20018302:	699a      	ldr	r2, [r3, #24]
20018304:	4b6a      	ldr	r3, [pc, #424]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
20018306:	69db      	ldr	r3, [r3, #28]
20018308:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
2001830c:	429a      	cmp	r2, r3
2001830e:	d925      	bls.n	2001835c <HAL_RCC_ClockConfig+0x1f8>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
20018310:	687b      	ldr	r3, [r7, #4]
20018312:	699b      	ldr	r3, [r3, #24]
20018314:	2b00      	cmp	r3, #0
20018316:	d018      	beq.n	2001834a <HAL_RCC_ClockConfig+0x1e6>
20018318:	687b      	ldr	r3, [r7, #4]
2001831a:	699b      	ldr	r3, [r3, #24]
2001831c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20018320:	d013      	beq.n	2001834a <HAL_RCC_ClockConfig+0x1e6>
20018322:	687b      	ldr	r3, [r7, #4]
20018324:	699b      	ldr	r3, [r3, #24]
20018326:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
2001832a:	d00e      	beq.n	2001834a <HAL_RCC_ClockConfig+0x1e6>
2001832c:	687b      	ldr	r3, [r7, #4]
2001832e:	699b      	ldr	r3, [r3, #24]
20018330:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
20018334:	d009      	beq.n	2001834a <HAL_RCC_ClockConfig+0x1e6>
20018336:	687b      	ldr	r3, [r7, #4]
20018338:	699b      	ldr	r3, [r3, #24]
2001833a:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
2001833e:	d004      	beq.n	2001834a <HAL_RCC_ClockConfig+0x1e6>
20018340:	f240 31bf 	movw	r1, #959	; 0x3bf
20018344:	485b      	ldr	r0, [pc, #364]	; (200184b4 <HAL_RCC_ClockConfig+0x350>)
20018346:	f7e8 fad5 	bl	200008f4 <assert_failed>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
2001834a:	4b59      	ldr	r3, [pc, #356]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
2001834c:	69db      	ldr	r3, [r3, #28]
2001834e:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
20018352:	687b      	ldr	r3, [r7, #4]
20018354:	699b      	ldr	r3, [r3, #24]
20018356:	4956      	ldr	r1, [pc, #344]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
20018358:	4313      	orrs	r3, r2
2001835a:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
2001835c:	687b      	ldr	r3, [r7, #4]
2001835e:	681b      	ldr	r3, [r3, #0]
20018360:	f003 0320 	and.w	r3, r3, #32
20018364:	2b00      	cmp	r3, #0
20018366:	d029      	beq.n	200183bc <HAL_RCC_ClockConfig+0x258>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
20018368:	687b      	ldr	r3, [r7, #4]
2001836a:	69da      	ldr	r2, [r3, #28]
2001836c:	4b50      	ldr	r3, [pc, #320]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
2001836e:	6a1b      	ldr	r3, [r3, #32]
20018370:	f003 0370 	and.w	r3, r3, #112	; 0x70
20018374:	429a      	cmp	r2, r3
20018376:	d921      	bls.n	200183bc <HAL_RCC_ClockConfig+0x258>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
20018378:	687b      	ldr	r3, [r7, #4]
2001837a:	69db      	ldr	r3, [r3, #28]
2001837c:	2b00      	cmp	r3, #0
2001837e:	d014      	beq.n	200183aa <HAL_RCC_ClockConfig+0x246>
20018380:	687b      	ldr	r3, [r7, #4]
20018382:	69db      	ldr	r3, [r3, #28]
20018384:	2b40      	cmp	r3, #64	; 0x40
20018386:	d010      	beq.n	200183aa <HAL_RCC_ClockConfig+0x246>
20018388:	687b      	ldr	r3, [r7, #4]
2001838a:	69db      	ldr	r3, [r3, #28]
2001838c:	2b50      	cmp	r3, #80	; 0x50
2001838e:	d00c      	beq.n	200183aa <HAL_RCC_ClockConfig+0x246>
20018390:	687b      	ldr	r3, [r7, #4]
20018392:	69db      	ldr	r3, [r3, #28]
20018394:	2b60      	cmp	r3, #96	; 0x60
20018396:	d008      	beq.n	200183aa <HAL_RCC_ClockConfig+0x246>
20018398:	687b      	ldr	r3, [r7, #4]
2001839a:	69db      	ldr	r3, [r3, #28]
2001839c:	2b70      	cmp	r3, #112	; 0x70
2001839e:	d004      	beq.n	200183aa <HAL_RCC_ClockConfig+0x246>
200183a0:	f240 31d1 	movw	r1, #977	; 0x3d1
200183a4:	4843      	ldr	r0, [pc, #268]	; (200184b4 <HAL_RCC_ClockConfig+0x350>)
200183a6:	f7e8 faa5 	bl	200008f4 <assert_failed>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
200183aa:	4b41      	ldr	r3, [pc, #260]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
200183ac:	6a1b      	ldr	r3, [r3, #32]
200183ae:	f023 0270 	bic.w	r2, r3, #112	; 0x70
200183b2:	687b      	ldr	r3, [r7, #4]
200183b4:	69db      	ldr	r3, [r3, #28]
200183b6:	493e      	ldr	r1, [pc, #248]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
200183b8:	4313      	orrs	r3, r2
200183ba:	620b      	str	r3, [r1, #32]
    }
#endif
  }

   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
200183bc:	687b      	ldr	r3, [r7, #4]
200183be:	681b      	ldr	r3, [r3, #0]
200183c0:	f003 0302 	and.w	r3, r3, #2
200183c4:	2b00      	cmp	r3, #0
200183c6:	d039      	beq.n	2001843c <HAL_RCC_ClockConfig+0x2d8>
  {
#if defined (RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
200183c8:	687b      	ldr	r3, [r7, #4]
200183ca:	68da      	ldr	r2, [r3, #12]
200183cc:	4b38      	ldr	r3, [pc, #224]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
200183ce:	699b      	ldr	r3, [r3, #24]
200183d0:	f003 030f 	and.w	r3, r3, #15
200183d4:	429a      	cmp	r2, r3
200183d6:	d931      	bls.n	2001843c <HAL_RCC_ClockConfig+0x2d8>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
200183d8:	687b      	ldr	r3, [r7, #4]
200183da:	68db      	ldr	r3, [r3, #12]
200183dc:	2b00      	cmp	r3, #0
200183de:	d024      	beq.n	2001842a <HAL_RCC_ClockConfig+0x2c6>
200183e0:	687b      	ldr	r3, [r7, #4]
200183e2:	68db      	ldr	r3, [r3, #12]
200183e4:	2b08      	cmp	r3, #8
200183e6:	d020      	beq.n	2001842a <HAL_RCC_ClockConfig+0x2c6>
200183e8:	687b      	ldr	r3, [r7, #4]
200183ea:	68db      	ldr	r3, [r3, #12]
200183ec:	2b09      	cmp	r3, #9
200183ee:	d01c      	beq.n	2001842a <HAL_RCC_ClockConfig+0x2c6>
200183f0:	687b      	ldr	r3, [r7, #4]
200183f2:	68db      	ldr	r3, [r3, #12]
200183f4:	2b0a      	cmp	r3, #10
200183f6:	d018      	beq.n	2001842a <HAL_RCC_ClockConfig+0x2c6>
200183f8:	687b      	ldr	r3, [r7, #4]
200183fa:	68db      	ldr	r3, [r3, #12]
200183fc:	2b0b      	cmp	r3, #11
200183fe:	d014      	beq.n	2001842a <HAL_RCC_ClockConfig+0x2c6>
20018400:	687b      	ldr	r3, [r7, #4]
20018402:	68db      	ldr	r3, [r3, #12]
20018404:	2b0c      	cmp	r3, #12
20018406:	d010      	beq.n	2001842a <HAL_RCC_ClockConfig+0x2c6>
20018408:	687b      	ldr	r3, [r7, #4]
2001840a:	68db      	ldr	r3, [r3, #12]
2001840c:	2b0d      	cmp	r3, #13
2001840e:	d00c      	beq.n	2001842a <HAL_RCC_ClockConfig+0x2c6>
20018410:	687b      	ldr	r3, [r7, #4]
20018412:	68db      	ldr	r3, [r3, #12]
20018414:	2b0e      	cmp	r3, #14
20018416:	d008      	beq.n	2001842a <HAL_RCC_ClockConfig+0x2c6>
20018418:	687b      	ldr	r3, [r7, #4]
2001841a:	68db      	ldr	r3, [r3, #12]
2001841c:	2b0f      	cmp	r3, #15
2001841e:	d004      	beq.n	2001842a <HAL_RCC_ClockConfig+0x2c6>
20018420:	f44f 7179 	mov.w	r1, #996	; 0x3e4
20018424:	4823      	ldr	r0, [pc, #140]	; (200184b4 <HAL_RCC_ClockConfig+0x350>)
20018426:	f7e8 fa65 	bl	200008f4 <assert_failed>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
2001842a:	4b21      	ldr	r3, [pc, #132]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
2001842c:	699b      	ldr	r3, [r3, #24]
2001842e:	f023 020f 	bic.w	r2, r3, #15
20018432:	687b      	ldr	r3, [r7, #4]
20018434:	68db      	ldr	r3, [r3, #12]
20018436:	491e      	ldr	r1, [pc, #120]	; (200184b0 <HAL_RCC_ClockConfig+0x34c>)
20018438:	4313      	orrs	r3, r2
2001843a:	618b      	str	r3, [r1, #24]
    }
#endif
  }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
2001843c:	687b      	ldr	r3, [r7, #4]
2001843e:	681b      	ldr	r3, [r3, #0]
20018440:	f003 0301 	and.w	r3, r3, #1
20018444:	2b00      	cmp	r3, #0
20018446:	f000 80a2 	beq.w	2001858e <HAL_RCC_ClockConfig+0x42a>
    {
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
2001844a:	687b      	ldr	r3, [r7, #4]
2001844c:	689b      	ldr	r3, [r3, #8]
2001844e:	2b00      	cmp	r3, #0
20018450:	d032      	beq.n	200184b8 <HAL_RCC_ClockConfig+0x354>
20018452:	687b      	ldr	r3, [r7, #4]
20018454:	689b      	ldr	r3, [r3, #8]
20018456:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2001845a:	d02d      	beq.n	200184b8 <HAL_RCC_ClockConfig+0x354>
2001845c:	687b      	ldr	r3, [r7, #4]
2001845e:	689b      	ldr	r3, [r3, #8]
20018460:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
20018464:	d028      	beq.n	200184b8 <HAL_RCC_ClockConfig+0x354>
20018466:	687b      	ldr	r3, [r7, #4]
20018468:	689b      	ldr	r3, [r3, #8]
2001846a:	f5b3 6f20 	cmp.w	r3, #2560	; 0xa00
2001846e:	d023      	beq.n	200184b8 <HAL_RCC_ClockConfig+0x354>
20018470:	687b      	ldr	r3, [r7, #4]
20018472:	689b      	ldr	r3, [r3, #8]
20018474:	f5b3 6f30 	cmp.w	r3, #2816	; 0xb00
20018478:	d01e      	beq.n	200184b8 <HAL_RCC_ClockConfig+0x354>
2001847a:	687b      	ldr	r3, [r7, #4]
2001847c:	689b      	ldr	r3, [r3, #8]
2001847e:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
20018482:	d019      	beq.n	200184b8 <HAL_RCC_ClockConfig+0x354>
20018484:	687b      	ldr	r3, [r7, #4]
20018486:	689b      	ldr	r3, [r3, #8]
20018488:	f5b3 6f50 	cmp.w	r3, #3328	; 0xd00
2001848c:	d014      	beq.n	200184b8 <HAL_RCC_ClockConfig+0x354>
2001848e:	687b      	ldr	r3, [r7, #4]
20018490:	689b      	ldr	r3, [r3, #8]
20018492:	f5b3 6f60 	cmp.w	r3, #3584	; 0xe00
20018496:	d00f      	beq.n	200184b8 <HAL_RCC_ClockConfig+0x354>
20018498:	687b      	ldr	r3, [r7, #4]
2001849a:	689b      	ldr	r3, [r3, #8]
2001849c:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
200184a0:	d00a      	beq.n	200184b8 <HAL_RCC_ClockConfig+0x354>
200184a2:	f44f 717d 	mov.w	r1, #1012	; 0x3f4
200184a6:	4803      	ldr	r0, [pc, #12]	; (200184b4 <HAL_RCC_ClockConfig+0x350>)
200184a8:	f7e8 fa24 	bl	200008f4 <assert_failed>
200184ac:	e004      	b.n	200184b8 <HAL_RCC_ClockConfig+0x354>
200184ae:	bf00      	nop
200184b0:	58024400 	.word	0x58024400
200184b4:	2001c2e0 	.word	0x2001c2e0
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
200184b8:	687b      	ldr	r3, [r7, #4]
200184ba:	685b      	ldr	r3, [r3, #4]
200184bc:	2b01      	cmp	r3, #1
200184be:	d010      	beq.n	200184e2 <HAL_RCC_ClockConfig+0x37e>
200184c0:	687b      	ldr	r3, [r7, #4]
200184c2:	685b      	ldr	r3, [r3, #4]
200184c4:	2b00      	cmp	r3, #0
200184c6:	d00c      	beq.n	200184e2 <HAL_RCC_ClockConfig+0x37e>
200184c8:	687b      	ldr	r3, [r7, #4]
200184ca:	685b      	ldr	r3, [r3, #4]
200184cc:	2b02      	cmp	r3, #2
200184ce:	d008      	beq.n	200184e2 <HAL_RCC_ClockConfig+0x37e>
200184d0:	687b      	ldr	r3, [r7, #4]
200184d2:	685b      	ldr	r3, [r3, #4]
200184d4:	2b03      	cmp	r3, #3
200184d6:	d004      	beq.n	200184e2 <HAL_RCC_ClockConfig+0x37e>
200184d8:	f240 31f5 	movw	r1, #1013	; 0x3f5
200184dc:	4858      	ldr	r0, [pc, #352]	; (20018640 <HAL_RCC_ClockConfig+0x4dc>)
200184de:	f7e8 fa09 	bl	200008f4 <assert_failed>
#if defined(RCC_D1CFGR_D1CPRE)
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
200184e2:	4b58      	ldr	r3, [pc, #352]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
200184e4:	699b      	ldr	r3, [r3, #24]
200184e6:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
200184ea:	687b      	ldr	r3, [r7, #4]
200184ec:	689b      	ldr	r3, [r3, #8]
200184ee:	4955      	ldr	r1, [pc, #340]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
200184f0:	4313      	orrs	r3, r2
200184f2:	618b      	str	r3, [r1, #24]
#else
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
#endif
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
200184f4:	687b      	ldr	r3, [r7, #4]
200184f6:	685b      	ldr	r3, [r3, #4]
200184f8:	2b02      	cmp	r3, #2
200184fa:	d107      	bne.n	2001850c <HAL_RCC_ClockConfig+0x3a8>
      {
        /* Check the HSE ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
200184fc:	4b51      	ldr	r3, [pc, #324]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
200184fe:	681b      	ldr	r3, [r3, #0]
20018500:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20018504:	2b00      	cmp	r3, #0
20018506:	d121      	bne.n	2001854c <HAL_RCC_ClockConfig+0x3e8>
        {
          return HAL_ERROR;
20018508:	2301      	movs	r3, #1
2001850a:	e18a      	b.n	20018822 <HAL_RCC_ClockConfig+0x6be>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
2001850c:	687b      	ldr	r3, [r7, #4]
2001850e:	685b      	ldr	r3, [r3, #4]
20018510:	2b03      	cmp	r3, #3
20018512:	d107      	bne.n	20018524 <HAL_RCC_ClockConfig+0x3c0>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
20018514:	4b4b      	ldr	r3, [pc, #300]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
20018516:	681b      	ldr	r3, [r3, #0]
20018518:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2001851c:	2b00      	cmp	r3, #0
2001851e:	d115      	bne.n	2001854c <HAL_RCC_ClockConfig+0x3e8>
        {
          return HAL_ERROR;
20018520:	2301      	movs	r3, #1
20018522:	e17e      	b.n	20018822 <HAL_RCC_ClockConfig+0x6be>
        }
      }
      /* CSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
20018524:	687b      	ldr	r3, [r7, #4]
20018526:	685b      	ldr	r3, [r3, #4]
20018528:	2b01      	cmp	r3, #1
2001852a:	d107      	bne.n	2001853c <HAL_RCC_ClockConfig+0x3d8>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
2001852c:	4b45      	ldr	r3, [pc, #276]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
2001852e:	681b      	ldr	r3, [r3, #0]
20018530:	f403 7380 	and.w	r3, r3, #256	; 0x100
20018534:	2b00      	cmp	r3, #0
20018536:	d109      	bne.n	2001854c <HAL_RCC_ClockConfig+0x3e8>
        {
          return HAL_ERROR;
20018538:	2301      	movs	r3, #1
2001853a:	e172      	b.n	20018822 <HAL_RCC_ClockConfig+0x6be>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
2001853c:	4b41      	ldr	r3, [pc, #260]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
2001853e:	681b      	ldr	r3, [r3, #0]
20018540:	f003 0304 	and.w	r3, r3, #4
20018544:	2b00      	cmp	r3, #0
20018546:	d101      	bne.n	2001854c <HAL_RCC_ClockConfig+0x3e8>
        {
          return HAL_ERROR;
20018548:	2301      	movs	r3, #1
2001854a:	e16a      	b.n	20018822 <HAL_RCC_ClockConfig+0x6be>
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
2001854c:	4b3d      	ldr	r3, [pc, #244]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
2001854e:	691b      	ldr	r3, [r3, #16]
20018550:	f023 0207 	bic.w	r2, r3, #7
20018554:	687b      	ldr	r3, [r7, #4]
20018556:	685b      	ldr	r3, [r3, #4]
20018558:	493a      	ldr	r1, [pc, #232]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
2001855a:	4313      	orrs	r3, r2
2001855c:	610b      	str	r3, [r1, #16]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
2001855e:	f7e9 fbc5 	bl	20001cec <HAL_GetTick>
20018562:	6178      	str	r0, [r7, #20]

        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
20018564:	e00a      	b.n	2001857c <HAL_RCC_ClockConfig+0x418>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
20018566:	f7e9 fbc1 	bl	20001cec <HAL_GetTick>
2001856a:	4602      	mov	r2, r0
2001856c:	697b      	ldr	r3, [r7, #20]
2001856e:	1ad3      	subs	r3, r2, r3
20018570:	f241 3288 	movw	r2, #5000	; 0x1388
20018574:	4293      	cmp	r3, r2
20018576:	d901      	bls.n	2001857c <HAL_RCC_ClockConfig+0x418>
          {
            return HAL_TIMEOUT;
20018578:	2303      	movs	r3, #3
2001857a:	e152      	b.n	20018822 <HAL_RCC_ClockConfig+0x6be>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
2001857c:	4b31      	ldr	r3, [pc, #196]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
2001857e:	691b      	ldr	r3, [r3, #16]
20018580:	f003 0238 	and.w	r2, r3, #56	; 0x38
20018584:	687b      	ldr	r3, [r7, #4]
20018586:	685b      	ldr	r3, [r3, #4]
20018588:	00db      	lsls	r3, r3, #3
2001858a:	429a      	cmp	r2, r3
2001858c:	d1eb      	bne.n	20018566 <HAL_RCC_ClockConfig+0x402>

    }

    /* Decreasing the BUS frequency divider */
   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
2001858e:	687b      	ldr	r3, [r7, #4]
20018590:	681b      	ldr	r3, [r3, #0]
20018592:	f003 0302 	and.w	r3, r3, #2
20018596:	2b00      	cmp	r3, #0
20018598:	d039      	beq.n	2001860e <HAL_RCC_ClockConfig+0x4aa>
  {
#if defined(RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
2001859a:	687b      	ldr	r3, [r7, #4]
2001859c:	68da      	ldr	r2, [r3, #12]
2001859e:	4b29      	ldr	r3, [pc, #164]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
200185a0:	699b      	ldr	r3, [r3, #24]
200185a2:	f003 030f 	and.w	r3, r3, #15
200185a6:	429a      	cmp	r2, r3
200185a8:	d231      	bcs.n	2001860e <HAL_RCC_ClockConfig+0x4aa>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
200185aa:	687b      	ldr	r3, [r7, #4]
200185ac:	68db      	ldr	r3, [r3, #12]
200185ae:	2b00      	cmp	r3, #0
200185b0:	d024      	beq.n	200185fc <HAL_RCC_ClockConfig+0x498>
200185b2:	687b      	ldr	r3, [r7, #4]
200185b4:	68db      	ldr	r3, [r3, #12]
200185b6:	2b08      	cmp	r3, #8
200185b8:	d020      	beq.n	200185fc <HAL_RCC_ClockConfig+0x498>
200185ba:	687b      	ldr	r3, [r7, #4]
200185bc:	68db      	ldr	r3, [r3, #12]
200185be:	2b09      	cmp	r3, #9
200185c0:	d01c      	beq.n	200185fc <HAL_RCC_ClockConfig+0x498>
200185c2:	687b      	ldr	r3, [r7, #4]
200185c4:	68db      	ldr	r3, [r3, #12]
200185c6:	2b0a      	cmp	r3, #10
200185c8:	d018      	beq.n	200185fc <HAL_RCC_ClockConfig+0x498>
200185ca:	687b      	ldr	r3, [r7, #4]
200185cc:	68db      	ldr	r3, [r3, #12]
200185ce:	2b0b      	cmp	r3, #11
200185d0:	d014      	beq.n	200185fc <HAL_RCC_ClockConfig+0x498>
200185d2:	687b      	ldr	r3, [r7, #4]
200185d4:	68db      	ldr	r3, [r3, #12]
200185d6:	2b0c      	cmp	r3, #12
200185d8:	d010      	beq.n	200185fc <HAL_RCC_ClockConfig+0x498>
200185da:	687b      	ldr	r3, [r7, #4]
200185dc:	68db      	ldr	r3, [r3, #12]
200185de:	2b0d      	cmp	r3, #13
200185e0:	d00c      	beq.n	200185fc <HAL_RCC_ClockConfig+0x498>
200185e2:	687b      	ldr	r3, [r7, #4]
200185e4:	68db      	ldr	r3, [r3, #12]
200185e6:	2b0e      	cmp	r3, #14
200185e8:	d008      	beq.n	200185fc <HAL_RCC_ClockConfig+0x498>
200185ea:	687b      	ldr	r3, [r7, #4]
200185ec:	68db      	ldr	r3, [r3, #12]
200185ee:	2b0f      	cmp	r3, #15
200185f0:	d004      	beq.n	200185fc <HAL_RCC_ClockConfig+0x498>
200185f2:	f240 4136 	movw	r1, #1078	; 0x436
200185f6:	4812      	ldr	r0, [pc, #72]	; (20018640 <HAL_RCC_ClockConfig+0x4dc>)
200185f8:	f7e8 f97c 	bl	200008f4 <assert_failed>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
200185fc:	4b11      	ldr	r3, [pc, #68]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
200185fe:	699b      	ldr	r3, [r3, #24]
20018600:	f023 020f 	bic.w	r2, r3, #15
20018604:	687b      	ldr	r3, [r7, #4]
20018606:	68db      	ldr	r3, [r3, #12]
20018608:	490e      	ldr	r1, [pc, #56]	; (20018644 <HAL_RCC_ClockConfig+0x4e0>)
2001860a:	4313      	orrs	r3, r2
2001860c:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
2001860e:	4b0e      	ldr	r3, [pc, #56]	; (20018648 <HAL_RCC_ClockConfig+0x4e4>)
20018610:	681b      	ldr	r3, [r3, #0]
20018612:	f003 030f 	and.w	r3, r3, #15
20018616:	683a      	ldr	r2, [r7, #0]
20018618:	429a      	cmp	r2, r3
2001861a:	d217      	bcs.n	2001864c <HAL_RCC_ClockConfig+0x4e8>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
2001861c:	4b0a      	ldr	r3, [pc, #40]	; (20018648 <HAL_RCC_ClockConfig+0x4e4>)
2001861e:	681b      	ldr	r3, [r3, #0]
20018620:	f023 020f 	bic.w	r2, r3, #15
20018624:	4908      	ldr	r1, [pc, #32]	; (20018648 <HAL_RCC_ClockConfig+0x4e4>)
20018626:	683b      	ldr	r3, [r7, #0]
20018628:	4313      	orrs	r3, r2
2001862a:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
2001862c:	4b06      	ldr	r3, [pc, #24]	; (20018648 <HAL_RCC_ClockConfig+0x4e4>)
2001862e:	681b      	ldr	r3, [r3, #0]
20018630:	f003 030f 	and.w	r3, r3, #15
20018634:	683a      	ldr	r2, [r7, #0]
20018636:	429a      	cmp	r2, r3
20018638:	d008      	beq.n	2001864c <HAL_RCC_ClockConfig+0x4e8>
    {
      return HAL_ERROR;
2001863a:	2301      	movs	r3, #1
2001863c:	e0f1      	b.n	20018822 <HAL_RCC_ClockConfig+0x6be>
2001863e:	bf00      	nop
20018640:	2001c2e0 	.word	0x2001c2e0
20018644:	58024400 	.word	0x58024400
20018648:	52002000 	.word	0x52002000
    }
 }

  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
2001864c:	687b      	ldr	r3, [r7, #4]
2001864e:	681b      	ldr	r3, [r3, #0]
20018650:	f003 0304 	and.w	r3, r3, #4
20018654:	2b00      	cmp	r3, #0
20018656:	d029      	beq.n	200186ac <HAL_RCC_ClockConfig+0x548>
 {
#if defined(RCC_D1CFGR_D1PPRE)
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
20018658:	687b      	ldr	r3, [r7, #4]
2001865a:	691a      	ldr	r2, [r3, #16]
2001865c:	4b73      	ldr	r3, [pc, #460]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
2001865e:	699b      	ldr	r3, [r3, #24]
20018660:	f003 0370 	and.w	r3, r3, #112	; 0x70
20018664:	429a      	cmp	r2, r3
20018666:	d221      	bcs.n	200186ac <HAL_RCC_ClockConfig+0x548>
   {
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
20018668:	687b      	ldr	r3, [r7, #4]
2001866a:	691b      	ldr	r3, [r3, #16]
2001866c:	2b00      	cmp	r3, #0
2001866e:	d014      	beq.n	2001869a <HAL_RCC_ClockConfig+0x536>
20018670:	687b      	ldr	r3, [r7, #4]
20018672:	691b      	ldr	r3, [r3, #16]
20018674:	2b40      	cmp	r3, #64	; 0x40
20018676:	d010      	beq.n	2001869a <HAL_RCC_ClockConfig+0x536>
20018678:	687b      	ldr	r3, [r7, #4]
2001867a:	691b      	ldr	r3, [r3, #16]
2001867c:	2b50      	cmp	r3, #80	; 0x50
2001867e:	d00c      	beq.n	2001869a <HAL_RCC_ClockConfig+0x536>
20018680:	687b      	ldr	r3, [r7, #4]
20018682:	691b      	ldr	r3, [r3, #16]
20018684:	2b60      	cmp	r3, #96	; 0x60
20018686:	d008      	beq.n	2001869a <HAL_RCC_ClockConfig+0x536>
20018688:	687b      	ldr	r3, [r7, #4]
2001868a:	691b      	ldr	r3, [r3, #16]
2001868c:	2b70      	cmp	r3, #112	; 0x70
2001868e:	d004      	beq.n	2001869a <HAL_RCC_ClockConfig+0x536>
20018690:	f240 4157 	movw	r1, #1111	; 0x457
20018694:	4866      	ldr	r0, [pc, #408]	; (20018830 <HAL_RCC_ClockConfig+0x6cc>)
20018696:	f7e8 f92d 	bl	200008f4 <assert_failed>
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
2001869a:	4b64      	ldr	r3, [pc, #400]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
2001869c:	699b      	ldr	r3, [r3, #24]
2001869e:	f023 0270 	bic.w	r2, r3, #112	; 0x70
200186a2:	687b      	ldr	r3, [r7, #4]
200186a4:	691b      	ldr	r3, [r3, #16]
200186a6:	4961      	ldr	r1, [pc, #388]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
200186a8:	4313      	orrs	r3, r2
200186aa:	618b      	str	r3, [r1, #24]
   }
#endif
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
200186ac:	687b      	ldr	r3, [r7, #4]
200186ae:	681b      	ldr	r3, [r3, #0]
200186b0:	f003 0308 	and.w	r3, r3, #8
200186b4:	2b00      	cmp	r3, #0
200186b6:	d029      	beq.n	2001870c <HAL_RCC_ClockConfig+0x5a8>
 {
#if defined(RCC_D2CFGR_D2PPRE1)
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
200186b8:	687b      	ldr	r3, [r7, #4]
200186ba:	695a      	ldr	r2, [r3, #20]
200186bc:	4b5b      	ldr	r3, [pc, #364]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
200186be:	69db      	ldr	r3, [r3, #28]
200186c0:	f003 0370 	and.w	r3, r3, #112	; 0x70
200186c4:	429a      	cmp	r2, r3
200186c6:	d221      	bcs.n	2001870c <HAL_RCC_ClockConfig+0x5a8>
   {
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
200186c8:	687b      	ldr	r3, [r7, #4]
200186ca:	695b      	ldr	r3, [r3, #20]
200186cc:	2b00      	cmp	r3, #0
200186ce:	d014      	beq.n	200186fa <HAL_RCC_ClockConfig+0x596>
200186d0:	687b      	ldr	r3, [r7, #4]
200186d2:	695b      	ldr	r3, [r3, #20]
200186d4:	2b40      	cmp	r3, #64	; 0x40
200186d6:	d010      	beq.n	200186fa <HAL_RCC_ClockConfig+0x596>
200186d8:	687b      	ldr	r3, [r7, #4]
200186da:	695b      	ldr	r3, [r3, #20]
200186dc:	2b50      	cmp	r3, #80	; 0x50
200186de:	d00c      	beq.n	200186fa <HAL_RCC_ClockConfig+0x596>
200186e0:	687b      	ldr	r3, [r7, #4]
200186e2:	695b      	ldr	r3, [r3, #20]
200186e4:	2b60      	cmp	r3, #96	; 0x60
200186e6:	d008      	beq.n	200186fa <HAL_RCC_ClockConfig+0x596>
200186e8:	687b      	ldr	r3, [r7, #4]
200186ea:	695b      	ldr	r3, [r3, #20]
200186ec:	2b70      	cmp	r3, #112	; 0x70
200186ee:	d004      	beq.n	200186fa <HAL_RCC_ClockConfig+0x596>
200186f0:	f240 4169 	movw	r1, #1129	; 0x469
200186f4:	484e      	ldr	r0, [pc, #312]	; (20018830 <HAL_RCC_ClockConfig+0x6cc>)
200186f6:	f7e8 f8fd 	bl	200008f4 <assert_failed>
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
200186fa:	4b4c      	ldr	r3, [pc, #304]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
200186fc:	69db      	ldr	r3, [r3, #28]
200186fe:	f023 0270 	bic.w	r2, r3, #112	; 0x70
20018702:	687b      	ldr	r3, [r7, #4]
20018704:	695b      	ldr	r3, [r3, #20]
20018706:	4949      	ldr	r1, [pc, #292]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
20018708:	4313      	orrs	r3, r2
2001870a:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
2001870c:	687b      	ldr	r3, [r7, #4]
2001870e:	681b      	ldr	r3, [r3, #0]
20018710:	f003 0310 	and.w	r3, r3, #16
20018714:	2b00      	cmp	r3, #0
20018716:	d02d      	beq.n	20018774 <HAL_RCC_ClockConfig+0x610>
 {
#if defined (RCC_D2CFGR_D2PPRE2)
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
20018718:	687b      	ldr	r3, [r7, #4]
2001871a:	699a      	ldr	r2, [r3, #24]
2001871c:	4b43      	ldr	r3, [pc, #268]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
2001871e:	69db      	ldr	r3, [r3, #28]
20018720:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
20018724:	429a      	cmp	r2, r3
20018726:	d225      	bcs.n	20018774 <HAL_RCC_ClockConfig+0x610>
   {
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
20018728:	687b      	ldr	r3, [r7, #4]
2001872a:	699b      	ldr	r3, [r3, #24]
2001872c:	2b00      	cmp	r3, #0
2001872e:	d018      	beq.n	20018762 <HAL_RCC_ClockConfig+0x5fe>
20018730:	687b      	ldr	r3, [r7, #4]
20018732:	699b      	ldr	r3, [r3, #24]
20018734:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20018738:	d013      	beq.n	20018762 <HAL_RCC_ClockConfig+0x5fe>
2001873a:	687b      	ldr	r3, [r7, #4]
2001873c:	699b      	ldr	r3, [r3, #24]
2001873e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
20018742:	d00e      	beq.n	20018762 <HAL_RCC_ClockConfig+0x5fe>
20018744:	687b      	ldr	r3, [r7, #4]
20018746:	699b      	ldr	r3, [r3, #24]
20018748:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
2001874c:	d009      	beq.n	20018762 <HAL_RCC_ClockConfig+0x5fe>
2001874e:	687b      	ldr	r3, [r7, #4]
20018750:	699b      	ldr	r3, [r3, #24]
20018752:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
20018756:	d004      	beq.n	20018762 <HAL_RCC_ClockConfig+0x5fe>
20018758:	f240 417b 	movw	r1, #1147	; 0x47b
2001875c:	4834      	ldr	r0, [pc, #208]	; (20018830 <HAL_RCC_ClockConfig+0x6cc>)
2001875e:	f7e8 f8c9 	bl	200008f4 <assert_failed>
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
20018762:	4b32      	ldr	r3, [pc, #200]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
20018764:	69db      	ldr	r3, [r3, #28]
20018766:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
2001876a:	687b      	ldr	r3, [r7, #4]
2001876c:	699b      	ldr	r3, [r3, #24]
2001876e:	492f      	ldr	r1, [pc, #188]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
20018770:	4313      	orrs	r3, r2
20018772:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
20018774:	687b      	ldr	r3, [r7, #4]
20018776:	681b      	ldr	r3, [r3, #0]
20018778:	f003 0320 	and.w	r3, r3, #32
2001877c:	2b00      	cmp	r3, #0
2001877e:	d029      	beq.n	200187d4 <HAL_RCC_ClockConfig+0x670>
 {
#if defined(RCC_D3CFGR_D3PPRE)
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
20018780:	687b      	ldr	r3, [r7, #4]
20018782:	69da      	ldr	r2, [r3, #28]
20018784:	4b29      	ldr	r3, [pc, #164]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
20018786:	6a1b      	ldr	r3, [r3, #32]
20018788:	f003 0370 	and.w	r3, r3, #112	; 0x70
2001878c:	429a      	cmp	r2, r3
2001878e:	d221      	bcs.n	200187d4 <HAL_RCC_ClockConfig+0x670>
   {
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
20018790:	687b      	ldr	r3, [r7, #4]
20018792:	69db      	ldr	r3, [r3, #28]
20018794:	2b00      	cmp	r3, #0
20018796:	d014      	beq.n	200187c2 <HAL_RCC_ClockConfig+0x65e>
20018798:	687b      	ldr	r3, [r7, #4]
2001879a:	69db      	ldr	r3, [r3, #28]
2001879c:	2b40      	cmp	r3, #64	; 0x40
2001879e:	d010      	beq.n	200187c2 <HAL_RCC_ClockConfig+0x65e>
200187a0:	687b      	ldr	r3, [r7, #4]
200187a2:	69db      	ldr	r3, [r3, #28]
200187a4:	2b50      	cmp	r3, #80	; 0x50
200187a6:	d00c      	beq.n	200187c2 <HAL_RCC_ClockConfig+0x65e>
200187a8:	687b      	ldr	r3, [r7, #4]
200187aa:	69db      	ldr	r3, [r3, #28]
200187ac:	2b60      	cmp	r3, #96	; 0x60
200187ae:	d008      	beq.n	200187c2 <HAL_RCC_ClockConfig+0x65e>
200187b0:	687b      	ldr	r3, [r7, #4]
200187b2:	69db      	ldr	r3, [r3, #28]
200187b4:	2b70      	cmp	r3, #112	; 0x70
200187b6:	d004      	beq.n	200187c2 <HAL_RCC_ClockConfig+0x65e>
200187b8:	f240 418d 	movw	r1, #1165	; 0x48d
200187bc:	481c      	ldr	r0, [pc, #112]	; (20018830 <HAL_RCC_ClockConfig+0x6cc>)
200187be:	f7e8 f899 	bl	200008f4 <assert_failed>
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
200187c2:	4b1a      	ldr	r3, [pc, #104]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
200187c4:	6a1b      	ldr	r3, [r3, #32]
200187c6:	f023 0270 	bic.w	r2, r3, #112	; 0x70
200187ca:	687b      	ldr	r3, [r7, #4]
200187cc:	69db      	ldr	r3, [r3, #28]
200187ce:	4917      	ldr	r1, [pc, #92]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
200187d0:	4313      	orrs	r3, r2
200187d2:	620b      	str	r3, [r1, #32]
#endif
 }

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
200187d4:	f000 f942 	bl	20018a5c <HAL_RCC_GetSysClockFreq>
200187d8:	4601      	mov	r1, r0
200187da:	4b14      	ldr	r3, [pc, #80]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
200187dc:	699b      	ldr	r3, [r3, #24]
200187de:	0a1b      	lsrs	r3, r3, #8
200187e0:	f003 030f 	and.w	r3, r3, #15
200187e4:	4a13      	ldr	r2, [pc, #76]	; (20018834 <HAL_RCC_ClockConfig+0x6d0>)
200187e6:	5cd3      	ldrb	r3, [r2, r3]
200187e8:	f003 031f 	and.w	r3, r3, #31
200187ec:	fa21 f303 	lsr.w	r3, r1, r3
200187f0:	613b      	str	r3, [r7, #16]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
200187f2:	4b0e      	ldr	r3, [pc, #56]	; (2001882c <HAL_RCC_ClockConfig+0x6c8>)
200187f4:	699b      	ldr	r3, [r3, #24]
200187f6:	f003 030f 	and.w	r3, r3, #15
200187fa:	4a0e      	ldr	r2, [pc, #56]	; (20018834 <HAL_RCC_ClockConfig+0x6d0>)
200187fc:	5cd3      	ldrb	r3, [r2, r3]
200187fe:	f003 031f 	and.w	r3, r3, #31
20018802:	693a      	ldr	r2, [r7, #16]
20018804:	fa22 f303 	lsr.w	r3, r2, r3
20018808:	4a0b      	ldr	r2, [pc, #44]	; (20018838 <HAL_RCC_ClockConfig+0x6d4>)
2001880a:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
2001880c:	4a0b      	ldr	r2, [pc, #44]	; (2001883c <HAL_RCC_ClockConfig+0x6d8>)
2001880e:	693b      	ldr	r3, [r7, #16]
20018810:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick (uwTickPrio);
20018812:	4b0b      	ldr	r3, [pc, #44]	; (20018840 <HAL_RCC_ClockConfig+0x6dc>)
20018814:	681b      	ldr	r3, [r3, #0]
20018816:	4618      	mov	r0, r3
20018818:	f7e9 fa1e 	bl	20001c58 <HAL_InitTick>
2001881c:	4603      	mov	r3, r0
2001881e:	73fb      	strb	r3, [r7, #15]

  return halstatus;
20018820:	7bfb      	ldrb	r3, [r7, #15]
}
20018822:	4618      	mov	r0, r3
20018824:	3718      	adds	r7, #24
20018826:	46bd      	mov	sp, r7
20018828:	bd80      	pop	{r7, pc}
2001882a:	bf00      	nop
2001882c:	58024400 	.word	0x58024400
20018830:	2001c2e0 	.word	0x2001c2e0
20018834:	2001bf54 	.word	0x2001bf54
20018838:	2001c97c 	.word	0x2001c97c
2001883c:	2001c978 	.word	0x2001c978
20018840:	2001c980 	.word	0x2001c980

20018844 <HAL_RCC_MCOConfig>:
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
20018844:	b580      	push	{r7, lr}
20018846:	b08c      	sub	sp, #48	; 0x30
20018848:	af00      	add	r7, sp, #0
2001884a:	60f8      	str	r0, [r7, #12]
2001884c:	60b9      	str	r1, [r7, #8]
2001884e:	607a      	str	r2, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
20018850:	68fb      	ldr	r3, [r7, #12]
20018852:	2b00      	cmp	r3, #0
20018854:	d007      	beq.n	20018866 <HAL_RCC_MCOConfig+0x22>
20018856:	68fb      	ldr	r3, [r7, #12]
20018858:	2b01      	cmp	r3, #1
2001885a:	d004      	beq.n	20018866 <HAL_RCC_MCOConfig+0x22>
2001885c:	f240 41e2 	movw	r1, #1250	; 0x4e2
20018860:	486a      	ldr	r0, [pc, #424]	; (20018a0c <HAL_RCC_MCOConfig+0x1c8>)
20018862:	f7e8 f847 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
20018866:	687b      	ldr	r3, [r7, #4]
20018868:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
2001886c:	d03c      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
2001886e:	687b      	ldr	r3, [r7, #4]
20018870:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
20018874:	d038      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
20018876:	687b      	ldr	r3, [r7, #4]
20018878:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
2001887c:	d034      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
2001887e:	687b      	ldr	r3, [r7, #4]
20018880:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
20018884:	d030      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
20018886:	687b      	ldr	r3, [r7, #4]
20018888:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
2001888c:	d02c      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
2001888e:	687b      	ldr	r3, [r7, #4]
20018890:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
20018894:	d028      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
20018896:	687b      	ldr	r3, [r7, #4]
20018898:	f5b3 1fe0 	cmp.w	r3, #1835008	; 0x1c0000
2001889c:	d024      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
2001889e:	687b      	ldr	r3, [r7, #4]
200188a0:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
200188a4:	d020      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
200188a6:	687b      	ldr	r3, [r7, #4]
200188a8:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
200188ac:	d01c      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
200188ae:	687b      	ldr	r3, [r7, #4]
200188b0:	f5b3 1f20 	cmp.w	r3, #2621440	; 0x280000
200188b4:	d018      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
200188b6:	687b      	ldr	r3, [r7, #4]
200188b8:	f5b3 1f30 	cmp.w	r3, #2883584	; 0x2c0000
200188bc:	d014      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
200188be:	687b      	ldr	r3, [r7, #4]
200188c0:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
200188c4:	d010      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
200188c6:	687b      	ldr	r3, [r7, #4]
200188c8:	f5b3 1f50 	cmp.w	r3, #3407872	; 0x340000
200188cc:	d00c      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
200188ce:	687b      	ldr	r3, [r7, #4]
200188d0:	f5b3 1f60 	cmp.w	r3, #3670016	; 0x380000
200188d4:	d008      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
200188d6:	687b      	ldr	r3, [r7, #4]
200188d8:	f5b3 1f70 	cmp.w	r3, #3932160	; 0x3c0000
200188dc:	d004      	beq.n	200188e8 <HAL_RCC_MCOConfig+0xa4>
200188de:	f240 41e3 	movw	r1, #1251	; 0x4e3
200188e2:	484a      	ldr	r0, [pc, #296]	; (20018a0c <HAL_RCC_MCOConfig+0x1c8>)
200188e4:	f7e8 f806 	bl	200008f4 <assert_failed>
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
200188e8:	68fb      	ldr	r3, [r7, #12]
200188ea:	2b00      	cmp	r3, #0
200188ec:	d142      	bne.n	20018974 <HAL_RCC_MCOConfig+0x130>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
200188ee:	68bb      	ldr	r3, [r7, #8]
200188f0:	2b00      	cmp	r3, #0
200188f2:	d014      	beq.n	2001891e <HAL_RCC_MCOConfig+0xda>
200188f4:	68bb      	ldr	r3, [r7, #8]
200188f6:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
200188fa:	d010      	beq.n	2001891e <HAL_RCC_MCOConfig+0xda>
200188fc:	68bb      	ldr	r3, [r7, #8]
200188fe:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
20018902:	d00c      	beq.n	2001891e <HAL_RCC_MCOConfig+0xda>
20018904:	68bb      	ldr	r3, [r7, #8]
20018906:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
2001890a:	d008      	beq.n	2001891e <HAL_RCC_MCOConfig+0xda>
2001890c:	68bb      	ldr	r3, [r7, #8]
2001890e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20018912:	d004      	beq.n	2001891e <HAL_RCC_MCOConfig+0xda>
20018914:	f240 41e7 	movw	r1, #1255	; 0x4e7
20018918:	483c      	ldr	r0, [pc, #240]	; (20018a0c <HAL_RCC_MCOConfig+0x1c8>)
2001891a:	f7e7 ffeb 	bl	200008f4 <assert_failed>

    /* MCO1 Clock Enable */
    MCO1_CLK_ENABLE();
2001891e:	4b3c      	ldr	r3, [pc, #240]	; (20018a10 <HAL_RCC_MCOConfig+0x1cc>)
20018920:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
20018924:	4a3a      	ldr	r2, [pc, #232]	; (20018a10 <HAL_RCC_MCOConfig+0x1cc>)
20018926:	f043 0301 	orr.w	r3, r3, #1
2001892a:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
2001892e:	4b38      	ldr	r3, [pc, #224]	; (20018a10 <HAL_RCC_MCOConfig+0x1cc>)
20018930:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
20018934:	f003 0301 	and.w	r3, r3, #1
20018938:	61bb      	str	r3, [r7, #24]
2001893a:	69bb      	ldr	r3, [r7, #24]

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO1_PIN;
2001893c:	f44f 7380 	mov.w	r3, #256	; 0x100
20018940:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20018942:	2302      	movs	r3, #2
20018944:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
20018946:	2303      	movs	r3, #3
20018948:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
2001894a:	2300      	movs	r3, #0
2001894c:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
2001894e:	2300      	movs	r3, #0
20018950:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
20018952:	f107 031c 	add.w	r3, r7, #28
20018956:	4619      	mov	r1, r3
20018958:	482e      	ldr	r0, [pc, #184]	; (20018a14 <HAL_RCC_MCOConfig+0x1d0>)
2001895a:	f7f3 f985 	bl	2000bc68 <HAL_GPIO_Init>

    /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
2001895e:	4b2c      	ldr	r3, [pc, #176]	; (20018a10 <HAL_RCC_MCOConfig+0x1cc>)
20018960:	691b      	ldr	r3, [r3, #16]
20018962:	f023 72fe 	bic.w	r2, r3, #33292288	; 0x1fc0000
20018966:	68b9      	ldr	r1, [r7, #8]
20018968:	687b      	ldr	r3, [r7, #4]
2001896a:	430b      	orrs	r3, r1
2001896c:	4928      	ldr	r1, [pc, #160]	; (20018a10 <HAL_RCC_MCOConfig+0x1cc>)
2001896e:	4313      	orrs	r3, r2
20018970:	610b      	str	r3, [r1, #16]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);

    /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
  }
}
20018972:	e046      	b.n	20018a02 <HAL_RCC_MCOConfig+0x1be>
    assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
20018974:	68bb      	ldr	r3, [r7, #8]
20018976:	2b00      	cmp	r3, #0
20018978:	d018      	beq.n	200189ac <HAL_RCC_MCOConfig+0x168>
2001897a:	68bb      	ldr	r3, [r7, #8]
2001897c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20018980:	d014      	beq.n	200189ac <HAL_RCC_MCOConfig+0x168>
20018982:	68bb      	ldr	r3, [r7, #8]
20018984:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20018988:	d010      	beq.n	200189ac <HAL_RCC_MCOConfig+0x168>
2001898a:	68bb      	ldr	r3, [r7, #8]
2001898c:	f1b3 4fc0 	cmp.w	r3, #1610612736	; 0x60000000
20018990:	d00c      	beq.n	200189ac <HAL_RCC_MCOConfig+0x168>
20018992:	68bb      	ldr	r3, [r7, #8]
20018994:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
20018998:	d008      	beq.n	200189ac <HAL_RCC_MCOConfig+0x168>
2001899a:	68bb      	ldr	r3, [r7, #8]
2001899c:	f1b3 4f20 	cmp.w	r3, #2684354560	; 0xa0000000
200189a0:	d004      	beq.n	200189ac <HAL_RCC_MCOConfig+0x168>
200189a2:	f240 41f9 	movw	r1, #1273	; 0x4f9
200189a6:	4819      	ldr	r0, [pc, #100]	; (20018a0c <HAL_RCC_MCOConfig+0x1c8>)
200189a8:	f7e7 ffa4 	bl	200008f4 <assert_failed>
    MCO2_CLK_ENABLE();
200189ac:	4b18      	ldr	r3, [pc, #96]	; (20018a10 <HAL_RCC_MCOConfig+0x1cc>)
200189ae:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200189b2:	4a17      	ldr	r2, [pc, #92]	; (20018a10 <HAL_RCC_MCOConfig+0x1cc>)
200189b4:	f043 0304 	orr.w	r3, r3, #4
200189b8:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
200189bc:	4b14      	ldr	r3, [pc, #80]	; (20018a10 <HAL_RCC_MCOConfig+0x1cc>)
200189be:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
200189c2:	f003 0304 	and.w	r3, r3, #4
200189c6:	617b      	str	r3, [r7, #20]
200189c8:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = MCO2_PIN;
200189ca:	f44f 7300 	mov.w	r3, #512	; 0x200
200189ce:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
200189d0:	2302      	movs	r3, #2
200189d2:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
200189d4:	2303      	movs	r3, #3
200189d6:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
200189d8:	2300      	movs	r3, #0
200189da:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
200189dc:	2300      	movs	r3, #0
200189de:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
200189e0:	f107 031c 	add.w	r3, r7, #28
200189e4:	4619      	mov	r1, r3
200189e6:	480c      	ldr	r0, [pc, #48]	; (20018a18 <HAL_RCC_MCOConfig+0x1d4>)
200189e8:	f7f3 f93e 	bl	2000bc68 <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
200189ec:	4b08      	ldr	r3, [pc, #32]	; (20018a10 <HAL_RCC_MCOConfig+0x1cc>)
200189ee:	691b      	ldr	r3, [r3, #16]
200189f0:	f023 427e 	bic.w	r2, r3, #4261412864	; 0xfe000000
200189f4:	687b      	ldr	r3, [r7, #4]
200189f6:	01d9      	lsls	r1, r3, #7
200189f8:	68bb      	ldr	r3, [r7, #8]
200189fa:	430b      	orrs	r3, r1
200189fc:	4904      	ldr	r1, [pc, #16]	; (20018a10 <HAL_RCC_MCOConfig+0x1cc>)
200189fe:	4313      	orrs	r3, r2
20018a00:	610b      	str	r3, [r1, #16]
}
20018a02:	bf00      	nop
20018a04:	3730      	adds	r7, #48	; 0x30
20018a06:	46bd      	mov	sp, r7
20018a08:	bd80      	pop	{r7, pc}
20018a0a:	bf00      	nop
20018a0c:	2001c2e0 	.word	0x2001c2e0
20018a10:	58024400 	.word	0x58024400
20018a14:	58020000 	.word	0x58020000
20018a18:	58020800 	.word	0x58020800

20018a1c <HAL_RCC_EnableCSS>:
  *         allowing the MCU to perform rescue operations. The CSSI is linked to
  *         the Cortex-M NMI (Non-Mask-able Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
20018a1c:	b480      	push	{r7}
20018a1e:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_CSSHSEON) ;
20018a20:	4b05      	ldr	r3, [pc, #20]	; (20018a38 <HAL_RCC_EnableCSS+0x1c>)
20018a22:	681b      	ldr	r3, [r3, #0]
20018a24:	4a04      	ldr	r2, [pc, #16]	; (20018a38 <HAL_RCC_EnableCSS+0x1c>)
20018a26:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
20018a2a:	6013      	str	r3, [r2, #0]
}
20018a2c:	bf00      	nop
20018a2e:	46bd      	mov	sp, r7
20018a30:	f85d 7b04 	ldr.w	r7, [sp], #4
20018a34:	4770      	bx	lr
20018a36:	bf00      	nop
20018a38:	58024400 	.word	0x58024400

20018a3c <HAL_RCC_DisableCSS>:
/**
  * @brief  Disables the Clock Security System.
  * @retval None
  */
void HAL_RCC_DisableCSS(void)
{
20018a3c:	b480      	push	{r7}
20018a3e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_CSSHSEON);
20018a40:	4b05      	ldr	r3, [pc, #20]	; (20018a58 <HAL_RCC_DisableCSS+0x1c>)
20018a42:	681b      	ldr	r3, [r3, #0]
20018a44:	4a04      	ldr	r2, [pc, #16]	; (20018a58 <HAL_RCC_DisableCSS+0x1c>)
20018a46:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
20018a4a:	6013      	str	r3, [r2, #0]
}
20018a4c:	bf00      	nop
20018a4e:	46bd      	mov	sp, r7
20018a50:	f85d 7b04 	ldr.w	r7, [sp], #4
20018a54:	4770      	bx	lr
20018a56:	bf00      	nop
20018a58:	58024400 	.word	0x58024400

20018a5c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
20018a5c:	b480      	push	{r7}
20018a5e:	b089      	sub	sp, #36	; 0x24
20018a60:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
20018a62:	4baf      	ldr	r3, [pc, #700]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018a64:	691b      	ldr	r3, [r3, #16]
20018a66:	f003 0338 	and.w	r3, r3, #56	; 0x38
20018a6a:	2b18      	cmp	r3, #24
20018a6c:	f200 814e 	bhi.w	20018d0c <HAL_RCC_GetSysClockFreq+0x2b0>
20018a70:	a201      	add	r2, pc, #4	; (adr r2, 20018a78 <HAL_RCC_GetSysClockFreq+0x1c>)
20018a72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20018a76:	bf00      	nop
20018a78:	20018add 	.word	0x20018add
20018a7c:	20018d0d 	.word	0x20018d0d
20018a80:	20018d0d 	.word	0x20018d0d
20018a84:	20018d0d 	.word	0x20018d0d
20018a88:	20018d0d 	.word	0x20018d0d
20018a8c:	20018d0d 	.word	0x20018d0d
20018a90:	20018d0d 	.word	0x20018d0d
20018a94:	20018d0d 	.word	0x20018d0d
20018a98:	20018b03 	.word	0x20018b03
20018a9c:	20018d0d 	.word	0x20018d0d
20018aa0:	20018d0d 	.word	0x20018d0d
20018aa4:	20018d0d 	.word	0x20018d0d
20018aa8:	20018d0d 	.word	0x20018d0d
20018aac:	20018d0d 	.word	0x20018d0d
20018ab0:	20018d0d 	.word	0x20018d0d
20018ab4:	20018d0d 	.word	0x20018d0d
20018ab8:	20018b09 	.word	0x20018b09
20018abc:	20018d0d 	.word	0x20018d0d
20018ac0:	20018d0d 	.word	0x20018d0d
20018ac4:	20018d0d 	.word	0x20018d0d
20018ac8:	20018d0d 	.word	0x20018d0d
20018acc:	20018d0d 	.word	0x20018d0d
20018ad0:	20018d0d 	.word	0x20018d0d
20018ad4:	20018d0d 	.word	0x20018d0d
20018ad8:	20018b0f 	.word	0x20018b0f
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
20018adc:	4b90      	ldr	r3, [pc, #576]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018ade:	681b      	ldr	r3, [r3, #0]
20018ae0:	f003 0320 	and.w	r3, r3, #32
20018ae4:	2b00      	cmp	r3, #0
20018ae6:	d009      	beq.n	20018afc <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
20018ae8:	4b8d      	ldr	r3, [pc, #564]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018aea:	681b      	ldr	r3, [r3, #0]
20018aec:	08db      	lsrs	r3, r3, #3
20018aee:	f003 0303 	and.w	r3, r3, #3
20018af2:	4a8c      	ldr	r2, [pc, #560]	; (20018d24 <HAL_RCC_GetSysClockFreq+0x2c8>)
20018af4:	fa22 f303 	lsr.w	r3, r2, r3
20018af8:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

    break;
20018afa:	e10a      	b.n	20018d12 <HAL_RCC_GetSysClockFreq+0x2b6>
        sysclockfreq = (uint32_t) HSI_VALUE;
20018afc:	4b89      	ldr	r3, [pc, #548]	; (20018d24 <HAL_RCC_GetSysClockFreq+0x2c8>)
20018afe:	61bb      	str	r3, [r7, #24]
    break;
20018b00:	e107      	b.n	20018d12 <HAL_RCC_GetSysClockFreq+0x2b6>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
20018b02:	4b89      	ldr	r3, [pc, #548]	; (20018d28 <HAL_RCC_GetSysClockFreq+0x2cc>)
20018b04:	61bb      	str	r3, [r7, #24]
    break;
20018b06:	e104      	b.n	20018d12 <HAL_RCC_GetSysClockFreq+0x2b6>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    sysclockfreq = HSE_VALUE;
20018b08:	4b88      	ldr	r3, [pc, #544]	; (20018d2c <HAL_RCC_GetSysClockFreq+0x2d0>)
20018b0a:	61bb      	str	r3, [r7, #24]
    break;
20018b0c:	e101      	b.n	20018d12 <HAL_RCC_GetSysClockFreq+0x2b6>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
20018b0e:	4b84      	ldr	r3, [pc, #528]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018b10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20018b12:	f003 0303 	and.w	r3, r3, #3
20018b16:	617b      	str	r3, [r7, #20]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
20018b18:	4b81      	ldr	r3, [pc, #516]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018b1a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20018b1c:	091b      	lsrs	r3, r3, #4
20018b1e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
20018b22:	613b      	str	r3, [r7, #16]
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
20018b24:	4b7e      	ldr	r3, [pc, #504]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018b26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20018b28:	f003 0301 	and.w	r3, r3, #1
20018b2c:	60fb      	str	r3, [r7, #12]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
20018b2e:	4b7c      	ldr	r3, [pc, #496]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018b30:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20018b32:	08db      	lsrs	r3, r3, #3
20018b34:	f3c3 030c 	ubfx	r3, r3, #0, #13
20018b38:	68fa      	ldr	r2, [r7, #12]
20018b3a:	fb02 f303 	mul.w	r3, r2, r3
20018b3e:	ee07 3a90 	vmov	s15, r3
20018b42:	eef8 7a67 	vcvt.f32.u32	s15, s15
20018b46:	edc7 7a02 	vstr	s15, [r7, #8]

    if (pllm != 0U)
20018b4a:	693b      	ldr	r3, [r7, #16]
20018b4c:	2b00      	cmp	r3, #0
20018b4e:	f000 80da 	beq.w	20018d06 <HAL_RCC_GetSysClockFreq+0x2aa>
    {
      switch (pllsource)
20018b52:	697b      	ldr	r3, [r7, #20]
20018b54:	2b01      	cmp	r3, #1
20018b56:	d05a      	beq.n	20018c0e <HAL_RCC_GetSysClockFreq+0x1b2>
20018b58:	2b01      	cmp	r3, #1
20018b5a:	d302      	bcc.n	20018b62 <HAL_RCC_GetSysClockFreq+0x106>
20018b5c:	2b02      	cmp	r3, #2
20018b5e:	d078      	beq.n	20018c52 <HAL_RCC_GetSysClockFreq+0x1f6>
20018b60:	e099      	b.n	20018c96 <HAL_RCC_GetSysClockFreq+0x23a>
      {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
20018b62:	4b6f      	ldr	r3, [pc, #444]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018b64:	681b      	ldr	r3, [r3, #0]
20018b66:	f003 0320 	and.w	r3, r3, #32
20018b6a:	2b00      	cmp	r3, #0
20018b6c:	d02d      	beq.n	20018bca <HAL_RCC_GetSysClockFreq+0x16e>
        {
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
20018b6e:	4b6c      	ldr	r3, [pc, #432]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018b70:	681b      	ldr	r3, [r3, #0]
20018b72:	08db      	lsrs	r3, r3, #3
20018b74:	f003 0303 	and.w	r3, r3, #3
20018b78:	4a6a      	ldr	r2, [pc, #424]	; (20018d24 <HAL_RCC_GetSysClockFreq+0x2c8>)
20018b7a:	fa22 f303 	lsr.w	r3, r2, r3
20018b7e:	607b      	str	r3, [r7, #4]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
20018b80:	687b      	ldr	r3, [r7, #4]
20018b82:	ee07 3a90 	vmov	s15, r3
20018b86:	eef8 6a67 	vcvt.f32.u32	s13, s15
20018b8a:	693b      	ldr	r3, [r7, #16]
20018b8c:	ee07 3a90 	vmov	s15, r3
20018b90:	eef8 7a67 	vcvt.f32.u32	s15, s15
20018b94:	ee86 7aa7 	vdiv.f32	s14, s13, s15
20018b98:	4b61      	ldr	r3, [pc, #388]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018b9a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20018b9c:	f3c3 0308 	ubfx	r3, r3, #0, #9
20018ba0:	ee07 3a90 	vmov	s15, r3
20018ba4:	eef8 6a67 	vcvt.f32.u32	s13, s15
20018ba8:	ed97 6a02 	vldr	s12, [r7, #8]
20018bac:	eddf 5a60 	vldr	s11, [pc, #384]	; 20018d30 <HAL_RCC_GetSysClockFreq+0x2d4>
20018bb0:	eec6 7a25 	vdiv.f32	s15, s12, s11
20018bb4:	ee76 7aa7 	vadd.f32	s15, s13, s15
20018bb8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
20018bbc:	ee77 7aa6 	vadd.f32	s15, s15, s13
20018bc0:	ee67 7a27 	vmul.f32	s15, s14, s15
20018bc4:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        }
        break;
20018bc8:	e087      	b.n	20018cda <HAL_RCC_GetSysClockFreq+0x27e>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
20018bca:	693b      	ldr	r3, [r7, #16]
20018bcc:	ee07 3a90 	vmov	s15, r3
20018bd0:	eef8 7a67 	vcvt.f32.u32	s15, s15
20018bd4:	eddf 6a57 	vldr	s13, [pc, #348]	; 20018d34 <HAL_RCC_GetSysClockFreq+0x2d8>
20018bd8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
20018bdc:	4b50      	ldr	r3, [pc, #320]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018bde:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20018be0:	f3c3 0308 	ubfx	r3, r3, #0, #9
20018be4:	ee07 3a90 	vmov	s15, r3
20018be8:	eef8 6a67 	vcvt.f32.u32	s13, s15
20018bec:	ed97 6a02 	vldr	s12, [r7, #8]
20018bf0:	eddf 5a4f 	vldr	s11, [pc, #316]	; 20018d30 <HAL_RCC_GetSysClockFreq+0x2d4>
20018bf4:	eec6 7a25 	vdiv.f32	s15, s12, s11
20018bf8:	ee76 7aa7 	vadd.f32	s15, s13, s15
20018bfc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
20018c00:	ee77 7aa6 	vadd.f32	s15, s15, s13
20018c04:	ee67 7a27 	vmul.f32	s15, s14, s15
20018c08:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
20018c0c:	e065      	b.n	20018cda <HAL_RCC_GetSysClockFreq+0x27e>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
20018c0e:	693b      	ldr	r3, [r7, #16]
20018c10:	ee07 3a90 	vmov	s15, r3
20018c14:	eef8 7a67 	vcvt.f32.u32	s15, s15
20018c18:	eddf 6a47 	vldr	s13, [pc, #284]	; 20018d38 <HAL_RCC_GetSysClockFreq+0x2dc>
20018c1c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
20018c20:	4b3f      	ldr	r3, [pc, #252]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018c22:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20018c24:	f3c3 0308 	ubfx	r3, r3, #0, #9
20018c28:	ee07 3a90 	vmov	s15, r3
20018c2c:	eef8 6a67 	vcvt.f32.u32	s13, s15
20018c30:	ed97 6a02 	vldr	s12, [r7, #8]
20018c34:	eddf 5a3e 	vldr	s11, [pc, #248]	; 20018d30 <HAL_RCC_GetSysClockFreq+0x2d4>
20018c38:	eec6 7a25 	vdiv.f32	s15, s12, s11
20018c3c:	ee76 7aa7 	vadd.f32	s15, s13, s15
20018c40:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
20018c44:	ee77 7aa6 	vadd.f32	s15, s15, s13
20018c48:	ee67 7a27 	vmul.f32	s15, s14, s15
20018c4c:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
20018c50:	e043      	b.n	20018cda <HAL_RCC_GetSysClockFreq+0x27e>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
20018c52:	693b      	ldr	r3, [r7, #16]
20018c54:	ee07 3a90 	vmov	s15, r3
20018c58:	eef8 7a67 	vcvt.f32.u32	s15, s15
20018c5c:	eddf 6a37 	vldr	s13, [pc, #220]	; 20018d3c <HAL_RCC_GetSysClockFreq+0x2e0>
20018c60:	ee86 7aa7 	vdiv.f32	s14, s13, s15
20018c64:	4b2e      	ldr	r3, [pc, #184]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018c66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20018c68:	f3c3 0308 	ubfx	r3, r3, #0, #9
20018c6c:	ee07 3a90 	vmov	s15, r3
20018c70:	eef8 6a67 	vcvt.f32.u32	s13, s15
20018c74:	ed97 6a02 	vldr	s12, [r7, #8]
20018c78:	eddf 5a2d 	vldr	s11, [pc, #180]	; 20018d30 <HAL_RCC_GetSysClockFreq+0x2d4>
20018c7c:	eec6 7a25 	vdiv.f32	s15, s12, s11
20018c80:	ee76 7aa7 	vadd.f32	s15, s13, s15
20018c84:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
20018c88:	ee77 7aa6 	vadd.f32	s15, s15, s13
20018c8c:	ee67 7a27 	vmul.f32	s15, s14, s15
20018c90:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
20018c94:	e021      	b.n	20018cda <HAL_RCC_GetSysClockFreq+0x27e>

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
20018c96:	693b      	ldr	r3, [r7, #16]
20018c98:	ee07 3a90 	vmov	s15, r3
20018c9c:	eef8 7a67 	vcvt.f32.u32	s15, s15
20018ca0:	eddf 6a25 	vldr	s13, [pc, #148]	; 20018d38 <HAL_RCC_GetSysClockFreq+0x2dc>
20018ca4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
20018ca8:	4b1d      	ldr	r3, [pc, #116]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018caa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20018cac:	f3c3 0308 	ubfx	r3, r3, #0, #9
20018cb0:	ee07 3a90 	vmov	s15, r3
20018cb4:	eef8 6a67 	vcvt.f32.u32	s13, s15
20018cb8:	ed97 6a02 	vldr	s12, [r7, #8]
20018cbc:	eddf 5a1c 	vldr	s11, [pc, #112]	; 20018d30 <HAL_RCC_GetSysClockFreq+0x2d4>
20018cc0:	eec6 7a25 	vdiv.f32	s15, s12, s11
20018cc4:	ee76 7aa7 	vadd.f32	s15, s13, s15
20018cc8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
20018ccc:	ee77 7aa6 	vadd.f32	s15, s15, s13
20018cd0:	ee67 7a27 	vmul.f32	s15, s14, s15
20018cd4:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
20018cd8:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
20018cda:	4b11      	ldr	r3, [pc, #68]	; (20018d20 <HAL_RCC_GetSysClockFreq+0x2c4>)
20018cdc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20018cde:	0a5b      	lsrs	r3, r3, #9
20018ce0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20018ce4:	3301      	adds	r3, #1
20018ce6:	603b      	str	r3, [r7, #0]
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
20018ce8:	683b      	ldr	r3, [r7, #0]
20018cea:	ee07 3a90 	vmov	s15, r3
20018cee:	eeb8 7a67 	vcvt.f32.u32	s14, s15
20018cf2:	edd7 6a07 	vldr	s13, [r7, #28]
20018cf6:	eec6 7a87 	vdiv.f32	s15, s13, s14
20018cfa:	eefc 7ae7 	vcvt.u32.f32	s15, s15
20018cfe:	ee17 3a90 	vmov	r3, s15
20018d02:	61bb      	str	r3, [r7, #24]
    }
    else
    {
      sysclockfreq = 0U;
    }
    break;
20018d04:	e005      	b.n	20018d12 <HAL_RCC_GetSysClockFreq+0x2b6>
      sysclockfreq = 0U;
20018d06:	2300      	movs	r3, #0
20018d08:	61bb      	str	r3, [r7, #24]
    break;
20018d0a:	e002      	b.n	20018d12 <HAL_RCC_GetSysClockFreq+0x2b6>

  default:
    sysclockfreq = CSI_VALUE;
20018d0c:	4b06      	ldr	r3, [pc, #24]	; (20018d28 <HAL_RCC_GetSysClockFreq+0x2cc>)
20018d0e:	61bb      	str	r3, [r7, #24]
    break;
20018d10:	bf00      	nop
  }

  return sysclockfreq;
20018d12:	69bb      	ldr	r3, [r7, #24]
}
20018d14:	4618      	mov	r0, r3
20018d16:	3724      	adds	r7, #36	; 0x24
20018d18:	46bd      	mov	sp, r7
20018d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
20018d1e:	4770      	bx	lr
20018d20:	58024400 	.word	0x58024400
20018d24:	03d09000 	.word	0x03d09000
20018d28:	003d0900 	.word	0x003d0900
20018d2c:	016e3600 	.word	0x016e3600
20018d30:	46000000 	.word	0x46000000
20018d34:	4c742400 	.word	0x4c742400
20018d38:	4a742400 	.word	0x4a742400
20018d3c:	4bb71b00 	.word	0x4bb71b00

20018d40 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
20018d40:	b580      	push	{r7, lr}
20018d42:	b082      	sub	sp, #8
20018d44:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
20018d46:	f7ff fe89 	bl	20018a5c <HAL_RCC_GetSysClockFreq>
20018d4a:	4601      	mov	r1, r0
20018d4c:	4b10      	ldr	r3, [pc, #64]	; (20018d90 <HAL_RCC_GetHCLKFreq+0x50>)
20018d4e:	699b      	ldr	r3, [r3, #24]
20018d50:	0a1b      	lsrs	r3, r3, #8
20018d52:	f003 030f 	and.w	r3, r3, #15
20018d56:	4a0f      	ldr	r2, [pc, #60]	; (20018d94 <HAL_RCC_GetHCLKFreq+0x54>)
20018d58:	5cd3      	ldrb	r3, [r2, r3]
20018d5a:	f003 031f 	and.w	r3, r3, #31
20018d5e:	fa21 f303 	lsr.w	r3, r1, r3
20018d62:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
20018d64:	4b0a      	ldr	r3, [pc, #40]	; (20018d90 <HAL_RCC_GetHCLKFreq+0x50>)
20018d66:	699b      	ldr	r3, [r3, #24]
20018d68:	f003 030f 	and.w	r3, r3, #15
20018d6c:	4a09      	ldr	r2, [pc, #36]	; (20018d94 <HAL_RCC_GetHCLKFreq+0x54>)
20018d6e:	5cd3      	ldrb	r3, [r2, r3]
20018d70:	f003 031f 	and.w	r3, r3, #31
20018d74:	687a      	ldr	r2, [r7, #4]
20018d76:	fa22 f303 	lsr.w	r3, r2, r3
20018d7a:	4a07      	ldr	r2, [pc, #28]	; (20018d98 <HAL_RCC_GetHCLKFreq+0x58>)
20018d7c:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
20018d7e:	4a07      	ldr	r2, [pc, #28]	; (20018d9c <HAL_RCC_GetHCLKFreq+0x5c>)
20018d80:	687b      	ldr	r3, [r7, #4]
20018d82:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
20018d84:	4b04      	ldr	r3, [pc, #16]	; (20018d98 <HAL_RCC_GetHCLKFreq+0x58>)
20018d86:	681b      	ldr	r3, [r3, #0]
}
20018d88:	4618      	mov	r0, r3
20018d8a:	3708      	adds	r7, #8
20018d8c:	46bd      	mov	sp, r7
20018d8e:	bd80      	pop	{r7, pc}
20018d90:	58024400 	.word	0x58024400
20018d94:	2001bf54 	.word	0x2001bf54
20018d98:	2001c97c 	.word	0x2001c97c
20018d9c:	2001c978 	.word	0x2001c978

20018da0 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
20018da0:	b580      	push	{r7, lr}
20018da2:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1)>> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
20018da4:	f7ff ffcc 	bl	20018d40 <HAL_RCC_GetHCLKFreq>
20018da8:	4601      	mov	r1, r0
20018daa:	4b06      	ldr	r3, [pc, #24]	; (20018dc4 <HAL_RCC_GetPCLK1Freq+0x24>)
20018dac:	69db      	ldr	r3, [r3, #28]
20018dae:	091b      	lsrs	r3, r3, #4
20018db0:	f003 0307 	and.w	r3, r3, #7
20018db4:	4a04      	ldr	r2, [pc, #16]	; (20018dc8 <HAL_RCC_GetPCLK1Freq+0x28>)
20018db6:	5cd3      	ldrb	r3, [r2, r3]
20018db8:	f003 031f 	and.w	r3, r3, #31
20018dbc:	fa21 f303 	lsr.w	r3, r1, r3
#else
 /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1)>> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
20018dc0:	4618      	mov	r0, r3
20018dc2:	bd80      	pop	{r7, pc}
20018dc4:	58024400 	.word	0x58024400
20018dc8:	2001bf54 	.word	0x2001bf54

20018dcc <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
20018dcc:	b580      	push	{r7, lr}
20018dce:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
20018dd0:	f7ff ffb6 	bl	20018d40 <HAL_RCC_GetHCLKFreq>
20018dd4:	4601      	mov	r1, r0
20018dd6:	4b06      	ldr	r3, [pc, #24]	; (20018df0 <HAL_RCC_GetPCLK2Freq+0x24>)
20018dd8:	69db      	ldr	r3, [r3, #28]
20018dda:	0a1b      	lsrs	r3, r3, #8
20018ddc:	f003 0307 	and.w	r3, r3, #7
20018de0:	4a04      	ldr	r2, [pc, #16]	; (20018df4 <HAL_RCC_GetPCLK2Freq+0x28>)
20018de2:	5cd3      	ldrb	r3, [r2, r3]
20018de4:	f003 031f 	and.w	r3, r3, #31
20018de8:	fa21 f303 	lsr.w	r3, r1, r3
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
20018dec:	4618      	mov	r0, r3
20018dee:	bd80      	pop	{r7, pc}
20018df0:	58024400 	.word	0x58024400
20018df4:	2001bf54 	.word	0x2001bf54

20018df8 <HAL_RCC_GetOscConfig>:
  * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
  * will be configured.
  * @retval None
  */
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
20018df8:	b580      	push	{r7, lr}
20018dfa:	b082      	sub	sp, #8
20018dfc:	af00      	add	r7, sp, #0
20018dfe:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \
20018e00:	687b      	ldr	r3, [r7, #4]
20018e02:	223f      	movs	r2, #63	; 0x3f
20018e04:	601a      	str	r2, [r3, #0]
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }
#else
  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
20018e06:	4b72      	ldr	r3, [pc, #456]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018e08:	681b      	ldr	r3, [r3, #0]
20018e0a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
20018e0e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
20018e12:	d104      	bne.n	20018e1e <HAL_RCC_GetOscConfig+0x26>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
20018e14:	687b      	ldr	r3, [r7, #4]
20018e16:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
20018e1a:	605a      	str	r2, [r3, #4]
20018e1c:	e00e      	b.n	20018e3c <HAL_RCC_GetOscConfig+0x44>
  }
  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
20018e1e:	4b6c      	ldr	r3, [pc, #432]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018e20:	681b      	ldr	r3, [r3, #0]
20018e22:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20018e26:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20018e2a:	d104      	bne.n	20018e36 <HAL_RCC_GetOscConfig+0x3e>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
20018e2c:	687b      	ldr	r3, [r7, #4]
20018e2e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
20018e32:	605a      	str	r2, [r3, #4]
20018e34:	e002      	b.n	20018e3c <HAL_RCC_GetOscConfig+0x44>
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
20018e36:	687b      	ldr	r3, [r7, #4]
20018e38:	2200      	movs	r2, #0
20018e3a:	605a      	str	r2, [r3, #4]
  }
#endif /* RCC_CR_HSEEXT */

   /* Get the CSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_CSION) == RCC_CR_CSION)
20018e3c:	4b64      	ldr	r3, [pc, #400]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018e3e:	681b      	ldr	r3, [r3, #0]
20018e40:	f003 0380 	and.w	r3, r3, #128	; 0x80
20018e44:	2b80      	cmp	r3, #128	; 0x80
20018e46:	d103      	bne.n	20018e50 <HAL_RCC_GetOscConfig+0x58>
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_ON;
20018e48:	687b      	ldr	r3, [r7, #4]
20018e4a:	2280      	movs	r2, #128	; 0x80
20018e4c:	61da      	str	r2, [r3, #28]
20018e4e:	e002      	b.n	20018e56 <HAL_RCC_GetOscConfig+0x5e>
  }
  else
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_OFF;
20018e50:	687b      	ldr	r3, [r7, #4]
20018e52:	2200      	movs	r2, #0
20018e54:	61da      	str	r2, [r3, #28]
  }

#if defined(RCC_VER_X)
  if(HAL_GetREVID() <= REV_ID_Y)
20018e56:	f7e8 fff1 	bl	20001e3c <HAL_GetREVID>
20018e5a:	4602      	mov	r2, r0
20018e5c:	f241 0303 	movw	r3, #4099	; 0x1003
20018e60:	429a      	cmp	r2, r3
20018e62:	d807      	bhi.n	20018e74 <HAL_RCC_GetOscConfig+0x7c>
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_CSITRIM_Msk) >> HAL_RCC_REV_Y_CSITRIM_Pos);
20018e64:	4b5a      	ldr	r3, [pc, #360]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018e66:	685b      	ldr	r3, [r3, #4]
20018e68:	0e9b      	lsrs	r3, r3, #26
20018e6a:	f003 021f 	and.w	r2, r3, #31
20018e6e:	687b      	ldr	r3, [r7, #4]
20018e70:	621a      	str	r2, [r3, #32]
20018e72:	e006      	b.n	20018e82 <HAL_RCC_GetOscConfig+0x8a>
  }
  else
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
20018e74:	4b56      	ldr	r3, [pc, #344]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018e76:	68db      	ldr	r3, [r3, #12]
20018e78:	0e1b      	lsrs	r3, r3, #24
20018e7a:	f003 023f 	and.w	r2, r3, #63	; 0x3f
20018e7e:	687b      	ldr	r3, [r7, #4]
20018e80:	621a      	str	r2, [r3, #32]
#else
 RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
#endif /*RCC_VER_X*/

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
20018e82:	4b53      	ldr	r3, [pc, #332]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018e84:	681b      	ldr	r3, [r3, #0]
20018e86:	f003 0301 	and.w	r3, r3, #1
20018e8a:	2b01      	cmp	r3, #1
20018e8c:	d103      	bne.n	20018e96 <HAL_RCC_GetOscConfig+0x9e>
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
20018e8e:	687b      	ldr	r3, [r7, #4]
20018e90:	2201      	movs	r2, #1
20018e92:	60da      	str	r2, [r3, #12]
20018e94:	e002      	b.n	20018e9c <HAL_RCC_GetOscConfig+0xa4>
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
20018e96:	687b      	ldr	r3, [r7, #4]
20018e98:	2200      	movs	r2, #0
20018e9a:	60da      	str	r2, [r3, #12]
  }

#if defined(RCC_VER_X)
  if(HAL_GetREVID() <= REV_ID_Y)
20018e9c:	f7e8 ffce 	bl	20001e3c <HAL_GetREVID>
20018ea0:	4602      	mov	r2, r0
20018ea2:	f241 0303 	movw	r3, #4099	; 0x1003
20018ea6:	429a      	cmp	r2, r3
20018ea8:	d807      	bhi.n	20018eba <HAL_RCC_GetOscConfig+0xc2>
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_HSITRIM_Msk) >> HAL_RCC_REV_Y_HSITRIM_Pos);
20018eaa:	4b49      	ldr	r3, [pc, #292]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018eac:	685b      	ldr	r3, [r3, #4]
20018eae:	0b1b      	lsrs	r3, r3, #12
20018eb0:	f003 023f 	and.w	r2, r3, #63	; 0x3f
20018eb4:	687b      	ldr	r3, [r7, #4]
20018eb6:	611a      	str	r2, [r3, #16]
20018eb8:	e006      	b.n	20018ec8 <HAL_RCC_GetOscConfig+0xd0>
  }
  else
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
20018eba:	4b45      	ldr	r3, [pc, #276]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018ebc:	685b      	ldr	r3, [r3, #4]
20018ebe:	0e1b      	lsrs	r3, r3, #24
20018ec0:	f003 027f 	and.w	r2, r3, #127	; 0x7f
20018ec4:	687b      	ldr	r3, [r7, #4]
20018ec6:	611a      	str	r2, [r3, #16]
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
  }
#else
  if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
20018ec8:	4b41      	ldr	r3, [pc, #260]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018eca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20018ecc:	f003 0304 	and.w	r3, r3, #4
20018ed0:	2b04      	cmp	r3, #4
20018ed2:	d103      	bne.n	20018edc <HAL_RCC_GetOscConfig+0xe4>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
20018ed4:	687b      	ldr	r3, [r7, #4]
20018ed6:	2205      	movs	r2, #5
20018ed8:	609a      	str	r2, [r3, #8]
20018eda:	e00c      	b.n	20018ef6 <HAL_RCC_GetOscConfig+0xfe>
  }
  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
20018edc:	4b3c      	ldr	r3, [pc, #240]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018ede:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20018ee0:	f003 0301 	and.w	r3, r3, #1
20018ee4:	2b01      	cmp	r3, #1
20018ee6:	d103      	bne.n	20018ef0 <HAL_RCC_GetOscConfig+0xf8>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
20018ee8:	687b      	ldr	r3, [r7, #4]
20018eea:	2201      	movs	r2, #1
20018eec:	609a      	str	r2, [r3, #8]
20018eee:	e002      	b.n	20018ef6 <HAL_RCC_GetOscConfig+0xfe>
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
20018ef0:	687b      	ldr	r3, [r7, #4]
20018ef2:	2200      	movs	r2, #0
20018ef4:	609a      	str	r2, [r3, #8]
  }
#endif /* RCC_BDCR_LSEEXT */

  /* Get the LSI configuration -----------------------------------------------*/
  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
20018ef6:	4b36      	ldr	r3, [pc, #216]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018ef8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20018efa:	f003 0301 	and.w	r3, r3, #1
20018efe:	2b01      	cmp	r3, #1
20018f00:	d103      	bne.n	20018f0a <HAL_RCC_GetOscConfig+0x112>
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
20018f02:	687b      	ldr	r3, [r7, #4]
20018f04:	2201      	movs	r2, #1
20018f06:	615a      	str	r2, [r3, #20]
20018f08:	e002      	b.n	20018f10 <HAL_RCC_GetOscConfig+0x118>
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
20018f0a:	687b      	ldr	r3, [r7, #4]
20018f0c:	2200      	movs	r2, #0
20018f0e:	615a      	str	r2, [r3, #20]
  }

  /* Get the HSI48 configuration ---------------------------------------------*/
  if((RCC->CR & RCC_CR_HSI48ON) == RCC_CR_HSI48ON)
20018f10:	4b2f      	ldr	r3, [pc, #188]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018f12:	681b      	ldr	r3, [r3, #0]
20018f14:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
20018f18:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20018f1c:	d103      	bne.n	20018f26 <HAL_RCC_GetOscConfig+0x12e>
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
20018f1e:	687b      	ldr	r3, [r7, #4]
20018f20:	2201      	movs	r2, #1
20018f22:	619a      	str	r2, [r3, #24]
20018f24:	e002      	b.n	20018f2c <HAL_RCC_GetOscConfig+0x134>
  }
  else
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
20018f26:	687b      	ldr	r3, [r7, #4]
20018f28:	2200      	movs	r2, #0
20018f2a:	619a      	str	r2, [r3, #24]
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
20018f2c:	4b28      	ldr	r3, [pc, #160]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018f2e:	681b      	ldr	r3, [r3, #0]
20018f30:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
20018f34:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20018f38:	d103      	bne.n	20018f42 <HAL_RCC_GetOscConfig+0x14a>
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
20018f3a:	687b      	ldr	r3, [r7, #4]
20018f3c:	2202      	movs	r2, #2
20018f3e:	625a      	str	r2, [r3, #36]	; 0x24
20018f40:	e002      	b.n	20018f48 <HAL_RCC_GetOscConfig+0x150>
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
20018f42:	687b      	ldr	r3, [r7, #4]
20018f44:	2201      	movs	r2, #1
20018f46:	625a      	str	r2, [r3, #36]	; 0x24
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
20018f48:	4b21      	ldr	r3, [pc, #132]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018f4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20018f4c:	f003 0203 	and.w	r2, r3, #3
20018f50:	687b      	ldr	r3, [r7, #4]
20018f52:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> RCC_PLLCKSELR_DIVM1_Pos);
20018f54:	4b1e      	ldr	r3, [pc, #120]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018f56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20018f58:	091b      	lsrs	r3, r3, #4
20018f5a:	f003 023f 	and.w	r2, r3, #63	; 0x3f
20018f5e:	687b      	ldr	r3, [r7, #4]
20018f60:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_N1) >> RCC_PLL1DIVR_N1_Pos)+ 1U;
20018f62:	4b1b      	ldr	r3, [pc, #108]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018f64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20018f66:	f3c3 0308 	ubfx	r3, r3, #0, #9
20018f6a:	1c5a      	adds	r2, r3, #1
20018f6c:	687b      	ldr	r3, [r7, #4]
20018f6e:	631a      	str	r2, [r3, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos)+ 1U;
20018f70:	4b17      	ldr	r3, [pc, #92]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018f72:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20018f74:	0e1b      	lsrs	r3, r3, #24
20018f76:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20018f7a:	1c5a      	adds	r2, r3, #1
20018f7c:	687b      	ldr	r3, [r7, #4]
20018f7e:	63da      	str	r2, [r3, #60]	; 0x3c
  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos)+ 1U;
20018f80:	4b13      	ldr	r3, [pc, #76]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018f82:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20018f84:	0a5b      	lsrs	r3, r3, #9
20018f86:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20018f8a:	1c5a      	adds	r2, r3, #1
20018f8c:	687b      	ldr	r3, [r7, #4]
20018f8e:	635a      	str	r2, [r3, #52]	; 0x34
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos)+ 1U;
20018f90:	4b0f      	ldr	r3, [pc, #60]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018f92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20018f94:	0c1b      	lsrs	r3, r3, #16
20018f96:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20018f9a:	1c5a      	adds	r2, r3, #1
20018f9c:	687b      	ldr	r3, [r7, #4]
20018f9e:	639a      	str	r2, [r3, #56]	; 0x38
  RCC_OscInitStruct->PLL.PLLRGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1RGE));
20018fa0:	4b0b      	ldr	r3, [pc, #44]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018fa2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20018fa4:	f003 020c 	and.w	r2, r3, #12
20018fa8:	687b      	ldr	r3, [r7, #4]
20018faa:	641a      	str	r2, [r3, #64]	; 0x40
  RCC_OscInitStruct->PLL.PLLVCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1VCOSEL) >> RCC_PLLCFGR_PLL1VCOSEL_Pos);
20018fac:	4b08      	ldr	r3, [pc, #32]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018fae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20018fb0:	085b      	lsrs	r3, r3, #1
20018fb2:	f003 0201 	and.w	r2, r3, #1
20018fb6:	687b      	ldr	r3, [r7, #4]
20018fb8:	645a      	str	r2, [r3, #68]	; 0x44
  RCC_OscInitStruct->PLL.PLLFRACN = (uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos));
20018fba:	4b05      	ldr	r3, [pc, #20]	; (20018fd0 <HAL_RCC_GetOscConfig+0x1d8>)
20018fbc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20018fbe:	08db      	lsrs	r3, r3, #3
20018fc0:	f3c3 020c 	ubfx	r2, r3, #0, #13
20018fc4:	687b      	ldr	r3, [r7, #4]
20018fc6:	649a      	str	r2, [r3, #72]	; 0x48
}
20018fc8:	bf00      	nop
20018fca:	3708      	adds	r7, #8
20018fcc:	46bd      	mov	sp, r7
20018fce:	bd80      	pop	{r7, pc}
20018fd0:	58024400 	.word	0x58024400

20018fd4 <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
20018fd4:	b480      	push	{r7}
20018fd6:	b083      	sub	sp, #12
20018fd8:	af00      	add	r7, sp, #0
20018fda:	6078      	str	r0, [r7, #4]
20018fdc:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
20018fde:	687b      	ldr	r3, [r7, #4]
20018fe0:	223f      	movs	r2, #63	; 0x3f
20018fe2:	601a      	str	r2, [r3, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
20018fe4:	4b1a      	ldr	r3, [pc, #104]	; (20019050 <HAL_RCC_GetClockConfig+0x7c>)
20018fe6:	691b      	ldr	r3, [r3, #16]
20018fe8:	f003 0207 	and.w	r2, r3, #7
20018fec:	687b      	ldr	r3, [r7, #4]
20018fee:	605a      	str	r2, [r3, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
20018ff0:	4b17      	ldr	r3, [pc, #92]	; (20019050 <HAL_RCC_GetClockConfig+0x7c>)
20018ff2:	699b      	ldr	r3, [r3, #24]
20018ff4:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
20018ff8:	687b      	ldr	r3, [r7, #4]
20018ffa:	609a      	str	r2, [r3, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
20018ffc:	4b14      	ldr	r3, [pc, #80]	; (20019050 <HAL_RCC_GetClockConfig+0x7c>)
20018ffe:	699b      	ldr	r3, [r3, #24]
20019000:	f003 020f 	and.w	r2, r3, #15
20019004:	687b      	ldr	r3, [r7, #4]
20019006:	60da      	str	r2, [r3, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
20019008:	4b11      	ldr	r3, [pc, #68]	; (20019050 <HAL_RCC_GetClockConfig+0x7c>)
2001900a:	699b      	ldr	r3, [r3, #24]
2001900c:	f003 0270 	and.w	r2, r3, #112	; 0x70
20019010:	687b      	ldr	r3, [r7, #4]
20019012:	611a      	str	r2, [r3, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
20019014:	4b0e      	ldr	r3, [pc, #56]	; (20019050 <HAL_RCC_GetClockConfig+0x7c>)
20019016:	69db      	ldr	r3, [r3, #28]
20019018:	f003 0270 	and.w	r2, r3, #112	; 0x70
2001901c:	687b      	ldr	r3, [r7, #4]
2001901e:	615a      	str	r2, [r3, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
20019020:	4b0b      	ldr	r3, [pc, #44]	; (20019050 <HAL_RCC_GetClockConfig+0x7c>)
20019022:	69db      	ldr	r3, [r3, #28]
20019024:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
20019028:	687b      	ldr	r3, [r7, #4]
2001902a:	619a      	str	r2, [r3, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
2001902c:	4b08      	ldr	r3, [pc, #32]	; (20019050 <HAL_RCC_GetClockConfig+0x7c>)
2001902e:	6a1b      	ldr	r3, [r3, #32]
20019030:	f003 0270 	and.w	r2, r3, #112	; 0x70
20019034:	687b      	ldr	r3, [r7, #4]
20019036:	61da      	str	r2, [r3, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
20019038:	4b06      	ldr	r3, [pc, #24]	; (20019054 <HAL_RCC_GetClockConfig+0x80>)
2001903a:	681b      	ldr	r3, [r3, #0]
2001903c:	f003 020f 	and.w	r2, r3, #15
20019040:	683b      	ldr	r3, [r7, #0]
20019042:	601a      	str	r2, [r3, #0]
}
20019044:	bf00      	nop
20019046:	370c      	adds	r7, #12
20019048:	46bd      	mov	sp, r7
2001904a:	f85d 7b04 	ldr.w	r7, [sp], #4
2001904e:	4770      	bx	lr
20019050:	58024400 	.word	0x58024400
20019054:	52002000 	.word	0x52002000

20019058 <HAL_RCC_NMI_IRQHandler>:
  * @brief This function handles the RCC CSS interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
20019058:	b580      	push	{r7, lr}
2001905a:	af00      	add	r7, sp, #0
  /* Check RCC CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
2001905c:	4b07      	ldr	r3, [pc, #28]	; (2001907c <HAL_RCC_NMI_IRQHandler+0x24>)
2001905e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20019060:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20019064:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20019068:	d105      	bne.n	20019076 <HAL_RCC_NMI_IRQHandler+0x1e>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CCSCallback();
2001906a:	f000 f809 	bl	20019080 <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
2001906e:	4b03      	ldr	r3, [pc, #12]	; (2001907c <HAL_RCC_NMI_IRQHandler+0x24>)
20019070:	f44f 6280 	mov.w	r2, #1024	; 0x400
20019074:	669a      	str	r2, [r3, #104]	; 0x68
  }
}
20019076:	bf00      	nop
20019078:	bd80      	pop	{r7, pc}
2001907a:	bf00      	nop
2001907c:	58024400 	.word	0x58024400

20019080 <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback
  * @retval none
  */
__weak void HAL_RCC_CCSCallback(void)
{
20019080:	b480      	push	{r7}
20019082:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CCSCallback could be implemented in the user file
   */
}
20019084:	bf00      	nop
20019086:	46bd      	mov	sp, r7
20019088:	f85d 7b04 	ldr.w	r7, [sp], #4
2001908c:	4770      	bx	lr
	...

20019090 <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
20019090:	b580      	push	{r7, lr}
20019092:	b086      	sub	sp, #24
20019094:	af00      	add	r7, sp, #0
20019096:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
20019098:	2300      	movs	r3, #0
2001909a:	75fb      	strb	r3, [r7, #23]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
2001909c:	2300      	movs	r3, #0
2001909e:	75bb      	strb	r3, [r7, #22]

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
200190a0:	687b      	ldr	r3, [r7, #4]
200190a2:	681b      	ldr	r3, [r3, #0]
200190a4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
200190a8:	2b00      	cmp	r3, #0
200190aa:	d03d      	beq.n	20019128 <HAL_RCCEx_PeriphCLKConfig+0x98>
  {

    switch(PeriphClkInit->SpdifrxClockSelection)
200190ac:	687b      	ldr	r3, [r7, #4]
200190ae:	6e5b      	ldr	r3, [r3, #100]	; 0x64
200190b0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
200190b4:	d013      	beq.n	200190de <HAL_RCCEx_PeriphCLKConfig+0x4e>
200190b6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
200190ba:	d802      	bhi.n	200190c2 <HAL_RCCEx_PeriphCLKConfig+0x32>
200190bc:	2b00      	cmp	r3, #0
200190be:	d007      	beq.n	200190d0 <HAL_RCCEx_PeriphCLKConfig+0x40>
200190c0:	e01f      	b.n	20019102 <HAL_RCCEx_PeriphCLKConfig+0x72>
200190c2:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
200190c6:	d013      	beq.n	200190f0 <HAL_RCCEx_PeriphCLKConfig+0x60>
200190c8:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
200190cc:	d01c      	beq.n	20019108 <HAL_RCCEx_PeriphCLKConfig+0x78>
200190ce:	e018      	b.n	20019102 <HAL_RCCEx_PeriphCLKConfig+0x72>
    {
    case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
      /* Enable PLL1Q Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
200190d0:	4baf      	ldr	r3, [pc, #700]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
200190d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200190d4:	4aae      	ldr	r2, [pc, #696]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
200190d6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
200190da:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
200190dc:	e015      	b.n	2001910a <HAL_RCCEx_PeriphCLKConfig+0x7a>

    case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
200190de:	687b      	ldr	r3, [r7, #4]
200190e0:	3304      	adds	r3, #4
200190e2:	2102      	movs	r1, #2
200190e4:	4618      	mov	r0, r3
200190e6:	f002 fc1b 	bl	2001b920 <RCCEx_PLL2_Config>
200190ea:	4603      	mov	r3, r0
200190ec:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
200190ee:	e00c      	b.n	2001910a <HAL_RCCEx_PeriphCLKConfig+0x7a>

    case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
200190f0:	687b      	ldr	r3, [r7, #4]
200190f2:	3324      	adds	r3, #36	; 0x24
200190f4:	2102      	movs	r1, #2
200190f6:	4618      	mov	r0, r3
200190f8:	f002 fd34 	bl	2001bb64 <RCCEx_PLL3_Config>
200190fc:	4603      	mov	r3, r0
200190fe:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
20019100:	e003      	b.n	2001910a <HAL_RCCEx_PeriphCLKConfig+0x7a>
      /* Internal OSC clock is used as source of SPDIFRX clock*/
      /* SPDIFRX clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
20019102:	2301      	movs	r3, #1
20019104:	75fb      	strb	r3, [r7, #23]
      break;
20019106:	e000      	b.n	2001910a <HAL_RCCEx_PeriphCLKConfig+0x7a>
      break;
20019108:	bf00      	nop
    }

    if(ret == HAL_OK)
2001910a:	7dfb      	ldrb	r3, [r7, #23]
2001910c:	2b00      	cmp	r3, #0
2001910e:	d109      	bne.n	20019124 <HAL_RCCEx_PeriphCLKConfig+0x94>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
20019110:	4b9f      	ldr	r3, [pc, #636]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
20019112:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20019114:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
20019118:	687b      	ldr	r3, [r7, #4]
2001911a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2001911c:	499c      	ldr	r1, [pc, #624]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2001911e:	4313      	orrs	r3, r2
20019120:	650b      	str	r3, [r1, #80]	; 0x50
20019122:	e001      	b.n	20019128 <HAL_RCCEx_PeriphCLKConfig+0x98>
    }
    else
    {
      /* set overall return value */
      status = ret;
20019124:	7dfb      	ldrb	r3, [r7, #23]
20019126:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
20019128:	687b      	ldr	r3, [r7, #4]
2001912a:	681b      	ldr	r3, [r3, #0]
2001912c:	f403 7380 	and.w	r3, r3, #256	; 0x100
20019130:	2b00      	cmp	r3, #0
20019132:	d03d      	beq.n	200191b0 <HAL_RCCEx_PeriphCLKConfig+0x120>
  {
    switch(PeriphClkInit->Sai1ClockSelection)
20019134:	687b      	ldr	r3, [r7, #4]
20019136:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20019138:	2b04      	cmp	r3, #4
2001913a:	d826      	bhi.n	2001918a <HAL_RCCEx_PeriphCLKConfig+0xfa>
2001913c:	a201      	add	r2, pc, #4	; (adr r2, 20019144 <HAL_RCCEx_PeriphCLKConfig+0xb4>)
2001913e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20019142:	bf00      	nop
20019144:	20019159 	.word	0x20019159
20019148:	20019167 	.word	0x20019167
2001914c:	20019179 	.word	0x20019179
20019150:	20019191 	.word	0x20019191
20019154:	20019191 	.word	0x20019191
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
20019158:	4b8d      	ldr	r3, [pc, #564]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2001915a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001915c:	4a8c      	ldr	r2, [pc, #560]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2001915e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
20019162:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
20019164:	e015      	b.n	20019192 <HAL_RCCEx_PeriphCLKConfig+0x102>

    case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
20019166:	687b      	ldr	r3, [r7, #4]
20019168:	3304      	adds	r3, #4
2001916a:	2100      	movs	r1, #0
2001916c:	4618      	mov	r0, r3
2001916e:	f002 fbd7 	bl	2001b920 <RCCEx_PLL2_Config>
20019172:	4603      	mov	r3, r0
20019174:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
20019176:	e00c      	b.n	20019192 <HAL_RCCEx_PeriphCLKConfig+0x102>

    case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
20019178:	687b      	ldr	r3, [r7, #4]
2001917a:	3324      	adds	r3, #36	; 0x24
2001917c:	2100      	movs	r1, #0
2001917e:	4618      	mov	r0, r3
20019180:	f002 fcf0 	bl	2001bb64 <RCCEx_PLL3_Config>
20019184:	4603      	mov	r3, r0
20019186:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
20019188:	e003      	b.n	20019192 <HAL_RCCEx_PeriphCLKConfig+0x102>
      /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2001918a:	2301      	movs	r3, #1
2001918c:	75fb      	strb	r3, [r7, #23]
      break;
2001918e:	e000      	b.n	20019192 <HAL_RCCEx_PeriphCLKConfig+0x102>
      break;
20019190:	bf00      	nop
    }

    if(ret == HAL_OK)
20019192:	7dfb      	ldrb	r3, [r7, #23]
20019194:	2b00      	cmp	r3, #0
20019196:	d109      	bne.n	200191ac <HAL_RCCEx_PeriphCLKConfig+0x11c>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
20019198:	4b7d      	ldr	r3, [pc, #500]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2001919a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001919c:	f023 0207 	bic.w	r2, r3, #7
200191a0:	687b      	ldr	r3, [r7, #4]
200191a2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
200191a4:	497a      	ldr	r1, [pc, #488]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
200191a6:	4313      	orrs	r3, r2
200191a8:	650b      	str	r3, [r1, #80]	; 0x50
200191aa:	e001      	b.n	200191b0 <HAL_RCCEx_PeriphCLKConfig+0x120>
    }
    else
    {
      /* set overall return value */
      status = ret;
200191ac:	7dfb      	ldrb	r3, [r7, #23]
200191ae:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
200191b0:	687b      	ldr	r3, [r7, #4]
200191b2:	681b      	ldr	r3, [r3, #0]
200191b4:	f403 7300 	and.w	r3, r3, #512	; 0x200
200191b8:	2b00      	cmp	r3, #0
200191ba:	d03e      	beq.n	2001923a <HAL_RCCEx_PeriphCLKConfig+0x1aa>
  {
    switch(PeriphClkInit->Sai23ClockSelection)
200191bc:	687b      	ldr	r3, [r7, #4]
200191be:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200191c0:	2b80      	cmp	r3, #128	; 0x80
200191c2:	d01c      	beq.n	200191fe <HAL_RCCEx_PeriphCLKConfig+0x16e>
200191c4:	2b80      	cmp	r3, #128	; 0x80
200191c6:	d804      	bhi.n	200191d2 <HAL_RCCEx_PeriphCLKConfig+0x142>
200191c8:	2b00      	cmp	r3, #0
200191ca:	d008      	beq.n	200191de <HAL_RCCEx_PeriphCLKConfig+0x14e>
200191cc:	2b40      	cmp	r3, #64	; 0x40
200191ce:	d00d      	beq.n	200191ec <HAL_RCCEx_PeriphCLKConfig+0x15c>
200191d0:	e01e      	b.n	20019210 <HAL_RCCEx_PeriphCLKConfig+0x180>
200191d2:	2bc0      	cmp	r3, #192	; 0xc0
200191d4:	d01f      	beq.n	20019216 <HAL_RCCEx_PeriphCLKConfig+0x186>
200191d6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
200191da:	d01e      	beq.n	2001921a <HAL_RCCEx_PeriphCLKConfig+0x18a>
200191dc:	e018      	b.n	20019210 <HAL_RCCEx_PeriphCLKConfig+0x180>
    {
    case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
200191de:	4b6c      	ldr	r3, [pc, #432]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
200191e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200191e2:	4a6b      	ldr	r2, [pc, #428]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
200191e4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
200191e8:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
200191ea:	e017      	b.n	2001921c <HAL_RCCEx_PeriphCLKConfig+0x18c>

    case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
200191ec:	687b      	ldr	r3, [r7, #4]
200191ee:	3304      	adds	r3, #4
200191f0:	2100      	movs	r1, #0
200191f2:	4618      	mov	r0, r3
200191f4:	f002 fb94 	bl	2001b920 <RCCEx_PLL2_Config>
200191f8:	4603      	mov	r3, r0
200191fa:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
200191fc:	e00e      	b.n	2001921c <HAL_RCCEx_PeriphCLKConfig+0x18c>

    case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
200191fe:	687b      	ldr	r3, [r7, #4]
20019200:	3324      	adds	r3, #36	; 0x24
20019202:	2100      	movs	r1, #0
20019204:	4618      	mov	r0, r3
20019206:	f002 fcad 	bl	2001bb64 <RCCEx_PLL3_Config>
2001920a:	4603      	mov	r3, r0
2001920c:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
2001920e:	e005      	b.n	2001921c <HAL_RCCEx_PeriphCLKConfig+0x18c>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
      /* SAI2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
20019210:	2301      	movs	r3, #1
20019212:	75fb      	strb	r3, [r7, #23]
      break;
20019214:	e002      	b.n	2001921c <HAL_RCCEx_PeriphCLKConfig+0x18c>
      break;
20019216:	bf00      	nop
20019218:	e000      	b.n	2001921c <HAL_RCCEx_PeriphCLKConfig+0x18c>
      break;
2001921a:	bf00      	nop
    }

    if(ret == HAL_OK)
2001921c:	7dfb      	ldrb	r3, [r7, #23]
2001921e:	2b00      	cmp	r3, #0
20019220:	d109      	bne.n	20019236 <HAL_RCCEx_PeriphCLKConfig+0x1a6>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
20019222:	4b5b      	ldr	r3, [pc, #364]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
20019224:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20019226:	f423 72e0 	bic.w	r2, r3, #448	; 0x1c0
2001922a:	687b      	ldr	r3, [r7, #4]
2001922c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001922e:	4958      	ldr	r1, [pc, #352]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
20019230:	4313      	orrs	r3, r2
20019232:	650b      	str	r3, [r1, #80]	; 0x50
20019234:	e001      	b.n	2001923a <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    }
    else
    {
      /* set overall return value */
      status = ret;
20019236:	7dfb      	ldrb	r3, [r7, #23]
20019238:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
2001923a:	687b      	ldr	r3, [r7, #4]
2001923c:	681b      	ldr	r3, [r3, #0]
2001923e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20019242:	2b00      	cmp	r3, #0
20019244:	d044      	beq.n	200192d0 <HAL_RCCEx_PeriphCLKConfig+0x240>
  {
    switch(PeriphClkInit->Sai4AClockSelection)
20019246:	687b      	ldr	r3, [r7, #4]
20019248:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
2001924c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
20019250:	d01f      	beq.n	20019292 <HAL_RCCEx_PeriphCLKConfig+0x202>
20019252:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
20019256:	d805      	bhi.n	20019264 <HAL_RCCEx_PeriphCLKConfig+0x1d4>
20019258:	2b00      	cmp	r3, #0
2001925a:	d00a      	beq.n	20019272 <HAL_RCCEx_PeriphCLKConfig+0x1e2>
2001925c:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
20019260:	d00e      	beq.n	20019280 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
20019262:	e01f      	b.n	200192a4 <HAL_RCCEx_PeriphCLKConfig+0x214>
20019264:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
20019268:	d01f      	beq.n	200192aa <HAL_RCCEx_PeriphCLKConfig+0x21a>
2001926a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
2001926e:	d01e      	beq.n	200192ae <HAL_RCCEx_PeriphCLKConfig+0x21e>
20019270:	e018      	b.n	200192a4 <HAL_RCCEx_PeriphCLKConfig+0x214>
    {
    case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
20019272:	4b47      	ldr	r3, [pc, #284]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
20019274:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20019276:	4a46      	ldr	r2, [pc, #280]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
20019278:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2001927c:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
2001927e:	e017      	b.n	200192b0 <HAL_RCCEx_PeriphCLKConfig+0x220>

    case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
20019280:	687b      	ldr	r3, [r7, #4]
20019282:	3304      	adds	r3, #4
20019284:	2100      	movs	r1, #0
20019286:	4618      	mov	r0, r3
20019288:	f002 fb4a 	bl	2001b920 <RCCEx_PLL2_Config>
2001928c:	4603      	mov	r3, r0
2001928e:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
20019290:	e00e      	b.n	200192b0 <HAL_RCCEx_PeriphCLKConfig+0x220>

    case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
20019292:	687b      	ldr	r3, [r7, #4]
20019294:	3324      	adds	r3, #36	; 0x24
20019296:	2100      	movs	r1, #0
20019298:	4618      	mov	r0, r3
2001929a:	f002 fc63 	bl	2001bb64 <RCCEx_PLL3_Config>
2001929e:	4603      	mov	r3, r0
200192a0:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
200192a2:	e005      	b.n	200192b0 <HAL_RCCEx_PeriphCLKConfig+0x220>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
200192a4:	2301      	movs	r3, #1
200192a6:	75fb      	strb	r3, [r7, #23]
      break;
200192a8:	e002      	b.n	200192b0 <HAL_RCCEx_PeriphCLKConfig+0x220>
      break;
200192aa:	bf00      	nop
200192ac:	e000      	b.n	200192b0 <HAL_RCCEx_PeriphCLKConfig+0x220>
      break;
200192ae:	bf00      	nop
    }

    if(ret == HAL_OK)
200192b0:	7dfb      	ldrb	r3, [r7, #23]
200192b2:	2b00      	cmp	r3, #0
200192b4:	d10a      	bne.n	200192cc <HAL_RCCEx_PeriphCLKConfig+0x23c>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
200192b6:	4b36      	ldr	r3, [pc, #216]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
200192b8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200192ba:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
200192be:	687b      	ldr	r3, [r7, #4]
200192c0:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
200192c4:	4932      	ldr	r1, [pc, #200]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
200192c6:	4313      	orrs	r3, r2
200192c8:	658b      	str	r3, [r1, #88]	; 0x58
200192ca:	e001      	b.n	200192d0 <HAL_RCCEx_PeriphCLKConfig+0x240>
    }
    else
    {
      /* set overall return value */
      status = ret;
200192cc:	7dfb      	ldrb	r3, [r7, #23]
200192ce:	75bb      	strb	r3, [r7, #22]
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
200192d0:	687b      	ldr	r3, [r7, #4]
200192d2:	681b      	ldr	r3, [r3, #0]
200192d4:	f403 6300 	and.w	r3, r3, #2048	; 0x800
200192d8:	2b00      	cmp	r3, #0
200192da:	d044      	beq.n	20019366 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
  {
    switch(PeriphClkInit->Sai4BClockSelection)
200192dc:	687b      	ldr	r3, [r7, #4]
200192de:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
200192e2:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200192e6:	d01f      	beq.n	20019328 <HAL_RCCEx_PeriphCLKConfig+0x298>
200192e8:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200192ec:	d805      	bhi.n	200192fa <HAL_RCCEx_PeriphCLKConfig+0x26a>
200192ee:	2b00      	cmp	r3, #0
200192f0:	d00a      	beq.n	20019308 <HAL_RCCEx_PeriphCLKConfig+0x278>
200192f2:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
200192f6:	d00e      	beq.n	20019316 <HAL_RCCEx_PeriphCLKConfig+0x286>
200192f8:	e01f      	b.n	2001933a <HAL_RCCEx_PeriphCLKConfig+0x2aa>
200192fa:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
200192fe:	d01f      	beq.n	20019340 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
20019300:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
20019304:	d01e      	beq.n	20019344 <HAL_RCCEx_PeriphCLKConfig+0x2b4>
20019306:	e018      	b.n	2001933a <HAL_RCCEx_PeriphCLKConfig+0x2aa>
    {
    case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
20019308:	4b21      	ldr	r3, [pc, #132]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2001930a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001930c:	4a20      	ldr	r2, [pc, #128]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2001930e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
20019312:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
20019314:	e017      	b.n	20019346 <HAL_RCCEx_PeriphCLKConfig+0x2b6>

    case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
20019316:	687b      	ldr	r3, [r7, #4]
20019318:	3304      	adds	r3, #4
2001931a:	2100      	movs	r1, #0
2001931c:	4618      	mov	r0, r3
2001931e:	f002 faff 	bl	2001b920 <RCCEx_PLL2_Config>
20019322:	4603      	mov	r3, r0
20019324:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
20019326:	e00e      	b.n	20019346 <HAL_RCCEx_PeriphCLKConfig+0x2b6>

    case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
20019328:	687b      	ldr	r3, [r7, #4]
2001932a:	3324      	adds	r3, #36	; 0x24
2001932c:	2100      	movs	r1, #0
2001932e:	4618      	mov	r0, r3
20019330:	f002 fc18 	bl	2001bb64 <RCCEx_PLL3_Config>
20019334:	4603      	mov	r3, r0
20019336:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
20019338:	e005      	b.n	20019346 <HAL_RCCEx_PeriphCLKConfig+0x2b6>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2001933a:	2301      	movs	r3, #1
2001933c:	75fb      	strb	r3, [r7, #23]
      break;
2001933e:	e002      	b.n	20019346 <HAL_RCCEx_PeriphCLKConfig+0x2b6>
      break;
20019340:	bf00      	nop
20019342:	e000      	b.n	20019346 <HAL_RCCEx_PeriphCLKConfig+0x2b6>
      break;
20019344:	bf00      	nop
    }

    if(ret == HAL_OK)
20019346:	7dfb      	ldrb	r3, [r7, #23]
20019348:	2b00      	cmp	r3, #0
2001934a:	d10a      	bne.n	20019362 <HAL_RCCEx_PeriphCLKConfig+0x2d2>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
2001934c:	4b10      	ldr	r3, [pc, #64]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2001934e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20019350:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
20019354:	687b      	ldr	r3, [r7, #4]
20019356:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
2001935a:	490d      	ldr	r1, [pc, #52]	; (20019390 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2001935c:	4313      	orrs	r3, r2
2001935e:	658b      	str	r3, [r1, #88]	; 0x58
20019360:	e001      	b.n	20019366 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
    }
    else
    {
      /* set overall return value */
      status = ret;
20019362:	7dfb      	ldrb	r3, [r7, #23]
20019364:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
20019366:	687b      	ldr	r3, [r7, #4]
20019368:	681b      	ldr	r3, [r3, #0]
2001936a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2001936e:	2b00      	cmp	r3, #0
20019370:	d035      	beq.n	200193de <HAL_RCCEx_PeriphCLKConfig+0x34e>
  {
    switch(PeriphClkInit->QspiClockSelection)
20019372:	687b      	ldr	r3, [r7, #4]
20019374:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20019376:	2b10      	cmp	r3, #16
20019378:	d00c      	beq.n	20019394 <HAL_RCCEx_PeriphCLKConfig+0x304>
2001937a:	2b10      	cmp	r3, #16
2001937c:	d802      	bhi.n	20019384 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
2001937e:	2b00      	cmp	r3, #0
20019380:	d01b      	beq.n	200193ba <HAL_RCCEx_PeriphCLKConfig+0x32a>
20019382:	e017      	b.n	200193b4 <HAL_RCCEx_PeriphCLKConfig+0x324>
20019384:	2b20      	cmp	r3, #32
20019386:	d00c      	beq.n	200193a2 <HAL_RCCEx_PeriphCLKConfig+0x312>
20019388:	2b30      	cmp	r3, #48	; 0x30
2001938a:	d018      	beq.n	200193be <HAL_RCCEx_PeriphCLKConfig+0x32e>
2001938c:	e012      	b.n	200193b4 <HAL_RCCEx_PeriphCLKConfig+0x324>
2001938e:	bf00      	nop
20019390:	58024400 	.word	0x58024400
    {
    case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
      /* Enable QSPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
20019394:	4baf      	ldr	r3, [pc, #700]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
20019396:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20019398:	4aae      	ldr	r2, [pc, #696]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2001939a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2001939e:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* QSPI clock source configuration done later after clock selection check */
      break;
200193a0:	e00e      	b.n	200193c0 <HAL_RCCEx_PeriphCLKConfig+0x330>

    case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
200193a2:	687b      	ldr	r3, [r7, #4]
200193a4:	3304      	adds	r3, #4
200193a6:	2102      	movs	r1, #2
200193a8:	4618      	mov	r0, r3
200193aa:	f002 fab9 	bl	2001b920 <RCCEx_PLL2_Config>
200193ae:	4603      	mov	r3, r0
200193b0:	75fb      	strb	r3, [r7, #23]

      /* QSPI clock source configuration done later after clock selection check */
      break;
200193b2:	e005      	b.n	200193c0 <HAL_RCCEx_PeriphCLKConfig+0x330>
    case RCC_QSPICLKSOURCE_D1HCLK:
      /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
200193b4:	2301      	movs	r3, #1
200193b6:	75fb      	strb	r3, [r7, #23]
      break;
200193b8:	e002      	b.n	200193c0 <HAL_RCCEx_PeriphCLKConfig+0x330>
      break;
200193ba:	bf00      	nop
200193bc:	e000      	b.n	200193c0 <HAL_RCCEx_PeriphCLKConfig+0x330>
      break;
200193be:	bf00      	nop
    }

    if(ret == HAL_OK)
200193c0:	7dfb      	ldrb	r3, [r7, #23]
200193c2:	2b00      	cmp	r3, #0
200193c4:	d109      	bne.n	200193da <HAL_RCCEx_PeriphCLKConfig+0x34a>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
200193c6:	4ba3      	ldr	r3, [pc, #652]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
200193c8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
200193ca:	f023 0230 	bic.w	r2, r3, #48	; 0x30
200193ce:	687b      	ldr	r3, [r7, #4]
200193d0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200193d2:	49a0      	ldr	r1, [pc, #640]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
200193d4:	4313      	orrs	r3, r2
200193d6:	64cb      	str	r3, [r1, #76]	; 0x4c
200193d8:	e001      	b.n	200193de <HAL_RCCEx_PeriphCLKConfig+0x34e>
    }
    else
    {
      /* set overall return value */
      status = ret;
200193da:	7dfb      	ldrb	r3, [r7, #23]
200193dc:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
200193de:	687b      	ldr	r3, [r7, #4]
200193e0:	681b      	ldr	r3, [r3, #0]
200193e2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
200193e6:	2b00      	cmp	r3, #0
200193e8:	d042      	beq.n	20019470 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
  {
    switch(PeriphClkInit->Spi123ClockSelection)
200193ea:	687b      	ldr	r3, [r7, #4]
200193ec:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200193ee:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
200193f2:	d01f      	beq.n	20019434 <HAL_RCCEx_PeriphCLKConfig+0x3a4>
200193f4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
200193f8:	d805      	bhi.n	20019406 <HAL_RCCEx_PeriphCLKConfig+0x376>
200193fa:	2b00      	cmp	r3, #0
200193fc:	d00a      	beq.n	20019414 <HAL_RCCEx_PeriphCLKConfig+0x384>
200193fe:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20019402:	d00e      	beq.n	20019422 <HAL_RCCEx_PeriphCLKConfig+0x392>
20019404:	e01f      	b.n	20019446 <HAL_RCCEx_PeriphCLKConfig+0x3b6>
20019406:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
2001940a:	d01f      	beq.n	2001944c <HAL_RCCEx_PeriphCLKConfig+0x3bc>
2001940c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20019410:	d01e      	beq.n	20019450 <HAL_RCCEx_PeriphCLKConfig+0x3c0>
20019412:	e018      	b.n	20019446 <HAL_RCCEx_PeriphCLKConfig+0x3b6>
    {
    case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
      /* Enable SPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
20019414:	4b8f      	ldr	r3, [pc, #572]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
20019416:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20019418:	4a8e      	ldr	r2, [pc, #568]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2001941a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2001941e:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
20019420:	e017      	b.n	20019452 <HAL_RCCEx_PeriphCLKConfig+0x3c2>

    case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
20019422:	687b      	ldr	r3, [r7, #4]
20019424:	3304      	adds	r3, #4
20019426:	2100      	movs	r1, #0
20019428:	4618      	mov	r0, r3
2001942a:	f002 fa79 	bl	2001b920 <RCCEx_PLL2_Config>
2001942e:	4603      	mov	r3, r0
20019430:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
20019432:	e00e      	b.n	20019452 <HAL_RCCEx_PeriphCLKConfig+0x3c2>

    case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
20019434:	687b      	ldr	r3, [r7, #4]
20019436:	3324      	adds	r3, #36	; 0x24
20019438:	2100      	movs	r1, #0
2001943a:	4618      	mov	r0, r3
2001943c:	f002 fb92 	bl	2001bb64 <RCCEx_PLL3_Config>
20019440:	4603      	mov	r3, r0
20019442:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
20019444:	e005      	b.n	20019452 <HAL_RCCEx_PeriphCLKConfig+0x3c2>
      /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
20019446:	2301      	movs	r3, #1
20019448:	75fb      	strb	r3, [r7, #23]
      break;
2001944a:	e002      	b.n	20019452 <HAL_RCCEx_PeriphCLKConfig+0x3c2>
      break;
2001944c:	bf00      	nop
2001944e:	e000      	b.n	20019452 <HAL_RCCEx_PeriphCLKConfig+0x3c2>
      break;
20019450:	bf00      	nop
    }

    if(ret == HAL_OK)
20019452:	7dfb      	ldrb	r3, [r7, #23]
20019454:	2b00      	cmp	r3, #0
20019456:	d109      	bne.n	2001946c <HAL_RCCEx_PeriphCLKConfig+0x3dc>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
20019458:	4b7e      	ldr	r3, [pc, #504]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2001945a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001945c:	f423 42e0 	bic.w	r2, r3, #28672	; 0x7000
20019460:	687b      	ldr	r3, [r7, #4]
20019462:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20019464:	497b      	ldr	r1, [pc, #492]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
20019466:	4313      	orrs	r3, r2
20019468:	650b      	str	r3, [r1, #80]	; 0x50
2001946a:	e001      	b.n	20019470 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    }
    else
    {
      /* set overall return value */
      status = ret;
2001946c:	7dfb      	ldrb	r3, [r7, #23]
2001946e:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
20019470:	687b      	ldr	r3, [r7, #4]
20019472:	681b      	ldr	r3, [r3, #0]
20019474:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
20019478:	2b00      	cmp	r3, #0
2001947a:	d042      	beq.n	20019502 <HAL_RCCEx_PeriphCLKConfig+0x472>
  {
    switch(PeriphClkInit->Spi45ClockSelection)
2001947c:	687b      	ldr	r3, [r7, #4]
2001947e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20019480:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20019484:	d01b      	beq.n	200194be <HAL_RCCEx_PeriphCLKConfig+0x42e>
20019486:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2001948a:	d805      	bhi.n	20019498 <HAL_RCCEx_PeriphCLKConfig+0x408>
2001948c:	2b00      	cmp	r3, #0
2001948e:	d022      	beq.n	200194d6 <HAL_RCCEx_PeriphCLKConfig+0x446>
20019490:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20019494:	d00a      	beq.n	200194ac <HAL_RCCEx_PeriphCLKConfig+0x41c>
20019496:	e01b      	b.n	200194d0 <HAL_RCCEx_PeriphCLKConfig+0x440>
20019498:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
2001949c:	d01d      	beq.n	200194da <HAL_RCCEx_PeriphCLKConfig+0x44a>
2001949e:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
200194a2:	d01c      	beq.n	200194de <HAL_RCCEx_PeriphCLKConfig+0x44e>
200194a4:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
200194a8:	d01b      	beq.n	200194e2 <HAL_RCCEx_PeriphCLKConfig+0x452>
200194aa:	e011      	b.n	200194d0 <HAL_RCCEx_PeriphCLKConfig+0x440>
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
200194ac:	687b      	ldr	r3, [r7, #4]
200194ae:	3304      	adds	r3, #4
200194b0:	2101      	movs	r1, #1
200194b2:	4618      	mov	r0, r3
200194b4:	f002 fa34 	bl	2001b920 <RCCEx_PLL2_Config>
200194b8:	4603      	mov	r3, r0
200194ba:	75fb      	strb	r3, [r7, #23]

      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
200194bc:	e012      	b.n	200194e4 <HAL_RCCEx_PeriphCLKConfig+0x454>
    case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
200194be:	687b      	ldr	r3, [r7, #4]
200194c0:	3324      	adds	r3, #36	; 0x24
200194c2:	2101      	movs	r1, #1
200194c4:	4618      	mov	r0, r3
200194c6:	f002 fb4d 	bl	2001bb64 <RCCEx_PLL3_Config>
200194ca:	4603      	mov	r3, r0
200194cc:	75fb      	strb	r3, [r7, #23]
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
200194ce:	e009      	b.n	200194e4 <HAL_RCCEx_PeriphCLKConfig+0x454>
      /* HSE,  oscillator is used as source of SPI4/5 clock */
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
200194d0:	2301      	movs	r3, #1
200194d2:	75fb      	strb	r3, [r7, #23]
      break;
200194d4:	e006      	b.n	200194e4 <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
200194d6:	bf00      	nop
200194d8:	e004      	b.n	200194e4 <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
200194da:	bf00      	nop
200194dc:	e002      	b.n	200194e4 <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
200194de:	bf00      	nop
200194e0:	e000      	b.n	200194e4 <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
200194e2:	bf00      	nop
    }

    if(ret == HAL_OK)
200194e4:	7dfb      	ldrb	r3, [r7, #23]
200194e6:	2b00      	cmp	r3, #0
200194e8:	d109      	bne.n	200194fe <HAL_RCCEx_PeriphCLKConfig+0x46e>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
200194ea:	4b5a      	ldr	r3, [pc, #360]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
200194ec:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200194ee:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
200194f2:	687b      	ldr	r3, [r7, #4]
200194f4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200194f6:	4957      	ldr	r1, [pc, #348]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
200194f8:	4313      	orrs	r3, r2
200194fa:	650b      	str	r3, [r1, #80]	; 0x50
200194fc:	e001      	b.n	20019502 <HAL_RCCEx_PeriphCLKConfig+0x472>
    }
    else
    {
      /* set overall return value */
      status = ret;
200194fe:	7dfb      	ldrb	r3, [r7, #23]
20019500:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
20019502:	687b      	ldr	r3, [r7, #4]
20019504:	681b      	ldr	r3, [r3, #0]
20019506:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2001950a:	2b00      	cmp	r3, #0
2001950c:	d044      	beq.n	20019598 <HAL_RCCEx_PeriphCLKConfig+0x508>
  {
    switch(PeriphClkInit->Spi6ClockSelection)
2001950e:	687b      	ldr	r3, [r7, #4]
20019510:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
20019514:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20019518:	d01b      	beq.n	20019552 <HAL_RCCEx_PeriphCLKConfig+0x4c2>
2001951a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001951e:	d805      	bhi.n	2001952c <HAL_RCCEx_PeriphCLKConfig+0x49c>
20019520:	2b00      	cmp	r3, #0
20019522:	d022      	beq.n	2001956a <HAL_RCCEx_PeriphCLKConfig+0x4da>
20019524:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
20019528:	d00a      	beq.n	20019540 <HAL_RCCEx_PeriphCLKConfig+0x4b0>
2001952a:	e01b      	b.n	20019564 <HAL_RCCEx_PeriphCLKConfig+0x4d4>
2001952c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20019530:	d01d      	beq.n	2001956e <HAL_RCCEx_PeriphCLKConfig+0x4de>
20019532:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
20019536:	d01c      	beq.n	20019572 <HAL_RCCEx_PeriphCLKConfig+0x4e2>
20019538:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
2001953c:	d01b      	beq.n	20019576 <HAL_RCCEx_PeriphCLKConfig+0x4e6>
2001953e:	e011      	b.n	20019564 <HAL_RCCEx_PeriphCLKConfig+0x4d4>
      /* SPI6 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
20019540:	687b      	ldr	r3, [r7, #4]
20019542:	3304      	adds	r3, #4
20019544:	2101      	movs	r1, #1
20019546:	4618      	mov	r0, r3
20019548:	f002 f9ea 	bl	2001b920 <RCCEx_PLL2_Config>
2001954c:	4603      	mov	r3, r0
2001954e:	75fb      	strb	r3, [r7, #23]

      /* SPI6 clock source configuration done later after clock selection check */
      break;
20019550:	e012      	b.n	20019578 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
    case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
20019552:	687b      	ldr	r3, [r7, #4]
20019554:	3324      	adds	r3, #36	; 0x24
20019556:	2101      	movs	r1, #1
20019558:	4618      	mov	r0, r3
2001955a:	f002 fb03 	bl	2001bb64 <RCCEx_PLL3_Config>
2001955e:	4603      	mov	r3, r0
20019560:	75fb      	strb	r3, [r7, #23]
      /* SPI6 clock source configuration done later after clock selection check */
      break;
20019562:	e009      	b.n	20019578 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      /* SPI6 clock source configuration done later after clock selection check */
      break;
#endif

    default:
      ret = HAL_ERROR;
20019564:	2301      	movs	r3, #1
20019566:	75fb      	strb	r3, [r7, #23]
      break;
20019568:	e006      	b.n	20019578 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
2001956a:	bf00      	nop
2001956c:	e004      	b.n	20019578 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
2001956e:	bf00      	nop
20019570:	e002      	b.n	20019578 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
20019572:	bf00      	nop
20019574:	e000      	b.n	20019578 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
20019576:	bf00      	nop
    }

    if(ret == HAL_OK)
20019578:	7dfb      	ldrb	r3, [r7, #23]
2001957a:	2b00      	cmp	r3, #0
2001957c:	d10a      	bne.n	20019594 <HAL_RCCEx_PeriphCLKConfig+0x504>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
2001957e:	4b35      	ldr	r3, [pc, #212]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
20019580:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20019582:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
20019586:	687b      	ldr	r3, [r7, #4]
20019588:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
2001958c:	4931      	ldr	r1, [pc, #196]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2001958e:	4313      	orrs	r3, r2
20019590:	658b      	str	r3, [r1, #88]	; 0x58
20019592:	e001      	b.n	20019598 <HAL_RCCEx_PeriphCLKConfig+0x508>
    }
    else
    {
      /* set overall return value */
      status = ret;
20019594:	7dfb      	ldrb	r3, [r7, #23]
20019596:	75bb      	strb	r3, [r7, #22]
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
20019598:	687b      	ldr	r3, [r7, #4]
2001959a:	681b      	ldr	r3, [r3, #0]
2001959c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
200195a0:	2b00      	cmp	r3, #0
200195a2:	d02d      	beq.n	20019600 <HAL_RCCEx_PeriphCLKConfig+0x570>
  {
    switch(PeriphClkInit->FdcanClockSelection)
200195a4:	687b      	ldr	r3, [r7, #4]
200195a6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
200195a8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
200195ac:	d005      	beq.n	200195ba <HAL_RCCEx_PeriphCLKConfig+0x52a>
200195ae:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
200195b2:	d009      	beq.n	200195c8 <HAL_RCCEx_PeriphCLKConfig+0x538>
200195b4:	2b00      	cmp	r3, #0
200195b6:	d013      	beq.n	200195e0 <HAL_RCCEx_PeriphCLKConfig+0x550>
200195b8:	e00f      	b.n	200195da <HAL_RCCEx_PeriphCLKConfig+0x54a>
    {
    case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
      /* Enable FDCAN Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
200195ba:	4b26      	ldr	r3, [pc, #152]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
200195bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200195be:	4a25      	ldr	r2, [pc, #148]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
200195c0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
200195c4:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FDCAN clock source configuration done later after clock selection check */
      break;
200195c6:	e00c      	b.n	200195e2 <HAL_RCCEx_PeriphCLKConfig+0x552>

    case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
200195c8:	687b      	ldr	r3, [r7, #4]
200195ca:	3304      	adds	r3, #4
200195cc:	2101      	movs	r1, #1
200195ce:	4618      	mov	r0, r3
200195d0:	f002 f9a6 	bl	2001b920 <RCCEx_PLL2_Config>
200195d4:	4603      	mov	r3, r0
200195d6:	75fb      	strb	r3, [r7, #23]

      /* FDCAN clock source configuration done later after clock selection check */
      break;
200195d8:	e003      	b.n	200195e2 <HAL_RCCEx_PeriphCLKConfig+0x552>
      /* HSE is used as clock source for FDCAN*/
      /* FDCAN clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
200195da:	2301      	movs	r3, #1
200195dc:	75fb      	strb	r3, [r7, #23]
      break;
200195de:	e000      	b.n	200195e2 <HAL_RCCEx_PeriphCLKConfig+0x552>
      break;
200195e0:	bf00      	nop
    }

    if(ret == HAL_OK)
200195e2:	7dfb      	ldrb	r3, [r7, #23]
200195e4:	2b00      	cmp	r3, #0
200195e6:	d109      	bne.n	200195fc <HAL_RCCEx_PeriphCLKConfig+0x56c>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
200195e8:	4b1a      	ldr	r3, [pc, #104]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
200195ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200195ec:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
200195f0:	687b      	ldr	r3, [r7, #4]
200195f2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
200195f4:	4917      	ldr	r1, [pc, #92]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
200195f6:	4313      	orrs	r3, r2
200195f8:	650b      	str	r3, [r1, #80]	; 0x50
200195fa:	e001      	b.n	20019600 <HAL_RCCEx_PeriphCLKConfig+0x570>
    }
    else
    {
      /* set overall return value */
      status = ret;
200195fc:	7dfb      	ldrb	r3, [r7, #23]
200195fe:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
20019600:	687b      	ldr	r3, [r7, #4]
20019602:	681b      	ldr	r3, [r3, #0]
20019604:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
20019608:	2b00      	cmp	r3, #0
2001960a:	d037      	beq.n	2001967c <HAL_RCCEx_PeriphCLKConfig+0x5ec>
  {
    switch(PeriphClkInit->FmcClockSelection)
2001960c:	687b      	ldr	r3, [r7, #4]
2001960e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20019610:	2b03      	cmp	r3, #3
20019612:	d81b      	bhi.n	2001964c <HAL_RCCEx_PeriphCLKConfig+0x5bc>
20019614:	a201      	add	r2, pc, #4	; (adr r2, 2001961c <HAL_RCCEx_PeriphCLKConfig+0x58c>)
20019616:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2001961a:	bf00      	nop
2001961c:	20019659 	.word	0x20019659
20019620:	2001962d 	.word	0x2001962d
20019624:	2001963b 	.word	0x2001963b
20019628:	20019659 	.word	0x20019659
    {
    case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
      /* Enable FMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2001962c:	4b09      	ldr	r3, [pc, #36]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2001962e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20019630:	4a08      	ldr	r2, [pc, #32]	; (20019654 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
20019632:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
20019636:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FMC clock source configuration done later after clock selection check */
      break;
20019638:	e00f      	b.n	2001965a <HAL_RCCEx_PeriphCLKConfig+0x5ca>

    case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
2001963a:	687b      	ldr	r3, [r7, #4]
2001963c:	3304      	adds	r3, #4
2001963e:	2102      	movs	r1, #2
20019640:	4618      	mov	r0, r3
20019642:	f002 f96d 	bl	2001b920 <RCCEx_PLL2_Config>
20019646:	4603      	mov	r3, r0
20019648:	75fb      	strb	r3, [r7, #23]

      /* FMC clock source configuration done later after clock selection check */
      break;
2001964a:	e006      	b.n	2001965a <HAL_RCCEx_PeriphCLKConfig+0x5ca>
    case RCC_FMCCLKSOURCE_HCLK:
      /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
2001964c:	2301      	movs	r3, #1
2001964e:	75fb      	strb	r3, [r7, #23]
      break;
20019650:	e003      	b.n	2001965a <HAL_RCCEx_PeriphCLKConfig+0x5ca>
20019652:	bf00      	nop
20019654:	58024400 	.word	0x58024400
      break;
20019658:	bf00      	nop
    }

    if(ret == HAL_OK)
2001965a:	7dfb      	ldrb	r3, [r7, #23]
2001965c:	2b00      	cmp	r3, #0
2001965e:	d10b      	bne.n	20019678 <HAL_RCCEx_PeriphCLKConfig+0x5e8>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
20019660:	4b04      	ldr	r3, [pc, #16]	; (20019674 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
20019662:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20019664:	f023 0203 	bic.w	r2, r3, #3
20019668:	687b      	ldr	r3, [r7, #4]
2001966a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2001966c:	4901      	ldr	r1, [pc, #4]	; (20019674 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
2001966e:	4313      	orrs	r3, r2
20019670:	64cb      	str	r3, [r1, #76]	; 0x4c
20019672:	e003      	b.n	2001967c <HAL_RCCEx_PeriphCLKConfig+0x5ec>
20019674:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
20019678:	7dfb      	ldrb	r3, [r7, #23]
2001967a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
2001967c:	687b      	ldr	r3, [r7, #4]
2001967e:	681b      	ldr	r3, [r3, #0]
20019680:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
20019684:	2b00      	cmp	r3, #0
20019686:	f000 829b 	beq.w	20019bc0 <HAL_RCCEx_PeriphCLKConfig+0xb30>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
2001968a:	687b      	ldr	r3, [r7, #4]
2001968c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019690:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20019694:	f000 81a9 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019698:	687b      	ldr	r3, [r7, #4]
2001969a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001969e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
200196a2:	f000 81a2 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200196a6:	687b      	ldr	r3, [r7, #4]
200196a8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200196ac:	f5b3 5f0c 	cmp.w	r3, #8960	; 0x2300
200196b0:	f000 819b 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200196b4:	687b      	ldr	r3, [r7, #4]
200196b6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200196ba:	f5b3 5f4c 	cmp.w	r3, #13056	; 0x3300
200196be:	f000 8194 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200196c2:	687b      	ldr	r3, [r7, #4]
200196c4:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200196c8:	f5b3 4f86 	cmp.w	r3, #17152	; 0x4300
200196cc:	f000 818d 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200196d0:	687b      	ldr	r3, [r7, #4]
200196d2:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200196d6:	f5b3 4fa6 	cmp.w	r3, #21248	; 0x5300
200196da:	f000 8186 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200196de:	687b      	ldr	r3, [r7, #4]
200196e0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200196e4:	f5b3 4fc6 	cmp.w	r3, #25344	; 0x6300
200196e8:	f000 817f 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200196ec:	687b      	ldr	r3, [r7, #4]
200196ee:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200196f2:	f5b3 4fe6 	cmp.w	r3, #29440	; 0x7300
200196f6:	f000 8178 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200196fa:	687b      	ldr	r3, [r7, #4]
200196fc:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019700:	f5b3 4f03 	cmp.w	r3, #33536	; 0x8300
20019704:	f000 8171 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019708:	687b      	ldr	r3, [r7, #4]
2001970a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001970e:	f5b3 4f13 	cmp.w	r3, #37632	; 0x9300
20019712:	f000 816a 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019716:	687b      	ldr	r3, [r7, #4]
20019718:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001971c:	f5b3 4f23 	cmp.w	r3, #41728	; 0xa300
20019720:	f000 8163 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019724:	687b      	ldr	r3, [r7, #4]
20019726:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001972a:	f5b3 4f33 	cmp.w	r3, #45824	; 0xb300
2001972e:	f000 815c 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019732:	687b      	ldr	r3, [r7, #4]
20019734:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019738:	f5b3 4f43 	cmp.w	r3, #49920	; 0xc300
2001973c:	f000 8155 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019740:	687b      	ldr	r3, [r7, #4]
20019742:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019746:	f5b3 4f53 	cmp.w	r3, #54016	; 0xd300
2001974a:	f000 814e 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
2001974e:	687b      	ldr	r3, [r7, #4]
20019750:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019754:	f5b3 4f63 	cmp.w	r3, #58112	; 0xe300
20019758:	f000 8147 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
2001975c:	687b      	ldr	r3, [r7, #4]
2001975e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019762:	f5b3 4f73 	cmp.w	r3, #62208	; 0xf300
20019766:	f000 8140 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
2001976a:	687b      	ldr	r3, [r7, #4]
2001976c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019770:	4aa8      	ldr	r2, [pc, #672]	; (20019a14 <HAL_RCCEx_PeriphCLKConfig+0x984>)
20019772:	4293      	cmp	r3, r2
20019774:	f000 8139 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019778:	687b      	ldr	r3, [r7, #4]
2001977a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001977e:	4aa6      	ldr	r2, [pc, #664]	; (20019a18 <HAL_RCCEx_PeriphCLKConfig+0x988>)
20019780:	4293      	cmp	r3, r2
20019782:	f000 8132 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019786:	687b      	ldr	r3, [r7, #4]
20019788:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001978c:	4aa3      	ldr	r2, [pc, #652]	; (20019a1c <HAL_RCCEx_PeriphCLKConfig+0x98c>)
2001978e:	4293      	cmp	r3, r2
20019790:	f000 812b 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019794:	687b      	ldr	r3, [r7, #4]
20019796:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001979a:	4aa1      	ldr	r2, [pc, #644]	; (20019a20 <HAL_RCCEx_PeriphCLKConfig+0x990>)
2001979c:	4293      	cmp	r3, r2
2001979e:	f000 8124 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200197a2:	687b      	ldr	r3, [r7, #4]
200197a4:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200197a8:	4a9e      	ldr	r2, [pc, #632]	; (20019a24 <HAL_RCCEx_PeriphCLKConfig+0x994>)
200197aa:	4293      	cmp	r3, r2
200197ac:	f000 811d 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200197b0:	687b      	ldr	r3, [r7, #4]
200197b2:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200197b6:	4a9c      	ldr	r2, [pc, #624]	; (20019a28 <HAL_RCCEx_PeriphCLKConfig+0x998>)
200197b8:	4293      	cmp	r3, r2
200197ba:	f000 8116 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200197be:	687b      	ldr	r3, [r7, #4]
200197c0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200197c4:	4a99      	ldr	r2, [pc, #612]	; (20019a2c <HAL_RCCEx_PeriphCLKConfig+0x99c>)
200197c6:	4293      	cmp	r3, r2
200197c8:	f000 810f 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200197cc:	687b      	ldr	r3, [r7, #4]
200197ce:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200197d2:	4a97      	ldr	r2, [pc, #604]	; (20019a30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
200197d4:	4293      	cmp	r3, r2
200197d6:	f000 8108 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200197da:	687b      	ldr	r3, [r7, #4]
200197dc:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200197e0:	4a94      	ldr	r2, [pc, #592]	; (20019a34 <HAL_RCCEx_PeriphCLKConfig+0x9a4>)
200197e2:	4293      	cmp	r3, r2
200197e4:	f000 8101 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200197e8:	687b      	ldr	r3, [r7, #4]
200197ea:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200197ee:	4a92      	ldr	r2, [pc, #584]	; (20019a38 <HAL_RCCEx_PeriphCLKConfig+0x9a8>)
200197f0:	4293      	cmp	r3, r2
200197f2:	f000 80fa 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200197f6:	687b      	ldr	r3, [r7, #4]
200197f8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200197fc:	4a8f      	ldr	r2, [pc, #572]	; (20019a3c <HAL_RCCEx_PeriphCLKConfig+0x9ac>)
200197fe:	4293      	cmp	r3, r2
20019800:	f000 80f3 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019804:	687b      	ldr	r3, [r7, #4]
20019806:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001980a:	4a8d      	ldr	r2, [pc, #564]	; (20019a40 <HAL_RCCEx_PeriphCLKConfig+0x9b0>)
2001980c:	4293      	cmp	r3, r2
2001980e:	f000 80ec 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019812:	687b      	ldr	r3, [r7, #4]
20019814:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019818:	4a8a      	ldr	r2, [pc, #552]	; (20019a44 <HAL_RCCEx_PeriphCLKConfig+0x9b4>)
2001981a:	4293      	cmp	r3, r2
2001981c:	f000 80e5 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019820:	687b      	ldr	r3, [r7, #4]
20019822:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019826:	4a88      	ldr	r2, [pc, #544]	; (20019a48 <HAL_RCCEx_PeriphCLKConfig+0x9b8>)
20019828:	4293      	cmp	r3, r2
2001982a:	f000 80de 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
2001982e:	687b      	ldr	r3, [r7, #4]
20019830:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019834:	4a85      	ldr	r2, [pc, #532]	; (20019a4c <HAL_RCCEx_PeriphCLKConfig+0x9bc>)
20019836:	4293      	cmp	r3, r2
20019838:	f000 80d7 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
2001983c:	687b      	ldr	r3, [r7, #4]
2001983e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019842:	4a83      	ldr	r2, [pc, #524]	; (20019a50 <HAL_RCCEx_PeriphCLKConfig+0x9c0>)
20019844:	4293      	cmp	r3, r2
20019846:	f000 80d0 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
2001984a:	687b      	ldr	r3, [r7, #4]
2001984c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019850:	4a80      	ldr	r2, [pc, #512]	; (20019a54 <HAL_RCCEx_PeriphCLKConfig+0x9c4>)
20019852:	4293      	cmp	r3, r2
20019854:	f000 80c9 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019858:	687b      	ldr	r3, [r7, #4]
2001985a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001985e:	4a7e      	ldr	r2, [pc, #504]	; (20019a58 <HAL_RCCEx_PeriphCLKConfig+0x9c8>)
20019860:	4293      	cmp	r3, r2
20019862:	f000 80c2 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019866:	687b      	ldr	r3, [r7, #4]
20019868:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001986c:	4a7b      	ldr	r2, [pc, #492]	; (20019a5c <HAL_RCCEx_PeriphCLKConfig+0x9cc>)
2001986e:	4293      	cmp	r3, r2
20019870:	f000 80bb 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019874:	687b      	ldr	r3, [r7, #4]
20019876:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001987a:	4a79      	ldr	r2, [pc, #484]	; (20019a60 <HAL_RCCEx_PeriphCLKConfig+0x9d0>)
2001987c:	4293      	cmp	r3, r2
2001987e:	f000 80b4 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019882:	687b      	ldr	r3, [r7, #4]
20019884:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019888:	4a76      	ldr	r2, [pc, #472]	; (20019a64 <HAL_RCCEx_PeriphCLKConfig+0x9d4>)
2001988a:	4293      	cmp	r3, r2
2001988c:	f000 80ad 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019890:	687b      	ldr	r3, [r7, #4]
20019892:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019896:	4a74      	ldr	r2, [pc, #464]	; (20019a68 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
20019898:	4293      	cmp	r3, r2
2001989a:	f000 80a6 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
2001989e:	687b      	ldr	r3, [r7, #4]
200198a0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200198a4:	4a71      	ldr	r2, [pc, #452]	; (20019a6c <HAL_RCCEx_PeriphCLKConfig+0x9dc>)
200198a6:	4293      	cmp	r3, r2
200198a8:	f000 809f 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200198ac:	687b      	ldr	r3, [r7, #4]
200198ae:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200198b2:	4a6f      	ldr	r2, [pc, #444]	; (20019a70 <HAL_RCCEx_PeriphCLKConfig+0x9e0>)
200198b4:	4293      	cmp	r3, r2
200198b6:	f000 8098 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200198ba:	687b      	ldr	r3, [r7, #4]
200198bc:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200198c0:	4a6c      	ldr	r2, [pc, #432]	; (20019a74 <HAL_RCCEx_PeriphCLKConfig+0x9e4>)
200198c2:	4293      	cmp	r3, r2
200198c4:	f000 8091 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200198c8:	687b      	ldr	r3, [r7, #4]
200198ca:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200198ce:	4a6a      	ldr	r2, [pc, #424]	; (20019a78 <HAL_RCCEx_PeriphCLKConfig+0x9e8>)
200198d0:	4293      	cmp	r3, r2
200198d2:	f000 808a 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200198d6:	687b      	ldr	r3, [r7, #4]
200198d8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200198dc:	4a67      	ldr	r2, [pc, #412]	; (20019a7c <HAL_RCCEx_PeriphCLKConfig+0x9ec>)
200198de:	4293      	cmp	r3, r2
200198e0:	f000 8083 	beq.w	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200198e4:	687b      	ldr	r3, [r7, #4]
200198e6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200198ea:	4a65      	ldr	r2, [pc, #404]	; (20019a80 <HAL_RCCEx_PeriphCLKConfig+0x9f0>)
200198ec:	4293      	cmp	r3, r2
200198ee:	d07c      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200198f0:	687b      	ldr	r3, [r7, #4]
200198f2:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200198f6:	4a63      	ldr	r2, [pc, #396]	; (20019a84 <HAL_RCCEx_PeriphCLKConfig+0x9f4>)
200198f8:	4293      	cmp	r3, r2
200198fa:	d076      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200198fc:	687b      	ldr	r3, [r7, #4]
200198fe:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019902:	4a61      	ldr	r2, [pc, #388]	; (20019a88 <HAL_RCCEx_PeriphCLKConfig+0x9f8>)
20019904:	4293      	cmp	r3, r2
20019906:	d070      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019908:	687b      	ldr	r3, [r7, #4]
2001990a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001990e:	4a5f      	ldr	r2, [pc, #380]	; (20019a8c <HAL_RCCEx_PeriphCLKConfig+0x9fc>)
20019910:	4293      	cmp	r3, r2
20019912:	d06a      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019914:	687b      	ldr	r3, [r7, #4]
20019916:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001991a:	4a5d      	ldr	r2, [pc, #372]	; (20019a90 <HAL_RCCEx_PeriphCLKConfig+0xa00>)
2001991c:	4293      	cmp	r3, r2
2001991e:	d064      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019920:	687b      	ldr	r3, [r7, #4]
20019922:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019926:	4a5b      	ldr	r2, [pc, #364]	; (20019a94 <HAL_RCCEx_PeriphCLKConfig+0xa04>)
20019928:	4293      	cmp	r3, r2
2001992a:	d05e      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
2001992c:	687b      	ldr	r3, [r7, #4]
2001992e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019932:	4a59      	ldr	r2, [pc, #356]	; (20019a98 <HAL_RCCEx_PeriphCLKConfig+0xa08>)
20019934:	4293      	cmp	r3, r2
20019936:	d058      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019938:	687b      	ldr	r3, [r7, #4]
2001993a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001993e:	4a57      	ldr	r2, [pc, #348]	; (20019a9c <HAL_RCCEx_PeriphCLKConfig+0xa0c>)
20019940:	4293      	cmp	r3, r2
20019942:	d052      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019944:	687b      	ldr	r3, [r7, #4]
20019946:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001994a:	4a55      	ldr	r2, [pc, #340]	; (20019aa0 <HAL_RCCEx_PeriphCLKConfig+0xa10>)
2001994c:	4293      	cmp	r3, r2
2001994e:	d04c      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019950:	687b      	ldr	r3, [r7, #4]
20019952:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019956:	4a53      	ldr	r2, [pc, #332]	; (20019aa4 <HAL_RCCEx_PeriphCLKConfig+0xa14>)
20019958:	4293      	cmp	r3, r2
2001995a:	d046      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
2001995c:	687b      	ldr	r3, [r7, #4]
2001995e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019962:	4a51      	ldr	r2, [pc, #324]	; (20019aa8 <HAL_RCCEx_PeriphCLKConfig+0xa18>)
20019964:	4293      	cmp	r3, r2
20019966:	d040      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019968:	687b      	ldr	r3, [r7, #4]
2001996a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001996e:	4a4f      	ldr	r2, [pc, #316]	; (20019aac <HAL_RCCEx_PeriphCLKConfig+0xa1c>)
20019970:	4293      	cmp	r3, r2
20019972:	d03a      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019974:	687b      	ldr	r3, [r7, #4]
20019976:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001997a:	4a4d      	ldr	r2, [pc, #308]	; (20019ab0 <HAL_RCCEx_PeriphCLKConfig+0xa20>)
2001997c:	4293      	cmp	r3, r2
2001997e:	d034      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019980:	687b      	ldr	r3, [r7, #4]
20019982:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019986:	4a4b      	ldr	r2, [pc, #300]	; (20019ab4 <HAL_RCCEx_PeriphCLKConfig+0xa24>)
20019988:	4293      	cmp	r3, r2
2001998a:	d02e      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
2001998c:	687b      	ldr	r3, [r7, #4]
2001998e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019992:	4a49      	ldr	r2, [pc, #292]	; (20019ab8 <HAL_RCCEx_PeriphCLKConfig+0xa28>)
20019994:	4293      	cmp	r3, r2
20019996:	d028      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
20019998:	687b      	ldr	r3, [r7, #4]
2001999a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2001999e:	4a47      	ldr	r2, [pc, #284]	; (20019abc <HAL_RCCEx_PeriphCLKConfig+0xa2c>)
200199a0:	4293      	cmp	r3, r2
200199a2:	d022      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200199a4:	687b      	ldr	r3, [r7, #4]
200199a6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200199aa:	4a45      	ldr	r2, [pc, #276]	; (20019ac0 <HAL_RCCEx_PeriphCLKConfig+0xa30>)
200199ac:	4293      	cmp	r3, r2
200199ae:	d01c      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200199b0:	687b      	ldr	r3, [r7, #4]
200199b2:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200199b6:	4a43      	ldr	r2, [pc, #268]	; (20019ac4 <HAL_RCCEx_PeriphCLKConfig+0xa34>)
200199b8:	4293      	cmp	r3, r2
200199ba:	d016      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200199bc:	687b      	ldr	r3, [r7, #4]
200199be:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200199c2:	4a41      	ldr	r2, [pc, #260]	; (20019ac8 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
200199c4:	4293      	cmp	r3, r2
200199c6:	d010      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200199c8:	687b      	ldr	r3, [r7, #4]
200199ca:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200199ce:	4a3f      	ldr	r2, [pc, #252]	; (20019acc <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
200199d0:	4293      	cmp	r3, r2
200199d2:	d00a      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200199d4:	687b      	ldr	r3, [r7, #4]
200199d6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
200199da:	4a3d      	ldr	r2, [pc, #244]	; (20019ad0 <HAL_RCCEx_PeriphCLKConfig+0xa40>)
200199dc:	4293      	cmp	r3, r2
200199de:	d004      	beq.n	200199ea <HAL_RCCEx_PeriphCLKConfig+0x95a>
200199e0:	f44f 715a 	mov.w	r1, #872	; 0x368
200199e4:	483b      	ldr	r0, [pc, #236]	; (20019ad4 <HAL_RCCEx_PeriphCLKConfig+0xa44>)
200199e6:	f7e6 ff85 	bl	200008f4 <assert_failed>

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
200199ea:	4b3b      	ldr	r3, [pc, #236]	; (20019ad8 <HAL_RCCEx_PeriphCLKConfig+0xa48>)
200199ec:	681b      	ldr	r3, [r3, #0]
200199ee:	4a3a      	ldr	r2, [pc, #232]	; (20019ad8 <HAL_RCCEx_PeriphCLKConfig+0xa48>)
200199f0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
200199f4:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
200199f6:	f7e8 f979 	bl	20001cec <HAL_GetTick>
200199fa:	6138      	str	r0, [r7, #16]

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
200199fc:	e06e      	b.n	20019adc <HAL_RCCEx_PeriphCLKConfig+0xa4c>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
200199fe:	f7e8 f975 	bl	20001cec <HAL_GetTick>
20019a02:	4602      	mov	r2, r0
20019a04:	693b      	ldr	r3, [r7, #16]
20019a06:	1ad3      	subs	r3, r2, r3
20019a08:	2b64      	cmp	r3, #100	; 0x64
20019a0a:	d967      	bls.n	20019adc <HAL_RCCEx_PeriphCLKConfig+0xa4c>
      {
        ret = HAL_TIMEOUT;
20019a0c:	2303      	movs	r3, #3
20019a0e:	75fb      	strb	r3, [r7, #23]
        break;
20019a10:	e06a      	b.n	20019ae8 <HAL_RCCEx_PeriphCLKConfig+0xa58>
20019a12:	bf00      	nop
20019a14:	00010300 	.word	0x00010300
20019a18:	00011300 	.word	0x00011300
20019a1c:	00012300 	.word	0x00012300
20019a20:	00013300 	.word	0x00013300
20019a24:	00014300 	.word	0x00014300
20019a28:	00015300 	.word	0x00015300
20019a2c:	00016300 	.word	0x00016300
20019a30:	00017300 	.word	0x00017300
20019a34:	00018300 	.word	0x00018300
20019a38:	00019300 	.word	0x00019300
20019a3c:	0001a300 	.word	0x0001a300
20019a40:	0001b300 	.word	0x0001b300
20019a44:	0001c300 	.word	0x0001c300
20019a48:	0001d300 	.word	0x0001d300
20019a4c:	0001e300 	.word	0x0001e300
20019a50:	0001f300 	.word	0x0001f300
20019a54:	00020300 	.word	0x00020300
20019a58:	00021300 	.word	0x00021300
20019a5c:	00022300 	.word	0x00022300
20019a60:	00023300 	.word	0x00023300
20019a64:	00024300 	.word	0x00024300
20019a68:	00025300 	.word	0x00025300
20019a6c:	00026300 	.word	0x00026300
20019a70:	00027300 	.word	0x00027300
20019a74:	00028300 	.word	0x00028300
20019a78:	00029300 	.word	0x00029300
20019a7c:	0002a300 	.word	0x0002a300
20019a80:	0002b300 	.word	0x0002b300
20019a84:	0002c300 	.word	0x0002c300
20019a88:	0002d300 	.word	0x0002d300
20019a8c:	0002e300 	.word	0x0002e300
20019a90:	0002f300 	.word	0x0002f300
20019a94:	00030300 	.word	0x00030300
20019a98:	00031300 	.word	0x00031300
20019a9c:	00032300 	.word	0x00032300
20019aa0:	00033300 	.word	0x00033300
20019aa4:	00034300 	.word	0x00034300
20019aa8:	00035300 	.word	0x00035300
20019aac:	00036300 	.word	0x00036300
20019ab0:	00037300 	.word	0x00037300
20019ab4:	00038300 	.word	0x00038300
20019ab8:	00039300 	.word	0x00039300
20019abc:	0003a300 	.word	0x0003a300
20019ac0:	0003b300 	.word	0x0003b300
20019ac4:	0003c300 	.word	0x0003c300
20019ac8:	0003d300 	.word	0x0003d300
20019acc:	0003e300 	.word	0x0003e300
20019ad0:	0003f300 	.word	0x0003f300
20019ad4:	2001c318 	.word	0x2001c318
20019ad8:	58024800 	.word	0x58024800
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
20019adc:	4bb9      	ldr	r3, [pc, #740]	; (20019dc4 <HAL_RCCEx_PeriphCLKConfig+0xd34>)
20019ade:	681b      	ldr	r3, [r3, #0]
20019ae0:	f403 7380 	and.w	r3, r3, #256	; 0x100
20019ae4:	2b00      	cmp	r3, #0
20019ae6:	d08a      	beq.n	200199fe <HAL_RCCEx_PeriphCLKConfig+0x96e>
      }
    }

    if(ret == HAL_OK)
20019ae8:	7dfb      	ldrb	r3, [r7, #23]
20019aea:	2b00      	cmp	r3, #0
20019aec:	d166      	bne.n	20019bbc <HAL_RCCEx_PeriphCLKConfig+0xb2c>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
20019aee:	4bb6      	ldr	r3, [pc, #728]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019af0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
20019af2:	687b      	ldr	r3, [r7, #4]
20019af4:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019af8:	4053      	eors	r3, r2
20019afa:	f403 7340 	and.w	r3, r3, #768	; 0x300
20019afe:	2b00      	cmp	r3, #0
20019b00:	d013      	beq.n	20019b2a <HAL_RCCEx_PeriphCLKConfig+0xa9a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
20019b02:	4bb1      	ldr	r3, [pc, #708]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b04:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20019b06:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20019b0a:	60fb      	str	r3, [r7, #12]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
20019b0c:	4bae      	ldr	r3, [pc, #696]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b0e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20019b10:	4aad      	ldr	r2, [pc, #692]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b12:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20019b16:	6713      	str	r3, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
20019b18:	4bab      	ldr	r3, [pc, #684]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b1a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20019b1c:	4aaa      	ldr	r2, [pc, #680]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b1e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20019b22:	6713      	str	r3, [r2, #112]	; 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
20019b24:	4aa8      	ldr	r2, [pc, #672]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b26:	68fb      	ldr	r3, [r7, #12]
20019b28:	6713      	str	r3, [r2, #112]	; 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
20019b2a:	687b      	ldr	r3, [r7, #4]
20019b2c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019b30:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20019b34:	d115      	bne.n	20019b62 <HAL_RCCEx_PeriphCLKConfig+0xad2>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20019b36:	f7e8 f8d9 	bl	20001cec <HAL_GetTick>
20019b3a:	6138      	str	r0, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
20019b3c:	e00b      	b.n	20019b56 <HAL_RCCEx_PeriphCLKConfig+0xac6>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
20019b3e:	f7e8 f8d5 	bl	20001cec <HAL_GetTick>
20019b42:	4602      	mov	r2, r0
20019b44:	693b      	ldr	r3, [r7, #16]
20019b46:	1ad3      	subs	r3, r2, r3
20019b48:	f241 3288 	movw	r2, #5000	; 0x1388
20019b4c:	4293      	cmp	r3, r2
20019b4e:	d902      	bls.n	20019b56 <HAL_RCCEx_PeriphCLKConfig+0xac6>
          {
            ret = HAL_TIMEOUT;
20019b50:	2303      	movs	r3, #3
20019b52:	75fb      	strb	r3, [r7, #23]
            break;
20019b54:	e005      	b.n	20019b62 <HAL_RCCEx_PeriphCLKConfig+0xad2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
20019b56:	4b9c      	ldr	r3, [pc, #624]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b58:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20019b5a:	f003 0302 	and.w	r3, r3, #2
20019b5e:	2b00      	cmp	r3, #0
20019b60:	d0ed      	beq.n	20019b3e <HAL_RCCEx_PeriphCLKConfig+0xaae>
          }
        }
      }

      if(ret == HAL_OK)
20019b62:	7dfb      	ldrb	r3, [r7, #23]
20019b64:	2b00      	cmp	r3, #0
20019b66:	d126      	bne.n	20019bb6 <HAL_RCCEx_PeriphCLKConfig+0xb26>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
20019b68:	687b      	ldr	r3, [r7, #4]
20019b6a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019b6e:	f403 7340 	and.w	r3, r3, #768	; 0x300
20019b72:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
20019b76:	d10d      	bne.n	20019b94 <HAL_RCCEx_PeriphCLKConfig+0xb04>
20019b78:	4b93      	ldr	r3, [pc, #588]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b7a:	691b      	ldr	r3, [r3, #16]
20019b7c:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
20019b80:	687b      	ldr	r3, [r7, #4]
20019b82:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019b86:	0919      	lsrs	r1, r3, #4
20019b88:	4b90      	ldr	r3, [pc, #576]	; (20019dcc <HAL_RCCEx_PeriphCLKConfig+0xd3c>)
20019b8a:	400b      	ands	r3, r1
20019b8c:	498e      	ldr	r1, [pc, #568]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b8e:	4313      	orrs	r3, r2
20019b90:	610b      	str	r3, [r1, #16]
20019b92:	e005      	b.n	20019ba0 <HAL_RCCEx_PeriphCLKConfig+0xb10>
20019b94:	4b8c      	ldr	r3, [pc, #560]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b96:	691b      	ldr	r3, [r3, #16]
20019b98:	4a8b      	ldr	r2, [pc, #556]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019b9a:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
20019b9e:	6113      	str	r3, [r2, #16]
20019ba0:	4b89      	ldr	r3, [pc, #548]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019ba2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
20019ba4:	687b      	ldr	r3, [r7, #4]
20019ba6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
20019baa:	f3c3 030b 	ubfx	r3, r3, #0, #12
20019bae:	4986      	ldr	r1, [pc, #536]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019bb0:	4313      	orrs	r3, r2
20019bb2:	670b      	str	r3, [r1, #112]	; 0x70
20019bb4:	e004      	b.n	20019bc0 <HAL_RCCEx_PeriphCLKConfig+0xb30>
      }
      else
      {
        /* set overall return value */
        status = ret;
20019bb6:	7dfb      	ldrb	r3, [r7, #23]
20019bb8:	75bb      	strb	r3, [r7, #22]
20019bba:	e001      	b.n	20019bc0 <HAL_RCCEx_PeriphCLKConfig+0xb30>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
20019bbc:	7dfb      	ldrb	r3, [r7, #23]
20019bbe:	75bb      	strb	r3, [r7, #22]
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
20019bc0:	687b      	ldr	r3, [r7, #4]
20019bc2:	681b      	ldr	r3, [r3, #0]
20019bc4:	f003 0301 	and.w	r3, r3, #1
20019bc8:	2b00      	cmp	r3, #0
20019bca:	d07e      	beq.n	20019cca <HAL_RCCEx_PeriphCLKConfig+0xc3a>
  {
    switch(PeriphClkInit->Usart16ClockSelection)
20019bcc:	687b      	ldr	r3, [r7, #4]
20019bce:	6f9b      	ldr	r3, [r3, #120]	; 0x78
20019bd0:	2b28      	cmp	r3, #40	; 0x28
20019bd2:	d867      	bhi.n	20019ca4 <HAL_RCCEx_PeriphCLKConfig+0xc14>
20019bd4:	a201      	add	r2, pc, #4	; (adr r2, 20019bdc <HAL_RCCEx_PeriphCLKConfig+0xb4c>)
20019bd6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20019bda:	bf00      	nop
20019bdc:	20019cab 	.word	0x20019cab
20019be0:	20019ca5 	.word	0x20019ca5
20019be4:	20019ca5 	.word	0x20019ca5
20019be8:	20019ca5 	.word	0x20019ca5
20019bec:	20019ca5 	.word	0x20019ca5
20019bf0:	20019ca5 	.word	0x20019ca5
20019bf4:	20019ca5 	.word	0x20019ca5
20019bf8:	20019ca5 	.word	0x20019ca5
20019bfc:	20019c81 	.word	0x20019c81
20019c00:	20019ca5 	.word	0x20019ca5
20019c04:	20019ca5 	.word	0x20019ca5
20019c08:	20019ca5 	.word	0x20019ca5
20019c0c:	20019ca5 	.word	0x20019ca5
20019c10:	20019ca5 	.word	0x20019ca5
20019c14:	20019ca5 	.word	0x20019ca5
20019c18:	20019ca5 	.word	0x20019ca5
20019c1c:	20019c93 	.word	0x20019c93
20019c20:	20019ca5 	.word	0x20019ca5
20019c24:	20019ca5 	.word	0x20019ca5
20019c28:	20019ca5 	.word	0x20019ca5
20019c2c:	20019ca5 	.word	0x20019ca5
20019c30:	20019ca5 	.word	0x20019ca5
20019c34:	20019ca5 	.word	0x20019ca5
20019c38:	20019ca5 	.word	0x20019ca5
20019c3c:	20019cab 	.word	0x20019cab
20019c40:	20019ca5 	.word	0x20019ca5
20019c44:	20019ca5 	.word	0x20019ca5
20019c48:	20019ca5 	.word	0x20019ca5
20019c4c:	20019ca5 	.word	0x20019ca5
20019c50:	20019ca5 	.word	0x20019ca5
20019c54:	20019ca5 	.word	0x20019ca5
20019c58:	20019ca5 	.word	0x20019ca5
20019c5c:	20019cab 	.word	0x20019cab
20019c60:	20019ca5 	.word	0x20019ca5
20019c64:	20019ca5 	.word	0x20019ca5
20019c68:	20019ca5 	.word	0x20019ca5
20019c6c:	20019ca5 	.word	0x20019ca5
20019c70:	20019ca5 	.word	0x20019ca5
20019c74:	20019ca5 	.word	0x20019ca5
20019c78:	20019ca5 	.word	0x20019ca5
20019c7c:	20019cab 	.word	0x20019cab
    case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
20019c80:	687b      	ldr	r3, [r7, #4]
20019c82:	3304      	adds	r3, #4
20019c84:	2101      	movs	r1, #1
20019c86:	4618      	mov	r0, r3
20019c88:	f001 fe4a 	bl	2001b920 <RCCEx_PLL2_Config>
20019c8c:	4603      	mov	r3, r0
20019c8e:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
20019c90:	e00c      	b.n	20019cac <HAL_RCCEx_PeriphCLKConfig+0xc1c>

    case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
20019c92:	687b      	ldr	r3, [r7, #4]
20019c94:	3324      	adds	r3, #36	; 0x24
20019c96:	2101      	movs	r1, #1
20019c98:	4618      	mov	r0, r3
20019c9a:	f001 ff63 	bl	2001bb64 <RCCEx_PLL3_Config>
20019c9e:	4603      	mov	r3, r0
20019ca0:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
20019ca2:	e003      	b.n	20019cac <HAL_RCCEx_PeriphCLKConfig+0xc1c>
      /* LSE,  oscillator is used as source of USART1/6 clock */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
20019ca4:	2301      	movs	r3, #1
20019ca6:	75fb      	strb	r3, [r7, #23]
      break;
20019ca8:	e000      	b.n	20019cac <HAL_RCCEx_PeriphCLKConfig+0xc1c>
      break;
20019caa:	bf00      	nop
    }

    if(ret == HAL_OK)
20019cac:	7dfb      	ldrb	r3, [r7, #23]
20019cae:	2b00      	cmp	r3, #0
20019cb0:	d109      	bne.n	20019cc6 <HAL_RCCEx_PeriphCLKConfig+0xc36>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
20019cb2:	4b45      	ldr	r3, [pc, #276]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019cb4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20019cb6:	f023 0238 	bic.w	r2, r3, #56	; 0x38
20019cba:	687b      	ldr	r3, [r7, #4]
20019cbc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
20019cbe:	4942      	ldr	r1, [pc, #264]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019cc0:	4313      	orrs	r3, r2
20019cc2:	654b      	str	r3, [r1, #84]	; 0x54
20019cc4:	e001      	b.n	20019cca <HAL_RCCEx_PeriphCLKConfig+0xc3a>
    }
    else
    {
      /* set overall return value */
      status = ret;
20019cc6:	7dfb      	ldrb	r3, [r7, #23]
20019cc8:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
20019cca:	687b      	ldr	r3, [r7, #4]
20019ccc:	681b      	ldr	r3, [r3, #0]
20019cce:	f003 0302 	and.w	r3, r3, #2
20019cd2:	2b00      	cmp	r3, #0
20019cd4:	d037      	beq.n	20019d46 <HAL_RCCEx_PeriphCLKConfig+0xcb6>
  {
    switch(PeriphClkInit->Usart234578ClockSelection)
20019cd6:	687b      	ldr	r3, [r7, #4]
20019cd8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20019cda:	2b05      	cmp	r3, #5
20019cdc:	d820      	bhi.n	20019d20 <HAL_RCCEx_PeriphCLKConfig+0xc90>
20019cde:	a201      	add	r2, pc, #4	; (adr r2, 20019ce4 <HAL_RCCEx_PeriphCLKConfig+0xc54>)
20019ce0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20019ce4:	20019d27 	.word	0x20019d27
20019ce8:	20019cfd 	.word	0x20019cfd
20019cec:	20019d0f 	.word	0x20019d0f
20019cf0:	20019d27 	.word	0x20019d27
20019cf4:	20019d27 	.word	0x20019d27
20019cf8:	20019d27 	.word	0x20019d27
    case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
20019cfc:	687b      	ldr	r3, [r7, #4]
20019cfe:	3304      	adds	r3, #4
20019d00:	2101      	movs	r1, #1
20019d02:	4618      	mov	r0, r3
20019d04:	f001 fe0c 	bl	2001b920 <RCCEx_PLL2_Config>
20019d08:	4603      	mov	r3, r0
20019d0a:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
20019d0c:	e00c      	b.n	20019d28 <HAL_RCCEx_PeriphCLKConfig+0xc98>

    case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
20019d0e:	687b      	ldr	r3, [r7, #4]
20019d10:	3324      	adds	r3, #36	; 0x24
20019d12:	2101      	movs	r1, #1
20019d14:	4618      	mov	r0, r3
20019d16:	f001 ff25 	bl	2001bb64 <RCCEx_PLL3_Config>
20019d1a:	4603      	mov	r3, r0
20019d1c:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
20019d1e:	e003      	b.n	20019d28 <HAL_RCCEx_PeriphCLKConfig+0xc98>
      /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
20019d20:	2301      	movs	r3, #1
20019d22:	75fb      	strb	r3, [r7, #23]
      break;
20019d24:	e000      	b.n	20019d28 <HAL_RCCEx_PeriphCLKConfig+0xc98>
      break;
20019d26:	bf00      	nop
    }

    if(ret == HAL_OK)
20019d28:	7dfb      	ldrb	r3, [r7, #23]
20019d2a:	2b00      	cmp	r3, #0
20019d2c:	d109      	bne.n	20019d42 <HAL_RCCEx_PeriphCLKConfig+0xcb2>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
20019d2e:	4b26      	ldr	r3, [pc, #152]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019d30:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20019d32:	f023 0207 	bic.w	r2, r3, #7
20019d36:	687b      	ldr	r3, [r7, #4]
20019d38:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20019d3a:	4923      	ldr	r1, [pc, #140]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019d3c:	4313      	orrs	r3, r2
20019d3e:	654b      	str	r3, [r1, #84]	; 0x54
20019d40:	e001      	b.n	20019d46 <HAL_RCCEx_PeriphCLKConfig+0xcb6>
    }
    else
    {
      /* set overall return value */
      status = ret;
20019d42:	7dfb      	ldrb	r3, [r7, #23]
20019d44:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
20019d46:	687b      	ldr	r3, [r7, #4]
20019d48:	681b      	ldr	r3, [r3, #0]
20019d4a:	f003 0304 	and.w	r3, r3, #4
20019d4e:	2b00      	cmp	r3, #0
20019d50:	d040      	beq.n	20019dd4 <HAL_RCCEx_PeriphCLKConfig+0xd44>
  {
    switch(PeriphClkInit->Lpuart1ClockSelection)
20019d52:	687b      	ldr	r3, [r7, #4]
20019d54:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20019d58:	2b05      	cmp	r3, #5
20019d5a:	d821      	bhi.n	20019da0 <HAL_RCCEx_PeriphCLKConfig+0xd10>
20019d5c:	a201      	add	r2, pc, #4	; (adr r2, 20019d64 <HAL_RCCEx_PeriphCLKConfig+0xcd4>)
20019d5e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20019d62:	bf00      	nop
20019d64:	20019da7 	.word	0x20019da7
20019d68:	20019d7d 	.word	0x20019d7d
20019d6c:	20019d8f 	.word	0x20019d8f
20019d70:	20019da7 	.word	0x20019da7
20019d74:	20019da7 	.word	0x20019da7
20019d78:	20019da7 	.word	0x20019da7
    case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
20019d7c:	687b      	ldr	r3, [r7, #4]
20019d7e:	3304      	adds	r3, #4
20019d80:	2101      	movs	r1, #1
20019d82:	4618      	mov	r0, r3
20019d84:	f001 fdcc 	bl	2001b920 <RCCEx_PLL2_Config>
20019d88:	4603      	mov	r3, r0
20019d8a:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
20019d8c:	e00c      	b.n	20019da8 <HAL_RCCEx_PeriphCLKConfig+0xd18>

    case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
20019d8e:	687b      	ldr	r3, [r7, #4]
20019d90:	3324      	adds	r3, #36	; 0x24
20019d92:	2101      	movs	r1, #1
20019d94:	4618      	mov	r0, r3
20019d96:	f001 fee5 	bl	2001bb64 <RCCEx_PLL3_Config>
20019d9a:	4603      	mov	r3, r0
20019d9c:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
20019d9e:	e003      	b.n	20019da8 <HAL_RCCEx_PeriphCLKConfig+0xd18>
      /* LSE,  oscillator is used as source of LPUART1 clock */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
20019da0:	2301      	movs	r3, #1
20019da2:	75fb      	strb	r3, [r7, #23]
      break;
20019da4:	e000      	b.n	20019da8 <HAL_RCCEx_PeriphCLKConfig+0xd18>
      break;
20019da6:	bf00      	nop
    }

    if(ret == HAL_OK)
20019da8:	7dfb      	ldrb	r3, [r7, #23]
20019daa:	2b00      	cmp	r3, #0
20019dac:	d110      	bne.n	20019dd0 <HAL_RCCEx_PeriphCLKConfig+0xd40>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
20019dae:	4b06      	ldr	r3, [pc, #24]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019db0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20019db2:	f023 0207 	bic.w	r2, r3, #7
20019db6:	687b      	ldr	r3, [r7, #4]
20019db8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20019dbc:	4902      	ldr	r1, [pc, #8]	; (20019dc8 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
20019dbe:	4313      	orrs	r3, r2
20019dc0:	658b      	str	r3, [r1, #88]	; 0x58
20019dc2:	e007      	b.n	20019dd4 <HAL_RCCEx_PeriphCLKConfig+0xd44>
20019dc4:	58024800 	.word	0x58024800
20019dc8:	58024400 	.word	0x58024400
20019dcc:	00ffffcf 	.word	0x00ffffcf
    }
    else
    {
      /* set overall return value */
      status = ret;
20019dd0:	7dfb      	ldrb	r3, [r7, #23]
20019dd2:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
20019dd4:	687b      	ldr	r3, [r7, #4]
20019dd6:	681b      	ldr	r3, [r3, #0]
20019dd8:	f003 0320 	and.w	r3, r3, #32
20019ddc:	2b00      	cmp	r3, #0
20019dde:	d044      	beq.n	20019e6a <HAL_RCCEx_PeriphCLKConfig+0xdda>
  {
    switch(PeriphClkInit->Lptim1ClockSelection)
20019de0:	687b      	ldr	r3, [r7, #4]
20019de2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
20019de6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20019dea:	d01b      	beq.n	20019e24 <HAL_RCCEx_PeriphCLKConfig+0xd94>
20019dec:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
20019df0:	d805      	bhi.n	20019dfe <HAL_RCCEx_PeriphCLKConfig+0xd6e>
20019df2:	2b00      	cmp	r3, #0
20019df4:	d022      	beq.n	20019e3c <HAL_RCCEx_PeriphCLKConfig+0xdac>
20019df6:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
20019dfa:	d00a      	beq.n	20019e12 <HAL_RCCEx_PeriphCLKConfig+0xd82>
20019dfc:	e01b      	b.n	20019e36 <HAL_RCCEx_PeriphCLKConfig+0xda6>
20019dfe:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20019e02:	d01d      	beq.n	20019e40 <HAL_RCCEx_PeriphCLKConfig+0xdb0>
20019e04:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
20019e08:	d01c      	beq.n	20019e44 <HAL_RCCEx_PeriphCLKConfig+0xdb4>
20019e0a:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
20019e0e:	d01b      	beq.n	20019e48 <HAL_RCCEx_PeriphCLKConfig+0xdb8>
20019e10:	e011      	b.n	20019e36 <HAL_RCCEx_PeriphCLKConfig+0xda6>
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
20019e12:	687b      	ldr	r3, [r7, #4]
20019e14:	3304      	adds	r3, #4
20019e16:	2100      	movs	r1, #0
20019e18:	4618      	mov	r0, r3
20019e1a:	f001 fd81 	bl	2001b920 <RCCEx_PLL2_Config>
20019e1e:	4603      	mov	r3, r0
20019e20:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
20019e22:	e012      	b.n	20019e4a <HAL_RCCEx_PeriphCLKConfig+0xdba>

    case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
20019e24:	687b      	ldr	r3, [r7, #4]
20019e26:	3324      	adds	r3, #36	; 0x24
20019e28:	2102      	movs	r1, #2
20019e2a:	4618      	mov	r0, r3
20019e2c:	f001 fe9a 	bl	2001bb64 <RCCEx_PLL3_Config>
20019e30:	4603      	mov	r3, r0
20019e32:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
20019e34:	e009      	b.n	20019e4a <HAL_RCCEx_PeriphCLKConfig+0xdba>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
20019e36:	2301      	movs	r3, #1
20019e38:	75fb      	strb	r3, [r7, #23]
      break;
20019e3a:	e006      	b.n	20019e4a <HAL_RCCEx_PeriphCLKConfig+0xdba>
      break;
20019e3c:	bf00      	nop
20019e3e:	e004      	b.n	20019e4a <HAL_RCCEx_PeriphCLKConfig+0xdba>
      break;
20019e40:	bf00      	nop
20019e42:	e002      	b.n	20019e4a <HAL_RCCEx_PeriphCLKConfig+0xdba>
      break;
20019e44:	bf00      	nop
20019e46:	e000      	b.n	20019e4a <HAL_RCCEx_PeriphCLKConfig+0xdba>
      break;
20019e48:	bf00      	nop
    }

    if(ret == HAL_OK)
20019e4a:	7dfb      	ldrb	r3, [r7, #23]
20019e4c:	2b00      	cmp	r3, #0
20019e4e:	d10a      	bne.n	20019e66 <HAL_RCCEx_PeriphCLKConfig+0xdd6>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
20019e50:	4bb6      	ldr	r3, [pc, #728]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
20019e52:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20019e54:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
20019e58:	687b      	ldr	r3, [r7, #4]
20019e5a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
20019e5e:	49b3      	ldr	r1, [pc, #716]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
20019e60:	4313      	orrs	r3, r2
20019e62:	654b      	str	r3, [r1, #84]	; 0x54
20019e64:	e001      	b.n	20019e6a <HAL_RCCEx_PeriphCLKConfig+0xdda>
    }
    else
    {
      /* set overall return value */
      status = ret;
20019e66:	7dfb      	ldrb	r3, [r7, #23]
20019e68:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
20019e6a:	687b      	ldr	r3, [r7, #4]
20019e6c:	681b      	ldr	r3, [r3, #0]
20019e6e:	f003 0340 	and.w	r3, r3, #64	; 0x40
20019e72:	2b00      	cmp	r3, #0
20019e74:	d044      	beq.n	20019f00 <HAL_RCCEx_PeriphCLKConfig+0xe70>
  {
    switch(PeriphClkInit->Lptim2ClockSelection)
20019e76:	687b      	ldr	r3, [r7, #4]
20019e78:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20019e7c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
20019e80:	d01b      	beq.n	20019eba <HAL_RCCEx_PeriphCLKConfig+0xe2a>
20019e82:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
20019e86:	d805      	bhi.n	20019e94 <HAL_RCCEx_PeriphCLKConfig+0xe04>
20019e88:	2b00      	cmp	r3, #0
20019e8a:	d022      	beq.n	20019ed2 <HAL_RCCEx_PeriphCLKConfig+0xe42>
20019e8c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20019e90:	d00a      	beq.n	20019ea8 <HAL_RCCEx_PeriphCLKConfig+0xe18>
20019e92:	e01b      	b.n	20019ecc <HAL_RCCEx_PeriphCLKConfig+0xe3c>
20019e94:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20019e98:	d01d      	beq.n	20019ed6 <HAL_RCCEx_PeriphCLKConfig+0xe46>
20019e9a:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
20019e9e:	d01c      	beq.n	20019eda <HAL_RCCEx_PeriphCLKConfig+0xe4a>
20019ea0:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
20019ea4:	d01b      	beq.n	20019ede <HAL_RCCEx_PeriphCLKConfig+0xe4e>
20019ea6:	e011      	b.n	20019ecc <HAL_RCCEx_PeriphCLKConfig+0xe3c>
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
20019ea8:	687b      	ldr	r3, [r7, #4]
20019eaa:	3304      	adds	r3, #4
20019eac:	2100      	movs	r1, #0
20019eae:	4618      	mov	r0, r3
20019eb0:	f001 fd36 	bl	2001b920 <RCCEx_PLL2_Config>
20019eb4:	4603      	mov	r3, r0
20019eb6:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
20019eb8:	e012      	b.n	20019ee0 <HAL_RCCEx_PeriphCLKConfig+0xe50>

    case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
20019eba:	687b      	ldr	r3, [r7, #4]
20019ebc:	3324      	adds	r3, #36	; 0x24
20019ebe:	2102      	movs	r1, #2
20019ec0:	4618      	mov	r0, r3
20019ec2:	f001 fe4f 	bl	2001bb64 <RCCEx_PLL3_Config>
20019ec6:	4603      	mov	r3, r0
20019ec8:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
20019eca:	e009      	b.n	20019ee0 <HAL_RCCEx_PeriphCLKConfig+0xe50>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
20019ecc:	2301      	movs	r3, #1
20019ece:	75fb      	strb	r3, [r7, #23]
      break;
20019ed0:	e006      	b.n	20019ee0 <HAL_RCCEx_PeriphCLKConfig+0xe50>
      break;
20019ed2:	bf00      	nop
20019ed4:	e004      	b.n	20019ee0 <HAL_RCCEx_PeriphCLKConfig+0xe50>
      break;
20019ed6:	bf00      	nop
20019ed8:	e002      	b.n	20019ee0 <HAL_RCCEx_PeriphCLKConfig+0xe50>
      break;
20019eda:	bf00      	nop
20019edc:	e000      	b.n	20019ee0 <HAL_RCCEx_PeriphCLKConfig+0xe50>
      break;
20019ede:	bf00      	nop
    }

    if(ret == HAL_OK)
20019ee0:	7dfb      	ldrb	r3, [r7, #23]
20019ee2:	2b00      	cmp	r3, #0
20019ee4:	d10a      	bne.n	20019efc <HAL_RCCEx_PeriphCLKConfig+0xe6c>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
20019ee6:	4b91      	ldr	r3, [pc, #580]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
20019ee8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20019eea:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
20019eee:	687b      	ldr	r3, [r7, #4]
20019ef0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20019ef4:	498d      	ldr	r1, [pc, #564]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
20019ef6:	4313      	orrs	r3, r2
20019ef8:	658b      	str	r3, [r1, #88]	; 0x58
20019efa:	e001      	b.n	20019f00 <HAL_RCCEx_PeriphCLKConfig+0xe70>
    }
    else
    {
      /* set overall return value */
      status = ret;
20019efc:	7dfb      	ldrb	r3, [r7, #23]
20019efe:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
20019f00:	687b      	ldr	r3, [r7, #4]
20019f02:	681b      	ldr	r3, [r3, #0]
20019f04:	f003 0380 	and.w	r3, r3, #128	; 0x80
20019f08:	2b00      	cmp	r3, #0
20019f0a:	d044      	beq.n	20019f96 <HAL_RCCEx_PeriphCLKConfig+0xf06>
  {
    switch(PeriphClkInit->Lptim345ClockSelection)
20019f0c:	687b      	ldr	r3, [r7, #4]
20019f0e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20019f12:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20019f16:	d01b      	beq.n	20019f50 <HAL_RCCEx_PeriphCLKConfig+0xec0>
20019f18:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20019f1c:	d805      	bhi.n	20019f2a <HAL_RCCEx_PeriphCLKConfig+0xe9a>
20019f1e:	2b00      	cmp	r3, #0
20019f20:	d022      	beq.n	20019f68 <HAL_RCCEx_PeriphCLKConfig+0xed8>
20019f22:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20019f26:	d00a      	beq.n	20019f3e <HAL_RCCEx_PeriphCLKConfig+0xeae>
20019f28:	e01b      	b.n	20019f62 <HAL_RCCEx_PeriphCLKConfig+0xed2>
20019f2a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20019f2e:	d01d      	beq.n	20019f6c <HAL_RCCEx_PeriphCLKConfig+0xedc>
20019f30:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
20019f34:	d01c      	beq.n	20019f70 <HAL_RCCEx_PeriphCLKConfig+0xee0>
20019f36:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
20019f3a:	d01b      	beq.n	20019f74 <HAL_RCCEx_PeriphCLKConfig+0xee4>
20019f3c:	e011      	b.n	20019f62 <HAL_RCCEx_PeriphCLKConfig+0xed2>
    case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
20019f3e:	687b      	ldr	r3, [r7, #4]
20019f40:	3304      	adds	r3, #4
20019f42:	2100      	movs	r1, #0
20019f44:	4618      	mov	r0, r3
20019f46:	f001 fceb 	bl	2001b920 <RCCEx_PLL2_Config>
20019f4a:	4603      	mov	r3, r0
20019f4c:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
20019f4e:	e012      	b.n	20019f76 <HAL_RCCEx_PeriphCLKConfig+0xee6>

    case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
20019f50:	687b      	ldr	r3, [r7, #4]
20019f52:	3324      	adds	r3, #36	; 0x24
20019f54:	2102      	movs	r1, #2
20019f56:	4618      	mov	r0, r3
20019f58:	f001 fe04 	bl	2001bb64 <RCCEx_PLL3_Config>
20019f5c:	4603      	mov	r3, r0
20019f5e:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
20019f60:	e009      	b.n	20019f76 <HAL_RCCEx_PeriphCLKConfig+0xee6>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
20019f62:	2301      	movs	r3, #1
20019f64:	75fb      	strb	r3, [r7, #23]
      break;
20019f66:	e006      	b.n	20019f76 <HAL_RCCEx_PeriphCLKConfig+0xee6>
      break;
20019f68:	bf00      	nop
20019f6a:	e004      	b.n	20019f76 <HAL_RCCEx_PeriphCLKConfig+0xee6>
      break;
20019f6c:	bf00      	nop
20019f6e:	e002      	b.n	20019f76 <HAL_RCCEx_PeriphCLKConfig+0xee6>
      break;
20019f70:	bf00      	nop
20019f72:	e000      	b.n	20019f76 <HAL_RCCEx_PeriphCLKConfig+0xee6>
      break;
20019f74:	bf00      	nop
    }

    if(ret == HAL_OK)
20019f76:	7dfb      	ldrb	r3, [r7, #23]
20019f78:	2b00      	cmp	r3, #0
20019f7a:	d10a      	bne.n	20019f92 <HAL_RCCEx_PeriphCLKConfig+0xf02>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
20019f7c:	4b6b      	ldr	r3, [pc, #428]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
20019f7e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20019f80:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
20019f84:	687b      	ldr	r3, [r7, #4]
20019f86:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20019f8a:	4968      	ldr	r1, [pc, #416]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
20019f8c:	4313      	orrs	r3, r2
20019f8e:	658b      	str	r3, [r1, #88]	; 0x58
20019f90:	e001      	b.n	20019f96 <HAL_RCCEx_PeriphCLKConfig+0xf06>
    }
    else
    {
      /* set overall return value */
      status = ret;
20019f92:	7dfb      	ldrb	r3, [r7, #23]
20019f94:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ I2C1/2/3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
20019f96:	687b      	ldr	r3, [r7, #4]
20019f98:	681b      	ldr	r3, [r3, #0]
20019f9a:	f003 0308 	and.w	r3, r3, #8
20019f9e:	2b00      	cmp	r3, #0
20019fa0:	d036      	beq.n	2001a010 <HAL_RCCEx_PeriphCLKConfig+0xf80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
20019fa2:	687b      	ldr	r3, [r7, #4]
20019fa4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
20019fa8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20019fac:	d015      	beq.n	20019fda <HAL_RCCEx_PeriphCLKConfig+0xf4a>
20019fae:	687b      	ldr	r3, [r7, #4]
20019fb0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
20019fb4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20019fb8:	d00f      	beq.n	20019fda <HAL_RCCEx_PeriphCLKConfig+0xf4a>
20019fba:	687b      	ldr	r3, [r7, #4]
20019fbc:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
20019fc0:	2b00      	cmp	r3, #0
20019fc2:	d00a      	beq.n	20019fda <HAL_RCCEx_PeriphCLKConfig+0xf4a>
20019fc4:	687b      	ldr	r3, [r7, #4]
20019fc6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
20019fca:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
20019fce:	d004      	beq.n	20019fda <HAL_RCCEx_PeriphCLKConfig+0xf4a>
20019fd0:	f240 41e6 	movw	r1, #1254	; 0x4e6
20019fd4:	4856      	ldr	r0, [pc, #344]	; (2001a130 <HAL_RCCEx_PeriphCLKConfig+0x10a0>)
20019fd6:	f7e6 fc8d 	bl	200008f4 <assert_failed>

    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
20019fda:	687b      	ldr	r3, [r7, #4]
20019fdc:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
20019fe0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20019fe4:	d10a      	bne.n	20019ffc <HAL_RCCEx_PeriphCLKConfig+0xf6c>
    {
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
20019fe6:	687b      	ldr	r3, [r7, #4]
20019fe8:	3324      	adds	r3, #36	; 0x24
20019fea:	2102      	movs	r1, #2
20019fec:	4618      	mov	r0, r3
20019fee:	f001 fdb9 	bl	2001bb64 <RCCEx_PLL3_Config>
20019ff2:	4603      	mov	r3, r0
20019ff4:	2b00      	cmp	r3, #0
20019ff6:	d001      	beq.n	20019ffc <HAL_RCCEx_PeriphCLKConfig+0xf6c>
        {
          status = HAL_ERROR;
20019ff8:	2301      	movs	r3, #1
20019ffa:	75bb      	strb	r3, [r7, #22]
        }
    }

      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
20019ffc:	4b4b      	ldr	r3, [pc, #300]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
20019ffe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2001a000:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
2001a004:	687b      	ldr	r3, [r7, #4]
2001a006:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2001a00a:	4948      	ldr	r1, [pc, #288]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
2001a00c:	4313      	orrs	r3, r2
2001a00e:	654b      	str	r3, [r1, #84]	; 0x54

  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
2001a010:	687b      	ldr	r3, [r7, #4]
2001a012:	681b      	ldr	r3, [r3, #0]
2001a014:	f003 0310 	and.w	r3, r3, #16
2001a018:	2b00      	cmp	r3, #0
2001a01a:	d036      	beq.n	2001a08a <HAL_RCCEx_PeriphCLKConfig+0xffa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
2001a01c:	687b      	ldr	r3, [r7, #4]
2001a01e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
2001a022:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2001a026:	d015      	beq.n	2001a054 <HAL_RCCEx_PeriphCLKConfig+0xfc4>
2001a028:	687b      	ldr	r3, [r7, #4]
2001a02a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
2001a02e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2001a032:	d00f      	beq.n	2001a054 <HAL_RCCEx_PeriphCLKConfig+0xfc4>
2001a034:	687b      	ldr	r3, [r7, #4]
2001a036:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
2001a03a:	2b00      	cmp	r3, #0
2001a03c:	d00a      	beq.n	2001a054 <HAL_RCCEx_PeriphCLKConfig+0xfc4>
2001a03e:	687b      	ldr	r3, [r7, #4]
2001a040:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
2001a044:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
2001a048:	d004      	beq.n	2001a054 <HAL_RCCEx_PeriphCLKConfig+0xfc4>
2001a04a:	f44f 619f 	mov.w	r1, #1272	; 0x4f8
2001a04e:	4838      	ldr	r0, [pc, #224]	; (2001a130 <HAL_RCCEx_PeriphCLKConfig+0x10a0>)
2001a050:	f7e6 fc50 	bl	200008f4 <assert_failed>

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
2001a054:	687b      	ldr	r3, [r7, #4]
2001a056:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
2001a05a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2001a05e:	d10a      	bne.n	2001a076 <HAL_RCCEx_PeriphCLKConfig+0xfe6>
    {
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
2001a060:	687b      	ldr	r3, [r7, #4]
2001a062:	3324      	adds	r3, #36	; 0x24
2001a064:	2102      	movs	r1, #2
2001a066:	4618      	mov	r0, r3
2001a068:	f001 fd7c 	bl	2001bb64 <RCCEx_PLL3_Config>
2001a06c:	4603      	mov	r3, r0
2001a06e:	2b00      	cmp	r3, #0
2001a070:	d001      	beq.n	2001a076 <HAL_RCCEx_PeriphCLKConfig+0xfe6>
      {
        status = HAL_ERROR;
2001a072:	2301      	movs	r3, #1
2001a074:	75bb      	strb	r3, [r7, #22]
      }
    }

      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
2001a076:	4b2d      	ldr	r3, [pc, #180]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
2001a078:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a07a:	f423 7240 	bic.w	r2, r3, #768	; 0x300
2001a07e:	687b      	ldr	r3, [r7, #4]
2001a080:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
2001a084:	4929      	ldr	r1, [pc, #164]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
2001a086:	4313      	orrs	r3, r2
2001a088:	658b      	str	r3, [r1, #88]	; 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
2001a08a:	687b      	ldr	r3, [r7, #4]
2001a08c:	681b      	ldr	r3, [r3, #0]
2001a08e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
2001a092:	2b00      	cmp	r3, #0
2001a094:	d030      	beq.n	2001a0f8 <HAL_RCCEx_PeriphCLKConfig+0x1068>
  {
    switch(PeriphClkInit->AdcClockSelection)
2001a096:	687b      	ldr	r3, [r7, #4]
2001a098:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
2001a09c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2001a0a0:	d00d      	beq.n	2001a0be <HAL_RCCEx_PeriphCLKConfig+0x102e>
2001a0a2:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2001a0a6:	d016      	beq.n	2001a0d6 <HAL_RCCEx_PeriphCLKConfig+0x1046>
2001a0a8:	2b00      	cmp	r3, #0
2001a0aa:	d111      	bne.n	2001a0d0 <HAL_RCCEx_PeriphCLKConfig+0x1040>
    {

    case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2001a0ac:	687b      	ldr	r3, [r7, #4]
2001a0ae:	3304      	adds	r3, #4
2001a0b0:	2100      	movs	r1, #0
2001a0b2:	4618      	mov	r0, r3
2001a0b4:	f001 fc34 	bl	2001b920 <RCCEx_PLL2_Config>
2001a0b8:	4603      	mov	r3, r0
2001a0ba:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
2001a0bc:	e00c      	b.n	2001a0d8 <HAL_RCCEx_PeriphCLKConfig+0x1048>

    case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2001a0be:	687b      	ldr	r3, [r7, #4]
2001a0c0:	3324      	adds	r3, #36	; 0x24
2001a0c2:	2102      	movs	r1, #2
2001a0c4:	4618      	mov	r0, r3
2001a0c6:	f001 fd4d 	bl	2001bb64 <RCCEx_PLL3_Config>
2001a0ca:	4603      	mov	r3, r0
2001a0cc:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
2001a0ce:	e003      	b.n	2001a0d8 <HAL_RCCEx_PeriphCLKConfig+0x1048>
      /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
      /* ADC clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2001a0d0:	2301      	movs	r3, #1
2001a0d2:	75fb      	strb	r3, [r7, #23]
      break;
2001a0d4:	e000      	b.n	2001a0d8 <HAL_RCCEx_PeriphCLKConfig+0x1048>
      break;
2001a0d6:	bf00      	nop
    }

    if(ret == HAL_OK)
2001a0d8:	7dfb      	ldrb	r3, [r7, #23]
2001a0da:	2b00      	cmp	r3, #0
2001a0dc:	d10a      	bne.n	2001a0f4 <HAL_RCCEx_PeriphCLKConfig+0x1064>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
2001a0de:	4b13      	ldr	r3, [pc, #76]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
2001a0e0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a0e2:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
2001a0e6:	687b      	ldr	r3, [r7, #4]
2001a0e8:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
2001a0ec:	490f      	ldr	r1, [pc, #60]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
2001a0ee:	4313      	orrs	r3, r2
2001a0f0:	658b      	str	r3, [r1, #88]	; 0x58
2001a0f2:	e001      	b.n	2001a0f8 <HAL_RCCEx_PeriphCLKConfig+0x1068>
    }
    else
    {
      /* set overall return value */
      status = ret;
2001a0f4:	7dfb      	ldrb	r3, [r7, #23]
2001a0f6:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
2001a0f8:	687b      	ldr	r3, [r7, #4]
2001a0fa:	681b      	ldr	r3, [r3, #0]
2001a0fc:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2001a100:	2b00      	cmp	r3, #0
2001a102:	d034      	beq.n	2001a16e <HAL_RCCEx_PeriphCLKConfig+0x10de>
  {

    switch(PeriphClkInit->UsbClockSelection)
2001a104:	687b      	ldr	r3, [r7, #4]
2001a106:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2001a10a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2001a10e:	d011      	beq.n	2001a134 <HAL_RCCEx_PeriphCLKConfig+0x10a4>
2001a110:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
2001a114:	d01a      	beq.n	2001a14c <HAL_RCCEx_PeriphCLKConfig+0x10bc>
2001a116:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2001a11a:	d114      	bne.n	2001a146 <HAL_RCCEx_PeriphCLKConfig+0x10b6>
    {
    case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
      /* Enable USB Clock output generated form System USB . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2001a11c:	4b03      	ldr	r3, [pc, #12]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
2001a11e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001a120:	4a02      	ldr	r2, [pc, #8]	; (2001a12c <HAL_RCCEx_PeriphCLKConfig+0x109c>)
2001a122:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2001a126:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* USB clock source configuration done later after clock selection check */
      break;
2001a128:	e011      	b.n	2001a14e <HAL_RCCEx_PeriphCLKConfig+0x10be>
2001a12a:	bf00      	nop
2001a12c:	58024400 	.word	0x58024400
2001a130:	2001c318 	.word	0x2001c318

    case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2001a134:	687b      	ldr	r3, [r7, #4]
2001a136:	3324      	adds	r3, #36	; 0x24
2001a138:	2101      	movs	r1, #1
2001a13a:	4618      	mov	r0, r3
2001a13c:	f001 fd12 	bl	2001bb64 <RCCEx_PLL3_Config>
2001a140:	4603      	mov	r3, r0
2001a142:	75fb      	strb	r3, [r7, #23]

      /* USB clock source configuration done later after clock selection check */
      break;
2001a144:	e003      	b.n	2001a14e <HAL_RCCEx_PeriphCLKConfig+0x10be>
      /* HSI48 oscillator is used as source of USB clock */
      /* USB clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2001a146:	2301      	movs	r3, #1
2001a148:	75fb      	strb	r3, [r7, #23]
      break;
2001a14a:	e000      	b.n	2001a14e <HAL_RCCEx_PeriphCLKConfig+0x10be>
      break;
2001a14c:	bf00      	nop
    }

    if(ret == HAL_OK)
2001a14e:	7dfb      	ldrb	r3, [r7, #23]
2001a150:	2b00      	cmp	r3, #0
2001a152:	d10a      	bne.n	2001a16a <HAL_RCCEx_PeriphCLKConfig+0x10da>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
2001a154:	4b8c      	ldr	r3, [pc, #560]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a156:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2001a158:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
2001a15c:	687b      	ldr	r3, [r7, #4]
2001a15e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2001a162:	4989      	ldr	r1, [pc, #548]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a164:	4313      	orrs	r3, r2
2001a166:	654b      	str	r3, [r1, #84]	; 0x54
2001a168:	e001      	b.n	2001a16e <HAL_RCCEx_PeriphCLKConfig+0x10de>
    }
    else
    {
      /* set overall return value */
      status = ret;
2001a16a:	7dfb      	ldrb	r3, [r7, #23]
2001a16c:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
2001a16e:	687b      	ldr	r3, [r7, #4]
2001a170:	681b      	ldr	r3, [r3, #0]
2001a172:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2001a176:	2b00      	cmp	r3, #0
2001a178:	d037      	beq.n	2001a1ea <HAL_RCCEx_PeriphCLKConfig+0x115a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
2001a17a:	687b      	ldr	r3, [r7, #4]
2001a17c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a17e:	2b00      	cmp	r3, #0
2001a180:	d009      	beq.n	2001a196 <HAL_RCCEx_PeriphCLKConfig+0x1106>
2001a182:	687b      	ldr	r3, [r7, #4]
2001a184:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a186:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2001a18a:	d004      	beq.n	2001a196 <HAL_RCCEx_PeriphCLKConfig+0x1106>
2001a18c:	f240 515e 	movw	r1, #1374	; 0x55e
2001a190:	487e      	ldr	r0, [pc, #504]	; (2001a38c <HAL_RCCEx_PeriphCLKConfig+0x12fc>)
2001a192:	f7e6 fbaf 	bl	200008f4 <assert_failed>

    switch(PeriphClkInit->SdmmcClockSelection)
2001a196:	687b      	ldr	r3, [r7, #4]
2001a198:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a19a:	2b00      	cmp	r3, #0
2001a19c:	d003      	beq.n	2001a1a6 <HAL_RCCEx_PeriphCLKConfig+0x1116>
2001a19e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2001a1a2:	d007      	beq.n	2001a1b4 <HAL_RCCEx_PeriphCLKConfig+0x1124>
2001a1a4:	e00f      	b.n	2001a1c6 <HAL_RCCEx_PeriphCLKConfig+0x1136>
    {
    case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
      /* Enable SDMMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2001a1a6:	4b78      	ldr	r3, [pc, #480]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a1a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001a1aa:	4a77      	ldr	r2, [pc, #476]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a1ac:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2001a1b0:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SDMMC clock source configuration done later after clock selection check */
      break;
2001a1b2:	e00b      	b.n	2001a1cc <HAL_RCCEx_PeriphCLKConfig+0x113c>

    case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
2001a1b4:	687b      	ldr	r3, [r7, #4]
2001a1b6:	3304      	adds	r3, #4
2001a1b8:	2102      	movs	r1, #2
2001a1ba:	4618      	mov	r0, r3
2001a1bc:	f001 fbb0 	bl	2001b920 <RCCEx_PLL2_Config>
2001a1c0:	4603      	mov	r3, r0
2001a1c2:	75fb      	strb	r3, [r7, #23]

      /* SDMMC clock source configuration done later after clock selection check */
      break;
2001a1c4:	e002      	b.n	2001a1cc <HAL_RCCEx_PeriphCLKConfig+0x113c>

    default:
      ret = HAL_ERROR;
2001a1c6:	2301      	movs	r3, #1
2001a1c8:	75fb      	strb	r3, [r7, #23]
      break;
2001a1ca:	bf00      	nop
    }

    if(ret == HAL_OK)
2001a1cc:	7dfb      	ldrb	r3, [r7, #23]
2001a1ce:	2b00      	cmp	r3, #0
2001a1d0:	d109      	bne.n	2001a1e6 <HAL_RCCEx_PeriphCLKConfig+0x1156>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
2001a1d2:	4b6d      	ldr	r3, [pc, #436]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a1d4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a1d6:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
2001a1da:	687b      	ldr	r3, [r7, #4]
2001a1dc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a1de:	496a      	ldr	r1, [pc, #424]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a1e0:	4313      	orrs	r3, r2
2001a1e2:	64cb      	str	r3, [r1, #76]	; 0x4c
2001a1e4:	e001      	b.n	2001a1ea <HAL_RCCEx_PeriphCLKConfig+0x115a>
    }
    else
    {
      /* set overall return value */
      status = ret;
2001a1e6:	7dfb      	ldrb	r3, [r7, #23]
2001a1e8:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
2001a1ea:	687b      	ldr	r3, [r7, #4]
2001a1ec:	681b      	ldr	r3, [r3, #0]
2001a1ee:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2001a1f2:	2b00      	cmp	r3, #0
2001a1f4:	d00a      	beq.n	2001a20c <HAL_RCCEx_PeriphCLKConfig+0x117c>
  {
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
2001a1f6:	687b      	ldr	r3, [r7, #4]
2001a1f8:	3324      	adds	r3, #36	; 0x24
2001a1fa:	2102      	movs	r1, #2
2001a1fc:	4618      	mov	r0, r3
2001a1fe:	f001 fcb1 	bl	2001bb64 <RCCEx_PLL3_Config>
2001a202:	4603      	mov	r3, r0
2001a204:	2b00      	cmp	r3, #0
2001a206:	d001      	beq.n	2001a20c <HAL_RCCEx_PeriphCLKConfig+0x117c>
    {
      status=HAL_ERROR;
2001a208:	2301      	movs	r3, #1
2001a20a:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
2001a20c:	687b      	ldr	r3, [r7, #4]
2001a20e:	681b      	ldr	r3, [r3, #0]
2001a210:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2001a214:	2b00      	cmp	r3, #0
2001a216:	d02f      	beq.n	2001a278 <HAL_RCCEx_PeriphCLKConfig+0x11e8>
  {

    switch(PeriphClkInit->RngClockSelection)
2001a218:	687b      	ldr	r3, [r7, #4]
2001a21a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
2001a21c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2001a220:	d00c      	beq.n	2001a23c <HAL_RCCEx_PeriphCLKConfig+0x11ac>
2001a222:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2001a226:	d802      	bhi.n	2001a22e <HAL_RCCEx_PeriphCLKConfig+0x119e>
2001a228:	2b00      	cmp	r3, #0
2001a22a:	d011      	beq.n	2001a250 <HAL_RCCEx_PeriphCLKConfig+0x11c0>
2001a22c:	e00d      	b.n	2001a24a <HAL_RCCEx_PeriphCLKConfig+0x11ba>
2001a22e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2001a232:	d00f      	beq.n	2001a254 <HAL_RCCEx_PeriphCLKConfig+0x11c4>
2001a234:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
2001a238:	d00e      	beq.n	2001a258 <HAL_RCCEx_PeriphCLKConfig+0x11c8>
2001a23a:	e006      	b.n	2001a24a <HAL_RCCEx_PeriphCLKConfig+0x11ba>
    {
    case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
      /* Enable RNG Clock output generated form System RNG . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2001a23c:	4b52      	ldr	r3, [pc, #328]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a23e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001a240:	4a51      	ldr	r2, [pc, #324]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a242:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2001a246:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* RNG clock source configuration done later after clock selection check */
      break;
2001a248:	e007      	b.n	2001a25a <HAL_RCCEx_PeriphCLKConfig+0x11ca>
      /* HSI48 oscillator is used as source of RNG clock */
      /* RNG clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2001a24a:	2301      	movs	r3, #1
2001a24c:	75fb      	strb	r3, [r7, #23]
      break;
2001a24e:	e004      	b.n	2001a25a <HAL_RCCEx_PeriphCLKConfig+0x11ca>
      break;
2001a250:	bf00      	nop
2001a252:	e002      	b.n	2001a25a <HAL_RCCEx_PeriphCLKConfig+0x11ca>
      break;
2001a254:	bf00      	nop
2001a256:	e000      	b.n	2001a25a <HAL_RCCEx_PeriphCLKConfig+0x11ca>
      break;
2001a258:	bf00      	nop
    }

    if(ret == HAL_OK)
2001a25a:	7dfb      	ldrb	r3, [r7, #23]
2001a25c:	2b00      	cmp	r3, #0
2001a25e:	d109      	bne.n	2001a274 <HAL_RCCEx_PeriphCLKConfig+0x11e4>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
2001a260:	4b49      	ldr	r3, [pc, #292]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a262:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2001a264:	f423 7240 	bic.w	r2, r3, #768	; 0x300
2001a268:	687b      	ldr	r3, [r7, #4]
2001a26a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
2001a26c:	4946      	ldr	r1, [pc, #280]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a26e:	4313      	orrs	r3, r2
2001a270:	654b      	str	r3, [r1, #84]	; 0x54
2001a272:	e001      	b.n	2001a278 <HAL_RCCEx_PeriphCLKConfig+0x11e8>
    }
    else
    {
      /* set overall return value */
      status = ret;
2001a274:	7dfb      	ldrb	r3, [r7, #23]
2001a276:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
2001a278:	687b      	ldr	r3, [r7, #4]
2001a27a:	681b      	ldr	r3, [r3, #0]
2001a27c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
2001a280:	2b00      	cmp	r3, #0
2001a282:	d016      	beq.n	2001a2b2 <HAL_RCCEx_PeriphCLKConfig+0x1222>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
2001a284:	687b      	ldr	r3, [r7, #4]
2001a286:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2001a288:	2b00      	cmp	r3, #0
2001a28a:	d009      	beq.n	2001a2a0 <HAL_RCCEx_PeriphCLKConfig+0x1210>
2001a28c:	687b      	ldr	r3, [r7, #4]
2001a28e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2001a290:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
2001a294:	d004      	beq.n	2001a2a0 <HAL_RCCEx_PeriphCLKConfig+0x1210>
2001a296:	f240 51bd 	movw	r1, #1469	; 0x5bd
2001a29a:	483c      	ldr	r0, [pc, #240]	; (2001a38c <HAL_RCCEx_PeriphCLKConfig+0x12fc>)
2001a29c:	f7e6 fb2a 	bl	200008f4 <assert_failed>

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
2001a2a0:	4b39      	ldr	r3, [pc, #228]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a2a2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a2a4:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
2001a2a8:	687b      	ldr	r3, [r7, #4]
2001a2aa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2001a2ac:	4936      	ldr	r1, [pc, #216]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a2ae:	4313      	orrs	r3, r2
2001a2b0:	650b      	str	r3, [r1, #80]	; 0x50
    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
  }
#endif  /*HRTIM*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
2001a2b2:	687b      	ldr	r3, [r7, #4]
2001a2b4:	681b      	ldr	r3, [r3, #0]
2001a2b6:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
2001a2ba:	2b00      	cmp	r3, #0
2001a2bc:	d016      	beq.n	2001a2ec <HAL_RCCEx_PeriphCLKConfig+0x125c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
2001a2be:	687b      	ldr	r3, [r7, #4]
2001a2c0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2001a2c2:	2b00      	cmp	r3, #0
2001a2c4:	d009      	beq.n	2001a2da <HAL_RCCEx_PeriphCLKConfig+0x124a>
2001a2c6:	687b      	ldr	r3, [r7, #4]
2001a2c8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2001a2ca:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2001a2ce:	d004      	beq.n	2001a2da <HAL_RCCEx_PeriphCLKConfig+0x124a>
2001a2d0:	f240 51d1 	movw	r1, #1489	; 0x5d1
2001a2d4:	482d      	ldr	r0, [pc, #180]	; (2001a38c <HAL_RCCEx_PeriphCLKConfig+0x12fc>)
2001a2d6:	f7e6 fb0d 	bl	200008f4 <assert_failed>

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
2001a2da:	4b2b      	ldr	r3, [pc, #172]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a2dc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a2de:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
2001a2e2:	687b      	ldr	r3, [r7, #4]
2001a2e4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2001a2e6:	4928      	ldr	r1, [pc, #160]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a2e8:	4313      	orrs	r3, r2
2001a2ea:	650b      	str	r3, [r1, #80]	; 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
2001a2ec:	687b      	ldr	r3, [r7, #4]
2001a2ee:	681b      	ldr	r3, [r3, #0]
2001a2f0:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2001a2f4:	2b00      	cmp	r3, #0
2001a2f6:	d01d      	beq.n	2001a334 <HAL_RCCEx_PeriphCLKConfig+0x12a4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
2001a2f8:	687b      	ldr	r3, [r7, #4]
2001a2fa:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
2001a2fe:	2b00      	cmp	r3, #0
2001a300:	d00a      	beq.n	2001a318 <HAL_RCCEx_PeriphCLKConfig+0x1288>
2001a302:	687b      	ldr	r3, [r7, #4]
2001a304:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
2001a308:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2001a30c:	d004      	beq.n	2001a318 <HAL_RCCEx_PeriphCLKConfig+0x1288>
2001a30e:	f240 51e7 	movw	r1, #1511	; 0x5e7
2001a312:	481e      	ldr	r0, [pc, #120]	; (2001a38c <HAL_RCCEx_PeriphCLKConfig+0x12fc>)
2001a314:	f7e6 faee 	bl	200008f4 <assert_failed>

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
2001a318:	4b1b      	ldr	r3, [pc, #108]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a31a:	691b      	ldr	r3, [r3, #16]
2001a31c:	4a1a      	ldr	r2, [pc, #104]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a31e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
2001a322:	6113      	str	r3, [r2, #16]
2001a324:	4b18      	ldr	r3, [pc, #96]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a326:	691a      	ldr	r2, [r3, #16]
2001a328:	687b      	ldr	r3, [r7, #4]
2001a32a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
2001a32e:	4916      	ldr	r1, [pc, #88]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a330:	4313      	orrs	r3, r2
2001a332:	610b      	str	r3, [r1, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
2001a334:	687b      	ldr	r3, [r7, #4]
2001a336:	681b      	ldr	r3, [r3, #0]
2001a338:	2b00      	cmp	r3, #0
2001a33a:	da1b      	bge.n	2001a374 <HAL_RCCEx_PeriphCLKConfig+0x12e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
2001a33c:	687b      	ldr	r3, [r7, #4]
2001a33e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a340:	2b00      	cmp	r3, #0
2001a342:	d00e      	beq.n	2001a362 <HAL_RCCEx_PeriphCLKConfig+0x12d2>
2001a344:	687b      	ldr	r3, [r7, #4]
2001a346:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a348:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001a34c:	d009      	beq.n	2001a362 <HAL_RCCEx_PeriphCLKConfig+0x12d2>
2001a34e:	687b      	ldr	r3, [r7, #4]
2001a350:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a352:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001a356:	d004      	beq.n	2001a362 <HAL_RCCEx_PeriphCLKConfig+0x12d2>
2001a358:	f240 51f1 	movw	r1, #1521	; 0x5f1
2001a35c:	480b      	ldr	r0, [pc, #44]	; (2001a38c <HAL_RCCEx_PeriphCLKConfig+0x12fc>)
2001a35e:	f7e6 fac9 	bl	200008f4 <assert_failed>

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
2001a362:	4b09      	ldr	r3, [pc, #36]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a364:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a366:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
2001a36a:	687b      	ldr	r3, [r7, #4]
2001a36c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a36e:	4906      	ldr	r1, [pc, #24]	; (2001a388 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
2001a370:	4313      	orrs	r3, r2
2001a372:	64cb      	str	r3, [r1, #76]	; 0x4c
  }

  if (status == HAL_OK)
2001a374:	7dbb      	ldrb	r3, [r7, #22]
2001a376:	2b00      	cmp	r3, #0
2001a378:	d101      	bne.n	2001a37e <HAL_RCCEx_PeriphCLKConfig+0x12ee>
  {
    return HAL_OK;
2001a37a:	2300      	movs	r3, #0
2001a37c:	e000      	b.n	2001a380 <HAL_RCCEx_PeriphCLKConfig+0x12f0>
  }
  return HAL_ERROR;
2001a37e:	2301      	movs	r3, #1
}
2001a380:	4618      	mov	r0, r3
2001a382:	3718      	adds	r7, #24
2001a384:	46bd      	mov	sp, r7
2001a386:	bd80      	pop	{r7, pc}
2001a388:	58024400 	.word	0x58024400
2001a38c:	2001c318 	.word	0x2001c318

2001a390 <HAL_RCCEx_GetPeriphCLKConfig>:
  * @retval None
  *
  *   (*) : Available on some STM32H7 lines only.
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
2001a390:	b480      	push	{r7}
2001a392:	b083      	sub	sp, #12
2001a394:	af00      	add	r7, sp, #0
2001a396:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the extended clock type parameter------------*/
  PeriphClkInit->PeriphClockSelection =
2001a398:	687b      	ldr	r3, [r7, #4]
2001a39a:	4aa3      	ldr	r2, [pc, #652]	; (2001a628 <HAL_RCCEx_GetPeriphCLKConfig+0x298>)
2001a39c:	601a      	str	r2, [r3, #0]
	         RCC_PERIPHCLK_FDCAN   | RCC_PERIPHCLK_SDMMC       | RCC_PERIPHCLK_RNG     | RCC_PERIPHCLK_USB      |
	         RCC_PERIPHCLK_ADC     | RCC_PERIPHCLK_SWPMI1      | RCC_PERIPHCLK_DFSDM1  | RCC_PERIPHCLK_RTC      |
	         RCC_PERIPHCLK_CEC     | RCC_PERIPHCLK_FMC         | RCC_PERIPHCLK_SPDIFRX | RCC_PERIPHCLK_TIM      |
	         RCC_PERIPHCLK_CKPER;

PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C123;
2001a39e:	687b      	ldr	r3, [r7, #4]
2001a3a0:	681b      	ldr	r3, [r3, #0]
2001a3a2:	f043 0208 	orr.w	r2, r3, #8
2001a3a6:	687b      	ldr	r3, [r7, #4]
2001a3a8:	601a      	str	r2, [r3, #0]
#endif /* RCC_CDCCIP1R_SAI2ASEL */
#if defined(RCC_CDCCIP1R_SAI2BSEL)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI2B;
#endif /* RCC_CDCCIP1R_SAI2BSEL */
#if defined(SAI3)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI23;
2001a3aa:	687b      	ldr	r3, [r7, #4]
2001a3ac:	681b      	ldr	r3, [r3, #0]
2001a3ae:	f443 7200 	orr.w	r2, r3, #512	; 0x200
2001a3b2:	687b      	ldr	r3, [r7, #4]
2001a3b4:	601a      	str	r2, [r3, #0]
#endif /* SAI3 */
#if defined(SAI4)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4A;
2001a3b6:	687b      	ldr	r3, [r7, #4]
2001a3b8:	681b      	ldr	r3, [r3, #0]
2001a3ba:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
2001a3be:	687b      	ldr	r3, [r7, #4]
2001a3c0:	601a      	str	r2, [r3, #0]
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4B;
2001a3c2:	687b      	ldr	r3, [r7, #4]
2001a3c4:	681b      	ldr	r3, [r3, #0]
2001a3c6:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
2001a3ca:	687b      	ldr	r3, [r7, #4]
2001a3cc:	601a      	str	r2, [r3, #0]
#endif /* SAI4 */
#if defined(DFSDM2_BASE)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DFSDM2;
#endif /* DFSDM2 */
#if defined(QUADSPI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_QSPI;
2001a3ce:	687b      	ldr	r3, [r7, #4]
2001a3d0:	681b      	ldr	r3, [r3, #0]
2001a3d2:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
2001a3d6:	687b      	ldr	r3, [r7, #4]
2001a3d8:	601a      	str	r2, [r3, #0]
#endif /* OCTOSPI1 || OCTOSPI2 */
#if defined(HRTIM)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_HRTIM1;
#endif /* HRTIM */
#if defined(LTDC)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LTDC;
2001a3da:	687b      	ldr	r3, [r7, #4]
2001a3dc:	681b      	ldr	r3, [r3, #0]
2001a3de:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
2001a3e2:	687b      	ldr	r3, [r7, #4]
2001a3e4:	601a      	str	r2, [r3, #0]
#if defined(DSI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DSI;
#endif /* DSI */

  /* Get the PLL3 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL3.PLL3M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> RCC_PLLCKSELR_DIVM3_Pos);
2001a3e6:	4b91      	ldr	r3, [pc, #580]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a3e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001a3ea:	0d1b      	lsrs	r3, r3, #20
2001a3ec:	f003 023f 	and.w	r2, r3, #63	; 0x3f
2001a3f0:	687b      	ldr	r3, [r7, #4]
2001a3f2:	625a      	str	r2, [r3, #36]	; 0x24
  PeriphClkInit->PLL3.PLL3N = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_N3) >> RCC_PLL3DIVR_N3_Pos)+ 1U;
2001a3f4:	4b8d      	ldr	r3, [pc, #564]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a3f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001a3f8:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001a3fc:	1c5a      	adds	r2, r3, #1
2001a3fe:	687b      	ldr	r3, [r7, #4]
2001a400:	629a      	str	r2, [r3, #40]	; 0x28
  PeriphClkInit->PLL3.PLL3R = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> RCC_PLL3DIVR_R3_Pos)+ 1U;
2001a402:	4b8a      	ldr	r3, [pc, #552]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a404:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001a406:	0e1b      	lsrs	r3, r3, #24
2001a408:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001a40c:	1c5a      	adds	r2, r3, #1
2001a40e:	687b      	ldr	r3, [r7, #4]
2001a410:	635a      	str	r2, [r3, #52]	; 0x34
  PeriphClkInit->PLL3.PLL3P = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> RCC_PLL3DIVR_P3_Pos)+ 1U;
2001a412:	4b86      	ldr	r3, [pc, #536]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a414:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001a416:	0a5b      	lsrs	r3, r3, #9
2001a418:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001a41c:	1c5a      	adds	r2, r3, #1
2001a41e:	687b      	ldr	r3, [r7, #4]
2001a420:	62da      	str	r2, [r3, #44]	; 0x2c
  PeriphClkInit->PLL3.PLL3Q = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> RCC_PLL3DIVR_Q3_Pos)+ 1U;
2001a422:	4b82      	ldr	r3, [pc, #520]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a424:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001a426:	0c1b      	lsrs	r3, r3, #16
2001a428:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001a42c:	1c5a      	adds	r2, r3, #1
2001a42e:	687b      	ldr	r3, [r7, #4]
2001a430:	631a      	str	r2, [r3, #48]	; 0x30
  PeriphClkInit->PLL3.PLL3RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3RGE) >> RCC_PLLCFGR_PLL3RGE_Pos);
2001a432:	4b7e      	ldr	r3, [pc, #504]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a434:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001a436:	0a9b      	lsrs	r3, r3, #10
2001a438:	f003 0203 	and.w	r2, r3, #3
2001a43c:	687b      	ldr	r3, [r7, #4]
2001a43e:	639a      	str	r2, [r3, #56]	; 0x38
  PeriphClkInit->PLL3.PLL3VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3VCOSEL) >> RCC_PLLCFGR_PLL3VCOSEL_Pos);
2001a440:	4b7a      	ldr	r3, [pc, #488]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a442:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001a444:	0a5b      	lsrs	r3, r3, #9
2001a446:	f003 0201 	and.w	r2, r3, #1
2001a44a:	687b      	ldr	r3, [r7, #4]
2001a44c:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Get the PLL2 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL2.PLL2M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> RCC_PLLCKSELR_DIVM2_Pos);
2001a44e:	4b77      	ldr	r3, [pc, #476]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a450:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001a452:	0b1b      	lsrs	r3, r3, #12
2001a454:	f003 023f 	and.w	r2, r3, #63	; 0x3f
2001a458:	687b      	ldr	r3, [r7, #4]
2001a45a:	605a      	str	r2, [r3, #4]
  PeriphClkInit->PLL2.PLL2N = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_N2) >> RCC_PLL2DIVR_N2_Pos)+ 1U;
2001a45c:	4b73      	ldr	r3, [pc, #460]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a45e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001a460:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001a464:	1c5a      	adds	r2, r3, #1
2001a466:	687b      	ldr	r3, [r7, #4]
2001a468:	609a      	str	r2, [r3, #8]
  PeriphClkInit->PLL2.PLL2R = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> RCC_PLL2DIVR_R2_Pos)+ 1U;
2001a46a:	4b70      	ldr	r3, [pc, #448]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a46c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001a46e:	0e1b      	lsrs	r3, r3, #24
2001a470:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001a474:	1c5a      	adds	r2, r3, #1
2001a476:	687b      	ldr	r3, [r7, #4]
2001a478:	615a      	str	r2, [r3, #20]
  PeriphClkInit->PLL2.PLL2P = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> RCC_PLL2DIVR_P2_Pos)+ 1U;
2001a47a:	4b6c      	ldr	r3, [pc, #432]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a47c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001a47e:	0a5b      	lsrs	r3, r3, #9
2001a480:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001a484:	1c5a      	adds	r2, r3, #1
2001a486:	687b      	ldr	r3, [r7, #4]
2001a488:	60da      	str	r2, [r3, #12]
  PeriphClkInit->PLL2.PLL2Q = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> RCC_PLL2DIVR_Q2_Pos)+ 1U;
2001a48a:	4b68      	ldr	r3, [pc, #416]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a48c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001a48e:	0c1b      	lsrs	r3, r3, #16
2001a490:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001a494:	1c5a      	adds	r2, r3, #1
2001a496:	687b      	ldr	r3, [r7, #4]
2001a498:	611a      	str	r2, [r3, #16]
  PeriphClkInit->PLL2.PLL2RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2RGE) >> RCC_PLLCFGR_PLL2RGE_Pos);
2001a49a:	4b64      	ldr	r3, [pc, #400]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a49c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001a49e:	099b      	lsrs	r3, r3, #6
2001a4a0:	f003 0203 	and.w	r2, r3, #3
2001a4a4:	687b      	ldr	r3, [r7, #4]
2001a4a6:	619a      	str	r2, [r3, #24]
  PeriphClkInit->PLL2.PLL2VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2VCOSEL) >> RCC_PLLCFGR_PLL2VCOSEL_Pos);
2001a4a8:	4b60      	ldr	r3, [pc, #384]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a4aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001a4ac:	095b      	lsrs	r3, r3, #5
2001a4ae:	f003 0201 	and.w	r2, r3, #1
2001a4b2:	687b      	ldr	r3, [r7, #4]
2001a4b4:	61da      	str	r2, [r3, #28]

  /* Get the USART1 configuration --------------------------------------------*/
  PeriphClkInit->Usart16ClockSelection      = __HAL_RCC_GET_USART16_SOURCE();
2001a4b6:	4b5d      	ldr	r3, [pc, #372]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a4b8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2001a4ba:	f003 0238 	and.w	r2, r3, #56	; 0x38
2001a4be:	687b      	ldr	r3, [r7, #4]
2001a4c0:	679a      	str	r2, [r3, #120]	; 0x78
  /* Get the USART2/3/4/5/7/8 clock source -----------------------------------*/
  PeriphClkInit->Usart234578ClockSelection  = __HAL_RCC_GET_USART234578_SOURCE();
2001a4c2:	4b5a      	ldr	r3, [pc, #360]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a4c4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2001a4c6:	f003 0207 	and.w	r2, r3, #7
2001a4ca:	687b      	ldr	r3, [r7, #4]
2001a4cc:	675a      	str	r2, [r3, #116]	; 0x74
  /* Get the LPUART1 clock source --------------------------------------------*/
  PeriphClkInit->Lpuart1ClockSelection      = __HAL_RCC_GET_LPUART1_SOURCE();
2001a4ce:	4b57      	ldr	r3, [pc, #348]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a4d0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a4d2:	f003 0207 	and.w	r2, r3, #7
2001a4d6:	687b      	ldr	r3, [r7, #4]
2001a4d8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  /* Get the I2C1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->I2c123ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();
2001a4dc:	4b53      	ldr	r3, [pc, #332]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a4de:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2001a4e0:	f403 5240 	and.w	r2, r3, #12288	; 0x3000
2001a4e4:	687b      	ldr	r3, [r7, #4]
2001a4e6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  /* Get the LPTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection       = __HAL_RCC_GET_LPTIM1_SOURCE();
2001a4ea:	4b50      	ldr	r3, [pc, #320]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a4ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2001a4ee:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
2001a4f2:	687b      	ldr	r3, [r7, #4]
2001a4f4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  /* Get the LPTIM2 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim2ClockSelection       = __HAL_RCC_GET_LPTIM2_SOURCE();
2001a4f8:	4b4c      	ldr	r3, [pc, #304]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a4fa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a4fc:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
2001a500:	687b      	ldr	r3, [r7, #4]
2001a502:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  /* Get the LPTIM3/4/5 clock source -----------------------------------------*/
  PeriphClkInit->Lptim345ClockSelection     = __HAL_RCC_GET_LPTIM345_SOURCE();
2001a506:	4b49      	ldr	r3, [pc, #292]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a508:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a50a:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
2001a50e:	687b      	ldr	r3, [r7, #4]
2001a510:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  /* Get the SAI1 clock source -----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection         = __HAL_RCC_GET_SAI1_SOURCE();
2001a514:	4b45      	ldr	r3, [pc, #276]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a516:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a518:	f003 0207 	and.w	r2, r3, #7
2001a51c:	687b      	ldr	r3, [r7, #4]
2001a51e:	655a      	str	r2, [r3, #84]	; 0x54
#if defined(SAI3)
  /* Get the SAI2/3 clock source ---------------------------------------------*/
  PeriphClkInit->Sai23ClockSelection        = __HAL_RCC_GET_SAI23_SOURCE();
2001a520:	4b42      	ldr	r3, [pc, #264]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a522:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a524:	f403 72e0 	and.w	r2, r3, #448	; 0x1c0
2001a528:	687b      	ldr	r3, [r7, #4]
2001a52a:	659a      	str	r2, [r3, #88]	; 0x58
  /* Get the SAI2B clock source ---------------------------------------------*/
  PeriphClkInit->Sai2BClockSelection        = __HAL_RCC_GET_SAI2B_SOURCE();
#endif  /*SAI2B*/
#if defined(SAI4)
  /* Get the SAI4A clock source ----------------------------------------------*/
  PeriphClkInit->Sai4AClockSelection        = __HAL_RCC_GET_SAI4A_SOURCE();
2001a52c:	4b3f      	ldr	r3, [pc, #252]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a52e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a530:	f403 0260 	and.w	r2, r3, #14680064	; 0xe00000
2001a534:	687b      	ldr	r3, [r7, #4]
2001a536:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  /* Get the SAI4B clock source ----------------------------------------------*/
  PeriphClkInit->Sai4BClockSelection        = __HAL_RCC_GET_SAI4B_SOURCE();
2001a53a:	4b3c      	ldr	r3, [pc, #240]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a53c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a53e:	f003 62e0 	and.w	r2, r3, #117440512	; 0x7000000
2001a542:	687b      	ldr	r3, [r7, #4]
2001a544:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
#endif  /*SAI4*/
  /* Get the RTC clock source ------------------------------------------------*/
  PeriphClkInit->RTCClockSelection          = __HAL_RCC_GET_RTC_SOURCE();
2001a548:	4b38      	ldr	r3, [pc, #224]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a54a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2001a54c:	f403 7240 	and.w	r2, r3, #768	; 0x300
2001a550:	687b      	ldr	r3, [r7, #4]
2001a552:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  /* Get the USB clock source ------------------------------------------------*/
  PeriphClkInit->UsbClockSelection          = __HAL_RCC_GET_USB_SOURCE();
2001a556:	4b35      	ldr	r3, [pc, #212]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a558:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2001a55a:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
2001a55e:	687b      	ldr	r3, [r7, #4]
2001a560:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  /* Get the SDMMC clock source ----------------------------------------------*/
  PeriphClkInit->SdmmcClockSelection        = __HAL_RCC_GET_SDMMC_SOURCE();
2001a564:	4b31      	ldr	r3, [pc, #196]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a566:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a568:	f403 3280 	and.w	r2, r3, #65536	; 0x10000
2001a56c:	687b      	ldr	r3, [r7, #4]
2001a56e:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Get the RNG clock source ------------------------------------------------*/
  PeriphClkInit->RngClockSelection          = __HAL_RCC_GET_RNG_SOURCE();
2001a570:	4b2e      	ldr	r3, [pc, #184]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a572:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2001a574:	f403 7240 	and.w	r2, r3, #768	; 0x300
2001a578:	687b      	ldr	r3, [r7, #4]
2001a57a:	67da      	str	r2, [r3, #124]	; 0x7c
#if defined(HRTIM1)
  /* Get the HRTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Hrtim1ClockSelection       = __HAL_RCC_GET_HRTIM1_SOURCE();
2001a57c:	4b2b      	ldr	r3, [pc, #172]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a57e:	691b      	ldr	r3, [r3, #16]
2001a580:	f403 4280 	and.w	r2, r3, #16384	; 0x4000
2001a584:	687b      	ldr	r3, [r7, #4]
2001a586:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
#endif /* HRTIM1 */
  /* Get the ADC clock source ------------------------------------------------*/
  PeriphClkInit->AdcClockSelection          = __HAL_RCC_GET_ADC_SOURCE();
2001a58a:	4b28      	ldr	r3, [pc, #160]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a58c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a58e:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
2001a592:	687b      	ldr	r3, [r7, #4]
2001a594:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  /* Get the SWPMI1 clock source ---------------------------------------------*/
  PeriphClkInit->Swpmi1ClockSelection       = __HAL_RCC_GET_SWPMI1_SOURCE();
2001a598:	4b24      	ldr	r3, [pc, #144]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a59a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a59c:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
2001a5a0:	687b      	ldr	r3, [r7, #4]
2001a5a2:	671a      	str	r2, [r3, #112]	; 0x70
  /* Get the DFSDM1 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm1ClockSelection       = __HAL_RCC_GET_DFSDM1_SOURCE();
2001a5a4:	4b21      	ldr	r3, [pc, #132]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a5a6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a5a8:	f003 7280 	and.w	r2, r3, #16777216	; 0x1000000
2001a5ac:	687b      	ldr	r3, [r7, #4]
2001a5ae:	669a      	str	r2, [r3, #104]	; 0x68
#if defined(DFSDM2_BASE)
  /* Get the DFSDM2 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm2ClockSelection       = __HAL_RCC_GET_DFSDM2_SOURCE();
#endif /* DFSDM2 */
  /* Get the SPDIFRX clock source --------------------------------------------*/
  PeriphClkInit->SpdifrxClockSelection      = __HAL_RCC_GET_SPDIFRX_SOURCE();
2001a5b0:	4b1e      	ldr	r3, [pc, #120]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a5b2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a5b4:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
2001a5b8:	687b      	ldr	r3, [r7, #4]
2001a5ba:	665a      	str	r2, [r3, #100]	; 0x64
  /* Get the SPI1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->Spi123ClockSelection       = __HAL_RCC_GET_SPI123_SOURCE();
2001a5bc:	4b1b      	ldr	r3, [pc, #108]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a5be:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a5c0:	f403 42e0 	and.w	r2, r3, #28672	; 0x7000
2001a5c4:	687b      	ldr	r3, [r7, #4]
2001a5c6:	65da      	str	r2, [r3, #92]	; 0x5c
  /* Get the SPI4/5 clock source ---------------------------------------------*/
  PeriphClkInit->Spi45ClockSelection        = __HAL_RCC_GET_SPI45_SOURCE();
2001a5c8:	4b18      	ldr	r3, [pc, #96]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a5ca:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a5cc:	f403 22e0 	and.w	r2, r3, #458752	; 0x70000
2001a5d0:	687b      	ldr	r3, [r7, #4]
2001a5d2:	661a      	str	r2, [r3, #96]	; 0x60
  /* Get the SPI6 clock source -----------------------------------------------*/
  PeriphClkInit->Spi6ClockSelection         = __HAL_RCC_GET_SPI6_SOURCE();
2001a5d4:	4b15      	ldr	r3, [pc, #84]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a5d6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a5d8:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
2001a5dc:	687b      	ldr	r3, [r7, #4]
2001a5de:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  /* Get the FDCAN clock source ----------------------------------------------*/
  PeriphClkInit->FdcanClockSelection        = __HAL_RCC_GET_FDCAN_SOURCE();
2001a5e2:	4b12      	ldr	r3, [pc, #72]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a5e4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a5e6:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
2001a5ea:	687b      	ldr	r3, [r7, #4]
2001a5ec:	66da      	str	r2, [r3, #108]	; 0x6c
  /* Get the CEC clock source ------------------------------------------------*/
  PeriphClkInit->CecClockSelection          = __HAL_RCC_GET_CEC_SOURCE();
2001a5ee:	4b0f      	ldr	r3, [pc, #60]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a5f0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2001a5f2:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
2001a5f6:	687b      	ldr	r3, [r7, #4]
2001a5f8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  /* Get the FMC clock source ------------------------------------------------*/
  PeriphClkInit->FmcClockSelection          = __HAL_RCC_GET_FMC_SOURCE();
2001a5fc:	4b0b      	ldr	r3, [pc, #44]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a5fe:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a600:	f003 0203 	and.w	r2, r3, #3
2001a604:	687b      	ldr	r3, [r7, #4]
2001a606:	645a      	str	r2, [r3, #68]	; 0x44
#if defined(QUADSPI)
  /* Get the QSPI clock source -----------------------------------------------*/
  PeriphClkInit->QspiClockSelection         = __HAL_RCC_GET_QSPI_SOURCE();
2001a608:	4b08      	ldr	r3, [pc, #32]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a60a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a60c:	f003 0230 	and.w	r2, r3, #48	; 0x30
2001a610:	687b      	ldr	r3, [r7, #4]
2001a612:	649a      	str	r2, [r3, #72]	; 0x48
  /* Get the DSI clock source ------------------------------------------------*/
  PeriphClkInit->DsiClockSelection          = __HAL_RCC_GET_DSI_SOURCE();
#endif /*DSI*/

  /* Get the CKPER clock source ----------------------------------------------*/
  PeriphClkInit->CkperClockSelection        = __HAL_RCC_GET_CLKP_SOURCE();
2001a614:	4b05      	ldr	r3, [pc, #20]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a616:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a618:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
2001a61c:	687b      	ldr	r3, [r7, #4]
2001a61e:	651a      	str	r2, [r3, #80]	; 0x50

  /* Get the TIM Prescaler configuration -------------------------------------*/
  if ((RCC->CFGR & RCC_CFGR_TIMPRE) == 0U)
2001a620:	4b02      	ldr	r3, [pc, #8]	; (2001a62c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2001a622:	691b      	ldr	r3, [r3, #16]
2001a624:	e004      	b.n	2001a630 <HAL_RCCEx_GetPeriphCLKConfig+0x2a0>
2001a626:	bf00      	nop
2001a628:	c9fff1f7 	.word	0xc9fff1f7
2001a62c:	58024400 	.word	0x58024400
2001a630:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2001a634:	2b00      	cmp	r3, #0
2001a636:	d104      	bne.n	2001a642 <HAL_RCCEx_GetPeriphCLKConfig+0x2b2>
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
2001a638:	687b      	ldr	r3, [r7, #4]
2001a63a:	2200      	movs	r2, #0
2001a63c:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
  }
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
  }
}
2001a640:	e004      	b.n	2001a64c <HAL_RCCEx_GetPeriphCLKConfig+0x2bc>
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
2001a642:	687b      	ldr	r3, [r7, #4]
2001a644:	f44f 4200 	mov.w	r2, #32768	; 0x8000
2001a648:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
2001a64c:	bf00      	nop
2001a64e:	370c      	adds	r7, #12
2001a650:	46bd      	mov	sp, r7
2001a652:	f85d 7b04 	ldr.w	r7, [sp], #4
2001a656:	4770      	bx	lr

2001a658 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in KHz
  *
  *  (*) : Available on some STM32H7 lines only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
2001a658:	b580      	push	{r7, lr}
2001a65a:	b090      	sub	sp, #64	; 0x40
2001a65c:	af00      	add	r7, sp, #0
2001a65e:	6078      	str	r0, [r7, #4]
  /* This variable is used to store the SAI and CKP clock source */
  uint32_t saiclocksource;
  uint32_t ckpclocksource;
  uint32_t srcclk;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
2001a660:	687b      	ldr	r3, [r7, #4]
2001a662:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2001a666:	d150      	bne.n	2001a70a <HAL_RCCEx_GetPeriphCLKFreq+0xb2>
    {

      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
2001a668:	4ba1      	ldr	r3, [pc, #644]	; (2001a8f0 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2001a66a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a66c:	f003 0307 	and.w	r3, r3, #7
2001a670:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
2001a672:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2001a674:	2b04      	cmp	r3, #4
2001a676:	d844      	bhi.n	2001a702 <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
2001a678:	a201      	add	r2, pc, #4	; (adr r2, 2001a680 <HAL_RCCEx_GetPeriphCLKFreq+0x28>)
2001a67a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2001a67e:	bf00      	nop
2001a680:	2001a695 	.word	0x2001a695
2001a684:	2001a6a5 	.word	0x2001a6a5
2001a688:	2001a6b5 	.word	0x2001a6b5
2001a68c:	2001a6fd 	.word	0x2001a6fd
2001a690:	2001a6c5 	.word	0x2001a6c5
      {
      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
2001a694:	f107 0324 	add.w	r3, r7, #36	; 0x24
2001a698:	4618      	mov	r0, r3
2001a69a:	f000 fd19 	bl	2001b0d0 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2001a69e:	6abb      	ldr	r3, [r7, #40]	; 0x28
2001a6a0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a6a2:	e241      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2001a6a4:	f107 0318 	add.w	r3, r7, #24
2001a6a8:	4618      	mov	r0, r3
2001a6aa:	f000 fa79 	bl	2001aba0 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2001a6ae:	69bb      	ldr	r3, [r7, #24]
2001a6b0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a6b2:	e239      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2001a6b4:	f107 030c 	add.w	r3, r7, #12
2001a6b8:	4618      	mov	r0, r3
2001a6ba:	f000 fbbd 	bl	2001ae38 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2001a6be:	68fb      	ldr	r3, [r7, #12]
2001a6c0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a6c2:	e231      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
2001a6c4:	4b8a      	ldr	r3, [pc, #552]	; (2001a8f0 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2001a6c6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a6c8:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2001a6cc:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2001a6ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a6d0:	2b00      	cmp	r3, #0
2001a6d2:	d102      	bne.n	2001a6da <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
2001a6d4:	4b87      	ldr	r3, [pc, #540]	; (2001a8f4 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
2001a6d6:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
2001a6d8:	e226      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
2001a6da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a6dc:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001a6e0:	d102      	bne.n	2001a6e8 <HAL_RCCEx_GetPeriphCLKFreq+0x90>
            frequency = CSI_VALUE;
2001a6e2:	4b85      	ldr	r3, [pc, #532]	; (2001a8f8 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
2001a6e4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a6e6:	e21f      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
2001a6e8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a6ea:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001a6ee:	d102      	bne.n	2001a6f6 <HAL_RCCEx_GetPeriphCLKFreq+0x9e>
            frequency = HSE_VALUE;
2001a6f0:	4b82      	ldr	r3, [pc, #520]	; (2001a8fc <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2001a6f2:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a6f4:	e218      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
2001a6f6:	2300      	movs	r3, #0
2001a6f8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a6fa:	e215      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
2001a6fc:	4b80      	ldr	r3, [pc, #512]	; (2001a900 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2001a6fe:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a700:	e212      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      default :
        {
          frequency = 0;
2001a702:	2300      	movs	r3, #0
2001a704:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a706:	bf00      	nop
2001a708:	e20e      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }

#if defined(SAI3)
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
2001a70a:	687b      	ldr	r3, [r7, #4]
2001a70c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2001a710:	d14f      	bne.n	2001a7b2 <HAL_RCCEx_GetPeriphCLKFreq+0x15a>
    {

      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
2001a712:	4b77      	ldr	r3, [pc, #476]	; (2001a8f0 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2001a714:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a716:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
2001a71a:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
2001a71c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2001a71e:	2b80      	cmp	r3, #128	; 0x80
2001a720:	d01c      	beq.n	2001a75c <HAL_RCCEx_GetPeriphCLKFreq+0x104>
2001a722:	2b80      	cmp	r3, #128	; 0x80
2001a724:	d804      	bhi.n	2001a730 <HAL_RCCEx_GetPeriphCLKFreq+0xd8>
2001a726:	2b00      	cmp	r3, #0
2001a728:	d008      	beq.n	2001a73c <HAL_RCCEx_GetPeriphCLKFreq+0xe4>
2001a72a:	2b40      	cmp	r3, #64	; 0x40
2001a72c:	d00e      	beq.n	2001a74c <HAL_RCCEx_GetPeriphCLKFreq+0xf4>
2001a72e:	e03c      	b.n	2001a7aa <HAL_RCCEx_GetPeriphCLKFreq+0x152>
2001a730:	2bc0      	cmp	r3, #192	; 0xc0
2001a732:	d037      	beq.n	2001a7a4 <HAL_RCCEx_GetPeriphCLKFreq+0x14c>
2001a734:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2001a738:	d018      	beq.n	2001a76c <HAL_RCCEx_GetPeriphCLKFreq+0x114>
2001a73a:	e036      	b.n	2001a7aa <HAL_RCCEx_GetPeriphCLKFreq+0x152>
      {
      case 0: /* PLL1 is the clock source for SAI2/3 */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
2001a73c:	f107 0324 	add.w	r3, r7, #36	; 0x24
2001a740:	4618      	mov	r0, r3
2001a742:	f000 fcc5 	bl	2001b0d0 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2001a746:	6abb      	ldr	r3, [r7, #40]	; 0x28
2001a748:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a74a:	e1ed      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI2/3 */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2001a74c:	f107 0318 	add.w	r3, r7, #24
2001a750:	4618      	mov	r0, r3
2001a752:	f000 fa25 	bl	2001aba0 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2001a756:	69bb      	ldr	r3, [r7, #24]
2001a758:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a75a:	e1e5      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI23CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI2/3 */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2001a75c:	f107 030c 	add.w	r3, r7, #12
2001a760:	4618      	mov	r0, r3
2001a762:	f000 fb69 	bl	2001ae38 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2001a766:	68fb      	ldr	r3, [r7, #12]
2001a768:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a76a:	e1dd      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI23CLKSOURCE_CLKP: /* CKPER is the clock source for SAI2/3 */
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
2001a76c:	4b60      	ldr	r3, [pc, #384]	; (2001a8f0 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2001a76e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a770:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2001a774:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2001a776:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a778:	2b00      	cmp	r3, #0
2001a77a:	d102      	bne.n	2001a782 <HAL_RCCEx_GetPeriphCLKFreq+0x12a>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
2001a77c:	4b5d      	ldr	r3, [pc, #372]	; (2001a8f4 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
2001a77e:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
2001a780:	e1d2      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
2001a782:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a784:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001a788:	d102      	bne.n	2001a790 <HAL_RCCEx_GetPeriphCLKFreq+0x138>
            frequency = CSI_VALUE;
2001a78a:	4b5b      	ldr	r3, [pc, #364]	; (2001a8f8 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
2001a78c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a78e:	e1cb      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
2001a790:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a792:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001a796:	d102      	bne.n	2001a79e <HAL_RCCEx_GetPeriphCLKFreq+0x146>
            frequency = HSE_VALUE;
2001a798:	4b58      	ldr	r3, [pc, #352]	; (2001a8fc <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2001a79a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a79c:	e1c4      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
2001a79e:	2300      	movs	r3, #0
2001a7a0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a7a2:	e1c1      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_SAI23CLKSOURCE_PIN): /* External clock is the clock source for SAI2/3 */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
2001a7a4:	4b56      	ldr	r3, [pc, #344]	; (2001a900 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2001a7a6:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a7a8:	e1be      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      default :
        {
          frequency = 0;
2001a7aa:	2300      	movs	r3, #0
2001a7ac:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a7ae:	bf00      	nop
2001a7b0:	e1ba      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
      }
    }
#endif

#if defined(SAI4)
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
2001a7b2:	687b      	ldr	r3, [r7, #4]
2001a7b4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2001a7b8:	d153      	bne.n	2001a862 <HAL_RCCEx_GetPeriphCLKFreq+0x20a>
    {

      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
2001a7ba:	4b4d      	ldr	r3, [pc, #308]	; (2001a8f0 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2001a7bc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a7be:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
2001a7c2:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
2001a7c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2001a7c6:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
2001a7ca:	d01f      	beq.n	2001a80c <HAL_RCCEx_GetPeriphCLKFreq+0x1b4>
2001a7cc:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
2001a7d0:	d805      	bhi.n	2001a7de <HAL_RCCEx_GetPeriphCLKFreq+0x186>
2001a7d2:	2b00      	cmp	r3, #0
2001a7d4:	d00a      	beq.n	2001a7ec <HAL_RCCEx_GetPeriphCLKFreq+0x194>
2001a7d6:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2001a7da:	d00f      	beq.n	2001a7fc <HAL_RCCEx_GetPeriphCLKFreq+0x1a4>
2001a7dc:	e03d      	b.n	2001a85a <HAL_RCCEx_GetPeriphCLKFreq+0x202>
2001a7de:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
2001a7e2:	d037      	beq.n	2001a854 <HAL_RCCEx_GetPeriphCLKFreq+0x1fc>
2001a7e4:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
2001a7e8:	d018      	beq.n	2001a81c <HAL_RCCEx_GetPeriphCLKFreq+0x1c4>
2001a7ea:	e036      	b.n	2001a85a <HAL_RCCEx_GetPeriphCLKFreq+0x202>
      {
      case 0: /* PLL1 is the clock source for SAI4A */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
2001a7ec:	f107 0324 	add.w	r3, r7, #36	; 0x24
2001a7f0:	4618      	mov	r0, r3
2001a7f2:	f000 fc6d 	bl	2001b0d0 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2001a7f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
2001a7f8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a7fa:	e195      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_D3CCIPR_SAI4ASEL_0: /* PLLI2 is the clock source for SAI4A */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2001a7fc:	f107 0318 	add.w	r3, r7, #24
2001a800:	4618      	mov	r0, r3
2001a802:	f000 f9cd 	bl	2001aba0 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2001a806:	69bb      	ldr	r3, [r7, #24]
2001a808:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a80a:	e18d      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4ASEL_1: /* PLLI3 is the clock source for SAI4A */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2001a80c:	f107 030c 	add.w	r3, r7, #12
2001a810:	4618      	mov	r0, r3
2001a812:	f000 fb11 	bl	2001ae38 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2001a816:	68fb      	ldr	r3, [r7, #12]
2001a818:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a81a:	e185      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4ASEL_2: /* CKPER is the clock source for SAI4A*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
2001a81c:	4b34      	ldr	r3, [pc, #208]	; (2001a8f0 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2001a81e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a820:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2001a824:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2001a826:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a828:	2b00      	cmp	r3, #0
2001a82a:	d102      	bne.n	2001a832 <HAL_RCCEx_GetPeriphCLKFreq+0x1da>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
2001a82c:	4b31      	ldr	r3, [pc, #196]	; (2001a8f4 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
2001a82e:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
2001a830:	e17a      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
2001a832:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a834:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001a838:	d102      	bne.n	2001a840 <HAL_RCCEx_GetPeriphCLKFreq+0x1e8>
            frequency = CSI_VALUE;
2001a83a:	4b2f      	ldr	r3, [pc, #188]	; (2001a8f8 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
2001a83c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a83e:	e173      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
2001a840:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a842:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001a846:	d102      	bne.n	2001a84e <HAL_RCCEx_GetPeriphCLKFreq+0x1f6>
            frequency = HSE_VALUE;
2001a848:	4b2c      	ldr	r3, [pc, #176]	; (2001a8fc <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2001a84a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a84c:	e16c      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
2001a84e:	2300      	movs	r3, #0
2001a850:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a852:	e169      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_D3CCIPR_SAI4ASEL_0 | RCC_D3CCIPR_SAI4ASEL_1 ): /* External clock is the clock source for SAI4A */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
2001a854:	4b2a      	ldr	r3, [pc, #168]	; (2001a900 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2001a856:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a858:	e166      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
2001a85a:	2300      	movs	r3, #0
2001a85c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a85e:	bf00      	nop
2001a860:	e162      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }

  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
2001a862:	687b      	ldr	r3, [r7, #4]
2001a864:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2001a868:	d15d      	bne.n	2001a926 <HAL_RCCEx_GetPeriphCLKFreq+0x2ce>
    {

      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
2001a86a:	4b21      	ldr	r3, [pc, #132]	; (2001a8f0 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2001a86c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a86e:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
2001a872:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
2001a874:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2001a876:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2001a87a:	d01f      	beq.n	2001a8bc <HAL_RCCEx_GetPeriphCLKFreq+0x264>
2001a87c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2001a880:	d805      	bhi.n	2001a88e <HAL_RCCEx_GetPeriphCLKFreq+0x236>
2001a882:	2b00      	cmp	r3, #0
2001a884:	d00a      	beq.n	2001a89c <HAL_RCCEx_GetPeriphCLKFreq+0x244>
2001a886:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2001a88a:	d00f      	beq.n	2001a8ac <HAL_RCCEx_GetPeriphCLKFreq+0x254>
2001a88c:	e047      	b.n	2001a91e <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
2001a88e:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
2001a892:	d041      	beq.n	2001a918 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>
2001a894:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
2001a898:	d018      	beq.n	2001a8cc <HAL_RCCEx_GetPeriphCLKFreq+0x274>
2001a89a:	e040      	b.n	2001a91e <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
      {
      case 0: /* PLL1 is the clock source for SAI4B */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
2001a89c:	f107 0324 	add.w	r3, r7, #36	; 0x24
2001a8a0:	4618      	mov	r0, r3
2001a8a2:	f000 fc15 	bl	2001b0d0 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2001a8a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
2001a8a8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a8aa:	e13d      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_D3CCIPR_SAI4BSEL_0: /* PLLI2 is the clock source for SAI4B */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2001a8ac:	f107 0318 	add.w	r3, r7, #24
2001a8b0:	4618      	mov	r0, r3
2001a8b2:	f000 f975 	bl	2001aba0 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2001a8b6:	69bb      	ldr	r3, [r7, #24]
2001a8b8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a8ba:	e135      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4BSEL_1: /* PLLI3 is the clock source for SAI4B */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2001a8bc:	f107 030c 	add.w	r3, r7, #12
2001a8c0:	4618      	mov	r0, r3
2001a8c2:	f000 fab9 	bl	2001ae38 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2001a8c6:	68fb      	ldr	r3, [r7, #12]
2001a8c8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a8ca:	e12d      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4BSEL_2: /* CKPER is the clock source for SAI4B*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
2001a8cc:	4b08      	ldr	r3, [pc, #32]	; (2001a8f0 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2001a8ce:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a8d0:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2001a8d4:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2001a8d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a8d8:	2b00      	cmp	r3, #0
2001a8da:	d102      	bne.n	2001a8e2 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
2001a8dc:	4b05      	ldr	r3, [pc, #20]	; (2001a8f4 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
2001a8de:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
2001a8e0:	e122      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
2001a8e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a8e4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001a8e8:	d10c      	bne.n	2001a904 <HAL_RCCEx_GetPeriphCLKFreq+0x2ac>
            frequency = CSI_VALUE;
2001a8ea:	4b03      	ldr	r3, [pc, #12]	; (2001a8f8 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
2001a8ec:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a8ee:	e11b      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
2001a8f0:	58024400 	.word	0x58024400
2001a8f4:	03d09000 	.word	0x03d09000
2001a8f8:	003d0900 	.word	0x003d0900
2001a8fc:	016e3600 	.word	0x016e3600
2001a900:	00bb8000 	.word	0x00bb8000
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
2001a904:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a906:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001a90a:	d102      	bne.n	2001a912 <HAL_RCCEx_GetPeriphCLKFreq+0x2ba>
            frequency = HSE_VALUE;
2001a90c:	4b89      	ldr	r3, [pc, #548]	; (2001ab34 <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
2001a90e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a910:	e10a      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
2001a912:	2300      	movs	r3, #0
2001a914:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a916:	e107      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_D3CCIPR_SAI4BSEL_0 | RCC_D3CCIPR_SAI4BSEL_1 ): /* External clock is the clock source for SAI4B */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
2001a918:	4b87      	ldr	r3, [pc, #540]	; (2001ab38 <HAL_RCCEx_GetPeriphCLKFreq+0x4e0>)
2001a91a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a91c:	e104      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
2001a91e:	2300      	movs	r3, #0
2001a920:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a922:	bf00      	nop
2001a924:	e100      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
#endif /*SAI4*/
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
2001a926:	687b      	ldr	r3, [r7, #4]
2001a928:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2001a92c:	d153      	bne.n	2001a9d6 <HAL_RCCEx_GetPeriphCLKFreq+0x37e>
    {
      /* Get SPI1/2/3 clock source */
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
2001a92e:	4b83      	ldr	r3, [pc, #524]	; (2001ab3c <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
2001a930:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2001a932:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
2001a936:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
2001a938:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2001a93a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2001a93e:	d01f      	beq.n	2001a980 <HAL_RCCEx_GetPeriphCLKFreq+0x328>
2001a940:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2001a944:	d805      	bhi.n	2001a952 <HAL_RCCEx_GetPeriphCLKFreq+0x2fa>
2001a946:	2b00      	cmp	r3, #0
2001a948:	d00a      	beq.n	2001a960 <HAL_RCCEx_GetPeriphCLKFreq+0x308>
2001a94a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2001a94e:	d00f      	beq.n	2001a970 <HAL_RCCEx_GetPeriphCLKFreq+0x318>
2001a950:	e03d      	b.n	2001a9ce <HAL_RCCEx_GetPeriphCLKFreq+0x376>
2001a952:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
2001a956:	d037      	beq.n	2001a9c8 <HAL_RCCEx_GetPeriphCLKFreq+0x370>
2001a958:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2001a95c:	d018      	beq.n	2001a990 <HAL_RCCEx_GetPeriphCLKFreq+0x338>
2001a95e:	e036      	b.n	2001a9ce <HAL_RCCEx_GetPeriphCLKFreq+0x376>
      {
      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for I2S */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
2001a960:	f107 0324 	add.w	r3, r7, #36	; 0x24
2001a964:	4618      	mov	r0, r3
2001a966:	f000 fbb3 	bl	2001b0d0 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2001a96a:	6abb      	ldr	r3, [r7, #40]	; 0x28
2001a96c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a96e:	e0db      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for I2S */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2001a970:	f107 0318 	add.w	r3, r7, #24
2001a974:	4618      	mov	r0, r3
2001a976:	f000 f913 	bl	2001aba0 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2001a97a:	69bb      	ldr	r3, [r7, #24]
2001a97c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a97e:	e0d3      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for I2S */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2001a980:	f107 030c 	add.w	r3, r7, #12
2001a984:	4618      	mov	r0, r3
2001a986:	f000 fa57 	bl	2001ae38 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2001a98a:	68fb      	ldr	r3, [r7, #12]
2001a98c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a98e:	e0cb      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for I2S */
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
2001a990:	4b6a      	ldr	r3, [pc, #424]	; (2001ab3c <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
2001a992:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001a994:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2001a998:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2001a99a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a99c:	2b00      	cmp	r3, #0
2001a99e:	d102      	bne.n	2001a9a6 <HAL_RCCEx_GetPeriphCLKFreq+0x34e>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
2001a9a0:	4b67      	ldr	r3, [pc, #412]	; (2001ab40 <HAL_RCCEx_GetPeriphCLKFreq+0x4e8>)
2001a9a2:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
2001a9a4:	e0c0      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
2001a9a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a9a8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001a9ac:	d102      	bne.n	2001a9b4 <HAL_RCCEx_GetPeriphCLKFreq+0x35c>
            frequency = CSI_VALUE;
2001a9ae:	4b65      	ldr	r3, [pc, #404]	; (2001ab44 <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>)
2001a9b0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a9b2:	e0b9      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
2001a9b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001a9b6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001a9ba:	d102      	bne.n	2001a9c2 <HAL_RCCEx_GetPeriphCLKFreq+0x36a>
            frequency = HSE_VALUE;
2001a9bc:	4b5d      	ldr	r3, [pc, #372]	; (2001ab34 <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
2001a9be:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a9c0:	e0b2      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
2001a9c2:	2300      	movs	r3, #0
2001a9c4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a9c6:	e0af      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
2001a9c8:	4b5b      	ldr	r3, [pc, #364]	; (2001ab38 <HAL_RCCEx_GetPeriphCLKFreq+0x4e0>)
2001a9ca:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a9cc:	e0ac      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      default :
        {
          frequency = 0;
2001a9ce:	2300      	movs	r3, #0
2001a9d0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001a9d2:	bf00      	nop
2001a9d4:	e0a8      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
2001a9d6:	687b      	ldr	r3, [r7, #4]
2001a9d8:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
2001a9dc:	d13d      	bne.n	2001aa5a <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    {
      /* Get ADC clock source */
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
2001a9de:	4b57      	ldr	r3, [pc, #348]	; (2001ab3c <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
2001a9e0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001a9e2:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
2001a9e6:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
2001a9e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2001a9ea:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2001a9ee:	d00c      	beq.n	2001aa0a <HAL_RCCEx_GetPeriphCLKFreq+0x3b2>
2001a9f0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2001a9f4:	d011      	beq.n	2001aa1a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
2001a9f6:	2b00      	cmp	r3, #0
2001a9f8:	d12b      	bne.n	2001aa52 <HAL_RCCEx_GetPeriphCLKFreq+0x3fa>
      {
      case RCC_ADCCLKSOURCE_PLL2:
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2001a9fa:	f107 0318 	add.w	r3, r7, #24
2001a9fe:	4618      	mov	r0, r3
2001aa00:	f000 f8ce 	bl	2001aba0 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2001aa04:	69bb      	ldr	r3, [r7, #24]
2001aa06:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001aa08:	e08e      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_ADCCLKSOURCE_PLL3:
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2001aa0a:	f107 030c 	add.w	r3, r7, #12
2001aa0e:	4618      	mov	r0, r3
2001aa10:	f000 fa12 	bl	2001ae38 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
2001aa14:	697b      	ldr	r3, [r7, #20]
2001aa16:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001aa18:	e086      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_ADCCLKSOURCE_CLKP:
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
2001aa1a:	4b48      	ldr	r3, [pc, #288]	; (2001ab3c <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
2001aa1c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001aa1e:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2001aa22:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2001aa24:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001aa26:	2b00      	cmp	r3, #0
2001aa28:	d102      	bne.n	2001aa30 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
2001aa2a:	4b45      	ldr	r3, [pc, #276]	; (2001ab40 <HAL_RCCEx_GetPeriphCLKFreq+0x4e8>)
2001aa2c:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
2001aa2e:	e07b      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
2001aa30:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001aa32:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001aa36:	d102      	bne.n	2001aa3e <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
            frequency = CSI_VALUE;
2001aa38:	4b42      	ldr	r3, [pc, #264]	; (2001ab44 <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>)
2001aa3a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001aa3c:	e074      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
2001aa3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2001aa40:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001aa44:	d102      	bne.n	2001aa4c <HAL_RCCEx_GetPeriphCLKFreq+0x3f4>
            frequency = HSE_VALUE;
2001aa46:	4b3b      	ldr	r3, [pc, #236]	; (2001ab34 <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
2001aa48:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001aa4a:	e06d      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
2001aa4c:	2300      	movs	r3, #0
2001aa4e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001aa50:	e06a      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
2001aa52:	2300      	movs	r3, #0
2001aa54:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001aa56:	bf00      	nop
2001aa58:	e066      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
2001aa5a:	687b      	ldr	r3, [r7, #4]
2001aa5c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2001aa60:	d11f      	bne.n	2001aaa2 <HAL_RCCEx_GetPeriphCLKFreq+0x44a>
    {
      /* Get SDMMC clock source */
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
2001aa62:	4b36      	ldr	r3, [pc, #216]	; (2001ab3c <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
2001aa64:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2001aa66:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2001aa6a:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
2001aa6c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2001aa6e:	2b00      	cmp	r3, #0
2001aa70:	d003      	beq.n	2001aa7a <HAL_RCCEx_GetPeriphCLKFreq+0x422>
2001aa72:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2001aa76:	d008      	beq.n	2001aa8a <HAL_RCCEx_GetPeriphCLKFreq+0x432>
2001aa78:	e00f      	b.n	2001aa9a <HAL_RCCEx_GetPeriphCLKFreq+0x442>
      {
      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
2001aa7a:	f107 0324 	add.w	r3, r7, #36	; 0x24
2001aa7e:	4618      	mov	r0, r3
2001aa80:	f000 fb26 	bl	2001b0d0 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2001aa84:	6abb      	ldr	r3, [r7, #40]	; 0x28
2001aa86:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001aa88:	e04e      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2001aa8a:	f107 0318 	add.w	r3, r7, #24
2001aa8e:	4618      	mov	r0, r3
2001aa90:	f000 f886 	bl	2001aba0 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
2001aa94:	6a3b      	ldr	r3, [r7, #32]
2001aa96:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001aa98:	e046      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
2001aa9a:	2300      	movs	r3, #0
2001aa9c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001aa9e:	bf00      	nop
2001aaa0:	e042      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
2001aaa2:	687b      	ldr	r3, [r7, #4]
2001aaa4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2001aaa8:	d13c      	bne.n	2001ab24 <HAL_RCCEx_GetPeriphCLKFreq+0x4cc>
    {
      /* Get SPI6 clock source */
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
2001aaaa:	4b24      	ldr	r3, [pc, #144]	; (2001ab3c <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
2001aaac:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2001aaae:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
2001aab2:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
2001aab4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2001aab6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001aaba:	d01e      	beq.n	2001aafa <HAL_RCCEx_GetPeriphCLKFreq+0x4a2>
2001aabc:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001aac0:	d805      	bhi.n	2001aace <HAL_RCCEx_GetPeriphCLKFreq+0x476>
2001aac2:	2b00      	cmp	r3, #0
2001aac4:	d00d      	beq.n	2001aae2 <HAL_RCCEx_GetPeriphCLKFreq+0x48a>
2001aac6:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001aaca:	d00e      	beq.n	2001aaea <HAL_RCCEx_GetPeriphCLKFreq+0x492>
2001aacc:	e026      	b.n	2001ab1c <HAL_RCCEx_GetPeriphCLKFreq+0x4c4>
2001aace:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2001aad2:	d01d      	beq.n	2001ab10 <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>
2001aad4:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
2001aad8:	d01d      	beq.n	2001ab16 <HAL_RCCEx_GetPeriphCLKFreq+0x4be>
2001aada:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
2001aade:	d014      	beq.n	2001ab0a <HAL_RCCEx_GetPeriphCLKFreq+0x4b2>
2001aae0:	e01c      	b.n	2001ab1c <HAL_RCCEx_GetPeriphCLKFreq+0x4c4>
      {
      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */
        {
          frequency = HAL_RCCEx_GetD3PCLK1Freq();
2001aae2:	f000 f847 	bl	2001ab74 <HAL_RCCEx_GetD3PCLK1Freq>
2001aae6:	63f8      	str	r0, [r7, #60]	; 0x3c
          break;
2001aae8:	e01e      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2001aaea:	f107 0318 	add.w	r3, r7, #24
2001aaee:	4618      	mov	r0, r3
2001aaf0:	f000 f856 	bl	2001aba0 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
2001aaf4:	69fb      	ldr	r3, [r7, #28]
2001aaf6:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001aaf8:	e016      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2001aafa:	f107 030c 	add.w	r3, r7, #12
2001aafe:	4618      	mov	r0, r3
2001ab00:	f000 f99a 	bl	2001ae38 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
2001ab04:	693b      	ldr	r3, [r7, #16]
2001ab06:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001ab08:	e00e      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */
        {
          frequency = HSI_VALUE;
2001ab0a:	4b0d      	ldr	r3, [pc, #52]	; (2001ab40 <HAL_RCCEx_GetPeriphCLKFreq+0x4e8>)
2001ab0c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001ab0e:	e00b      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */
        {
          frequency = CSI_VALUE;
2001ab10:	4b0c      	ldr	r3, [pc, #48]	; (2001ab44 <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>)
2001ab12:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001ab14:	e008      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */
        {
          frequency = HSE_VALUE;
2001ab16:	4b07      	ldr	r3, [pc, #28]	; (2001ab34 <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
2001ab18:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001ab1a:	e005      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          break;
        }
#endif /* RCC_SPI6CLKSOURCE_PIN */
      default :
        {
          frequency = 0;
2001ab1c:	2300      	movs	r3, #0
2001ab1e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2001ab20:	bf00      	nop
2001ab22:	e001      	b.n	2001ab28 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else
    {
      frequency = 0;
2001ab24:	2300      	movs	r3, #0
2001ab26:	63fb      	str	r3, [r7, #60]	; 0x3c
    }

  return frequency;
2001ab28:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
2001ab2a:	4618      	mov	r0, r3
2001ab2c:	3740      	adds	r7, #64	; 0x40
2001ab2e:	46bd      	mov	sp, r7
2001ab30:	bd80      	pop	{r7, pc}
2001ab32:	bf00      	nop
2001ab34:	016e3600 	.word	0x016e3600
2001ab38:	00bb8000 	.word	0x00bb8000
2001ab3c:	58024400 	.word	0x58024400
2001ab40:	03d09000 	.word	0x03d09000
2001ab44:	003d0900 	.word	0x003d0900

2001ab48 <HAL_RCCEx_GetD1PCLK1Freq>:
  * @note   Each time D1PCLK1 changes, this function must be called to update the
  *         right D1PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D1PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD1PCLK1Freq(void)
{
2001ab48:	b580      	push	{r7, lr}
2001ab4a:	af00      	add	r7, sp, #0
#if defined(RCC_D1CFGR_D1PPRE)
  /* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1PPRE)>> RCC_D1CFGR_D1PPRE_Pos] & 0x1FU));
2001ab4c:	f7fe f8f8 	bl	20018d40 <HAL_RCC_GetHCLKFreq>
2001ab50:	4601      	mov	r1, r0
2001ab52:	4b06      	ldr	r3, [pc, #24]	; (2001ab6c <HAL_RCCEx_GetD1PCLK1Freq+0x24>)
2001ab54:	699b      	ldr	r3, [r3, #24]
2001ab56:	091b      	lsrs	r3, r3, #4
2001ab58:	f003 0307 	and.w	r3, r3, #7
2001ab5c:	4a04      	ldr	r2, [pc, #16]	; (2001ab70 <HAL_RCCEx_GetD1PCLK1Freq+0x28>)
2001ab5e:	5cd3      	ldrb	r3, [r2, r3]
2001ab60:	f003 031f 	and.w	r3, r3, #31
2001ab64:	fa21 f303 	lsr.w	r3, r1, r3
#else
/* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE)>> RCC_CDCFGR1_CDPPRE_Pos] & 0x1FU));
#endif
}
2001ab68:	4618      	mov	r0, r3
2001ab6a:	bd80      	pop	{r7, pc}
2001ab6c:	58024400 	.word	0x58024400
2001ab70:	2001bf54 	.word	0x2001bf54

2001ab74 <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
2001ab74:	b580      	push	{r7, lr}
2001ab76:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
2001ab78:	f7fe f8e2 	bl	20018d40 <HAL_RCC_GetHCLKFreq>
2001ab7c:	4601      	mov	r1, r0
2001ab7e:	4b06      	ldr	r3, [pc, #24]	; (2001ab98 <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
2001ab80:	6a1b      	ldr	r3, [r3, #32]
2001ab82:	091b      	lsrs	r3, r3, #4
2001ab84:	f003 0307 	and.w	r3, r3, #7
2001ab88:	4a04      	ldr	r2, [pc, #16]	; (2001ab9c <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
2001ab8a:	5cd3      	ldrb	r3, [r2, r3]
2001ab8c:	f003 031f 	and.w	r3, r3, #31
2001ab90:	fa21 f303 	lsr.w	r3, r1, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE)>> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
2001ab94:	4618      	mov	r0, r3
2001ab96:	bd80      	pop	{r7, pc}
2001ab98:	58024400 	.word	0x58024400
2001ab9c:	2001bf54 	.word	0x2001bf54

2001aba0 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef* PLL2_Clocks)
{
2001aba0:	b480      	push	{r7}
2001aba2:	b089      	sub	sp, #36	; 0x24
2001aba4:	af00      	add	r7, sp, #0
2001aba6:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2001aba8:	4b9d      	ldr	r3, [pc, #628]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001abaa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001abac:	f003 0303 	and.w	r3, r3, #3
2001abb0:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
2001abb2:	4b9b      	ldr	r3, [pc, #620]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001abb4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001abb6:	0b1b      	lsrs	r3, r3, #12
2001abb8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2001abbc:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
2001abbe:	4b98      	ldr	r3, [pc, #608]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001abc0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001abc2:	091b      	lsrs	r3, r3, #4
2001abc4:	f003 0301 	and.w	r3, r3, #1
2001abc8:	613b      	str	r3, [r7, #16]
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
2001abca:	4b95      	ldr	r3, [pc, #596]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001abcc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2001abce:	08db      	lsrs	r3, r3, #3
2001abd0:	f3c3 030c 	ubfx	r3, r3, #0, #13
2001abd4:	693a      	ldr	r2, [r7, #16]
2001abd6:	fb02 f303 	mul.w	r3, r2, r3
2001abda:	ee07 3a90 	vmov	s15, r3
2001abde:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001abe2:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
2001abe6:	697b      	ldr	r3, [r7, #20]
2001abe8:	2b00      	cmp	r3, #0
2001abea:	f000 810a 	beq.w	2001ae02 <HAL_RCCEx_GetPLL2ClockFreq+0x262>
  {
    switch (pllsource)
2001abee:	69bb      	ldr	r3, [r7, #24]
2001abf0:	2b01      	cmp	r3, #1
2001abf2:	d05a      	beq.n	2001acaa <HAL_RCCEx_GetPLL2ClockFreq+0x10a>
2001abf4:	2b01      	cmp	r3, #1
2001abf6:	d302      	bcc.n	2001abfe <HAL_RCCEx_GetPLL2ClockFreq+0x5e>
2001abf8:	2b02      	cmp	r3, #2
2001abfa:	d078      	beq.n	2001acee <HAL_RCCEx_GetPLL2ClockFreq+0x14e>
2001abfc:	e099      	b.n	2001ad32 <HAL_RCCEx_GetPLL2ClockFreq+0x192>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
2001abfe:	4b88      	ldr	r3, [pc, #544]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001ac00:	681b      	ldr	r3, [r3, #0]
2001ac02:	f003 0320 	and.w	r3, r3, #32
2001ac06:	2b00      	cmp	r3, #0
2001ac08:	d02d      	beq.n	2001ac66 <HAL_RCCEx_GetPLL2ClockFreq+0xc6>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2001ac0a:	4b85      	ldr	r3, [pc, #532]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001ac0c:	681b      	ldr	r3, [r3, #0]
2001ac0e:	08db      	lsrs	r3, r3, #3
2001ac10:	f003 0303 	and.w	r3, r3, #3
2001ac14:	4a83      	ldr	r2, [pc, #524]	; (2001ae24 <HAL_RCCEx_GetPLL2ClockFreq+0x284>)
2001ac16:	fa22 f303 	lsr.w	r3, r2, r3
2001ac1a:	60bb      	str	r3, [r7, #8]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2001ac1c:	68bb      	ldr	r3, [r7, #8]
2001ac1e:	ee07 3a90 	vmov	s15, r3
2001ac22:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001ac26:	697b      	ldr	r3, [r7, #20]
2001ac28:	ee07 3a90 	vmov	s15, r3
2001ac2c:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001ac30:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001ac34:	4b7a      	ldr	r3, [pc, #488]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001ac36:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001ac38:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001ac3c:	ee07 3a90 	vmov	s15, r3
2001ac40:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001ac44:	ed97 6a03 	vldr	s12, [r7, #12]
2001ac48:	eddf 5a77 	vldr	s11, [pc, #476]	; 2001ae28 <HAL_RCCEx_GetPLL2ClockFreq+0x288>
2001ac4c:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001ac50:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001ac54:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001ac58:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001ac5c:	ee67 7a27 	vmul.f32	s15, s14, s15
2001ac60:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
      }
      break;
2001ac64:	e087      	b.n	2001ad76 <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2001ac66:	697b      	ldr	r3, [r7, #20]
2001ac68:	ee07 3a90 	vmov	s15, r3
2001ac6c:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001ac70:	eddf 6a6e 	vldr	s13, [pc, #440]	; 2001ae2c <HAL_RCCEx_GetPLL2ClockFreq+0x28c>
2001ac74:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001ac78:	4b69      	ldr	r3, [pc, #420]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001ac7a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001ac7c:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001ac80:	ee07 3a90 	vmov	s15, r3
2001ac84:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001ac88:	ed97 6a03 	vldr	s12, [r7, #12]
2001ac8c:	eddf 5a66 	vldr	s11, [pc, #408]	; 2001ae28 <HAL_RCCEx_GetPLL2ClockFreq+0x288>
2001ac90:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001ac94:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001ac98:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001ac9c:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001aca0:	ee67 7a27 	vmul.f32	s15, s14, s15
2001aca4:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001aca8:	e065      	b.n	2001ad76 <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>

    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2001acaa:	697b      	ldr	r3, [r7, #20]
2001acac:	ee07 3a90 	vmov	s15, r3
2001acb0:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001acb4:	eddf 6a5e 	vldr	s13, [pc, #376]	; 2001ae30 <HAL_RCCEx_GetPLL2ClockFreq+0x290>
2001acb8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001acbc:	4b58      	ldr	r3, [pc, #352]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001acbe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001acc0:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001acc4:	ee07 3a90 	vmov	s15, r3
2001acc8:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001accc:	ed97 6a03 	vldr	s12, [r7, #12]
2001acd0:	eddf 5a55 	vldr	s11, [pc, #340]	; 2001ae28 <HAL_RCCEx_GetPLL2ClockFreq+0x288>
2001acd4:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001acd8:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001acdc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001ace0:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001ace4:	ee67 7a27 	vmul.f32	s15, s14, s15
2001ace8:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001acec:	e043      	b.n	2001ad76 <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2001acee:	697b      	ldr	r3, [r7, #20]
2001acf0:	ee07 3a90 	vmov	s15, r3
2001acf4:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001acf8:	eddf 6a4e 	vldr	s13, [pc, #312]	; 2001ae34 <HAL_RCCEx_GetPLL2ClockFreq+0x294>
2001acfc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001ad00:	4b47      	ldr	r3, [pc, #284]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001ad02:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001ad04:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001ad08:	ee07 3a90 	vmov	s15, r3
2001ad0c:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001ad10:	ed97 6a03 	vldr	s12, [r7, #12]
2001ad14:	eddf 5a44 	vldr	s11, [pc, #272]	; 2001ae28 <HAL_RCCEx_GetPLL2ClockFreq+0x288>
2001ad18:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001ad1c:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001ad20:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001ad24:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001ad28:	ee67 7a27 	vmul.f32	s15, s14, s15
2001ad2c:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001ad30:	e021      	b.n	2001ad76 <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>

    default:
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2001ad32:	697b      	ldr	r3, [r7, #20]
2001ad34:	ee07 3a90 	vmov	s15, r3
2001ad38:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001ad3c:	eddf 6a3c 	vldr	s13, [pc, #240]	; 2001ae30 <HAL_RCCEx_GetPLL2ClockFreq+0x290>
2001ad40:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001ad44:	4b36      	ldr	r3, [pc, #216]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001ad46:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001ad48:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001ad4c:	ee07 3a90 	vmov	s15, r3
2001ad50:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001ad54:	ed97 6a03 	vldr	s12, [r7, #12]
2001ad58:	eddf 5a33 	vldr	s11, [pc, #204]	; 2001ae28 <HAL_RCCEx_GetPLL2ClockFreq+0x288>
2001ad5c:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001ad60:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001ad64:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001ad68:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001ad6c:	ee67 7a27 	vmul.f32	s15, s14, s15
2001ad70:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001ad74:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
2001ad76:	4b2a      	ldr	r3, [pc, #168]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001ad78:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001ad7a:	0a5b      	lsrs	r3, r3, #9
2001ad7c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001ad80:	ee07 3a90 	vmov	s15, r3
2001ad84:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001ad88:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2001ad8c:	ee37 7a87 	vadd.f32	s14, s15, s14
2001ad90:	edd7 6a07 	vldr	s13, [r7, #28]
2001ad94:	eec6 7a87 	vdiv.f32	s15, s13, s14
2001ad98:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2001ad9c:	ee17 2a90 	vmov	r2, s15
2001ada0:	687b      	ldr	r3, [r7, #4]
2001ada2:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
2001ada4:	4b1e      	ldr	r3, [pc, #120]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001ada6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001ada8:	0c1b      	lsrs	r3, r3, #16
2001adaa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001adae:	ee07 3a90 	vmov	s15, r3
2001adb2:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001adb6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2001adba:	ee37 7a87 	vadd.f32	s14, s15, s14
2001adbe:	edd7 6a07 	vldr	s13, [r7, #28]
2001adc2:	eec6 7a87 	vdiv.f32	s15, s13, s14
2001adc6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2001adca:	ee17 2a90 	vmov	r2, s15
2001adce:	687b      	ldr	r3, [r7, #4]
2001add0:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
2001add2:	4b13      	ldr	r3, [pc, #76]	; (2001ae20 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2001add4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2001add6:	0e1b      	lsrs	r3, r3, #24
2001add8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001addc:	ee07 3a90 	vmov	s15, r3
2001ade0:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001ade4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2001ade8:	ee37 7a87 	vadd.f32	s14, s15, s14
2001adec:	edd7 6a07 	vldr	s13, [r7, #28]
2001adf0:	eec6 7a87 	vdiv.f32	s15, s13, s14
2001adf4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2001adf8:	ee17 2a90 	vmov	r2, s15
2001adfc:	687b      	ldr	r3, [r7, #4]
2001adfe:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
2001ae00:	e008      	b.n	2001ae14 <HAL_RCCEx_GetPLL2ClockFreq+0x274>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
2001ae02:	687b      	ldr	r3, [r7, #4]
2001ae04:	2200      	movs	r2, #0
2001ae06:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
2001ae08:	687b      	ldr	r3, [r7, #4]
2001ae0a:	2200      	movs	r2, #0
2001ae0c:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
2001ae0e:	687b      	ldr	r3, [r7, #4]
2001ae10:	2200      	movs	r2, #0
2001ae12:	609a      	str	r2, [r3, #8]
}
2001ae14:	bf00      	nop
2001ae16:	3724      	adds	r7, #36	; 0x24
2001ae18:	46bd      	mov	sp, r7
2001ae1a:	f85d 7b04 	ldr.w	r7, [sp], #4
2001ae1e:	4770      	bx	lr
2001ae20:	58024400 	.word	0x58024400
2001ae24:	03d09000 	.word	0x03d09000
2001ae28:	46000000 	.word	0x46000000
2001ae2c:	4c742400 	.word	0x4c742400
2001ae30:	4a742400 	.word	0x4a742400
2001ae34:	4bb71b00 	.word	0x4bb71b00

2001ae38 <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef* PLL3_Clocks)
{
2001ae38:	b480      	push	{r7}
2001ae3a:	b089      	sub	sp, #36	; 0x24
2001ae3c:	af00      	add	r7, sp, #0
2001ae3e:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2001ae40:	4b9d      	ldr	r3, [pc, #628]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001ae42:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001ae44:	f003 0303 	and.w	r3, r3, #3
2001ae48:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
2001ae4a:	4b9b      	ldr	r3, [pc, #620]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001ae4c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001ae4e:	0d1b      	lsrs	r3, r3, #20
2001ae50:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2001ae54:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
2001ae56:	4b98      	ldr	r3, [pc, #608]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001ae58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001ae5a:	0a1b      	lsrs	r3, r3, #8
2001ae5c:	f003 0301 	and.w	r3, r3, #1
2001ae60:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
2001ae62:	4b95      	ldr	r3, [pc, #596]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001ae64:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2001ae66:	08db      	lsrs	r3, r3, #3
2001ae68:	f3c3 030c 	ubfx	r3, r3, #0, #13
2001ae6c:	693a      	ldr	r2, [r7, #16]
2001ae6e:	fb02 f303 	mul.w	r3, r2, r3
2001ae72:	ee07 3a90 	vmov	s15, r3
2001ae76:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001ae7a:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
2001ae7e:	697b      	ldr	r3, [r7, #20]
2001ae80:	2b00      	cmp	r3, #0
2001ae82:	f000 810a 	beq.w	2001b09a <HAL_RCCEx_GetPLL3ClockFreq+0x262>
  {
    switch (pllsource)
2001ae86:	69bb      	ldr	r3, [r7, #24]
2001ae88:	2b01      	cmp	r3, #1
2001ae8a:	d05a      	beq.n	2001af42 <HAL_RCCEx_GetPLL3ClockFreq+0x10a>
2001ae8c:	2b01      	cmp	r3, #1
2001ae8e:	d302      	bcc.n	2001ae96 <HAL_RCCEx_GetPLL3ClockFreq+0x5e>
2001ae90:	2b02      	cmp	r3, #2
2001ae92:	d078      	beq.n	2001af86 <HAL_RCCEx_GetPLL3ClockFreq+0x14e>
2001ae94:	e099      	b.n	2001afca <HAL_RCCEx_GetPLL3ClockFreq+0x192>
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
2001ae96:	4b88      	ldr	r3, [pc, #544]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001ae98:	681b      	ldr	r3, [r3, #0]
2001ae9a:	f003 0320 	and.w	r3, r3, #32
2001ae9e:	2b00      	cmp	r3, #0
2001aea0:	d02d      	beq.n	2001aefe <HAL_RCCEx_GetPLL3ClockFreq+0xc6>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2001aea2:	4b85      	ldr	r3, [pc, #532]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001aea4:	681b      	ldr	r3, [r3, #0]
2001aea6:	08db      	lsrs	r3, r3, #3
2001aea8:	f003 0303 	and.w	r3, r3, #3
2001aeac:	4a83      	ldr	r2, [pc, #524]	; (2001b0bc <HAL_RCCEx_GetPLL3ClockFreq+0x284>)
2001aeae:	fa22 f303 	lsr.w	r3, r2, r3
2001aeb2:	60bb      	str	r3, [r7, #8]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2001aeb4:	68bb      	ldr	r3, [r7, #8]
2001aeb6:	ee07 3a90 	vmov	s15, r3
2001aeba:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001aebe:	697b      	ldr	r3, [r7, #20]
2001aec0:	ee07 3a90 	vmov	s15, r3
2001aec4:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001aec8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001aecc:	4b7a      	ldr	r3, [pc, #488]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001aece:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001aed0:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001aed4:	ee07 3a90 	vmov	s15, r3
2001aed8:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001aedc:	ed97 6a03 	vldr	s12, [r7, #12]
2001aee0:	eddf 5a77 	vldr	s11, [pc, #476]	; 2001b0c0 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
2001aee4:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001aee8:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001aeec:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001aef0:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001aef4:	ee67 7a27 	vmul.f32	s15, s14, s15
2001aef8:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
      }
      break;
2001aefc:	e087      	b.n	2001b00e <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2001aefe:	697b      	ldr	r3, [r7, #20]
2001af00:	ee07 3a90 	vmov	s15, r3
2001af04:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001af08:	eddf 6a6e 	vldr	s13, [pc, #440]	; 2001b0c4 <HAL_RCCEx_GetPLL3ClockFreq+0x28c>
2001af0c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001af10:	4b69      	ldr	r3, [pc, #420]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001af12:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001af14:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001af18:	ee07 3a90 	vmov	s15, r3
2001af1c:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001af20:	ed97 6a03 	vldr	s12, [r7, #12]
2001af24:	eddf 5a66 	vldr	s11, [pc, #408]	; 2001b0c0 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
2001af28:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001af2c:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001af30:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001af34:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001af38:	ee67 7a27 	vmul.f32	s15, s14, s15
2001af3c:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001af40:	e065      	b.n	2001b00e <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2001af42:	697b      	ldr	r3, [r7, #20]
2001af44:	ee07 3a90 	vmov	s15, r3
2001af48:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001af4c:	eddf 6a5e 	vldr	s13, [pc, #376]	; 2001b0c8 <HAL_RCCEx_GetPLL3ClockFreq+0x290>
2001af50:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001af54:	4b58      	ldr	r3, [pc, #352]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001af56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001af58:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001af5c:	ee07 3a90 	vmov	s15, r3
2001af60:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001af64:	ed97 6a03 	vldr	s12, [r7, #12]
2001af68:	eddf 5a55 	vldr	s11, [pc, #340]	; 2001b0c0 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
2001af6c:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001af70:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001af74:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001af78:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001af7c:	ee67 7a27 	vmul.f32	s15, s14, s15
2001af80:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001af84:	e043      	b.n	2001b00e <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2001af86:	697b      	ldr	r3, [r7, #20]
2001af88:	ee07 3a90 	vmov	s15, r3
2001af8c:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001af90:	eddf 6a4e 	vldr	s13, [pc, #312]	; 2001b0cc <HAL_RCCEx_GetPLL3ClockFreq+0x294>
2001af94:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001af98:	4b47      	ldr	r3, [pc, #284]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001af9a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001af9c:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001afa0:	ee07 3a90 	vmov	s15, r3
2001afa4:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001afa8:	ed97 6a03 	vldr	s12, [r7, #12]
2001afac:	eddf 5a44 	vldr	s11, [pc, #272]	; 2001b0c0 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
2001afb0:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001afb4:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001afb8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001afbc:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001afc0:	ee67 7a27 	vmul.f32	s15, s14, s15
2001afc4:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001afc8:	e021      	b.n	2001b00e <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>

    default:
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2001afca:	697b      	ldr	r3, [r7, #20]
2001afcc:	ee07 3a90 	vmov	s15, r3
2001afd0:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001afd4:	eddf 6a3c 	vldr	s13, [pc, #240]	; 2001b0c8 <HAL_RCCEx_GetPLL3ClockFreq+0x290>
2001afd8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001afdc:	4b36      	ldr	r3, [pc, #216]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001afde:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001afe0:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001afe4:	ee07 3a90 	vmov	s15, r3
2001afe8:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001afec:	ed97 6a03 	vldr	s12, [r7, #12]
2001aff0:	eddf 5a33 	vldr	s11, [pc, #204]	; 2001b0c0 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
2001aff4:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001aff8:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001affc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001b000:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001b004:	ee67 7a27 	vmul.f32	s15, s14, s15
2001b008:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001b00c:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
2001b00e:	4b2a      	ldr	r3, [pc, #168]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001b010:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001b012:	0a5b      	lsrs	r3, r3, #9
2001b014:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001b018:	ee07 3a90 	vmov	s15, r3
2001b01c:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b020:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2001b024:	ee37 7a87 	vadd.f32	s14, s15, s14
2001b028:	edd7 6a07 	vldr	s13, [r7, #28]
2001b02c:	eec6 7a87 	vdiv.f32	s15, s13, s14
2001b030:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2001b034:	ee17 2a90 	vmov	r2, s15
2001b038:	687b      	ldr	r3, [r7, #4]
2001b03a:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
2001b03c:	4b1e      	ldr	r3, [pc, #120]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001b03e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001b040:	0c1b      	lsrs	r3, r3, #16
2001b042:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001b046:	ee07 3a90 	vmov	s15, r3
2001b04a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b04e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2001b052:	ee37 7a87 	vadd.f32	s14, s15, s14
2001b056:	edd7 6a07 	vldr	s13, [r7, #28]
2001b05a:	eec6 7a87 	vdiv.f32	s15, s13, s14
2001b05e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2001b062:	ee17 2a90 	vmov	r2, s15
2001b066:	687b      	ldr	r3, [r7, #4]
2001b068:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
2001b06a:	4b13      	ldr	r3, [pc, #76]	; (2001b0b8 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2001b06c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2001b06e:	0e1b      	lsrs	r3, r3, #24
2001b070:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001b074:	ee07 3a90 	vmov	s15, r3
2001b078:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b07c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2001b080:	ee37 7a87 	vadd.f32	s14, s15, s14
2001b084:	edd7 6a07 	vldr	s13, [r7, #28]
2001b088:	eec6 7a87 	vdiv.f32	s15, s13, s14
2001b08c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2001b090:	ee17 2a90 	vmov	r2, s15
2001b094:	687b      	ldr	r3, [r7, #4]
2001b096:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
2001b098:	e008      	b.n	2001b0ac <HAL_RCCEx_GetPLL3ClockFreq+0x274>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
2001b09a:	687b      	ldr	r3, [r7, #4]
2001b09c:	2200      	movs	r2, #0
2001b09e:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
2001b0a0:	687b      	ldr	r3, [r7, #4]
2001b0a2:	2200      	movs	r2, #0
2001b0a4:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
2001b0a6:	687b      	ldr	r3, [r7, #4]
2001b0a8:	2200      	movs	r2, #0
2001b0aa:	609a      	str	r2, [r3, #8]
}
2001b0ac:	bf00      	nop
2001b0ae:	3724      	adds	r7, #36	; 0x24
2001b0b0:	46bd      	mov	sp, r7
2001b0b2:	f85d 7b04 	ldr.w	r7, [sp], #4
2001b0b6:	4770      	bx	lr
2001b0b8:	58024400 	.word	0x58024400
2001b0bc:	03d09000 	.word	0x03d09000
2001b0c0:	46000000 	.word	0x46000000
2001b0c4:	4c742400 	.word	0x4c742400
2001b0c8:	4a742400 	.word	0x4a742400
2001b0cc:	4bb71b00 	.word	0x4bb71b00

2001b0d0 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef* PLL1_Clocks)
{
2001b0d0:	b480      	push	{r7}
2001b0d2:	b089      	sub	sp, #36	; 0x24
2001b0d4:	af00      	add	r7, sp, #0
2001b0d6:	6078      	str	r0, [r7, #4]
  uint32_t pllsource, pll1m, pll1fracen, hsivalue;
  float_t fracn1, pll1vco;

  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2001b0d8:	4b9d      	ldr	r3, [pc, #628]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b0da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001b0dc:	f003 0303 	and.w	r3, r3, #3
2001b0e0:	61bb      	str	r3, [r7, #24]
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
2001b0e2:	4b9b      	ldr	r3, [pc, #620]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b0e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001b0e6:	091b      	lsrs	r3, r3, #4
2001b0e8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2001b0ec:	617b      	str	r3, [r7, #20]
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
2001b0ee:	4b98      	ldr	r3, [pc, #608]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b0f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001b0f2:	f003 0301 	and.w	r3, r3, #1
2001b0f6:	613b      	str	r3, [r7, #16]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
2001b0f8:	4b95      	ldr	r3, [pc, #596]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b0fa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2001b0fc:	08db      	lsrs	r3, r3, #3
2001b0fe:	f3c3 030c 	ubfx	r3, r3, #0, #13
2001b102:	693a      	ldr	r2, [r7, #16]
2001b104:	fb02 f303 	mul.w	r3, r2, r3
2001b108:	ee07 3a90 	vmov	s15, r3
2001b10c:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b110:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll1m != 0U)
2001b114:	697b      	ldr	r3, [r7, #20]
2001b116:	2b00      	cmp	r3, #0
2001b118:	f000 810a 	beq.w	2001b330 <HAL_RCCEx_GetPLL1ClockFreq+0x260>
  {
    switch (pllsource)
2001b11c:	69bb      	ldr	r3, [r7, #24]
2001b11e:	2b01      	cmp	r3, #1
2001b120:	d05a      	beq.n	2001b1d8 <HAL_RCCEx_GetPLL1ClockFreq+0x108>
2001b122:	2b01      	cmp	r3, #1
2001b124:	d302      	bcc.n	2001b12c <HAL_RCCEx_GetPLL1ClockFreq+0x5c>
2001b126:	2b02      	cmp	r3, #2
2001b128:	d078      	beq.n	2001b21c <HAL_RCCEx_GetPLL1ClockFreq+0x14c>
2001b12a:	e099      	b.n	2001b260 <HAL_RCCEx_GetPLL1ClockFreq+0x190>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
2001b12c:	4b88      	ldr	r3, [pc, #544]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b12e:	681b      	ldr	r3, [r3, #0]
2001b130:	f003 0320 	and.w	r3, r3, #32
2001b134:	2b00      	cmp	r3, #0
2001b136:	d02d      	beq.n	2001b194 <HAL_RCCEx_GetPLL1ClockFreq+0xc4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2001b138:	4b85      	ldr	r3, [pc, #532]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b13a:	681b      	ldr	r3, [r3, #0]
2001b13c:	08db      	lsrs	r3, r3, #3
2001b13e:	f003 0303 	and.w	r3, r3, #3
2001b142:	4a84      	ldr	r2, [pc, #528]	; (2001b354 <HAL_RCCEx_GetPLL1ClockFreq+0x284>)
2001b144:	fa22 f303 	lsr.w	r3, r2, r3
2001b148:	60bb      	str	r3, [r7, #8]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2001b14a:	68bb      	ldr	r3, [r7, #8]
2001b14c:	ee07 3a90 	vmov	s15, r3
2001b150:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001b154:	697b      	ldr	r3, [r7, #20]
2001b156:	ee07 3a90 	vmov	s15, r3
2001b15a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b15e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001b162:	4b7b      	ldr	r3, [pc, #492]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b164:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001b166:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001b16a:	ee07 3a90 	vmov	s15, r3
2001b16e:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001b172:	ed97 6a03 	vldr	s12, [r7, #12]
2001b176:	eddf 5a78 	vldr	s11, [pc, #480]	; 2001b358 <HAL_RCCEx_GetPLL1ClockFreq+0x288>
2001b17a:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001b17e:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001b182:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001b186:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001b18a:	ee67 7a27 	vmul.f32	s15, s14, s15
2001b18e:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
      }
      break;
2001b192:	e087      	b.n	2001b2a4 <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2001b194:	697b      	ldr	r3, [r7, #20]
2001b196:	ee07 3a90 	vmov	s15, r3
2001b19a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b19e:	eddf 6a6f 	vldr	s13, [pc, #444]	; 2001b35c <HAL_RCCEx_GetPLL1ClockFreq+0x28c>
2001b1a2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001b1a6:	4b6a      	ldr	r3, [pc, #424]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b1a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001b1aa:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001b1ae:	ee07 3a90 	vmov	s15, r3
2001b1b2:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001b1b6:	ed97 6a03 	vldr	s12, [r7, #12]
2001b1ba:	eddf 5a67 	vldr	s11, [pc, #412]	; 2001b358 <HAL_RCCEx_GetPLL1ClockFreq+0x288>
2001b1be:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001b1c2:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001b1c6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001b1ca:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001b1ce:	ee67 7a27 	vmul.f32	s15, s14, s15
2001b1d2:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001b1d6:	e065      	b.n	2001b2a4 <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2001b1d8:	697b      	ldr	r3, [r7, #20]
2001b1da:	ee07 3a90 	vmov	s15, r3
2001b1de:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b1e2:	eddf 6a5f 	vldr	s13, [pc, #380]	; 2001b360 <HAL_RCCEx_GetPLL1ClockFreq+0x290>
2001b1e6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001b1ea:	4b59      	ldr	r3, [pc, #356]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b1ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001b1ee:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001b1f2:	ee07 3a90 	vmov	s15, r3
2001b1f6:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001b1fa:	ed97 6a03 	vldr	s12, [r7, #12]
2001b1fe:	eddf 5a56 	vldr	s11, [pc, #344]	; 2001b358 <HAL_RCCEx_GetPLL1ClockFreq+0x288>
2001b202:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001b206:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001b20a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001b20e:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001b212:	ee67 7a27 	vmul.f32	s15, s14, s15
2001b216:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001b21a:	e043      	b.n	2001b2a4 <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2001b21c:	697b      	ldr	r3, [r7, #20]
2001b21e:	ee07 3a90 	vmov	s15, r3
2001b222:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b226:	eddf 6a4f 	vldr	s13, [pc, #316]	; 2001b364 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
2001b22a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001b22e:	4b48      	ldr	r3, [pc, #288]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b230:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001b232:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001b236:	ee07 3a90 	vmov	s15, r3
2001b23a:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001b23e:	ed97 6a03 	vldr	s12, [r7, #12]
2001b242:	eddf 5a45 	vldr	s11, [pc, #276]	; 2001b358 <HAL_RCCEx_GetPLL1ClockFreq+0x288>
2001b246:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001b24a:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001b24e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001b252:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001b256:	ee67 7a27 	vmul.f32	s15, s14, s15
2001b25a:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001b25e:	e021      	b.n	2001b2a4 <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>

    default:
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2001b260:	697b      	ldr	r3, [r7, #20]
2001b262:	ee07 3a90 	vmov	s15, r3
2001b266:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b26a:	eddf 6a3d 	vldr	s13, [pc, #244]	; 2001b360 <HAL_RCCEx_GetPLL1ClockFreq+0x290>
2001b26e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2001b272:	4b37      	ldr	r3, [pc, #220]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b274:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001b276:	f3c3 0308 	ubfx	r3, r3, #0, #9
2001b27a:	ee07 3a90 	vmov	s15, r3
2001b27e:	eef8 6a67 	vcvt.f32.u32	s13, s15
2001b282:	ed97 6a03 	vldr	s12, [r7, #12]
2001b286:	eddf 5a34 	vldr	s11, [pc, #208]	; 2001b358 <HAL_RCCEx_GetPLL1ClockFreq+0x288>
2001b28a:	eec6 7a25 	vdiv.f32	s15, s12, s11
2001b28e:	ee76 7aa7 	vadd.f32	s15, s13, s15
2001b292:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2001b296:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001b29a:	ee67 7a27 	vmul.f32	s15, s14, s15
2001b29e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2001b2a2:	bf00      	nop
    }

    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
2001b2a4:	4b2a      	ldr	r3, [pc, #168]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b2a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001b2a8:	0a5b      	lsrs	r3, r3, #9
2001b2aa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001b2ae:	ee07 3a90 	vmov	s15, r3
2001b2b2:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b2b6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2001b2ba:	ee37 7a87 	vadd.f32	s14, s15, s14
2001b2be:	edd7 6a07 	vldr	s13, [r7, #28]
2001b2c2:	eec6 7a87 	vdiv.f32	s15, s13, s14
2001b2c6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2001b2ca:	ee17 2a90 	vmov	r2, s15
2001b2ce:	687b      	ldr	r3, [r7, #4]
2001b2d0:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
2001b2d2:	4b1f      	ldr	r3, [pc, #124]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b2d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001b2d6:	0c1b      	lsrs	r3, r3, #16
2001b2d8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001b2dc:	ee07 3a90 	vmov	s15, r3
2001b2e0:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b2e4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2001b2e8:	ee37 7a87 	vadd.f32	s14, s15, s14
2001b2ec:	edd7 6a07 	vldr	s13, [r7, #28]
2001b2f0:	eec6 7a87 	vdiv.f32	s15, s13, s14
2001b2f4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2001b2f8:	ee17 2a90 	vmov	r2, s15
2001b2fc:	687b      	ldr	r3, [r7, #4]
2001b2fe:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
2001b300:	4b13      	ldr	r3, [pc, #76]	; (2001b350 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
2001b302:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2001b304:	0e1b      	lsrs	r3, r3, #24
2001b306:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2001b30a:	ee07 3a90 	vmov	s15, r3
2001b30e:	eef8 7a67 	vcvt.f32.u32	s15, s15
2001b312:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2001b316:	ee37 7a87 	vadd.f32	s14, s15, s14
2001b31a:	edd7 6a07 	vldr	s13, [r7, #28]
2001b31e:	eec6 7a87 	vdiv.f32	s15, s13, s14
2001b322:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2001b326:	ee17 2a90 	vmov	r2, s15
2001b32a:	687b      	ldr	r3, [r7, #4]
2001b32c:	609a      	str	r2, [r3, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
2001b32e:	e008      	b.n	2001b342 <HAL_RCCEx_GetPLL1ClockFreq+0x272>
    PLL1_Clocks->PLL1_P_Frequency = 0U;
2001b330:	687b      	ldr	r3, [r7, #4]
2001b332:	2200      	movs	r2, #0
2001b334:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
2001b336:	687b      	ldr	r3, [r7, #4]
2001b338:	2200      	movs	r2, #0
2001b33a:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
2001b33c:	687b      	ldr	r3, [r7, #4]
2001b33e:	2200      	movs	r2, #0
2001b340:	609a      	str	r2, [r3, #8]
}
2001b342:	bf00      	nop
2001b344:	3724      	adds	r7, #36	; 0x24
2001b346:	46bd      	mov	sp, r7
2001b348:	f85d 7b04 	ldr.w	r7, [sp], #4
2001b34c:	4770      	bx	lr
2001b34e:	bf00      	nop
2001b350:	58024400 	.word	0x58024400
2001b354:	03d09000 	.word	0x03d09000
2001b358:	46000000 	.word	0x46000000
2001b35c:	4c742400 	.word	0x4c742400
2001b360:	4a742400 	.word	0x4a742400
2001b364:	4bb71b00 	.word	0x4bb71b00

2001b368 <HAL_RCCEx_GetD1SysClockFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System current Core Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCCEx_GetD1SysClockFreq(void)
{
2001b368:	b580      	push	{r7, lr}
2001b36a:	b082      	sub	sp, #8
2001b36c:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
2001b36e:	f7fd fb75 	bl	20018a5c <HAL_RCC_GetSysClockFreq>
2001b372:	4601      	mov	r1, r0
2001b374:	4b10      	ldr	r3, [pc, #64]	; (2001b3b8 <HAL_RCCEx_GetD1SysClockFreq+0x50>)
2001b376:	699b      	ldr	r3, [r3, #24]
2001b378:	0a1b      	lsrs	r3, r3, #8
2001b37a:	f003 030f 	and.w	r3, r3, #15
2001b37e:	4a0f      	ldr	r2, [pc, #60]	; (2001b3bc <HAL_RCCEx_GetD1SysClockFreq+0x54>)
2001b380:	5cd3      	ldrb	r3, [r2, r3]
2001b382:	f003 031f 	and.w	r3, r3, #31
2001b386:	fa21 f303 	lsr.w	r3, r1, r3
2001b38a:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
2001b38c:	4b0a      	ldr	r3, [pc, #40]	; (2001b3b8 <HAL_RCCEx_GetD1SysClockFreq+0x50>)
2001b38e:	699b      	ldr	r3, [r3, #24]
2001b390:	f003 030f 	and.w	r3, r3, #15
2001b394:	4a09      	ldr	r2, [pc, #36]	; (2001b3bc <HAL_RCCEx_GetD1SysClockFreq+0x54>)
2001b396:	5cd3      	ldrb	r3, [r2, r3]
2001b398:	f003 031f 	and.w	r3, r3, #31
2001b39c:	687a      	ldr	r2, [r7, #4]
2001b39e:	fa22 f303 	lsr.w	r3, r2, r3
2001b3a2:	4a07      	ldr	r2, [pc, #28]	; (2001b3c0 <HAL_RCCEx_GetD1SysClockFreq+0x58>)
2001b3a4:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
2001b3a6:	4a07      	ldr	r2, [pc, #28]	; (2001b3c4 <HAL_RCCEx_GetD1SysClockFreq+0x5c>)
2001b3a8:	687b      	ldr	r3, [r7, #4]
2001b3aa:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return common_system_clock;
2001b3ac:	687b      	ldr	r3, [r7, #4]
}
2001b3ae:	4618      	mov	r0, r3
2001b3b0:	3708      	adds	r7, #8
2001b3b2:	46bd      	mov	sp, r7
2001b3b4:	bd80      	pop	{r7, pc}
2001b3b6:	bf00      	nop
2001b3b8:	58024400 	.word	0x58024400
2001b3bc:	2001bf54 	.word	0x2001bf54
2001b3c0:	2001c97c 	.word	0x2001c97c
2001b3c4:	2001c978 	.word	0x2001c978

2001b3c8 <HAL_RCCEx_EnableLSECSS>:
  *         with HAL_RCC_OscConfig() and the LSE oscillator clock is to be selected as RTC
  *         clock with HAL_RCCEx_PeriphCLKConfig().
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS(void)
{
2001b3c8:	b480      	push	{r7}
2001b3ca:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
2001b3cc:	4b05      	ldr	r3, [pc, #20]	; (2001b3e4 <HAL_RCCEx_EnableLSECSS+0x1c>)
2001b3ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2001b3d0:	4a04      	ldr	r2, [pc, #16]	; (2001b3e4 <HAL_RCCEx_EnableLSECSS+0x1c>)
2001b3d2:	f043 0320 	orr.w	r3, r3, #32
2001b3d6:	6713      	str	r3, [r2, #112]	; 0x70
}
2001b3d8:	bf00      	nop
2001b3da:	46bd      	mov	sp, r7
2001b3dc:	f85d 7b04 	ldr.w	r7, [sp], #4
2001b3e0:	4770      	bx	lr
2001b3e2:	bf00      	nop
2001b3e4:	58024400 	.word	0x58024400

2001b3e8 <HAL_RCCEx_DisableLSECSS>:
  * @brief  Disables the LSE Clock Security System.
  * @note   LSE Clock Security System can only be disabled after a LSE failure detection.
  * @retval None
  */
void HAL_RCCEx_DisableLSECSS(void)
{
2001b3e8:	b480      	push	{r7}
2001b3ea:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
2001b3ec:	4b08      	ldr	r3, [pc, #32]	; (2001b410 <HAL_RCCEx_DisableLSECSS+0x28>)
2001b3ee:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2001b3f0:	4a07      	ldr	r2, [pc, #28]	; (2001b410 <HAL_RCCEx_DisableLSECSS+0x28>)
2001b3f2:	f023 0320 	bic.w	r3, r3, #32
2001b3f6:	6713      	str	r3, [r2, #112]	; 0x70
  /* Disable LSE CSS IT if any */
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
2001b3f8:	4b05      	ldr	r3, [pc, #20]	; (2001b410 <HAL_RCCEx_DisableLSECSS+0x28>)
2001b3fa:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2001b3fc:	4a04      	ldr	r2, [pc, #16]	; (2001b410 <HAL_RCCEx_DisableLSECSS+0x28>)
2001b3fe:	f423 7300 	bic.w	r3, r3, #512	; 0x200
2001b402:	6613      	str	r3, [r2, #96]	; 0x60
}
2001b404:	bf00      	nop
2001b406:	46bd      	mov	sp, r7
2001b408:	f85d 7b04 	ldr.w	r7, [sp], #4
2001b40c:	4770      	bx	lr
2001b40e:	bf00      	nop
2001b410:	58024400 	.word	0x58024400

2001b414 <HAL_RCCEx_EnableLSECSS_IT>:
  * @brief  Enable the LSE Clock Security System Interrupt & corresponding EXTI line.
  * @note   LSE Clock Security System Interrupt is mapped on EXTI line 18
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS_IT(void)
{
2001b414:	b480      	push	{r7}
2001b416:	af00      	add	r7, sp, #0
  /* Enable LSE CSS */
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
2001b418:	4b11      	ldr	r3, [pc, #68]	; (2001b460 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
2001b41a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2001b41c:	4a10      	ldr	r2, [pc, #64]	; (2001b460 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
2001b41e:	f043 0320 	orr.w	r3, r3, #32
2001b422:	6713      	str	r3, [r2, #112]	; 0x70

  /* Enable LSE CSS IT */
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
2001b424:	4b0e      	ldr	r3, [pc, #56]	; (2001b460 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
2001b426:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2001b428:	4a0d      	ldr	r2, [pc, #52]	; (2001b460 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
2001b42a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2001b42e:	6613      	str	r3, [r2, #96]	; 0x60

  /* Enable IT on EXTI Line 18 */
#if defined(DUAL_CORE) && defined(CORE_CM4)
  __HAL_RCC_C2_LSECSS_EXTI_ENABLE_IT();
#else
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
2001b430:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2001b434:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2001b438:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2001b43c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
2001b440:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* DUAL_CORE && CORE_CM4 */
  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
2001b444:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2001b448:	681b      	ldr	r3, [r3, #0]
2001b44a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2001b44e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
2001b452:	6013      	str	r3, [r2, #0]
}
2001b454:	bf00      	nop
2001b456:	46bd      	mov	sp, r7
2001b458:	f85d 7b04 	ldr.w	r7, [sp], #4
2001b45c:	4770      	bx	lr
2001b45e:	bf00      	nop
2001b460:	58024400 	.word	0x58024400

2001b464 <HAL_RCCEx_WakeUpStopCLKConfig>:
  * @note   This function shall not be called after the Clock Security System on HSE has been
  *         enabled.
  * @retval None
  */
void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
{
2001b464:	b580      	push	{r7, lr}
2001b466:	b082      	sub	sp, #8
2001b468:	af00      	add	r7, sp, #0
2001b46a:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));
2001b46c:	687b      	ldr	r3, [r7, #4]
2001b46e:	2b40      	cmp	r3, #64	; 0x40
2001b470:	d007      	beq.n	2001b482 <HAL_RCCEx_WakeUpStopCLKConfig+0x1e>
2001b472:	687b      	ldr	r3, [r7, #4]
2001b474:	2b00      	cmp	r3, #0
2001b476:	d004      	beq.n	2001b482 <HAL_RCCEx_WakeUpStopCLKConfig+0x1e>
2001b478:	f44f 612b 	mov.w	r1, #2736	; 0xab0
2001b47c:	4807      	ldr	r0, [pc, #28]	; (2001b49c <HAL_RCCEx_WakeUpStopCLKConfig+0x38>)
2001b47e:	f7e5 fa39 	bl	200008f4 <assert_failed>

  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
2001b482:	4b07      	ldr	r3, [pc, #28]	; (2001b4a0 <HAL_RCCEx_WakeUpStopCLKConfig+0x3c>)
2001b484:	691b      	ldr	r3, [r3, #16]
2001b486:	f023 0240 	bic.w	r2, r3, #64	; 0x40
2001b48a:	4905      	ldr	r1, [pc, #20]	; (2001b4a0 <HAL_RCCEx_WakeUpStopCLKConfig+0x3c>)
2001b48c:	687b      	ldr	r3, [r7, #4]
2001b48e:	4313      	orrs	r3, r2
2001b490:	610b      	str	r3, [r1, #16]
}
2001b492:	bf00      	nop
2001b494:	3708      	adds	r7, #8
2001b496:	46bd      	mov	sp, r7
2001b498:	bd80      	pop	{r7, pc}
2001b49a:	bf00      	nop
2001b49c:	2001c318 	.word	0x2001c318
2001b4a0:	58024400 	.word	0x58024400

2001b4a4 <HAL_RCCEx_KerWakeUpStopCLKConfig>:
  *            @arg RCC_STOP_KERWAKEUPCLOCK_CSI: CSI oscillator selection
  *            @arg RCC_STOP_KERWAKEUPCLOCK_HSI: HSI oscillator selection
  * @retval None
  */
void HAL_RCCEx_KerWakeUpStopCLKConfig(uint32_t WakeUpClk)
{
2001b4a4:	b580      	push	{r7, lr}
2001b4a6:	b082      	sub	sp, #8
2001b4a8:	af00      	add	r7, sp, #0
2001b4aa:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_STOP_KERWAKEUPCLOCK(WakeUpClk));
2001b4ac:	687b      	ldr	r3, [r7, #4]
2001b4ae:	2b80      	cmp	r3, #128	; 0x80
2001b4b0:	d007      	beq.n	2001b4c2 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x1e>
2001b4b2:	687b      	ldr	r3, [r7, #4]
2001b4b4:	2b00      	cmp	r3, #0
2001b4b6:	d004      	beq.n	2001b4c2 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x1e>
2001b4b8:	f640 21bf 	movw	r1, #2751	; 0xabf
2001b4bc:	4807      	ldr	r0, [pc, #28]	; (2001b4dc <HAL_RCCEx_KerWakeUpStopCLKConfig+0x38>)
2001b4be:	f7e5 fa19 	bl	200008f4 <assert_failed>

  __HAL_RCC_KERWAKEUPSTOP_CLK_CONFIG(WakeUpClk);
2001b4c2:	4b07      	ldr	r3, [pc, #28]	; (2001b4e0 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x3c>)
2001b4c4:	691b      	ldr	r3, [r3, #16]
2001b4c6:	f023 0280 	bic.w	r2, r3, #128	; 0x80
2001b4ca:	4905      	ldr	r1, [pc, #20]	; (2001b4e0 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x3c>)
2001b4cc:	687b      	ldr	r3, [r7, #4]
2001b4ce:	4313      	orrs	r3, r2
2001b4d0:	610b      	str	r3, [r1, #16]
}
2001b4d2:	bf00      	nop
2001b4d4:	3708      	adds	r7, #8
2001b4d6:	46bd      	mov	sp, r7
2001b4d8:	bd80      	pop	{r7, pc}
2001b4da:	bf00      	nop
2001b4dc:	2001c318 	.word	0x2001c318
2001b4e0:	58024400 	.word	0x58024400

2001b4e4 <HAL_RCCEx_WWDGxSysResetConfig>:
  * @note   This bit can be set by software but is cleared by hardware during a system reset
  *
  * @retval None
  */
void HAL_RCCEx_WWDGxSysResetConfig(uint32_t RCC_WWDGx)
{
2001b4e4:	b580      	push	{r7, lr}
2001b4e6:	b082      	sub	sp, #8
2001b4e8:	af00      	add	r7, sp, #0
2001b4ea:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_SCOPE_WWDG(RCC_WWDGx));
2001b4ec:	687b      	ldr	r3, [r7, #4]
2001b4ee:	2b01      	cmp	r3, #1
2001b4f0:	d004      	beq.n	2001b4fc <HAL_RCCEx_WWDGxSysResetConfig+0x18>
2001b4f2:	f640 21f5 	movw	r1, #2805	; 0xaf5
2001b4f6:	4807      	ldr	r0, [pc, #28]	; (2001b514 <HAL_RCCEx_WWDGxSysResetConfig+0x30>)
2001b4f8:	f7e5 f9fc 	bl	200008f4 <assert_failed>
  SET_BIT(RCC->GCR, RCC_WWDGx) ;
2001b4fc:	4b06      	ldr	r3, [pc, #24]	; (2001b518 <HAL_RCCEx_WWDGxSysResetConfig+0x34>)
2001b4fe:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
2001b502:	4905      	ldr	r1, [pc, #20]	; (2001b518 <HAL_RCCEx_WWDGxSysResetConfig+0x34>)
2001b504:	687b      	ldr	r3, [r7, #4]
2001b506:	4313      	orrs	r3, r2
2001b508:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
}
2001b50c:	bf00      	nop
2001b50e:	3708      	adds	r7, #8
2001b510:	46bd      	mov	sp, r7
2001b512:	bd80      	pop	{r7, pc}
2001b514:	2001c318 	.word	0x2001c318
2001b518:	58024400 	.word	0x58024400

2001b51c <HAL_RCCEx_CRSConfig>:
  * @brief  Start automatic synchronization for polling mode
  * @param  pInit Pointer on RCC_CRSInitTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit)
{
2001b51c:	b580      	push	{r7, lr}
2001b51e:	b084      	sub	sp, #16
2001b520:	af00      	add	r7, sp, #0
2001b522:	6078      	str	r0, [r7, #4]
  uint32_t value;

  /* Check the parameters */
  assert_param(IS_RCC_CRS_SYNC_DIV(pInit->Prescaler));
2001b524:	687b      	ldr	r3, [r7, #4]
2001b526:	681b      	ldr	r3, [r3, #0]
2001b528:	2b00      	cmp	r3, #0
2001b52a:	d027      	beq.n	2001b57c <HAL_RCCEx_CRSConfig+0x60>
2001b52c:	687b      	ldr	r3, [r7, #4]
2001b52e:	681b      	ldr	r3, [r3, #0]
2001b530:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2001b534:	d022      	beq.n	2001b57c <HAL_RCCEx_CRSConfig+0x60>
2001b536:	687b      	ldr	r3, [r7, #4]
2001b538:	681b      	ldr	r3, [r3, #0]
2001b53a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2001b53e:	d01d      	beq.n	2001b57c <HAL_RCCEx_CRSConfig+0x60>
2001b540:	687b      	ldr	r3, [r7, #4]
2001b542:	681b      	ldr	r3, [r3, #0]
2001b544:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
2001b548:	d018      	beq.n	2001b57c <HAL_RCCEx_CRSConfig+0x60>
2001b54a:	687b      	ldr	r3, [r7, #4]
2001b54c:	681b      	ldr	r3, [r3, #0]
2001b54e:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
2001b552:	d013      	beq.n	2001b57c <HAL_RCCEx_CRSConfig+0x60>
2001b554:	687b      	ldr	r3, [r7, #4]
2001b556:	681b      	ldr	r3, [r3, #0]
2001b558:	f1b3 6fa0 	cmp.w	r3, #83886080	; 0x5000000
2001b55c:	d00e      	beq.n	2001b57c <HAL_RCCEx_CRSConfig+0x60>
2001b55e:	687b      	ldr	r3, [r7, #4]
2001b560:	681b      	ldr	r3, [r3, #0]
2001b562:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
2001b566:	d009      	beq.n	2001b57c <HAL_RCCEx_CRSConfig+0x60>
2001b568:	687b      	ldr	r3, [r7, #4]
2001b56a:	681b      	ldr	r3, [r3, #0]
2001b56c:	f1b3 6fe0 	cmp.w	r3, #117440512	; 0x7000000
2001b570:	d004      	beq.n	2001b57c <HAL_RCCEx_CRSConfig+0x60>
2001b572:	f640 3149 	movw	r1, #2889	; 0xb49
2001b576:	4849      	ldr	r0, [pc, #292]	; (2001b69c <HAL_RCCEx_CRSConfig+0x180>)
2001b578:	f7e5 f9bc 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_CRS_SYNC_SOURCE(pInit->Source));
2001b57c:	687b      	ldr	r3, [r7, #4]
2001b57e:	685b      	ldr	r3, [r3, #4]
2001b580:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
2001b584:	d012      	beq.n	2001b5ac <HAL_RCCEx_CRSConfig+0x90>
2001b586:	687b      	ldr	r3, [r7, #4]
2001b588:	685b      	ldr	r3, [r3, #4]
2001b58a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2001b58e:	d00d      	beq.n	2001b5ac <HAL_RCCEx_CRSConfig+0x90>
2001b590:	687b      	ldr	r3, [r7, #4]
2001b592:	685b      	ldr	r3, [r3, #4]
2001b594:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2001b598:	d008      	beq.n	2001b5ac <HAL_RCCEx_CRSConfig+0x90>
2001b59a:	687b      	ldr	r3, [r7, #4]
2001b59c:	685b      	ldr	r3, [r3, #4]
2001b59e:	2b00      	cmp	r3, #0
2001b5a0:	d004      	beq.n	2001b5ac <HAL_RCCEx_CRSConfig+0x90>
2001b5a2:	f640 314a 	movw	r1, #2890	; 0xb4a
2001b5a6:	483d      	ldr	r0, [pc, #244]	; (2001b69c <HAL_RCCEx_CRSConfig+0x180>)
2001b5a8:	f7e5 f9a4 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_CRS_SYNC_POLARITY(pInit->Polarity));
2001b5ac:	687b      	ldr	r3, [r7, #4]
2001b5ae:	689b      	ldr	r3, [r3, #8]
2001b5b0:	2b00      	cmp	r3, #0
2001b5b2:	d009      	beq.n	2001b5c8 <HAL_RCCEx_CRSConfig+0xac>
2001b5b4:	687b      	ldr	r3, [r7, #4]
2001b5b6:	689b      	ldr	r3, [r3, #8]
2001b5b8:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
2001b5bc:	d004      	beq.n	2001b5c8 <HAL_RCCEx_CRSConfig+0xac>
2001b5be:	f640 314b 	movw	r1, #2891	; 0xb4b
2001b5c2:	4836      	ldr	r0, [pc, #216]	; (2001b69c <HAL_RCCEx_CRSConfig+0x180>)
2001b5c4:	f7e5 f996 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_CRS_RELOADVALUE(pInit->ReloadValue));
2001b5c8:	687b      	ldr	r3, [r7, #4]
2001b5ca:	68db      	ldr	r3, [r3, #12]
2001b5cc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2001b5d0:	d304      	bcc.n	2001b5dc <HAL_RCCEx_CRSConfig+0xc0>
2001b5d2:	f640 314c 	movw	r1, #2892	; 0xb4c
2001b5d6:	4831      	ldr	r0, [pc, #196]	; (2001b69c <HAL_RCCEx_CRSConfig+0x180>)
2001b5d8:	f7e5 f98c 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_CRS_ERRORLIMIT(pInit->ErrorLimitValue));
2001b5dc:	687b      	ldr	r3, [r7, #4]
2001b5de:	691b      	ldr	r3, [r3, #16]
2001b5e0:	2bff      	cmp	r3, #255	; 0xff
2001b5e2:	d904      	bls.n	2001b5ee <HAL_RCCEx_CRSConfig+0xd2>
2001b5e4:	f640 314d 	movw	r1, #2893	; 0xb4d
2001b5e8:	482c      	ldr	r0, [pc, #176]	; (2001b69c <HAL_RCCEx_CRSConfig+0x180>)
2001b5ea:	f7e5 f983 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));
2001b5ee:	687b      	ldr	r3, [r7, #4]
2001b5f0:	695b      	ldr	r3, [r3, #20]
2001b5f2:	2b3f      	cmp	r3, #63	; 0x3f
2001b5f4:	d904      	bls.n	2001b600 <HAL_RCCEx_CRSConfig+0xe4>
2001b5f6:	f640 314e 	movw	r1, #2894	; 0xb4e
2001b5fa:	4828      	ldr	r0, [pc, #160]	; (2001b69c <HAL_RCCEx_CRSConfig+0x180>)
2001b5fc:	f7e5 f97a 	bl	200008f4 <assert_failed>

  /* CONFIGURATION */

  /* Before configuration, reset CRS registers to their default values*/
  __HAL_RCC_CRS_FORCE_RESET();
2001b600:	4b27      	ldr	r3, [pc, #156]	; (2001b6a0 <HAL_RCCEx_CRSConfig+0x184>)
2001b602:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
2001b606:	4a26      	ldr	r2, [pc, #152]	; (2001b6a0 <HAL_RCCEx_CRSConfig+0x184>)
2001b608:	f043 0302 	orr.w	r3, r3, #2
2001b60c:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  __HAL_RCC_CRS_RELEASE_RESET();
2001b610:	4b23      	ldr	r3, [pc, #140]	; (2001b6a0 <HAL_RCCEx_CRSConfig+0x184>)
2001b612:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
2001b616:	4a22      	ldr	r2, [pc, #136]	; (2001b6a0 <HAL_RCCEx_CRSConfig+0x184>)
2001b618:	f023 0302 	bic.w	r3, r3, #2
2001b61c:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

  /* Set the SYNCDIV[2:0] bits according to Pre-scaler value */
  /* Set the SYNCSRC[1:0] bits according to Source value */
  /* Set the SYNCSPOL bit according to Polarity value */
  if ((HAL_GetREVID() <= REV_ID_Y) && (pInit->Source == RCC_CRS_SYNC_SOURCE_USB2))
2001b620:	f7e6 fc0c 	bl	20001e3c <HAL_GetREVID>
2001b624:	4602      	mov	r2, r0
2001b626:	f241 0303 	movw	r3, #4099	; 0x1003
2001b62a:	429a      	cmp	r2, r3
2001b62c:	d80b      	bhi.n	2001b646 <HAL_RCCEx_CRSConfig+0x12a>
2001b62e:	687b      	ldr	r3, [r7, #4]
2001b630:	685b      	ldr	r3, [r3, #4]
2001b632:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
2001b636:	d106      	bne.n	2001b646 <HAL_RCCEx_CRSConfig+0x12a>
  {
    /* Use Rev.Y value of USB2 */
    value = (pInit->Prescaler | RCC_CRS_SYNC_SOURCE_PIN | pInit->Polarity);
2001b638:	687b      	ldr	r3, [r7, #4]
2001b63a:	681a      	ldr	r2, [r3, #0]
2001b63c:	687b      	ldr	r3, [r7, #4]
2001b63e:	689b      	ldr	r3, [r3, #8]
2001b640:	4313      	orrs	r3, r2
2001b642:	60fb      	str	r3, [r7, #12]
2001b644:	e008      	b.n	2001b658 <HAL_RCCEx_CRSConfig+0x13c>
  }
  else
  {
    value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
2001b646:	687b      	ldr	r3, [r7, #4]
2001b648:	681a      	ldr	r2, [r3, #0]
2001b64a:	687b      	ldr	r3, [r7, #4]
2001b64c:	685b      	ldr	r3, [r3, #4]
2001b64e:	431a      	orrs	r2, r3
2001b650:	687b      	ldr	r3, [r7, #4]
2001b652:	689b      	ldr	r3, [r3, #8]
2001b654:	4313      	orrs	r3, r2
2001b656:	60fb      	str	r3, [r7, #12]
  }
  /* Set the RELOAD[15:0] bits according to ReloadValue value */
  value |= pInit->ReloadValue;
2001b658:	687b      	ldr	r3, [r7, #4]
2001b65a:	68db      	ldr	r3, [r3, #12]
2001b65c:	68fa      	ldr	r2, [r7, #12]
2001b65e:	4313      	orrs	r3, r2
2001b660:	60fb      	str	r3, [r7, #12]
  /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
2001b662:	687b      	ldr	r3, [r7, #4]
2001b664:	691b      	ldr	r3, [r3, #16]
2001b666:	041b      	lsls	r3, r3, #16
2001b668:	68fa      	ldr	r2, [r7, #12]
2001b66a:	4313      	orrs	r3, r2
2001b66c:	60fb      	str	r3, [r7, #12]
  WRITE_REG(CRS->CFGR, value);
2001b66e:	4a0d      	ldr	r2, [pc, #52]	; (2001b6a4 <HAL_RCCEx_CRSConfig+0x188>)
2001b670:	68fb      	ldr	r3, [r7, #12]
2001b672:	6053      	str	r3, [r2, #4]

  /* Adjust HSI48 oscillator smooth trimming */
  /* Set the TRIM[5:0] bits according to RCC_CRS_HSI48CalibrationValue value */
  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
2001b674:	4b0b      	ldr	r3, [pc, #44]	; (2001b6a4 <HAL_RCCEx_CRSConfig+0x188>)
2001b676:	681b      	ldr	r3, [r3, #0]
2001b678:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
2001b67c:	687b      	ldr	r3, [r7, #4]
2001b67e:	695b      	ldr	r3, [r3, #20]
2001b680:	021b      	lsls	r3, r3, #8
2001b682:	4908      	ldr	r1, [pc, #32]	; (2001b6a4 <HAL_RCCEx_CRSConfig+0x188>)
2001b684:	4313      	orrs	r3, r2
2001b686:	600b      	str	r3, [r1, #0]

  /* START AUTOMATIC SYNCHRONIZATION*/

  /* Enable Automatic trimming & Frequency error counter */
  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
2001b688:	4b06      	ldr	r3, [pc, #24]	; (2001b6a4 <HAL_RCCEx_CRSConfig+0x188>)
2001b68a:	681b      	ldr	r3, [r3, #0]
2001b68c:	4a05      	ldr	r2, [pc, #20]	; (2001b6a4 <HAL_RCCEx_CRSConfig+0x188>)
2001b68e:	f043 0360 	orr.w	r3, r3, #96	; 0x60
2001b692:	6013      	str	r3, [r2, #0]
}
2001b694:	bf00      	nop
2001b696:	3710      	adds	r7, #16
2001b698:	46bd      	mov	sp, r7
2001b69a:	bd80      	pop	{r7, pc}
2001b69c:	2001c318 	.word	0x2001c318
2001b6a0:	58024400 	.word	0x58024400
2001b6a4:	40008400 	.word	0x40008400

2001b6a8 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate>:
/**
  * @brief  Generate the software synchronization event
  * @retval None
  */
void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
{
2001b6a8:	b480      	push	{r7}
2001b6aa:	af00      	add	r7, sp, #0
  SET_BIT(CRS->CR, CRS_CR_SWSYNC);
2001b6ac:	4b05      	ldr	r3, [pc, #20]	; (2001b6c4 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
2001b6ae:	681b      	ldr	r3, [r3, #0]
2001b6b0:	4a04      	ldr	r2, [pc, #16]	; (2001b6c4 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
2001b6b2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
2001b6b6:	6013      	str	r3, [r2, #0]
}
2001b6b8:	bf00      	nop
2001b6ba:	46bd      	mov	sp, r7
2001b6bc:	f85d 7b04 	ldr.w	r7, [sp], #4
2001b6c0:	4770      	bx	lr
2001b6c2:	bf00      	nop
2001b6c4:	40008400 	.word	0x40008400

2001b6c8 <HAL_RCCEx_CRSGetSynchronizationInfo>:
  * @brief  Return synchronization info
  * @param  pSynchroInfo Pointer on RCC_CRSSynchroInfoTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo)
{
2001b6c8:	b580      	push	{r7, lr}
2001b6ca:	b082      	sub	sp, #8
2001b6cc:	af00      	add	r7, sp, #0
2001b6ce:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(pSynchroInfo != (void *)NULL);
2001b6d0:	687b      	ldr	r3, [r7, #4]
2001b6d2:	2b00      	cmp	r3, #0
2001b6d4:	d104      	bne.n	2001b6e0 <HAL_RCCEx_CRSGetSynchronizationInfo+0x18>
2001b6d6:	f640 3183 	movw	r1, #2947	; 0xb83
2001b6da:	480f      	ldr	r0, [pc, #60]	; (2001b718 <HAL_RCCEx_CRSGetSynchronizationInfo+0x50>)
2001b6dc:	f7e5 f90a 	bl	200008f4 <assert_failed>

  /* Get the reload value */
  pSynchroInfo->ReloadValue = (uint32_t)(READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
2001b6e0:	4b0e      	ldr	r3, [pc, #56]	; (2001b71c <HAL_RCCEx_CRSGetSynchronizationInfo+0x54>)
2001b6e2:	685b      	ldr	r3, [r3, #4]
2001b6e4:	b29a      	uxth	r2, r3
2001b6e6:	687b      	ldr	r3, [r7, #4]
2001b6e8:	601a      	str	r2, [r3, #0]

  /* Get HSI48 oscillator smooth trimming */
  pSynchroInfo->HSI48CalibrationValue = (uint32_t)(READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
2001b6ea:	4b0c      	ldr	r3, [pc, #48]	; (2001b71c <HAL_RCCEx_CRSGetSynchronizationInfo+0x54>)
2001b6ec:	681b      	ldr	r3, [r3, #0]
2001b6ee:	0a1b      	lsrs	r3, r3, #8
2001b6f0:	f003 023f 	and.w	r2, r3, #63	; 0x3f
2001b6f4:	687b      	ldr	r3, [r7, #4]
2001b6f6:	605a      	str	r2, [r3, #4]

  /* Get Frequency error capture */
  pSynchroInfo->FreqErrorCapture = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
2001b6f8:	4b08      	ldr	r3, [pc, #32]	; (2001b71c <HAL_RCCEx_CRSGetSynchronizationInfo+0x54>)
2001b6fa:	689b      	ldr	r3, [r3, #8]
2001b6fc:	0c1b      	lsrs	r3, r3, #16
2001b6fe:	b29a      	uxth	r2, r3
2001b700:	687b      	ldr	r3, [r7, #4]
2001b702:	609a      	str	r2, [r3, #8]

  /* Get Frequency error direction */
  pSynchroInfo->FreqErrorDirection = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
2001b704:	4b05      	ldr	r3, [pc, #20]	; (2001b71c <HAL_RCCEx_CRSGetSynchronizationInfo+0x54>)
2001b706:	689b      	ldr	r3, [r3, #8]
2001b708:	f403 4200 	and.w	r2, r3, #32768	; 0x8000
2001b70c:	687b      	ldr	r3, [r7, #4]
2001b70e:	60da      	str	r2, [r3, #12]
}
2001b710:	bf00      	nop
2001b712:	3708      	adds	r7, #8
2001b714:	46bd      	mov	sp, r7
2001b716:	bd80      	pop	{r7, pc}
2001b718:	2001c318 	.word	0x2001c318
2001b71c:	40008400 	.word	0x40008400

2001b720 <HAL_RCCEx_CRSWaitSynchronization>:
*            @arg @ref RCC_CRS_SYNCERR
*            @arg @ref RCC_CRS_SYNCMISS
*            @arg @ref RCC_CRS_TRIMOVF
*/
uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
{
2001b720:	b580      	push	{r7, lr}
2001b722:	b084      	sub	sp, #16
2001b724:	af00      	add	r7, sp, #0
2001b726:	6078      	str	r0, [r7, #4]
  uint32_t crsstatus = RCC_CRS_NONE;
2001b728:	2300      	movs	r3, #0
2001b72a:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart;

  /* Get time-out */
  tickstart = HAL_GetTick();
2001b72c:	f7e6 fade 	bl	20001cec <HAL_GetTick>
2001b730:	60b8      	str	r0, [r7, #8]

  /* Wait for CRS flag or time-out detection */
  do
  {
    if(Timeout != HAL_MAX_DELAY)
2001b732:	687b      	ldr	r3, [r7, #4]
2001b734:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
2001b738:	d00c      	beq.n	2001b754 <HAL_RCCEx_CRSWaitSynchronization+0x34>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2001b73a:	f7e6 fad7 	bl	20001cec <HAL_GetTick>
2001b73e:	4602      	mov	r2, r0
2001b740:	68bb      	ldr	r3, [r7, #8]
2001b742:	1ad3      	subs	r3, r2, r3
2001b744:	687a      	ldr	r2, [r7, #4]
2001b746:	429a      	cmp	r2, r3
2001b748:	d302      	bcc.n	2001b750 <HAL_RCCEx_CRSWaitSynchronization+0x30>
2001b74a:	687b      	ldr	r3, [r7, #4]
2001b74c:	2b00      	cmp	r3, #0
2001b74e:	d101      	bne.n	2001b754 <HAL_RCCEx_CRSWaitSynchronization+0x34>
      {
        crsstatus = RCC_CRS_TIMEOUT;
2001b750:	2301      	movs	r3, #1
2001b752:	60fb      	str	r3, [r7, #12]
      }
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
2001b754:	4b2a      	ldr	r3, [pc, #168]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b756:	689b      	ldr	r3, [r3, #8]
2001b758:	f003 0301 	and.w	r3, r3, #1
2001b75c:	2b01      	cmp	r3, #1
2001b75e:	d106      	bne.n	2001b76e <HAL_RCCEx_CRSWaitSynchronization+0x4e>
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;
2001b760:	68fb      	ldr	r3, [r7, #12]
2001b762:	f043 0302 	orr.w	r3, r3, #2
2001b766:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
2001b768:	4b25      	ldr	r3, [pc, #148]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b76a:	2201      	movs	r2, #1
2001b76c:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
2001b76e:	4b24      	ldr	r3, [pc, #144]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b770:	689b      	ldr	r3, [r3, #8]
2001b772:	f003 0302 	and.w	r3, r3, #2
2001b776:	2b02      	cmp	r3, #2
2001b778:	d106      	bne.n	2001b788 <HAL_RCCEx_CRSWaitSynchronization+0x68>
    {
      /* CRS SYNC warning */
      crsstatus |= RCC_CRS_SYNCWARN;
2001b77a:	68fb      	ldr	r3, [r7, #12]
2001b77c:	f043 0304 	orr.w	r3, r3, #4
2001b780:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNCWARN bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
2001b782:	4b1f      	ldr	r3, [pc, #124]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b784:	2202      	movs	r2, #2
2001b786:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
2001b788:	4b1d      	ldr	r3, [pc, #116]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b78a:	689b      	ldr	r3, [r3, #8]
2001b78c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2001b790:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2001b794:	d106      	bne.n	2001b7a4 <HAL_RCCEx_CRSWaitSynchronization+0x84>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_TRIMOVF;
2001b796:	68fb      	ldr	r3, [r7, #12]
2001b798:	f043 0320 	orr.w	r3, r3, #32
2001b79c:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
2001b79e:	4b18      	ldr	r3, [pc, #96]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b7a0:	2204      	movs	r2, #4
2001b7a2:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
2001b7a4:	4b16      	ldr	r3, [pc, #88]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b7a6:	689b      	ldr	r3, [r3, #8]
2001b7a8:	f403 7380 	and.w	r3, r3, #256	; 0x100
2001b7ac:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2001b7b0:	d106      	bne.n	2001b7c0 <HAL_RCCEx_CRSWaitSynchronization+0xa0>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_SYNCERR;
2001b7b2:	68fb      	ldr	r3, [r7, #12]
2001b7b4:	f043 0308 	orr.w	r3, r3, #8
2001b7b8:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
2001b7ba:	4b11      	ldr	r3, [pc, #68]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b7bc:	2204      	movs	r2, #4
2001b7be:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
2001b7c0:	4b0f      	ldr	r3, [pc, #60]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b7c2:	689b      	ldr	r3, [r3, #8]
2001b7c4:	f403 7300 	and.w	r3, r3, #512	; 0x200
2001b7c8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2001b7cc:	d106      	bne.n	2001b7dc <HAL_RCCEx_CRSWaitSynchronization+0xbc>
    {
      /* CRS SYNC Missed */
      crsstatus |= RCC_CRS_SYNCMISS;
2001b7ce:	68fb      	ldr	r3, [r7, #12]
2001b7d0:	f043 0310 	orr.w	r3, r3, #16
2001b7d4:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC Missed bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
2001b7d6:	4b0a      	ldr	r3, [pc, #40]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b7d8:	2204      	movs	r2, #4
2001b7da:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Expected SYNC flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
2001b7dc:	4b08      	ldr	r3, [pc, #32]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b7de:	689b      	ldr	r3, [r3, #8]
2001b7e0:	f003 0308 	and.w	r3, r3, #8
2001b7e4:	2b08      	cmp	r3, #8
2001b7e6:	d102      	bne.n	2001b7ee <HAL_RCCEx_CRSWaitSynchronization+0xce>
    {
      /* frequency error counter reached a zero value */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
2001b7e8:	4b05      	ldr	r3, [pc, #20]	; (2001b800 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2001b7ea:	2208      	movs	r2, #8
2001b7ec:	60da      	str	r2, [r3, #12]
    }
  } while(RCC_CRS_NONE == crsstatus);
2001b7ee:	68fb      	ldr	r3, [r7, #12]
2001b7f0:	2b00      	cmp	r3, #0
2001b7f2:	d09e      	beq.n	2001b732 <HAL_RCCEx_CRSWaitSynchronization+0x12>

  return crsstatus;
2001b7f4:	68fb      	ldr	r3, [r7, #12]
}
2001b7f6:	4618      	mov	r0, r3
2001b7f8:	3710      	adds	r7, #16
2001b7fa:	46bd      	mov	sp, r7
2001b7fc:	bd80      	pop	{r7, pc}
2001b7fe:	bf00      	nop
2001b800:	40008400 	.word	0x40008400

2001b804 <HAL_RCCEx_CRS_IRQHandler>:
/**
  * @brief Handle the Clock Recovery System interrupt request.
  * @retval None
  */
void HAL_RCCEx_CRS_IRQHandler(void)
{
2001b804:	b580      	push	{r7, lr}
2001b806:	b084      	sub	sp, #16
2001b808:	af00      	add	r7, sp, #0
  uint32_t crserror = RCC_CRS_NONE;
2001b80a:	2300      	movs	r3, #0
2001b80c:	60fb      	str	r3, [r7, #12]
  /* Get current IT flags and IT sources values */
  uint32_t itflags = READ_REG(CRS->ISR);
2001b80e:	4b33      	ldr	r3, [pc, #204]	; (2001b8dc <HAL_RCCEx_CRS_IRQHandler+0xd8>)
2001b810:	689b      	ldr	r3, [r3, #8]
2001b812:	60bb      	str	r3, [r7, #8]
  uint32_t itsources = READ_REG(CRS->CR);
2001b814:	4b31      	ldr	r3, [pc, #196]	; (2001b8dc <HAL_RCCEx_CRS_IRQHandler+0xd8>)
2001b816:	681b      	ldr	r3, [r3, #0]
2001b818:	607b      	str	r3, [r7, #4]

  /* Check CRS SYNCOK flag  */
  if(((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
2001b81a:	68bb      	ldr	r3, [r7, #8]
2001b81c:	f003 0301 	and.w	r3, r3, #1
2001b820:	2b00      	cmp	r3, #0
2001b822:	d00a      	beq.n	2001b83a <HAL_RCCEx_CRS_IRQHandler+0x36>
2001b824:	687b      	ldr	r3, [r7, #4]
2001b826:	f003 0301 	and.w	r3, r3, #1
2001b82a:	2b00      	cmp	r3, #0
2001b82c:	d005      	beq.n	2001b83a <HAL_RCCEx_CRS_IRQHandler+0x36>
  {
    /* Clear CRS SYNC event OK flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
2001b82e:	4b2b      	ldr	r3, [pc, #172]	; (2001b8dc <HAL_RCCEx_CRS_IRQHandler+0xd8>)
2001b830:	2201      	movs	r2, #1
2001b832:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncOkCallback();
2001b834:	f000 f854 	bl	2001b8e0 <HAL_RCCEx_CRS_SyncOkCallback>
2001b838:	e04b      	b.n	2001b8d2 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS SYNCWARN flag  */
  else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
2001b83a:	68bb      	ldr	r3, [r7, #8]
2001b83c:	f003 0302 	and.w	r3, r3, #2
2001b840:	2b00      	cmp	r3, #0
2001b842:	d00a      	beq.n	2001b85a <HAL_RCCEx_CRS_IRQHandler+0x56>
2001b844:	687b      	ldr	r3, [r7, #4]
2001b846:	f003 0302 	and.w	r3, r3, #2
2001b84a:	2b00      	cmp	r3, #0
2001b84c:	d005      	beq.n	2001b85a <HAL_RCCEx_CRS_IRQHandler+0x56>
  {
    /* Clear CRS SYNCWARN flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
2001b84e:	4b23      	ldr	r3, [pc, #140]	; (2001b8dc <HAL_RCCEx_CRS_IRQHandler+0xd8>)
2001b850:	2202      	movs	r2, #2
2001b852:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncWarnCallback();
2001b854:	f000 f84b 	bl	2001b8ee <HAL_RCCEx_CRS_SyncWarnCallback>
2001b858:	e03b      	b.n	2001b8d2 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Expected SYNC flag  */
  else if(((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
2001b85a:	68bb      	ldr	r3, [r7, #8]
2001b85c:	f003 0308 	and.w	r3, r3, #8
2001b860:	2b00      	cmp	r3, #0
2001b862:	d00a      	beq.n	2001b87a <HAL_RCCEx_CRS_IRQHandler+0x76>
2001b864:	687b      	ldr	r3, [r7, #4]
2001b866:	f003 0308 	and.w	r3, r3, #8
2001b86a:	2b00      	cmp	r3, #0
2001b86c:	d005      	beq.n	2001b87a <HAL_RCCEx_CRS_IRQHandler+0x76>
  {
    /* frequency error counter reached a zero value */
    WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
2001b86e:	4b1b      	ldr	r3, [pc, #108]	; (2001b8dc <HAL_RCCEx_CRS_IRQHandler+0xd8>)
2001b870:	2208      	movs	r2, #8
2001b872:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_ExpectedSyncCallback();
2001b874:	f000 f842 	bl	2001b8fc <HAL_RCCEx_CRS_ExpectedSyncCallback>
2001b878:	e02b      	b.n	2001b8d2 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Error flags  */
  else
  {
    if(((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
2001b87a:	68bb      	ldr	r3, [r7, #8]
2001b87c:	f003 0304 	and.w	r3, r3, #4
2001b880:	2b00      	cmp	r3, #0
2001b882:	d026      	beq.n	2001b8d2 <HAL_RCCEx_CRS_IRQHandler+0xce>
2001b884:	687b      	ldr	r3, [r7, #4]
2001b886:	f003 0304 	and.w	r3, r3, #4
2001b88a:	2b00      	cmp	r3, #0
2001b88c:	d021      	beq.n	2001b8d2 <HAL_RCCEx_CRS_IRQHandler+0xce>
    {
      if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
2001b88e:	68bb      	ldr	r3, [r7, #8]
2001b890:	f403 7380 	and.w	r3, r3, #256	; 0x100
2001b894:	2b00      	cmp	r3, #0
2001b896:	d003      	beq.n	2001b8a0 <HAL_RCCEx_CRS_IRQHandler+0x9c>
      {
        crserror |= RCC_CRS_SYNCERR;
2001b898:	68fb      	ldr	r3, [r7, #12]
2001b89a:	f043 0308 	orr.w	r3, r3, #8
2001b89e:	60fb      	str	r3, [r7, #12]
      }
      if((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
2001b8a0:	68bb      	ldr	r3, [r7, #8]
2001b8a2:	f403 7300 	and.w	r3, r3, #512	; 0x200
2001b8a6:	2b00      	cmp	r3, #0
2001b8a8:	d003      	beq.n	2001b8b2 <HAL_RCCEx_CRS_IRQHandler+0xae>
      {
        crserror |= RCC_CRS_SYNCMISS;
2001b8aa:	68fb      	ldr	r3, [r7, #12]
2001b8ac:	f043 0310 	orr.w	r3, r3, #16
2001b8b0:	60fb      	str	r3, [r7, #12]
      }
      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
2001b8b2:	68bb      	ldr	r3, [r7, #8]
2001b8b4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2001b8b8:	2b00      	cmp	r3, #0
2001b8ba:	d003      	beq.n	2001b8c4 <HAL_RCCEx_CRS_IRQHandler+0xc0>
      {
        crserror |= RCC_CRS_TRIMOVF;
2001b8bc:	68fb      	ldr	r3, [r7, #12]
2001b8be:	f043 0320 	orr.w	r3, r3, #32
2001b8c2:	60fb      	str	r3, [r7, #12]
      }

      /* Clear CRS Error flags */
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
2001b8c4:	4b05      	ldr	r3, [pc, #20]	; (2001b8dc <HAL_RCCEx_CRS_IRQHandler+0xd8>)
2001b8c6:	2204      	movs	r2, #4
2001b8c8:	60da      	str	r2, [r3, #12]

      /* user error callback */
      HAL_RCCEx_CRS_ErrorCallback(crserror);
2001b8ca:	68f8      	ldr	r0, [r7, #12]
2001b8cc:	f000 f81d 	bl	2001b90a <HAL_RCCEx_CRS_ErrorCallback>
    }
  }
}
2001b8d0:	e7ff      	b.n	2001b8d2 <HAL_RCCEx_CRS_IRQHandler+0xce>
2001b8d2:	bf00      	nop
2001b8d4:	3710      	adds	r7, #16
2001b8d6:	46bd      	mov	sp, r7
2001b8d8:	bd80      	pop	{r7, pc}
2001b8da:	bf00      	nop
2001b8dc:	40008400 	.word	0x40008400

2001b8e0 <HAL_RCCEx_CRS_SyncOkCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCOK interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncOkCallback(void)
{
2001b8e0:	b480      	push	{r7}
2001b8e2:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncOkCallback should be implemented in the user file
   */
}
2001b8e4:	bf00      	nop
2001b8e6:	46bd      	mov	sp, r7
2001b8e8:	f85d 7b04 	ldr.w	r7, [sp], #4
2001b8ec:	4770      	bx	lr

2001b8ee <HAL_RCCEx_CRS_SyncWarnCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCWARN interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncWarnCallback(void)
{
2001b8ee:	b480      	push	{r7}
2001b8f0:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncWarnCallback should be implemented in the user file
   */
}
2001b8f2:	bf00      	nop
2001b8f4:	46bd      	mov	sp, r7
2001b8f6:	f85d 7b04 	ldr.w	r7, [sp], #4
2001b8fa:	4770      	bx	lr

2001b8fc <HAL_RCCEx_CRS_ExpectedSyncCallback>:
/**
  * @brief  RCCEx Clock Recovery System Expected SYNC interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
{
2001b8fc:	b480      	push	{r7}
2001b8fe:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ExpectedSyncCallback should be implemented in the user file
   */
}
2001b900:	bf00      	nop
2001b902:	46bd      	mov	sp, r7
2001b904:	f85d 7b04 	ldr.w	r7, [sp], #4
2001b908:	4770      	bx	lr

2001b90a <HAL_RCCEx_CRS_ErrorCallback>:
  *           @arg @ref RCC_CRS_SYNCMISS
  *           @arg @ref RCC_CRS_TRIMOVF
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
{
2001b90a:	b480      	push	{r7}
2001b90c:	b083      	sub	sp, #12
2001b90e:	af00      	add	r7, sp, #0
2001b910:	6078      	str	r0, [r7, #4]
  UNUSED(Error);

  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ErrorCallback should be implemented in the user file
   */
}
2001b912:	bf00      	nop
2001b914:	370c      	adds	r7, #12
2001b916:	46bd      	mov	sp, r7
2001b918:	f85d 7b04 	ldr.w	r7, [sp], #4
2001b91c:	4770      	bx	lr
	...

2001b920 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
2001b920:	b580      	push	{r7, lr}
2001b922:	b084      	sub	sp, #16
2001b924:	af00      	add	r7, sp, #0
2001b926:	6078      	str	r0, [r7, #4]
2001b928:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
2001b92a:	2300      	movs	r3, #0
2001b92c:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
2001b92e:	687b      	ldr	r3, [r7, #4]
2001b930:	681b      	ldr	r3, [r3, #0]
2001b932:	2b00      	cmp	r3, #0
2001b934:	d003      	beq.n	2001b93e <RCCEx_PLL2_Config+0x1e>
2001b936:	687b      	ldr	r3, [r7, #4]
2001b938:	681b      	ldr	r3, [r3, #0]
2001b93a:	2b3f      	cmp	r3, #63	; 0x3f
2001b93c:	d904      	bls.n	2001b948 <RCCEx_PLL2_Config+0x28>
2001b93e:	f640 417f 	movw	r1, #3199	; 0xc7f
2001b942:	4885      	ldr	r0, [pc, #532]	; (2001bb58 <RCCEx_PLL2_Config+0x238>)
2001b944:	f7e4 ffd6 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
2001b948:	687b      	ldr	r3, [r7, #4]
2001b94a:	685b      	ldr	r3, [r3, #4]
2001b94c:	2b03      	cmp	r3, #3
2001b94e:	d904      	bls.n	2001b95a <RCCEx_PLL2_Config+0x3a>
2001b950:	687b      	ldr	r3, [r7, #4]
2001b952:	685b      	ldr	r3, [r3, #4]
2001b954:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2001b958:	d904      	bls.n	2001b964 <RCCEx_PLL2_Config+0x44>
2001b95a:	f44f 6148 	mov.w	r1, #3200	; 0xc80
2001b95e:	487e      	ldr	r0, [pc, #504]	; (2001bb58 <RCCEx_PLL2_Config+0x238>)
2001b960:	f7e4 ffc8 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
2001b964:	687b      	ldr	r3, [r7, #4]
2001b966:	689b      	ldr	r3, [r3, #8]
2001b968:	2b00      	cmp	r3, #0
2001b96a:	d003      	beq.n	2001b974 <RCCEx_PLL2_Config+0x54>
2001b96c:	687b      	ldr	r3, [r7, #4]
2001b96e:	689b      	ldr	r3, [r3, #8]
2001b970:	2b80      	cmp	r3, #128	; 0x80
2001b972:	d904      	bls.n	2001b97e <RCCEx_PLL2_Config+0x5e>
2001b974:	f640 4181 	movw	r1, #3201	; 0xc81
2001b978:	4877      	ldr	r0, [pc, #476]	; (2001bb58 <RCCEx_PLL2_Config+0x238>)
2001b97a:	f7e4 ffbb 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
2001b97e:	687b      	ldr	r3, [r7, #4]
2001b980:	691b      	ldr	r3, [r3, #16]
2001b982:	2b00      	cmp	r3, #0
2001b984:	d003      	beq.n	2001b98e <RCCEx_PLL2_Config+0x6e>
2001b986:	687b      	ldr	r3, [r7, #4]
2001b988:	691b      	ldr	r3, [r3, #16]
2001b98a:	2b80      	cmp	r3, #128	; 0x80
2001b98c:	d904      	bls.n	2001b998 <RCCEx_PLL2_Config+0x78>
2001b98e:	f640 4182 	movw	r1, #3202	; 0xc82
2001b992:	4871      	ldr	r0, [pc, #452]	; (2001bb58 <RCCEx_PLL2_Config+0x238>)
2001b994:	f7e4 ffae 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
2001b998:	687b      	ldr	r3, [r7, #4]
2001b99a:	68db      	ldr	r3, [r3, #12]
2001b99c:	2b00      	cmp	r3, #0
2001b99e:	d003      	beq.n	2001b9a8 <RCCEx_PLL2_Config+0x88>
2001b9a0:	687b      	ldr	r3, [r7, #4]
2001b9a2:	68db      	ldr	r3, [r3, #12]
2001b9a4:	2b80      	cmp	r3, #128	; 0x80
2001b9a6:	d904      	bls.n	2001b9b2 <RCCEx_PLL2_Config+0x92>
2001b9a8:	f640 4183 	movw	r1, #3203	; 0xc83
2001b9ac:	486a      	ldr	r0, [pc, #424]	; (2001bb58 <RCCEx_PLL2_Config+0x238>)
2001b9ae:	f7e4 ffa1 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
2001b9b2:	687b      	ldr	r3, [r7, #4]
2001b9b4:	695b      	ldr	r3, [r3, #20]
2001b9b6:	2b00      	cmp	r3, #0
2001b9b8:	d010      	beq.n	2001b9dc <RCCEx_PLL2_Config+0xbc>
2001b9ba:	687b      	ldr	r3, [r7, #4]
2001b9bc:	695b      	ldr	r3, [r3, #20]
2001b9be:	2b40      	cmp	r3, #64	; 0x40
2001b9c0:	d00c      	beq.n	2001b9dc <RCCEx_PLL2_Config+0xbc>
2001b9c2:	687b      	ldr	r3, [r7, #4]
2001b9c4:	695b      	ldr	r3, [r3, #20]
2001b9c6:	2b80      	cmp	r3, #128	; 0x80
2001b9c8:	d008      	beq.n	2001b9dc <RCCEx_PLL2_Config+0xbc>
2001b9ca:	687b      	ldr	r3, [r7, #4]
2001b9cc:	695b      	ldr	r3, [r3, #20]
2001b9ce:	2bc0      	cmp	r3, #192	; 0xc0
2001b9d0:	d004      	beq.n	2001b9dc <RCCEx_PLL2_Config+0xbc>
2001b9d2:	f640 4184 	movw	r1, #3204	; 0xc84
2001b9d6:	4860      	ldr	r0, [pc, #384]	; (2001bb58 <RCCEx_PLL2_Config+0x238>)
2001b9d8:	f7e4 ff8c 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
2001b9dc:	687b      	ldr	r3, [r7, #4]
2001b9de:	699b      	ldr	r3, [r3, #24]
2001b9e0:	2b00      	cmp	r3, #0
2001b9e2:	d008      	beq.n	2001b9f6 <RCCEx_PLL2_Config+0xd6>
2001b9e4:	687b      	ldr	r3, [r7, #4]
2001b9e6:	699b      	ldr	r3, [r3, #24]
2001b9e8:	2b20      	cmp	r3, #32
2001b9ea:	d004      	beq.n	2001b9f6 <RCCEx_PLL2_Config+0xd6>
2001b9ec:	f640 4185 	movw	r1, #3205	; 0xc85
2001b9f0:	4859      	ldr	r0, [pc, #356]	; (2001bb58 <RCCEx_PLL2_Config+0x238>)
2001b9f2:	f7e4 ff7f 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
2001b9f6:	687b      	ldr	r3, [r7, #4]
2001b9f8:	69db      	ldr	r3, [r3, #28]
2001b9fa:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2001b9fe:	d304      	bcc.n	2001ba0a <RCCEx_PLL2_Config+0xea>
2001ba00:	f640 4186 	movw	r1, #3206	; 0xc86
2001ba04:	4854      	ldr	r0, [pc, #336]	; (2001bb58 <RCCEx_PLL2_Config+0x238>)
2001ba06:	f7e4 ff75 	bl	200008f4 <assert_failed>

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
2001ba0a:	4b54      	ldr	r3, [pc, #336]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001ba0c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001ba0e:	f003 0303 	and.w	r3, r3, #3
2001ba12:	2b03      	cmp	r3, #3
2001ba14:	d101      	bne.n	2001ba1a <RCCEx_PLL2_Config+0xfa>
  {
    return HAL_ERROR;
2001ba16:	2301      	movs	r3, #1
2001ba18:	e099      	b.n	2001bb4e <RCCEx_PLL2_Config+0x22e>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
2001ba1a:	4b50      	ldr	r3, [pc, #320]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001ba1c:	681b      	ldr	r3, [r3, #0]
2001ba1e:	4a4f      	ldr	r2, [pc, #316]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001ba20:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
2001ba24:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2001ba26:	f7e6 f961 	bl	20001cec <HAL_GetTick>
2001ba2a:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
2001ba2c:	e008      	b.n	2001ba40 <RCCEx_PLL2_Config+0x120>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
2001ba2e:	f7e6 f95d 	bl	20001cec <HAL_GetTick>
2001ba32:	4602      	mov	r2, r0
2001ba34:	68bb      	ldr	r3, [r7, #8]
2001ba36:	1ad3      	subs	r3, r2, r3
2001ba38:	2b02      	cmp	r3, #2
2001ba3a:	d901      	bls.n	2001ba40 <RCCEx_PLL2_Config+0x120>
      {
        return HAL_TIMEOUT;
2001ba3c:	2303      	movs	r3, #3
2001ba3e:	e086      	b.n	2001bb4e <RCCEx_PLL2_Config+0x22e>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
2001ba40:	4b46      	ldr	r3, [pc, #280]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001ba42:	681b      	ldr	r3, [r3, #0]
2001ba44:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2001ba48:	2b00      	cmp	r3, #0
2001ba4a:	d1f0      	bne.n	2001ba2e <RCCEx_PLL2_Config+0x10e>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
2001ba4c:	4b43      	ldr	r3, [pc, #268]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001ba4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001ba50:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
2001ba54:	687b      	ldr	r3, [r7, #4]
2001ba56:	681b      	ldr	r3, [r3, #0]
2001ba58:	031b      	lsls	r3, r3, #12
2001ba5a:	4940      	ldr	r1, [pc, #256]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001ba5c:	4313      	orrs	r3, r2
2001ba5e:	628b      	str	r3, [r1, #40]	; 0x28
2001ba60:	687b      	ldr	r3, [r7, #4]
2001ba62:	685b      	ldr	r3, [r3, #4]
2001ba64:	3b01      	subs	r3, #1
2001ba66:	f3c3 0208 	ubfx	r2, r3, #0, #9
2001ba6a:	687b      	ldr	r3, [r7, #4]
2001ba6c:	689b      	ldr	r3, [r3, #8]
2001ba6e:	3b01      	subs	r3, #1
2001ba70:	025b      	lsls	r3, r3, #9
2001ba72:	b29b      	uxth	r3, r3
2001ba74:	431a      	orrs	r2, r3
2001ba76:	687b      	ldr	r3, [r7, #4]
2001ba78:	68db      	ldr	r3, [r3, #12]
2001ba7a:	3b01      	subs	r3, #1
2001ba7c:	041b      	lsls	r3, r3, #16
2001ba7e:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
2001ba82:	431a      	orrs	r2, r3
2001ba84:	687b      	ldr	r3, [r7, #4]
2001ba86:	691b      	ldr	r3, [r3, #16]
2001ba88:	3b01      	subs	r3, #1
2001ba8a:	061b      	lsls	r3, r3, #24
2001ba8c:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
2001ba90:	4932      	ldr	r1, [pc, #200]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001ba92:	4313      	orrs	r3, r2
2001ba94:	638b      	str	r3, [r1, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
2001ba96:	4b31      	ldr	r3, [pc, #196]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001ba98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001ba9a:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
2001ba9e:	687b      	ldr	r3, [r7, #4]
2001baa0:	695b      	ldr	r3, [r3, #20]
2001baa2:	492e      	ldr	r1, [pc, #184]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001baa4:	4313      	orrs	r3, r2
2001baa6:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
2001baa8:	4b2c      	ldr	r3, [pc, #176]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001baaa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001baac:	f023 0220 	bic.w	r2, r3, #32
2001bab0:	687b      	ldr	r3, [r7, #4]
2001bab2:	699b      	ldr	r3, [r3, #24]
2001bab4:	4929      	ldr	r1, [pc, #164]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bab6:	4313      	orrs	r3, r2
2001bab8:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
2001baba:	4b28      	ldr	r3, [pc, #160]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001babc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001babe:	4a27      	ldr	r2, [pc, #156]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bac0:	f023 0310 	bic.w	r3, r3, #16
2001bac4:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
2001bac6:	4b25      	ldr	r3, [pc, #148]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bac8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
2001baca:	4b25      	ldr	r3, [pc, #148]	; (2001bb60 <RCCEx_PLL2_Config+0x240>)
2001bacc:	4013      	ands	r3, r2
2001bace:	687a      	ldr	r2, [r7, #4]
2001bad0:	69d2      	ldr	r2, [r2, #28]
2001bad2:	00d2      	lsls	r2, r2, #3
2001bad4:	4921      	ldr	r1, [pc, #132]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bad6:	4313      	orrs	r3, r2
2001bad8:	63cb      	str	r3, [r1, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
2001bada:	4b20      	ldr	r3, [pc, #128]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001badc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001bade:	4a1f      	ldr	r2, [pc, #124]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bae0:	f043 0310 	orr.w	r3, r3, #16
2001bae4:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
2001bae6:	683b      	ldr	r3, [r7, #0]
2001bae8:	2b00      	cmp	r3, #0
2001baea:	d106      	bne.n	2001bafa <RCCEx_PLL2_Config+0x1da>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
2001baec:	4b1b      	ldr	r3, [pc, #108]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001baee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001baf0:	4a1a      	ldr	r2, [pc, #104]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001baf2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
2001baf6:	62d3      	str	r3, [r2, #44]	; 0x2c
2001baf8:	e00f      	b.n	2001bb1a <RCCEx_PLL2_Config+0x1fa>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
2001bafa:	683b      	ldr	r3, [r7, #0]
2001bafc:	2b01      	cmp	r3, #1
2001bafe:	d106      	bne.n	2001bb0e <RCCEx_PLL2_Config+0x1ee>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
2001bb00:	4b16      	ldr	r3, [pc, #88]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bb02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001bb04:	4a15      	ldr	r2, [pc, #84]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bb06:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
2001bb0a:	62d3      	str	r3, [r2, #44]	; 0x2c
2001bb0c:	e005      	b.n	2001bb1a <RCCEx_PLL2_Config+0x1fa>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
2001bb0e:	4b13      	ldr	r3, [pc, #76]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bb10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001bb12:	4a12      	ldr	r2, [pc, #72]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bb14:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
2001bb18:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
2001bb1a:	4b10      	ldr	r3, [pc, #64]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bb1c:	681b      	ldr	r3, [r3, #0]
2001bb1e:	4a0f      	ldr	r2, [pc, #60]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bb20:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
2001bb24:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2001bb26:	f7e6 f8e1 	bl	20001cec <HAL_GetTick>
2001bb2a:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
2001bb2c:	e008      	b.n	2001bb40 <RCCEx_PLL2_Config+0x220>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
2001bb2e:	f7e6 f8dd 	bl	20001cec <HAL_GetTick>
2001bb32:	4602      	mov	r2, r0
2001bb34:	68bb      	ldr	r3, [r7, #8]
2001bb36:	1ad3      	subs	r3, r2, r3
2001bb38:	2b02      	cmp	r3, #2
2001bb3a:	d901      	bls.n	2001bb40 <RCCEx_PLL2_Config+0x220>
      {
        return HAL_TIMEOUT;
2001bb3c:	2303      	movs	r3, #3
2001bb3e:	e006      	b.n	2001bb4e <RCCEx_PLL2_Config+0x22e>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
2001bb40:	4b06      	ldr	r3, [pc, #24]	; (2001bb5c <RCCEx_PLL2_Config+0x23c>)
2001bb42:	681b      	ldr	r3, [r3, #0]
2001bb44:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2001bb48:	2b00      	cmp	r3, #0
2001bb4a:	d0f0      	beq.n	2001bb2e <RCCEx_PLL2_Config+0x20e>
    }

  }


  return status;
2001bb4c:	7bfb      	ldrb	r3, [r7, #15]
}
2001bb4e:	4618      	mov	r0, r3
2001bb50:	3710      	adds	r7, #16
2001bb52:	46bd      	mov	sp, r7
2001bb54:	bd80      	pop	{r7, pc}
2001bb56:	bf00      	nop
2001bb58:	2001c318 	.word	0x2001c318
2001bb5c:	58024400 	.word	0x58024400
2001bb60:	ffff0007 	.word	0xffff0007

2001bb64 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
2001bb64:	b580      	push	{r7, lr}
2001bb66:	b084      	sub	sp, #16
2001bb68:	af00      	add	r7, sp, #0
2001bb6a:	6078      	str	r0, [r7, #4]
2001bb6c:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
2001bb6e:	2300      	movs	r3, #0
2001bb70:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
2001bb72:	687b      	ldr	r3, [r7, #4]
2001bb74:	681b      	ldr	r3, [r3, #0]
2001bb76:	2b00      	cmp	r3, #0
2001bb78:	d003      	beq.n	2001bb82 <RCCEx_PLL3_Config+0x1e>
2001bb7a:	687b      	ldr	r3, [r7, #4]
2001bb7c:	681b      	ldr	r3, [r3, #0]
2001bb7e:	2b3f      	cmp	r3, #63	; 0x3f
2001bb80:	d904      	bls.n	2001bb8c <RCCEx_PLL3_Config+0x28>
2001bb82:	f640 41e7 	movw	r1, #3303	; 0xce7
2001bb86:	4887      	ldr	r0, [pc, #540]	; (2001bda4 <RCCEx_PLL3_Config+0x240>)
2001bb88:	f7e4 feb4 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
2001bb8c:	687b      	ldr	r3, [r7, #4]
2001bb8e:	685b      	ldr	r3, [r3, #4]
2001bb90:	2b03      	cmp	r3, #3
2001bb92:	d904      	bls.n	2001bb9e <RCCEx_PLL3_Config+0x3a>
2001bb94:	687b      	ldr	r3, [r7, #4]
2001bb96:	685b      	ldr	r3, [r3, #4]
2001bb98:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2001bb9c:	d904      	bls.n	2001bba8 <RCCEx_PLL3_Config+0x44>
2001bb9e:	f640 41e8 	movw	r1, #3304	; 0xce8
2001bba2:	4880      	ldr	r0, [pc, #512]	; (2001bda4 <RCCEx_PLL3_Config+0x240>)
2001bba4:	f7e4 fea6 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
2001bba8:	687b      	ldr	r3, [r7, #4]
2001bbaa:	689b      	ldr	r3, [r3, #8]
2001bbac:	2b00      	cmp	r3, #0
2001bbae:	d003      	beq.n	2001bbb8 <RCCEx_PLL3_Config+0x54>
2001bbb0:	687b      	ldr	r3, [r7, #4]
2001bbb2:	689b      	ldr	r3, [r3, #8]
2001bbb4:	2b80      	cmp	r3, #128	; 0x80
2001bbb6:	d904      	bls.n	2001bbc2 <RCCEx_PLL3_Config+0x5e>
2001bbb8:	f640 41e9 	movw	r1, #3305	; 0xce9
2001bbbc:	4879      	ldr	r0, [pc, #484]	; (2001bda4 <RCCEx_PLL3_Config+0x240>)
2001bbbe:	f7e4 fe99 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
2001bbc2:	687b      	ldr	r3, [r7, #4]
2001bbc4:	691b      	ldr	r3, [r3, #16]
2001bbc6:	2b00      	cmp	r3, #0
2001bbc8:	d003      	beq.n	2001bbd2 <RCCEx_PLL3_Config+0x6e>
2001bbca:	687b      	ldr	r3, [r7, #4]
2001bbcc:	691b      	ldr	r3, [r3, #16]
2001bbce:	2b80      	cmp	r3, #128	; 0x80
2001bbd0:	d904      	bls.n	2001bbdc <RCCEx_PLL3_Config+0x78>
2001bbd2:	f640 41ea 	movw	r1, #3306	; 0xcea
2001bbd6:	4873      	ldr	r0, [pc, #460]	; (2001bda4 <RCCEx_PLL3_Config+0x240>)
2001bbd8:	f7e4 fe8c 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
2001bbdc:	687b      	ldr	r3, [r7, #4]
2001bbde:	68db      	ldr	r3, [r3, #12]
2001bbe0:	2b00      	cmp	r3, #0
2001bbe2:	d003      	beq.n	2001bbec <RCCEx_PLL3_Config+0x88>
2001bbe4:	687b      	ldr	r3, [r7, #4]
2001bbe6:	68db      	ldr	r3, [r3, #12]
2001bbe8:	2b80      	cmp	r3, #128	; 0x80
2001bbea:	d904      	bls.n	2001bbf6 <RCCEx_PLL3_Config+0x92>
2001bbec:	f640 41eb 	movw	r1, #3307	; 0xceb
2001bbf0:	486c      	ldr	r0, [pc, #432]	; (2001bda4 <RCCEx_PLL3_Config+0x240>)
2001bbf2:	f7e4 fe7f 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
2001bbf6:	687b      	ldr	r3, [r7, #4]
2001bbf8:	695b      	ldr	r3, [r3, #20]
2001bbfa:	2b00      	cmp	r3, #0
2001bbfc:	d013      	beq.n	2001bc26 <RCCEx_PLL3_Config+0xc2>
2001bbfe:	687b      	ldr	r3, [r7, #4]
2001bc00:	695b      	ldr	r3, [r3, #20]
2001bc02:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2001bc06:	d00e      	beq.n	2001bc26 <RCCEx_PLL3_Config+0xc2>
2001bc08:	687b      	ldr	r3, [r7, #4]
2001bc0a:	695b      	ldr	r3, [r3, #20]
2001bc0c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2001bc10:	d009      	beq.n	2001bc26 <RCCEx_PLL3_Config+0xc2>
2001bc12:	687b      	ldr	r3, [r7, #4]
2001bc14:	695b      	ldr	r3, [r3, #20]
2001bc16:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
2001bc1a:	d004      	beq.n	2001bc26 <RCCEx_PLL3_Config+0xc2>
2001bc1c:	f640 41ec 	movw	r1, #3308	; 0xcec
2001bc20:	4860      	ldr	r0, [pc, #384]	; (2001bda4 <RCCEx_PLL3_Config+0x240>)
2001bc22:	f7e4 fe67 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
2001bc26:	687b      	ldr	r3, [r7, #4]
2001bc28:	699b      	ldr	r3, [r3, #24]
2001bc2a:	2b00      	cmp	r3, #0
2001bc2c:	d009      	beq.n	2001bc42 <RCCEx_PLL3_Config+0xde>
2001bc2e:	687b      	ldr	r3, [r7, #4]
2001bc30:	699b      	ldr	r3, [r3, #24]
2001bc32:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2001bc36:	d004      	beq.n	2001bc42 <RCCEx_PLL3_Config+0xde>
2001bc38:	f640 41ed 	movw	r1, #3309	; 0xced
2001bc3c:	4859      	ldr	r0, [pc, #356]	; (2001bda4 <RCCEx_PLL3_Config+0x240>)
2001bc3e:	f7e4 fe59 	bl	200008f4 <assert_failed>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
2001bc42:	687b      	ldr	r3, [r7, #4]
2001bc44:	69db      	ldr	r3, [r3, #28]
2001bc46:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2001bc4a:	d304      	bcc.n	2001bc56 <RCCEx_PLL3_Config+0xf2>
2001bc4c:	f640 41ee 	movw	r1, #3310	; 0xcee
2001bc50:	4854      	ldr	r0, [pc, #336]	; (2001bda4 <RCCEx_PLL3_Config+0x240>)
2001bc52:	f7e4 fe4f 	bl	200008f4 <assert_failed>

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
2001bc56:	4b54      	ldr	r3, [pc, #336]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bc58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001bc5a:	f003 0303 	and.w	r3, r3, #3
2001bc5e:	2b03      	cmp	r3, #3
2001bc60:	d101      	bne.n	2001bc66 <RCCEx_PLL3_Config+0x102>
  {
    return HAL_ERROR;
2001bc62:	2301      	movs	r3, #1
2001bc64:	e099      	b.n	2001bd9a <RCCEx_PLL3_Config+0x236>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
2001bc66:	4b50      	ldr	r3, [pc, #320]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bc68:	681b      	ldr	r3, [r3, #0]
2001bc6a:	4a4f      	ldr	r2, [pc, #316]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bc6c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
2001bc70:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2001bc72:	f7e6 f83b 	bl	20001cec <HAL_GetTick>
2001bc76:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
2001bc78:	e008      	b.n	2001bc8c <RCCEx_PLL3_Config+0x128>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
2001bc7a:	f7e6 f837 	bl	20001cec <HAL_GetTick>
2001bc7e:	4602      	mov	r2, r0
2001bc80:	68bb      	ldr	r3, [r7, #8]
2001bc82:	1ad3      	subs	r3, r2, r3
2001bc84:	2b02      	cmp	r3, #2
2001bc86:	d901      	bls.n	2001bc8c <RCCEx_PLL3_Config+0x128>
      {
        return HAL_TIMEOUT;
2001bc88:	2303      	movs	r3, #3
2001bc8a:	e086      	b.n	2001bd9a <RCCEx_PLL3_Config+0x236>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
2001bc8c:	4b46      	ldr	r3, [pc, #280]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bc8e:	681b      	ldr	r3, [r3, #0]
2001bc90:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2001bc94:	2b00      	cmp	r3, #0
2001bc96:	d1f0      	bne.n	2001bc7a <RCCEx_PLL3_Config+0x116>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
2001bc98:	4b43      	ldr	r3, [pc, #268]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bc9a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2001bc9c:	f023 727c 	bic.w	r2, r3, #66060288	; 0x3f00000
2001bca0:	687b      	ldr	r3, [r7, #4]
2001bca2:	681b      	ldr	r3, [r3, #0]
2001bca4:	051b      	lsls	r3, r3, #20
2001bca6:	4940      	ldr	r1, [pc, #256]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bca8:	4313      	orrs	r3, r2
2001bcaa:	628b      	str	r3, [r1, #40]	; 0x28
2001bcac:	687b      	ldr	r3, [r7, #4]
2001bcae:	685b      	ldr	r3, [r3, #4]
2001bcb0:	3b01      	subs	r3, #1
2001bcb2:	f3c3 0208 	ubfx	r2, r3, #0, #9
2001bcb6:	687b      	ldr	r3, [r7, #4]
2001bcb8:	689b      	ldr	r3, [r3, #8]
2001bcba:	3b01      	subs	r3, #1
2001bcbc:	025b      	lsls	r3, r3, #9
2001bcbe:	b29b      	uxth	r3, r3
2001bcc0:	431a      	orrs	r2, r3
2001bcc2:	687b      	ldr	r3, [r7, #4]
2001bcc4:	68db      	ldr	r3, [r3, #12]
2001bcc6:	3b01      	subs	r3, #1
2001bcc8:	041b      	lsls	r3, r3, #16
2001bcca:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
2001bcce:	431a      	orrs	r2, r3
2001bcd0:	687b      	ldr	r3, [r7, #4]
2001bcd2:	691b      	ldr	r3, [r3, #16]
2001bcd4:	3b01      	subs	r3, #1
2001bcd6:	061b      	lsls	r3, r3, #24
2001bcd8:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
2001bcdc:	4932      	ldr	r1, [pc, #200]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bcde:	4313      	orrs	r3, r2
2001bce0:	640b      	str	r3, [r1, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
2001bce2:	4b31      	ldr	r3, [pc, #196]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bce4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001bce6:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
2001bcea:	687b      	ldr	r3, [r7, #4]
2001bcec:	695b      	ldr	r3, [r3, #20]
2001bcee:	492e      	ldr	r1, [pc, #184]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bcf0:	4313      	orrs	r3, r2
2001bcf2:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
2001bcf4:	4b2c      	ldr	r3, [pc, #176]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bcf6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001bcf8:	f423 7200 	bic.w	r2, r3, #512	; 0x200
2001bcfc:	687b      	ldr	r3, [r7, #4]
2001bcfe:	699b      	ldr	r3, [r3, #24]
2001bd00:	4929      	ldr	r1, [pc, #164]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd02:	4313      	orrs	r3, r2
2001bd04:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
2001bd06:	4b28      	ldr	r3, [pc, #160]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001bd0a:	4a27      	ldr	r2, [pc, #156]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd0c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
2001bd10:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
2001bd12:	4b25      	ldr	r3, [pc, #148]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd14:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2001bd16:	4b25      	ldr	r3, [pc, #148]	; (2001bdac <RCCEx_PLL3_Config+0x248>)
2001bd18:	4013      	ands	r3, r2
2001bd1a:	687a      	ldr	r2, [r7, #4]
2001bd1c:	69d2      	ldr	r2, [r2, #28]
2001bd1e:	00d2      	lsls	r2, r2, #3
2001bd20:	4921      	ldr	r1, [pc, #132]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd22:	4313      	orrs	r3, r2
2001bd24:	644b      	str	r3, [r1, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
2001bd26:	4b20      	ldr	r3, [pc, #128]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd28:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001bd2a:	4a1f      	ldr	r2, [pc, #124]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd2c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2001bd30:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
2001bd32:	683b      	ldr	r3, [r7, #0]
2001bd34:	2b00      	cmp	r3, #0
2001bd36:	d106      	bne.n	2001bd46 <RCCEx_PLL3_Config+0x1e2>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
2001bd38:	4b1b      	ldr	r3, [pc, #108]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001bd3c:	4a1a      	ldr	r2, [pc, #104]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd3e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
2001bd42:	62d3      	str	r3, [r2, #44]	; 0x2c
2001bd44:	e00f      	b.n	2001bd66 <RCCEx_PLL3_Config+0x202>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
2001bd46:	683b      	ldr	r3, [r7, #0]
2001bd48:	2b01      	cmp	r3, #1
2001bd4a:	d106      	bne.n	2001bd5a <RCCEx_PLL3_Config+0x1f6>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2001bd4c:	4b16      	ldr	r3, [pc, #88]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001bd50:	4a15      	ldr	r2, [pc, #84]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd52:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
2001bd56:	62d3      	str	r3, [r2, #44]	; 0x2c
2001bd58:	e005      	b.n	2001bd66 <RCCEx_PLL3_Config+0x202>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2001bd5a:	4b13      	ldr	r3, [pc, #76]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd5c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2001bd5e:	4a12      	ldr	r2, [pc, #72]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd60:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
2001bd64:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
2001bd66:	4b10      	ldr	r3, [pc, #64]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd68:	681b      	ldr	r3, [r3, #0]
2001bd6a:	4a0f      	ldr	r2, [pc, #60]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd6c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2001bd70:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2001bd72:	f7e5 ffbb 	bl	20001cec <HAL_GetTick>
2001bd76:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
2001bd78:	e008      	b.n	2001bd8c <RCCEx_PLL3_Config+0x228>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
2001bd7a:	f7e5 ffb7 	bl	20001cec <HAL_GetTick>
2001bd7e:	4602      	mov	r2, r0
2001bd80:	68bb      	ldr	r3, [r7, #8]
2001bd82:	1ad3      	subs	r3, r2, r3
2001bd84:	2b02      	cmp	r3, #2
2001bd86:	d901      	bls.n	2001bd8c <RCCEx_PLL3_Config+0x228>
      {
        return HAL_TIMEOUT;
2001bd88:	2303      	movs	r3, #3
2001bd8a:	e006      	b.n	2001bd9a <RCCEx_PLL3_Config+0x236>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
2001bd8c:	4b06      	ldr	r3, [pc, #24]	; (2001bda8 <RCCEx_PLL3_Config+0x244>)
2001bd8e:	681b      	ldr	r3, [r3, #0]
2001bd90:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2001bd94:	2b00      	cmp	r3, #0
2001bd96:	d0f0      	beq.n	2001bd7a <RCCEx_PLL3_Config+0x216>
    }

  }


  return status;
2001bd98:	7bfb      	ldrb	r3, [r7, #15]
}
2001bd9a:	4618      	mov	r0, r3
2001bd9c:	3710      	adds	r7, #16
2001bd9e:	46bd      	mov	sp, r7
2001bda0:	bd80      	pop	{r7, pc}
2001bda2:	bf00      	nop
2001bda4:	2001c318 	.word	0x2001c318
2001bda8:	58024400 	.word	0x58024400
2001bdac:	ffff0007 	.word	0xffff0007

2001bdb0 <HAL_RCCEx_LSECSS_IRQHandler>:
/**
  * @brief Handle the RCC LSE Clock Security System interrupt request.
  * @retval None
  */
void HAL_RCCEx_LSECSS_IRQHandler(void)
{
2001bdb0:	b580      	push	{r7, lr}
2001bdb2:	af00      	add	r7, sp, #0
  /* Check RCC LSE CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
2001bdb4:	4b07      	ldr	r3, [pc, #28]	; (2001bdd4 <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
2001bdb6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2001bdb8:	f403 7300 	and.w	r3, r3, #512	; 0x200
2001bdbc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2001bdc0:	d105      	bne.n	2001bdce <HAL_RCCEx_LSECSS_IRQHandler+0x1e>
  {

    /* Clear RCC LSE CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
2001bdc2:	4b04      	ldr	r3, [pc, #16]	; (2001bdd4 <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
2001bdc4:	f44f 7200 	mov.w	r2, #512	; 0x200
2001bdc8:	669a      	str	r2, [r3, #104]	; 0x68

    /* RCC LSE Clock Security System interrupt user callback */
    HAL_RCCEx_LSECSS_Callback();
2001bdca:	f000 f805 	bl	2001bdd8 <HAL_RCCEx_LSECSS_Callback>

  }
}
2001bdce:	bf00      	nop
2001bdd0:	bd80      	pop	{r7, pc}
2001bdd2:	bf00      	nop
2001bdd4:	58024400 	.word	0x58024400

2001bdd8 <HAL_RCCEx_LSECSS_Callback>:
/**
  * @brief  RCCEx LSE Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_LSECSS_Callback(void)
{
2001bdd8:	b480      	push	{r7}
2001bdda:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
   */
}
2001bddc:	bf00      	nop
2001bdde:	46bd      	mov	sp, r7
2001bde0:	f85d 7b04 	ldr.w	r7, [sp], #4
2001bde4:	4770      	bx	lr
	...

2001bde8 <__errno>:
2001bde8:	4b01      	ldr	r3, [pc, #4]	; (2001bdf0 <__errno+0x8>)
2001bdea:	6818      	ldr	r0, [r3, #0]
2001bdec:	4770      	bx	lr
2001bdee:	bf00      	nop
2001bdf0:	2001c988 	.word	0x2001c988

2001bdf4 <exit>:
2001bdf4:	b508      	push	{r3, lr}
2001bdf6:	4b07      	ldr	r3, [pc, #28]	; (2001be14 <exit+0x20>)
2001bdf8:	4604      	mov	r4, r0
2001bdfa:	b113      	cbz	r3, 2001be02 <exit+0xe>
2001bdfc:	2100      	movs	r1, #0
2001bdfe:	f3af 8000 	nop.w
2001be02:	4b05      	ldr	r3, [pc, #20]	; (2001be18 <exit+0x24>)
2001be04:	6818      	ldr	r0, [r3, #0]
2001be06:	6a83      	ldr	r3, [r0, #40]	; 0x28
2001be08:	b103      	cbz	r3, 2001be0c <exit+0x18>
2001be0a:	4798      	blx	r3
2001be0c:	4620      	mov	r0, r4
2001be0e:	f7e5 fba0 	bl	20001552 <_exit>
2001be12:	bf00      	nop
2001be14:	00000000 	.word	0x00000000
2001be18:	2001c354 	.word	0x2001c354

2001be1c <__libc_init_array>:
2001be1c:	b570      	push	{r4, r5, r6, lr}
2001be1e:	4e0d      	ldr	r6, [pc, #52]	; (2001be54 <__libc_init_array+0x38>)
2001be20:	4c0d      	ldr	r4, [pc, #52]	; (2001be58 <__libc_init_array+0x3c>)
2001be22:	1ba4      	subs	r4, r4, r6
2001be24:	10a4      	asrs	r4, r4, #2
2001be26:	2500      	movs	r5, #0
2001be28:	42a5      	cmp	r5, r4
2001be2a:	d109      	bne.n	2001be40 <__libc_init_array+0x24>
2001be2c:	4e0b      	ldr	r6, [pc, #44]	; (2001be5c <__libc_init_array+0x40>)
2001be2e:	4c0c      	ldr	r4, [pc, #48]	; (2001be60 <__libc_init_array+0x44>)
2001be30:	f000 f820 	bl	2001be74 <_init>
2001be34:	1ba4      	subs	r4, r4, r6
2001be36:	10a4      	asrs	r4, r4, #2
2001be38:	2500      	movs	r5, #0
2001be3a:	42a5      	cmp	r5, r4
2001be3c:	d105      	bne.n	2001be4a <__libc_init_array+0x2e>
2001be3e:	bd70      	pop	{r4, r5, r6, pc}
2001be40:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
2001be44:	4798      	blx	r3
2001be46:	3501      	adds	r5, #1
2001be48:	e7ee      	b.n	2001be28 <__libc_init_array+0xc>
2001be4a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
2001be4e:	4798      	blx	r3
2001be50:	3501      	adds	r5, #1
2001be52:	e7f2      	b.n	2001be3a <__libc_init_array+0x1e>
2001be54:	2001c968 	.word	0x2001c968
2001be58:	2001c968 	.word	0x2001c968
2001be5c:	2001c968 	.word	0x2001c968
2001be60:	2001c96c 	.word	0x2001c96c

2001be64 <memset>:
2001be64:	4402      	add	r2, r0
2001be66:	4603      	mov	r3, r0
2001be68:	4293      	cmp	r3, r2
2001be6a:	d100      	bne.n	2001be6e <memset+0xa>
2001be6c:	4770      	bx	lr
2001be6e:	f803 1b01 	strb.w	r1, [r3], #1
2001be72:	e7f9      	b.n	2001be68 <memset+0x4>

2001be74 <_init>:
2001be74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2001be76:	bf00      	nop
2001be78:	bcf8      	pop	{r3, r4, r5, r6, r7}
2001be7a:	bc08      	pop	{r3}
2001be7c:	469e      	mov	lr, r3
2001be7e:	4770      	bx	lr

2001be80 <_fini>:
2001be80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2001be82:	bf00      	nop
2001be84:	bcf8      	pop	{r3, r4, r5, r6, r7}
2001be86:	bc08      	pop	{r3}
2001be88:	469e      	mov	lr, r3
2001be8a:	4770      	bx	lr
